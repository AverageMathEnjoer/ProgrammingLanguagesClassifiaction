b'{-# LANGUAGE CPP #-}\n#include "containers.h"\n{-# LANGUAGE BangPatterns #-}\n#if __GLASGOW_HASKELL__\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskellQuotes #-}\n{-# LANGUAGE Trustworthy #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n#endif\n#ifdef DEFINE_PATTERN_SYNONYMS\n{-# LANGUAGE PatternSynonyms #-}\n{-# LANGUAGE ViewPatterns #-}\n#endif\n{-# LANGUAGE PatternGuards #-}\n\n{-# OPTIONS_HADDOCK not-home #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Sequence.Internal\n-- Copyright   :  (c) Ross Paterson 2005\n--                (c) Louis Wasserman 2009\n--                (c) Bertram Felgenhauer, David Feuer, Ross Paterson, and\n--                    Milan Straka 2014\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- General purpose finite sequences.\n-- Apart from being finite and having strict operations, sequences\n-- also differ from lists in supporting a wider variety of operations\n-- efficiently.\n--\n-- An amortized running time is given for each operation, with \\( n \\) referring\n-- to the length of the sequence and \\( i \\) being the integral index used by\n-- some operations. These bounds hold even in a persistent (shared) setting.\n--\n-- The implementation uses 2-3 finger trees annotated with sizes,\n-- as described in section 4.2 of\n--\n--    * Ralf Hinze and Ross Paterson,\n--      \\"Finger trees: a simple general-purpose data structure\\",\n--      /Journal of Functional Programming/ 16:2 (2006) pp 197-217.\n--      <http://staff.city.ac.uk/~ross/papers/FingerTree.html>\n--\n-- /Note/: Many of these operations have the same names as similar\n-- operations on lists in the "Prelude". The ambiguity may be resolved\n-- using either qualification or the @hiding@ clause.\n--\n-- /Warning/: The size of a \'Seq\' must not exceed @maxBound::Int@.  Violation\n-- of this condition is not detected and if the size limit is exceeded, the\n-- behaviour of the sequence is undefined.  This is unlikely to occur in most\n-- applications, but some care may be required when using \'><\', \'<*>\', \'*>\', or\n-- \'>>\', particularly repeatedly and particularly in combination with\n-- \'replicate\' or \'fromFunction\'.\n--\n-- @since 0.5.9\n-----------------------------------------------------------------------------\n\nmodule Data.Sequence.Internal (\n    Elem(..), FingerTree(..), Node(..), Digit(..), Sized(..), MaybeForce,\n#if defined(DEFINE_PATTERN_SYNONYMS)\n    Seq (.., Empty, (:<|), (:|>)),\n#else\n    Seq (..),\n#endif\n    State(..),\n    execState,\n    foldDigit,\n    foldNode,\n    foldWithIndexDigit,\n    foldWithIndexNode,\n\n    -- * Construction\n    empty,          -- :: Seq a\n    singleton,      -- :: a -> Seq a\n    (<|),           -- :: a -> Seq a -> Seq a\n    (|>),           -- :: Seq a -> a -> Seq a\n    (><),           -- :: Seq a -> Seq a -> Seq a\n    fromList,       -- :: [a] -> Seq a\n    fromFunction,   -- :: Int -> (Int -> a) -> Seq a\n    fromArray,      -- :: Ix i => Array i a -> Seq a\n    -- ** Repetition\n    replicate,      -- :: Int -> a -> Seq a\n    replicateA,     -- :: Applicative f => Int -> f a -> f (Seq a)\n    replicateM,     -- :: Applicative m => Int -> m a -> m (Seq a)\n    cycleTaking,    -- :: Int -> Seq a -> Seq a\n    -- ** Iterative construction\n    iterateN,       -- :: Int -> (a -> a) -> a -> Seq a\n    unfoldr,        -- :: (b -> Maybe (a, b)) -> b -> Seq a\n    unfoldl,        -- :: (b -> Maybe (b, a)) -> b -> Seq a\n    -- * Deconstruction\n    -- | Additional functions for deconstructing sequences are available\n    -- via the \'Foldable\' instance of \'Seq\'.\n\n    -- ** Queries\n    null,           -- :: Seq a -> Bool\n    length,         -- :: Seq a -> Int\n    -- ** Views\n    ViewL(..),\n    viewl,          -- :: Seq a -> ViewL a\n    ViewR(..),\n    viewr,          -- :: Seq a -> ViewR a\n    -- * Scans\n    scanl,          -- :: (a -> b -> a) -> a -> Seq b -> Seq a\n    scanl1,         -- :: (a -> a -> a) -> Seq a -> Seq a\n    scanr,          -- :: (a -> b -> b) -> b -> Seq a -> Seq b\n    scanr1,         -- :: (a -> a -> a) -> Seq a -> Seq a\n    -- * Sublists\n    tails,          -- :: Seq a -> Seq (Seq a)\n    inits,          -- :: Seq a -> Seq (Seq a)\n    chunksOf,       -- :: Int -> Seq a -> Seq (Seq a)\n    -- ** Sequential searches\n    takeWhileL,     -- :: (a -> Bool) -> Seq a -> Seq a\n    takeWhileR,     -- :: (a -> Bool) -> Seq a -> Seq a\n    dropWhileL,     -- :: (a -> Bool) -> Seq a -> Seq a\n    dropWhileR,     -- :: (a -> Bool) -> Seq a -> Seq a\n    spanl,          -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    spanr,          -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    breakl,         -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    breakr,         -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    partition,      -- :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\n    filter,         -- :: (a -> Bool) -> Seq a -> Seq a\n    -- * Indexing\n    lookup,         -- :: Int -> Seq a -> Maybe a\n    (!?),           -- :: Seq a -> Int -> Maybe a\n    index,          -- :: Seq a -> Int -> a\n    adjust,         -- :: (a -> a) -> Int -> Seq a -> Seq a\n    adjust\',        -- :: (a -> a) -> Int -> Seq a -> Seq a\n    update,         -- :: Int -> a -> Seq a -> Seq a\n    take,           -- :: Int -> Seq a -> Seq a\n    drop,           -- :: Int -> Seq a -> Seq a\n    insertAt,       -- :: Int -> a -> Seq a -> Seq a\n    deleteAt,       -- :: Int -> Seq a -> Seq a\n    splitAt,        -- :: Int -> Seq a -> (Seq a, Seq a)\n    -- ** Indexing with predicates\n    -- | These functions perform sequential searches from the left\n    -- or right ends of the sequence, returning indices of matching\n    -- elements.\n    elemIndexL,     -- :: Eq a => a -> Seq a -> Maybe Int\n    elemIndicesL,   -- :: Eq a => a -> Seq a -> [Int]\n    elemIndexR,     -- :: Eq a => a -> Seq a -> Maybe Int\n    elemIndicesR,   -- :: Eq a => a -> Seq a -> [Int]\n    findIndexL,     -- :: (a -> Bool) -> Seq a -> Maybe Int\n    findIndicesL,   -- :: (a -> Bool) -> Seq a -> [Int]\n    findIndexR,     -- :: (a -> Bool) -> Seq a -> Maybe Int\n    findIndicesR,   -- :: (a -> Bool) -> Seq a -> [Int]\n    -- * Folds\n    -- | General folds are available via the \'Foldable\' instance of \'Seq\'.\n    foldMapWithIndex, -- :: Monoid m => (Int -> a -> m) -> Seq a -> m\n    foldlWithIndex, -- :: (b -> Int -> a -> b) -> b -> Seq a -> b\n    foldrWithIndex, -- :: (Int -> a -> b -> b) -> b -> Seq a -> b\n    -- * Transformations\n    mapWithIndex,   -- :: (Int -> a -> b) -> Seq a -> Seq b\n    traverseWithIndex, -- :: Applicative f => (Int -> a -> f b) -> Seq a -> f (Seq b)\n    reverse,        -- :: Seq a -> Seq a\n    intersperse,    -- :: a -> Seq a -> Seq a\n    liftA2Seq,      -- :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\n    -- ** Zips and unzips\n    zip,            -- :: Seq a -> Seq b -> Seq (a, b)\n    zipWith,        -- :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\n    zip3,           -- :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)\n    zipWith3,       -- :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d\n    zip4,           -- :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a, b, c, d)\n    zipWith4,       -- :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e\n    unzip,          -- :: Seq (a, b) -> (Seq a, Seq b)\n    unzipWith,      -- :: (a -> (b, c)) -> Seq a -> (Seq b, Seq c)\n#ifdef TESTING\n    deep,\n    node2,\n    node3,\n#endif\n    ) where\n\nimport Utils.Containers.Internal.Prelude hiding (\n    Functor(..),\n#if MIN_VERSION_base(4,11,0)\n    (<>),\n#endif\n    (<$>), foldMap, Monoid,\n    null, length, lookup, take, drop, splitAt, foldl, foldl1, foldr, foldr1,\n    scanl, scanl1, scanr, scanr1, replicate, zip, zipWith, zip3, zipWith3,\n    unzip, takeWhile, dropWhile, iterate, reverse, filter, mapM, sum, all)\nimport Prelude ()\nimport Control.Applicative ((<$>), (<**>),  Alternative,\n                            liftA3)\nimport qualified Control.Applicative as Applicative\nimport Control.DeepSeq (NFData(rnf))\nimport Control.Monad (MonadPlus(..))\nimport Data.Monoid (Monoid(..))\nimport Data.Functor (Functor(..))\nimport Utils.Containers.Internal.State (State(..), execState)\nimport Data.Foldable (Foldable(foldl, foldl1, foldr, foldr1, foldMap, foldl\', foldr\'), toList)\nimport qualified Data.Foldable as F\n\nimport qualified Data.Semigroup as Semigroup\nimport Data.Functor.Classes\nimport Data.Traversable\n\n-- GHC specific stuff\n#ifdef __GLASGOW_HASKELL__\nimport GHC.Exts (build)\nimport Text.Read (Lexeme(Ident), lexP, parens, prec,\n    readPrec, readListPrec, readListPrecDefault)\nimport Data.Data\nimport Data.String (IsString(..))\nimport qualified Language.Haskell.TH.Syntax as TH\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\nimport GHC.Generics (Generic, Generic1)\n#endif\n\n-- Array stuff, with GHC.Arr on GHC\nimport Data.Array (Ix, Array)\nimport qualified Data.Array\n#ifdef __GLASGOW_HASKELL__\nimport qualified GHC.Arr\n#endif\n\nimport Utils.Containers.Internal.Coercions ((.#), (.^#))\nimport Data.Coerce\nimport qualified GHC.Exts\n\nimport Data.Functor.Identity (Identity(..))\n\nimport Utils.Containers.Internal.StrictPair (StrictPair (..), toPair)\nimport Control.Monad.Zip (MonadZip (..))\nimport Control.Monad.Fix (MonadFix (..), fix)\n\ndefault ()\n\n-- We define our own copy here, for Monoid only, even though this\n-- is now a Semigroup operator in base. The essential reason is that\n-- we have absolutely no use for semigroups in this module. Everything\n-- that needs to sum things up requires a Monoid constraint to deal\n-- with empty sequences. I\'m not sure if there\'s a risk of walking\n-- through dictionaries to reach <> from Monoid, but I see no reason\n-- to risk it.\ninfixr 6 <>\n(<>) :: Monoid m => m -> m -> m\n(<>) = mappend\n{-# INLINE (<>) #-}\n\ninfixr 5 `consTree`\ninfixl 5 `snocTree`\ninfixr 5 `appendTree0`\n\ninfixr 5 ><\ninfixr 5 <|, :<\ninfixl 5 |>, :>\n\n#ifdef DEFINE_PATTERN_SYNONYMS\ninfixr 5 :<|\ninfixl 5 :|>\n\n#if __GLASGOW_HASKELL__ >= 801\n{-# COMPLETE (:<|), Empty #-}\n{-# COMPLETE (:|>), Empty #-}\n#endif\n\n-- | A bidirectional pattern synonym matching an empty sequence.\n--\n-- @since 0.5.8\npattern Empty :: Seq a\npattern Empty = Seq EmptyT\n\n-- | A bidirectional pattern synonym viewing the front of a non-empty\n-- sequence.\n--\n-- @since 0.5.8\npattern (:<|) :: a -> Seq a -> Seq a\npattern x :<| xs <- (viewl -> x :< xs)\n  where\n    x :<| xs = x <| xs\n\n-- | A bidirectional pattern synonym viewing the rear of a non-empty\n-- sequence.\n--\n-- @since 0.5.8\npattern (:|>) :: Seq a -> a -> Seq a\npattern xs :|> x <- (viewr -> xs :> x)\n  where\n    xs :|> x = xs |> x\n#endif\n\nclass Sized a where\n    size :: a -> Int\n\n-- In much the same way that Sized lets us handle the\n-- sizes of elements and nodes uniformly, MaybeForce lets\n-- us handle their strictness (or lack thereof) uniformly.\n-- We can `mseq` something and not have to worry about\n-- whether it\'s an element or a node.\nclass MaybeForce a where\n  maybeRwhnf :: a -> ()\n\nmseq :: MaybeForce a => a -> b -> b\nmseq a b = case maybeRwhnf a of () -> b\n{-# INLINE mseq #-}\n\ninfixr 0 $!?\n($!?) :: MaybeForce a => (a -> b) -> a -> b\nf $!? a = case maybeRwhnf a of () -> f a\n{-# INLINE ($!?) #-}\n\ninstance MaybeForce (Elem a) where\n  maybeRwhnf _ = ()\n  {-# INLINE maybeRwhnf #-}\n\ninstance MaybeForce (Node a) where\n  maybeRwhnf !_ = ()\n  {-# INLINE maybeRwhnf #-}\n\n-- A wrapper making mseq = seq\nnewtype ForceBox a = ForceBox a\ninstance MaybeForce (ForceBox a) where\n  maybeRwhnf !_ = ()\ninstance Sized (ForceBox a) where\n  size _ = 1\n\n-- | General-purpose finite sequences.\nnewtype Seq a = Seq (FingerTree (Elem a))\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.6\ninstance TH.Lift a => TH.Lift (Seq a) where\n#  if MIN_VERSION_template_haskell(2,16,0)\n  liftTyped t = [|| coerceFT z ||]\n#  else\n  lift t = [| coerceFT z |]\n#  endif\n    where\n      -- We rebalance the sequence to use only 3-nodes before lifting its\n      -- underlying finger tree. This should minimize the size and depth of the\n      -- tree generated at run-time. It also reduces the size of the splice,\n      -- but I don\'t know how that affects the size of the resulting Core once\n      -- all the types are added.\n      Seq ft = zipWith (flip const) (replicate (length t) ()) t\n\n      -- We remove the \'Elem\' constructors to reduce the size of the splice\n      -- and the number of types and coercions in the generated Core. Instead\n      -- of, say,\n      --\n      --   Seq (Deep 3 (Two (Elem 1) (Elem 2)) EmptyT (One (Elem 3)))\n      --\n      -- we generate\n      --\n      --   coerceFT (Deep 3 (Two 1 2)) EmptyT (One 3)\n      z :: FingerTree a\n      z = coerce ft\n\n-- | We use this to help the types work out for splices in the\n-- Lift instance. Things get a bit yucky otherwise.\ncoerceFT :: FingerTree a -> Seq a\ncoerceFT = coerce\n\n#endif\n\ninstance Functor Seq where\n    fmap = fmapSeq\n#ifdef __GLASGOW_HASKELL__\n    x <$ s = replicate (length s) x\n#endif\n\nfmapSeq :: (a -> b) -> Seq a -> Seq b\nfmapSeq f (Seq xs) = Seq (fmap (fmap f) xs)\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] fmapSeq #-}\n{-# RULES\n"fmapSeq/fmapSeq" forall f g xs . fmapSeq f (fmapSeq g xs) = fmapSeq (f . g) xs\n"fmapSeq/coerce" fmapSeq coerce = coerce\n #-}\n#endif\n\ngetSeq :: Seq a -> FingerTree (Elem a)\ngetSeq (Seq xs) = xs\n\ninstance Foldable Seq where\n    foldMap f = foldMap (f .# getElem) .# getSeq\n    foldr f z = foldr (f .# getElem) z .# getSeq\n    foldl f z = foldl (f .^# getElem) z .# getSeq\n\n#if __GLASGOW_HASKELL__\n    {-# INLINABLE foldMap #-}\n    {-# INLINABLE foldr #-}\n    {-# INLINABLE foldl #-}\n#endif\n\n    foldr\' f z = foldr\' (f .# getElem) z .# getSeq\n    foldl\' f z = foldl\' (f .^# getElem) z .# getSeq\n\n#if __GLASGOW_HASKELL__\n    {-# INLINABLE foldr\' #-}\n    {-# INLINABLE foldl\' #-}\n#endif\n\n    foldr1 f (Seq xs) = getElem (foldr1 f\' xs)\n      where f\' (Elem x) (Elem y) = Elem (f x y)\n\n    foldl1 f (Seq xs) = getElem (foldl1 f\' xs)\n      where f\' (Elem x) (Elem y) = Elem (f x y)\n\n    length = length\n    {-# INLINE length #-}\n    null   = null\n    {-# INLINE null #-}\n\ninstance Traversable Seq where\n#if __GLASGOW_HASKELL__\n    {-# INLINABLE traverse #-}\n#endif\n    traverse _ (Seq EmptyT) = pure (Seq EmptyT)\n    traverse f\' (Seq (Single (Elem x\'))) =\n        (\\x\'\' -> Seq (Single (Elem x\'\'))) <$> f\' x\'\n    traverse f\' (Seq (Deep s\' pr\' m\' sf\')) =\n        liftA3\n            (\\pr\'\' m\'\' sf\'\' -> Seq (Deep s\' pr\'\' m\'\' sf\'\'))\n            (traverseDigitE f\' pr\')\n            (traverseTree (traverseNodeE f\') m\')\n            (traverseDigitE f\' sf\')\n      where\n        traverseTree\n            :: Applicative f\n            => (Node a -> f (Node b))\n            -> FingerTree (Node a)\n            -> f (FingerTree (Node b))\n        traverseTree _ EmptyT = pure EmptyT\n        traverseTree f (Single x) = Single <$> f x\n        traverseTree f (Deep s pr m sf) =\n            liftA3\n                (Deep s)\n                (traverseDigitN f pr)\n                (traverseTree (traverseNodeN f) m)\n                (traverseDigitN f sf)\n        traverseDigitE\n            :: Applicative f\n            => (a -> f b) -> Digit (Elem a) -> f (Digit (Elem b))\n        traverseDigitE f (One (Elem a)) =\n            (\\a\' -> One (Elem a\')) <$>\n            f a\n        traverseDigitE f (Two (Elem a) (Elem b)) =\n            liftA2\n                (\\a\' b\' -> Two (Elem a\') (Elem b\'))\n                (f a)\n                (f b)\n        traverseDigitE f (Three (Elem a) (Elem b) (Elem c)) =\n            liftA3\n                (\\a\' b\' c\' ->\n                      Three (Elem a\') (Elem b\') (Elem c\'))\n                (f a)\n                (f b)\n                (f c)\n        traverseDigitE f (Four (Elem a) (Elem b) (Elem c) (Elem d)) =\n            liftA3\n                (\\a\' b\' c\' d\' -> Four (Elem a\') (Elem b\') (Elem c\') (Elem d\'))\n                (f a)\n                (f b)\n                (f c) <*>\n                (f d)\n        traverseDigitN\n            :: Applicative f\n            => (Node a -> f (Node b)) -> Digit (Node a) -> f (Digit (Node b))\n        traverseDigitN f t = traverse f t\n        traverseNodeE\n            :: Applicative f\n            => (a -> f b) -> Node (Elem a) -> f (Node (Elem b))\n        traverseNodeE f (Node2 s (Elem a) (Elem b)) =\n            liftA2\n                (\\a\' b\' -> Node2 s (Elem a\') (Elem b\'))\n                (f a)\n                (f b)\n        traverseNodeE f (Node3 s (Elem a) (Elem b) (Elem c)) =\n            liftA3\n                (\\a\' b\' c\' ->\n                      Node3 s (Elem a\') (Elem b\') (Elem c\'))\n                (f a)\n                (f b)\n                (f c)\n        traverseNodeN\n            :: Applicative f\n            => (Node a -> f (Node b)) -> Node (Node a) -> f (Node (Node b))\n        traverseNodeN f t = traverse f t\n\ninstance NFData a => NFData (Seq a) where\n    rnf (Seq xs) = rnf xs\n\ninstance Monad Seq where\n    return = pure\n    xs >>= f = foldl\' add empty xs\n      where add ys x = ys >< f x\n    (>>) = (*>)\n\n-- | @since 0.5.11\ninstance MonadFix Seq where\n    mfix = mfixSeq\n\n-- This is just like the instance for lists, but we can take advantage of\n-- constant-time length and logarithmic-time indexing to speed things up.\n-- Using fromFunction, we make this about as lazy as we can.\nmfixSeq :: (a -> Seq a) -> Seq a\nmfixSeq f = fromFunction (length (f err)) (\\k -> fix (\\xk -> f xk `index` k))\n  where\n    err = error "mfix for Data.Sequence.Seq applied to strict function"\n\n-- | @since 0.5.4\ninstance Applicative Seq where\n    pure = singleton\n    xs *> ys = cycleNTimes (length xs) ys\n    (<*>) = apSeq\n#if MIN_VERSION_base(4,10,0)\n    liftA2 = liftA2Seq\n#endif\n    xs <* ys = beforeSeq xs ys\n\napSeq :: Seq (a -> b) -> Seq a -> Seq b\napSeq fs xs@(Seq xsFT) = case viewl fs of\n  EmptyL -> empty\n  firstf :< fs\' -> case viewr fs\' of\n    EmptyR -> fmap firstf xs\n    Seq fs\'\'FT :> lastf -> case rigidify xsFT of\n         RigidEmpty -> empty\n         RigidOne (Elem x) -> fmap ($ x) fs\n         RigidTwo (Elem x1) (Elem x2) ->\n            Seq $ ap2FT firstf fs\'\'FT lastf (x1, x2)\n         RigidThree (Elem x1) (Elem x2) (Elem x3) ->\n            Seq $ ap3FT firstf fs\'\'FT lastf (x1, x2, x3)\n         RigidFull r@(Rigid s pr _m sf) -> Seq $\n               Deep (s * length fs)\n                    (fmap (fmap firstf) (nodeToDigit pr))\n                    (liftA2Middle (fmap firstf) (fmap lastf) fmap fs\'\'FT r)\n                    (fmap (fmap lastf) (nodeToDigit sf))\n{-# NOINLINE [1] apSeq #-}\n\n{-# RULES\n"ap/fmap1" forall f xs ys . apSeq (fmapSeq f xs) ys = liftA2Seq f xs ys\n"ap/fmap2" forall f gs xs . apSeq gs (fmapSeq f xs) =\n                              liftA2Seq (\\g x -> g (f x)) gs xs\n"fmap/ap" forall f gs xs . fmapSeq f (gs `apSeq` xs) =\n                             liftA2Seq (\\g x -> f (g x)) gs xs\n"fmap/liftA2" forall f g m n . fmapSeq f (liftA2Seq g m n) =\n                       liftA2Seq (\\x y -> f (g x y)) m n\n"liftA2/fmap1" forall f g m n . liftA2Seq f (fmapSeq g m) n =\n                       liftA2Seq (\\x y -> f (g x) y) m n\n"liftA2/fmap2" forall f g m n . liftA2Seq f m (fmapSeq g n) =\n                       liftA2Seq (\\x y -> f x (g y)) m n\n #-}\n\nap2FT :: (a -> b) -> FingerTree (Elem (a->b)) -> (a -> b) -> (a,a) -> FingerTree (Elem b)\nap2FT firstf fs lastf (x,y) =\n                 Deep (size fs * 2 + 4)\n                      (Two (Elem $ firstf x) (Elem $ firstf y))\n                      (mapMulFT 2 (\\(Elem f) -> Node2 2 (Elem (f x)) (Elem (f y))) fs)\n                      (Two (Elem $ lastf x) (Elem $ lastf y))\n\nap3FT :: (a -> b) -> FingerTree (Elem (a->b)) -> (a -> b) -> (a,a,a) -> FingerTree (Elem b)\nap3FT firstf fs lastf (x,y,z) = Deep (size fs * 3 + 6)\n                        (Three (Elem $ firstf x) (Elem $ firstf y) (Elem $ firstf z))\n                        (mapMulFT 3 (\\(Elem f) -> Node3 3 (Elem (f x)) (Elem (f y)) (Elem (f z))) fs)\n                        (Three (Elem $ lastf x) (Elem $ lastf y) (Elem $ lastf z))\n\nlift2FT :: (a -> b -> c) -> a -> FingerTree (Elem a) -> a -> (b,b) -> FingerTree (Elem c)\nlift2FT f firstx xs lastx (y1,y2) =\n                 Deep (size xs * 2 + 4)\n                      (Two (Elem $ f firstx y1) (Elem $ f firstx y2))\n                      (mapMulFT 2 (\\(Elem x) -> Node2 2 (Elem (f x y1)) (Elem (f x y2))) xs)\n                      (Two (Elem $ f lastx y1) (Elem $ f lastx y2))\n\nlift3FT :: (a -> b -> c) -> a -> FingerTree (Elem a) -> a -> (b,b,b) -> FingerTree (Elem c)\nlift3FT f firstx xs lastx (y1,y2,y3) =\n                 Deep (size xs * 3 + 6)\n                      (Three (Elem $ f firstx y1) (Elem $ f firstx y2) (Elem $ f firstx y3))\n                      (mapMulFT 3 (\\(Elem x) -> Node3 3 (Elem (f x y1)) (Elem (f x y2)) (Elem (f x y3))) xs)\n                      (Three (Elem $ f lastx y1) (Elem $ f lastx y2) (Elem $ f lastx y3))\n\nliftA2Seq :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\nliftA2Seq f xs ys@(Seq ysFT) = case viewl xs of\n  EmptyL -> empty\n  firstx :< xs\' -> case viewr xs\' of\n    EmptyR -> f firstx <$> ys\n    Seq xs\'\'FT :> lastx -> case rigidify ysFT of\n      RigidEmpty -> empty\n      RigidOne (Elem y) -> fmap (\\x -> f x y) xs\n      RigidTwo (Elem y1) (Elem y2) ->\n        Seq $ lift2FT f firstx xs\'\'FT lastx (y1, y2)\n      RigidThree (Elem y1) (Elem y2) (Elem y3) ->\n        Seq $ lift3FT f firstx xs\'\'FT lastx (y1, y2, y3)\n      RigidFull r@(Rigid s pr _m sf) -> Seq $\n        Deep (s * length xs)\n             (fmap (fmap (f firstx)) (nodeToDigit pr))\n             (liftA2Middle (fmap (f firstx)) (fmap (f lastx)) (lift_elem f) xs\'\'FT r)\n             (fmap (fmap (f lastx)) (nodeToDigit sf))\n  where\n    lift_elem :: (a -> b -> c) -> a -> Elem b -> Elem c\n#ifdef __GLASGOW_HASKELL__\n    lift_elem = coerce\n#else\n    lift_elem f x (Elem y) = Elem (f x y)\n#endif\n{-# NOINLINE [1] liftA2Seq #-}\n\n\ndata Rigidified a = RigidEmpty\n                  | RigidOne a\n                  | RigidTwo a a\n                  | RigidThree a a a\n                  | RigidFull (Rigid a)\n#ifdef TESTING\n                  deriving Show\n#endif\n\n-- | A finger tree whose top level has only Two and/or Three digits, and whose\n-- other levels have only One and Two digits. A Rigid tree is precisely what one\n-- gets by unzipping/inverting a 2-3 tree, so it is precisely what we need to\n-- turn a finger tree into in order to transform it into a 2-3 tree.\ndata Rigid a = Rigid {-# UNPACK #-} !Int !(Digit23 a) (Thin (Node a)) !(Digit23 a)\n#ifdef TESTING\n             deriving Show\n#endif\n\n-- | A finger tree whose digits are all ones and twos\ndata Thin a = EmptyTh\n            | SingleTh a\n            | DeepTh {-# UNPACK #-} !Int !(Digit12 a) (Thin (Node a)) !(Digit12 a)\n#ifdef TESTING\n            deriving Show\n#endif\n\ndata Digit12 a = One12 a | Two12 a a\n#ifdef TESTING\n        deriving Show\n#endif\n\n-- | Sometimes, we want to emphasize that we are viewing a node as a top-level\n-- digit of a \'Rigid\' tree.\ntype Digit23 a = Node a\n\n-- | \'liftA2Middle\' does most of the hard work of computing @liftA2 f xs ys@.  It\n-- produces the center part of a finger tree, with a prefix corresponding to\n-- the first element of @xs@ and a suffix corresponding to its last element omitted;\n-- the missing suffix and prefix are added by the caller.  For the recursive\n-- call, it squashes the prefix and the suffix into the center tree. Once it\n-- gets to the bottom, it turns the tree into a 2-3 tree, applies \'mapMulFT\' to\n-- produce the main body, and glues all the pieces together.\n--\n-- @f@ itself is a bit horrifying because of the nested types involved. Its\n-- job is to map over the *elements* of a 2-3 tree, rather than the subtrees.\n-- If we used a higher-order nested type with MPTC, we could probably use a\n-- class, but as it is we have to build up @f@ explicitly through the\n-- recursion.\n--\n-- === Description of parameters\n--\n-- ==== Types\n--\n-- @a@ remains constant through recursive calls (in the @DeepTh@ case),\n-- while @b@ and @c@ do not: \'liftAMiddle\' calls itself at types @Node b@ and\n-- @Node c@.\n--\n-- ==== Values\n--\n-- \'liftA2Middle\' is used when the original @xs :: Sequence a@ has at\n-- least two elements, so it can be decomposed by taking off the first and last\n-- elements:\n--\n-- > xs = firstx <: midxs :> lastx\n--\n-- - the first two arguments @ffirstx, flastx :: b -> c@ are equal to\n--   @f firstx@ and @f lastx@, where @f :: a -> b -> c@ is the third argument.\n--   This ensures sharing when @f@ computes some data upon being partially\n--   applied to its first argument. The way @f@ gets accumulated also ensures\n--   sharing for the middle section.\n--\n-- - the fourth argument is the middle part @midxs@, always constant.\n--\n-- - the last argument, a tuple of type @Rigid b@, holds all the elements of\n--   @ys@, in three parts: a middle part around which the recursion is\n--   structured, surrounded by a prefix and a suffix that accumulate\n--   elements on the side as we walk down the middle.\n--\n-- === Invariants\n--\n-- > 1. Viewing the various trees as the lists they represent\n-- >    (the types of the toList functions are given a few paragraphs below):\n-- >\n-- >    toListFTN result\n-- >      =  (ffirstx                    <$> (toListThinN m ++ toListD sf))\n-- >      ++ (f      <$> toListFTE midxs <*> (toListD pr ++ toListThinN m ++ toListD sf))\n-- >      ++ (flastx                     <$> (toListD pr ++ toListThinN m))\n-- >\n-- > 2. s = size m + size pr + size sf\n-- >\n-- > 3. size (ffirstx y) = size (flastx y) = size (f x y) = size y\n-- >      for any (x :: a) (y :: b)\n--\n-- Projecting invariant 1 on sizes, using 2 and 3 to simplify, we have the\n-- following corollary.\n-- It is weaker than invariant 1, but it may be easier to keep track of.\n--\n-- > 1a. size result = s * (size midxs + 1) + size m\n--\n-- In invariant 1, the types of the auxiliary functions are as follows\n-- for reference:\n--\n-- > toListFTE   :: FingerTree (Elem a) -> [a]\n-- > toListFTN   :: FingerTree (Node c) -> [c]\n-- > toListThinN :: Thin (Node b) -> [b]\n-- > toListD     :: Digit12 b -> [b]\nliftA2Middle\n  :: (b -> c)              -- ^ @ffirstx@\n  -> (b -> c)              -- ^ @flastx@\n  -> (a -> b -> c)         -- ^ @f@\n  -> FingerTree (Elem a)   -- ^ @midxs@\n  -> Rigid b               -- ^ @Rigid s pr m sf@ (@pr@: prefix, @sf@: suffix)\n  -> FingerTree (Node c)\n\n-- Not at the bottom yet\n\nliftA2Middle\n    ffirstx\n    flastx\n    f\n    midxs\n    (Rigid s pr (DeepTh sm prm mm sfm) sf)\n    -- note: size (DeepTh sm pr mm sfm) = sm = size pr + size mm + size sfm\n    = Deep (sm + s * (size midxs + 1)) -- note: sm = s - size pr - size sf\n           (fmap (fmap ffirstx) (digit12ToDigit prm))\n           (liftA2Middle\n               (fmap ffirstx)\n               (fmap flastx)\n               (fmap . f)\n               midxs\n               (Rigid s (squashL pr prm) mm (squashR sfm sf)))\n           (fmap (fmap flastx) (digit12ToDigit sfm))\n\n-- At the bottom\n\nliftA2Middle\n    ffirstx\n    flastx\n    f\n    midxs\n    (Rigid s pr EmptyTh sf)\n    = deep\n           (One (fmap ffirstx sf))\n           (mapMulFT s (\\(Elem x) -> fmap (fmap (f x)) converted) midxs)\n           (One (fmap flastx pr))\n   where converted = node2 pr sf\n\nliftA2Middle\n    ffirstx\n    flastx\n    f\n    midxs\n    (Rigid s pr (SingleTh q) sf)\n    = deep\n           (Two (fmap ffirstx q) (fmap ffirstx sf))\n           (mapMulFT s (\\(Elem x) -> fmap (fmap (f x)) converted) midxs)\n           (Two (fmap flastx pr) (fmap flastx q))\n   where converted = node3 pr q sf\n\ndigit12ToDigit :: Digit12 a -> Digit a\ndigit12ToDigit (One12 a) = One a\ndigit12ToDigit (Two12 a b) = Two a b\n\n-- Squash the first argument down onto the left side of the second.\nsquashL :: Digit23 a -> Digit12 (Node a) -> Digit23 (Node a)\nsquashL m (One12 n) = node2 m n\nsquashL m (Two12 n1 n2) = node3 m n1 n2\n\n-- Squash the second argument down onto the right side of the first\nsquashR :: Digit12 (Node a) -> Digit23 a -> Digit23 (Node a)\nsquashR (One12 n) m = node2 n m\nsquashR (Two12 n1 n2) m = node3 n1 n2 m\n\n\n-- | \\(O(mn)\\) (incremental) Takes an \\(O(m)\\) function and a finger tree of size\n-- \\(n\\) and maps the function over the tree leaves. Unlike the usual \'fmap\', the\n-- function is applied to the "leaves" of the \'FingerTree\' (i.e., given a\n-- @FingerTree (Elem a)@, it applies the function to elements of type @Elem\n-- a@), replacing the leaves with subtrees of at least the same height, e.g.,\n-- @Node(Node(Elem y))@. The multiplier argument serves to make the annotations\n-- match up properly.\nmapMulFT :: Int -> (a -> b) -> FingerTree a -> FingerTree b\nmapMulFT !_ _ EmptyT = EmptyT\nmapMulFT _mul f (Single a) = Single (f a)\nmapMulFT mul f (Deep s pr m sf) = Deep (mul * s) (fmap f pr) (mapMulFT mul (mapMulNode mul f) m) (fmap f sf)\n\nmapMulNode :: Int -> (a -> b) -> Node a -> Node b\nmapMulNode mul f (Node2 s a b)   = Node2 (mul * s) (f a) (f b)\nmapMulNode mul f (Node3 s a b c) = Node3 (mul * s) (f a) (f b) (f c)\n\n-- | \\(O(\\log n)\\) (incremental) Takes the extra flexibility out of a \'FingerTree\'\n-- to make it a genuine 2-3 finger tree. The result of \'rigidify\' will have\n-- only two and three digits at the top level and only one and two\n-- digits elsewhere. If the tree has fewer than four elements, \'rigidify\'\n-- will simply extract them, and will not build a tree.\nrigidify :: FingerTree (Elem a) -> Rigidified (Elem a)\n-- The patterns below just fix up the top level of the tree; \'rigidify\'\n-- delegates the hard work to \'thin\'.\n\nrigidify EmptyT = RigidEmpty\n\nrigidify (Single q) = RigidOne q\n\n-- The left digit is Two or Three\nrigidify (Deep s (Two a b) m sf) = rigidifyRight s (node2 a b) m sf\nrigidify (Deep s (Three a b c) m sf) = rigidifyRight s (node3 a b c) m sf\n\n-- The left digit is Four\nrigidify (Deep s (Four a b c d) m sf) = rigidifyRight s (node2 a b) (node2 c d `consTree` m) sf\n\n-- The left digit is One\nrigidify (Deep s (One a) m sf) = case viewLTree m of\n   ConsLTree (Node2 _ b c) m\' -> rigidifyRight s (node3 a b c) m\' sf\n   ConsLTree (Node3 _ b c d) m\' -> rigidifyRight s (node2 a b) (node2 c d `consTree` m\') sf\n   EmptyLTree -> case sf of\n     One b -> RigidTwo a b\n     Two b c -> RigidThree a b c\n     Three b c d -> RigidFull $ Rigid s (node2 a b) EmptyTh (node2 c d)\n     Four b c d e -> RigidFull $ Rigid s (node3 a b c) EmptyTh (node2 d e)\n\n-- | \\(O(\\log n)\\) (incremental) Takes a tree whose left side has been rigidified\n-- and finishes the job.\nrigidifyRight :: Int -> Digit23 (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> Rigidified (Elem a)\n\n-- The right digit is Two, Three, or Four\nrigidifyRight s pr m (Two a b) = RigidFull $ Rigid s pr (thin m) (node2 a b)\nrigidifyRight s pr m (Three a b c) = RigidFull $ Rigid s pr (thin m) (node3 a b c)\nrigidifyRight s pr m (Four a b c d) = RigidFull $ Rigid s pr (thin $ m `snocTree` node2 a b) (node2 c d)\n\n-- The right digit is One\nrigidifyRight s pr m (One e) = case viewRTree m of\n    SnocRTree m\' (Node2 _ a b) -> RigidFull $ Rigid s pr (thin m\') (node3 a b e)\n    SnocRTree m\' (Node3 _ a b c) -> RigidFull $ Rigid s pr (thin $ m\' `snocTree` node2 a b) (node2 c e)\n    EmptyRTree -> case pr of\n      Node2 _ a b -> RigidThree a b e\n      Node3 _ a b c -> RigidFull $ Rigid s (node2 a b) EmptyTh (node2 c e)\n\n-- | \\(O(\\log n)\\) (incremental) Rejigger a finger tree so the digits are all ones\n-- and twos.\nthin :: Sized a => FingerTree a -> Thin a\n-- Note that \'thin12\' will produce a \'DeepTh\' constructor immediately before\n-- recursively calling \'thin\'.\nthin EmptyT = EmptyTh\nthin (Single a) = SingleTh a\nthin (Deep s pr m sf) =\n  case pr of\n    One a -> thin12 s (One12 a) m sf\n    Two a b -> thin12 s (Two12 a b) m sf\n    Three a b c  -> thin12 s (One12 a) (node2 b c `consTree` m) sf\n    Four a b c d -> thin12 s (Two12 a b) (node2 c d `consTree` m) sf\n\nthin12 :: Sized a => Int -> Digit12 a -> FingerTree (Node a) -> Digit a -> Thin a\nthin12 s pr m (One a) = DeepTh s pr (thin m) (One12 a)\nthin12 s pr m (Two a b) = DeepTh s pr (thin m) (Two12 a b)\nthin12 s pr m (Three a b c) = DeepTh s pr (thin $ m `snocTree` node2 a b) (One12 c)\nthin12 s pr m (Four a b c d) = DeepTh s pr (thin $ m `snocTree` node2 a b) (Two12 c d)\n\n-- | \\( O(n) \\). Intersperse an element between the elements of a sequence.\n--\n-- @\n-- intersperse a empty = empty\n-- intersperse a (singleton x) = singleton x\n-- intersperse a (fromList [x,y]) = fromList [x,a,y]\n-- intersperse a (fromList [x,y,z]) = fromList [x,a,y,a,z]\n-- @\n--\n-- @since 0.5.8\nintersperse :: a -> Seq a -> Seq a\nintersperse y xs = case viewl xs of\n  EmptyL -> empty\n  p :< ps -> p <| (ps <**> (const y <| singleton id))\n-- We used to use\n--\n-- intersperse y xs = drop 1 $ xs <**> (const y <| singleton id)\n--\n-- but if length xs = ((maxBound :: Int) `quot` 2) + 1 then\n--\n-- length (xs <**> (const y <| singleton id)) will wrap around to negative\n-- and the drop won\'t work. The new implementation can produce a result\n-- right up to maxBound :: Int\n\ninstance MonadPlus Seq where\n    mzero = empty\n    mplus = (><)\n\n-- | @since 0.5.4\ninstance Alternative Seq where\n    empty = empty\n    (<|>) = (><)\n\ninstance Eq a => Eq (Seq a) where\n    xs == ys = length xs == length ys && toList xs == toList ys\n\ninstance Ord a => Ord (Seq a) where\n    compare xs ys = compare (toList xs) (toList ys)\n\n#ifdef TESTING\ninstance Show a => Show (Seq a) where\n    showsPrec p (Seq x) = showsPrec p x\n#else\ninstance Show a => Show (Seq a) where\n    showsPrec p xs = showParen (p > 10) $\n        showString "fromList " . shows (toList xs)\n#endif\n\n-- | @since 0.5.9\ninstance Show1 Seq where\n  liftShowsPrec _shwsPrc shwList p xs = showParen (p > 10) $\n        showString "fromList " . shwList (toList xs)\n\n-- | @since 0.5.9\ninstance Eq1 Seq where\n    liftEq eq xs ys = length xs == length ys && liftEq eq (toList xs) (toList ys)\n\n-- | @since 0.5.9\ninstance Ord1 Seq where\n    liftCompare cmp xs ys = liftCompare cmp (toList xs) (toList ys)\n\ninstance Read a => Read (Seq a) where\n#ifdef __GLASGOW_HASKELL__\n    readPrec = parens $ prec 10 $ do\n        Ident "fromList" <- lexP\n        xs <- readPrec\n        return (fromList xs)\n\n    readListPrec = readListPrecDefault\n#else\n    readsPrec p = readParen (p > 10) $ \\ r -> do\n        ("fromList",s) <- lex r\n        (xs,t) <- reads s\n        return (fromList xs,t)\n#endif\n\n-- | @since 0.5.9\ninstance Read1 Seq where\n  liftReadsPrec _rp readLst p = readParen (p > 10) $ \\r -> do\n    ("fromList",s) <- lex r\n    (xs,t) <- readLst s\n    pure (fromList xs, t)\n\ninstance Monoid (Seq a) where\n    mempty = empty\n    mappend = (Semigroup.<>)\n\n-- | @since 0.5.7\ninstance Semigroup.Semigroup (Seq a) where\n    (<>)    = (><)\n    stimes = cycleNTimes . fromIntegral\n\n#if __GLASGOW_HASKELL__\ninstance Data a => Data (Seq a) where\n    gfoldl f z s    = case viewl s of\n        EmptyL  -> z empty\n        x :< xs -> z (<|) `f` x `f` xs\n\n    gunfold k z c   = case constrIndex c of\n        1 -> z empty\n        2 -> k (k (z (<|)))\n        _ -> error "gunfold"\n\n    toConstr xs\n      | null xs     = emptyConstr\n      | otherwise   = consConstr\n\n    dataTypeOf _    = seqDataType\n\n    dataCast1 f     = gcast1 f\n\nemptyConstr, consConstr :: Constr\nemptyConstr = mkConstr seqDataType "empty" [] Prefix\nconsConstr  = mkConstr seqDataType "<|" [] Infix\n\nseqDataType :: DataType\nseqDataType = mkDataType "Data.Sequence.Seq" [emptyConstr, consConstr]\n#endif\n\n-- Finger trees\n\ndata FingerTree a\n    = EmptyT\n    | Single a\n    | Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)\n#ifdef TESTING\n    deriving Show\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.1\nderiving instance Generic1 FingerTree\n\n-- | @since 0.6.1\nderiving instance Generic (FingerTree a)\n\n-- | @since 0.6.6\nderiving instance TH.Lift a => TH.Lift (FingerTree a)\n#endif\n\ninstance Sized a => Sized (FingerTree a) where\n    {-# SPECIALIZE instance Sized (FingerTree (Elem a)) #-}\n    {-# SPECIALIZE instance Sized (FingerTree (Node a)) #-}\n    size EmptyT             = 0\n    size (Single x)         = size x\n    size (Deep v _ _ _)     = v\n\ninstance Foldable FingerTree where\n    foldMap _ EmptyT = mempty\n    foldMap f\' (Single x\') = f\' x\'\n    foldMap f\' (Deep _ pr\' m\' sf\') =\n        foldMapDigit f\' pr\' <>\n        foldMapTree (foldMapNode f\') m\' <>\n        foldMapDigit f\' sf\'\n      where\n        foldMapTree :: Monoid m => (Node a -> m) -> FingerTree (Node a) -> m\n        foldMapTree _ EmptyT = mempty\n        foldMapTree f (Single x) = f x\n        foldMapTree f (Deep _ pr m sf) =\n            foldMapDigitN f pr <>\n            foldMapTree (foldMapNodeN f) m <>\n            foldMapDigitN f sf\n\n        foldMapDigit :: Monoid m => (a -> m) -> Digit a -> m\n        foldMapDigit f t = foldDigit (<>) f t\n\n        foldMapDigitN :: Monoid m => (Node a -> m) -> Digit (Node a) -> m\n        foldMapDigitN f t = foldDigit (<>) f t\n\n        foldMapNode :: Monoid m => (a -> m) -> Node a -> m\n        foldMapNode f t = foldNode (<>) f t\n\n        foldMapNodeN :: Monoid m => (Node a -> m) -> Node (Node a) -> m\n        foldMapNodeN f t = foldNode (<>) f t\n#if __GLASGOW_HASKELL__\n    {-# INLINABLE foldMap #-}\n#endif\n\n    foldr _ z\' EmptyT = z\'\n    foldr f\' z\' (Single x\') = x\' `f\'` z\'\n    foldr f\' z\' (Deep _ pr\' m\' sf\') =\n        foldrDigit f\' (foldrTree (foldrNode f\') (foldrDigit f\' z\' sf\') m\') pr\'\n      where\n        foldrTree :: (Node a -> b -> b) -> b -> FingerTree (Node a) -> b\n        foldrTree _ z EmptyT = z\n        foldrTree f z (Single x) = x `f` z\n        foldrTree f z (Deep _ pr m sf) =\n            foldrDigitN f (foldrTree (foldrNodeN f) (foldrDigitN f z sf) m) pr\n\n        foldrDigit :: (a -> b -> b) -> b -> Digit a -> b\n        foldrDigit f z t = foldr f z t\n\n        foldrDigitN :: (Node a -> b -> b) -> b -> Digit (Node a) -> b\n        foldrDigitN f z t = foldr f z t\n\n        foldrNode :: (a -> b -> b) -> Node a -> b -> b\n        foldrNode f t z = foldr f z t\n\n        foldrNodeN :: (Node a -> b -> b) -> Node (Node a) -> b -> b\n        foldrNodeN f t z = foldr f z t\n    {-# INLINE foldr #-}\n\n\n    foldl _ z\' EmptyT = z\'\n    foldl f\' z\' (Single x\') = z\' `f\'` x\'\n    foldl f\' z\' (Deep _ pr\' m\' sf\') =\n        foldlDigit f\' (foldlTree (foldlNode f\') (foldlDigit f\' z\' pr\') m\') sf\'\n      where\n        foldlTree :: (b -> Node a -> b) -> b -> FingerTree (Node a) -> b\n        foldlTree _ z EmptyT = z\n        foldlTree f z (Single x) = z `f` x\n        foldlTree f z (Deep _ pr m sf) =\n            foldlDigitN f (foldlTree (foldlNodeN f) (foldlDigitN f z pr) m) sf\n\n        foldlDigit :: (b -> a -> b) -> b -> Digit a -> b\n        foldlDigit f z t = foldl f z t\n\n        foldlDigitN :: (b -> Node a -> b) -> b -> Digit (Node a) -> b\n        foldlDigitN f z t = foldl f z t\n\n        foldlNode :: (b -> a -> b) -> b -> Node a -> b\n        foldlNode f z t = foldl f z t\n\n        foldlNodeN :: (b -> Node a -> b) -> b -> Node (Node a) -> b\n        foldlNodeN f z t = foldl f z t\n    {-# INLINE foldl #-}\n\n    foldr\' _ z\' EmptyT = z\'\n    foldr\' f\' z\' (Single x\') = f\' x\' z\'\n    foldr\' f\' z\' (Deep _ pr\' m\' sf\') =\n        (foldrDigit\' f\' $! (foldrTree\' (foldrNode\' f\') $! (foldrDigit\' f\' z\') sf\') m\') pr\'\n      where\n        foldrTree\' :: (Node a -> b -> b) -> b -> FingerTree (Node a) -> b\n        foldrTree\' _ z EmptyT = z\n        foldrTree\' f z (Single x) = f x $! z\n        foldrTree\' f z (Deep _ pr m sf) =\n            (foldr\' f $! (foldrTree\' (foldrNodeN\' f) $! (foldr\' f $! z) sf) m) pr\n\n        foldrDigit\' :: (a -> b -> b) -> b -> Digit a -> b\n        foldrDigit\' f z t = foldr\' f z t\n\n        foldrNode\' :: (a -> b -> b) -> Node a -> b -> b\n        foldrNode\' f t z = foldr\' f z t\n\n        foldrNodeN\' :: (Node a -> b -> b) -> Node (Node a) -> b -> b\n        foldrNodeN\' f t z = foldr\' f z t\n    {-# INLINE foldr\' #-}\n\n    foldl\' _ z\' EmptyT = z\'\n    foldl\' f\' z\' (Single x\') = f\' z\' x\'\n    foldl\' f\' z\' (Deep _ pr\' m\' sf\') =\n        (foldlDigit\' f\' $!\n         (foldlTree\' (foldlNode\' f\') $! (foldlDigit\' f\' z\') pr\') m\')\n            sf\'\n      where\n        foldlTree\' :: (b -> Node a -> b) -> b -> FingerTree (Node a) -> b\n        foldlTree\' _ z EmptyT = z\n        foldlTree\' f z (Single xs) = f z xs\n        foldlTree\' f z (Deep _ pr m sf) =\n            (foldl\' f $! (foldlTree\' (foldl\' f) $! foldl\' f z pr) m) sf\n\n        foldlDigit\' :: (b -> a -> b) -> b -> Digit a -> b\n        foldlDigit\' f z t = foldl\' f z t\n\n        foldlNode\' :: (b -> a -> b) -> b -> Node a -> b\n        foldlNode\' f z t = foldl\' f z t\n    {-# INLINE foldl\' #-}\n\n    foldr1 _ EmptyT = error "foldr1: empty sequence"\n    foldr1 _ (Single x) = x\n    foldr1 f (Deep _ pr m sf) =\n        foldr f (foldr (flip (foldr f)) (foldr1 f sf) m) pr\n\n    foldl1 _ EmptyT = error "foldl1: empty sequence"\n    foldl1 _ (Single x) = x\n    foldl1 f (Deep _ pr m sf) =\n        foldl f (foldl (foldl f) (foldl1 f pr) m) sf\n\ninstance Functor FingerTree where\n    fmap _ EmptyT = EmptyT\n    fmap f (Single x) = Single (f x)\n    fmap f (Deep v pr m sf) =\n        Deep v (fmap f pr) (fmap (fmap f) m) (fmap f sf)\n\ninstance Traversable FingerTree where\n    traverse _ EmptyT = pure EmptyT\n    traverse f (Single x) = Single <$> f x\n    traverse f (Deep v pr m sf) =\n        liftA3 (Deep v) (traverse f pr) (traverse (traverse f) m)\n            (traverse f sf)\n\ninstance NFData a => NFData (FingerTree a) where\n    rnf EmptyT = ()\n    rnf (Single x) = rnf x\n    rnf (Deep _ pr m sf) = rnf pr `seq` rnf sf `seq` rnf m\n\n{-# INLINE deep #-}\ndeep            :: Sized a => Digit a -> FingerTree (Node a) -> Digit a -> FingerTree a\ndeep pr m sf    =  Deep (size pr + size m + size sf) pr m sf\n\n{-# INLINE pullL #-}\npullL :: Int -> FingerTree (Node a) -> Digit a -> FingerTree a\npullL s m sf = case viewLTree m of\n    EmptyLTree          -> digitToTree\' s sf\n    ConsLTree pr m\'     -> Deep s (nodeToDigit pr) m\' sf\n\n{-# INLINE pullR #-}\npullR :: Int -> Digit a -> FingerTree (Node a) -> FingerTree a\npullR s pr m = case viewRTree m of\n    EmptyRTree          -> digitToTree\' s pr\n    SnocRTree m\' sf     -> Deep s pr m\' (nodeToDigit sf)\n\n-- Digits\n\ndata Digit a\n    = One a\n    | Two a a\n    | Three a a a\n    | Four a a a a\n#ifdef TESTING\n    deriving Show\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.1\nderiving instance Generic1 Digit\n\n-- | @since 0.6.1\nderiving instance Generic (Digit a)\n\n-- | @since 0.6.6\nderiving instance TH.Lift a => TH.Lift (Digit a)\n#endif\n\nfoldDigit :: (b -> b -> b) -> (a -> b) -> Digit a -> b\nfoldDigit _     f (One a) = f a\nfoldDigit (<+>) f (Two a b) = f a <+> f b\nfoldDigit (<+>) f (Three a b c) = f a <+> f b <+> f c\nfoldDigit (<+>) f (Four a b c d) = f a <+> f b <+> f c <+> f d\n{-# INLINE foldDigit #-}\n\ninstance Foldable Digit where\n    foldMap = foldDigit mappend\n\n    foldr f z (One a) = a `f` z\n    foldr f z (Two a b) = a `f` (b `f` z)\n    foldr f z (Three a b c) = a `f` (b `f` (c `f` z))\n    foldr f z (Four a b c d) = a `f` (b `f` (c `f` (d `f` z)))\n    {-# INLINE foldr #-}\n\n    foldl f z (One a) = z `f` a\n    foldl f z (Two a b) = (z `f` a) `f` b\n    foldl f z (Three a b c) = ((z `f` a) `f` b) `f` c\n    foldl f z (Four a b c d) = (((z `f` a) `f` b) `f` c) `f` d\n    {-# INLINE foldl #-}\n\n    foldr\' f z (One a) = f a z\n    foldr\' f z (Two a b) = f a $! f b z\n    foldr\' f z (Three a b c) = f a $! f b $! f c z\n    foldr\' f z (Four a b c d) = f a $! f b $! f c $! f d z\n    {-# INLINE foldr\' #-}\n\n    foldl\' f z (One a) = f z a\n    foldl\' f z (Two a b) = (f $! f z a) b\n    foldl\' f z (Three a b c) = (f $! (f $! f z a) b) c\n    foldl\' f z (Four a b c d) = (f $! (f $! (f $! f z a) b) c) d\n    {-# INLINE foldl\' #-}\n\n    foldr1 _ (One a) = a\n    foldr1 f (Two a b) = a `f` b\n    foldr1 f (Three a b c) = a `f` (b `f` c)\n    foldr1 f (Four a b c d) = a `f` (b `f` (c `f` d))\n\n    foldl1 _ (One a) = a\n    foldl1 f (Two a b) = a `f` b\n    foldl1 f (Three a b c) = (a `f` b) `f` c\n    foldl1 f (Four a b c d) = ((a `f` b) `f` c) `f` d\n\ninstance Functor Digit where\n    {-# INLINE fmap #-}\n    fmap f (One a) = One (f a)\n    fmap f (Two a b) = Two (f a) (f b)\n    fmap f (Three a b c) = Three (f a) (f b) (f c)\n    fmap f (Four a b c d) = Four (f a) (f b) (f c) (f d)\n\ninstance Traversable Digit where\n    {-# INLINE traverse #-}\n    traverse f (One a) = One <$> f a\n    traverse f (Two a b) = liftA2 Two (f a) (f b)\n    traverse f (Three a b c) = liftA3 Three (f a) (f b) (f c)\n    traverse f (Four a b c d) = liftA3 Four (f a) (f b) (f c) <*> f d\n\ninstance NFData a => NFData (Digit a) where\n    rnf (One a) = rnf a\n    rnf (Two a b) = rnf a `seq` rnf b\n    rnf (Three a b c) = rnf a `seq` rnf b `seq` rnf c\n    rnf (Four a b c d) = rnf a `seq` rnf b `seq` rnf c `seq` rnf d\n\ninstance Sized a => Sized (Digit a) where\n    {-# INLINE size #-}\n    size = foldl1 (+) . fmap size\n\n{-# SPECIALIZE digitToTree :: Digit (Elem a) -> FingerTree (Elem a) #-}\n{-# SPECIALIZE digitToTree :: Digit (Node a) -> FingerTree (Node a) #-}\ndigitToTree     :: Sized a => Digit a -> FingerTree a\ndigitToTree (One a) = Single a\ndigitToTree (Two a b) = deep (One a) EmptyT (One b)\ndigitToTree (Three a b c) = deep (Two a b) EmptyT (One c)\ndigitToTree (Four a b c d) = deep (Two a b) EmptyT (Two c d)\n\n-- | Given the size of a digit and the digit itself, efficiently converts\n-- it to a FingerTree.\ndigitToTree\' :: Int -> Digit a -> FingerTree a\ndigitToTree\' n (Four a b c d) = Deep n (Two a b) EmptyT (Two c d)\ndigitToTree\' n (Three a b c) = Deep n (Two a b) EmptyT (One c)\ndigitToTree\' n (Two a b) = Deep n (One a) EmptyT (One b)\ndigitToTree\' !_n (One a) = Single a\n\n-- Nodes\n\ndata Node a\n    = Node2 {-# UNPACK #-} !Int a a\n    | Node3 {-# UNPACK #-} !Int a a a\n#ifdef TESTING\n    deriving Show\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.1\nderiving instance Generic1 Node\n\n-- | @since 0.6.1\nderiving instance Generic (Node a)\n\n-- | @since 0.6.6\nderiving instance TH.Lift a => TH.Lift (Node a)\n#endif\n\nfoldNode :: (b -> b -> b) -> (a -> b) -> Node a -> b\nfoldNode (<+>) f (Node2 _ a b) = f a <+> f b\nfoldNode (<+>) f (Node3 _ a b c) = f a <+> f b <+> f c\n{-# INLINE foldNode #-}\n\ninstance Foldable Node where\n    foldMap = foldNode mappend\n\n    foldr f z (Node2 _ a b) = a `f` (b `f` z)\n    foldr f z (Node3 _ a b c) = a `f` (b `f` (c `f` z))\n    {-# INLINE foldr #-}\n\n    foldl f z (Node2 _ a b) = (z `f` a) `f` b\n    foldl f z (Node3 _ a b c) = ((z `f` a) `f` b) `f` c\n    {-# INLINE foldl #-}\n\n    foldr\' f z (Node2 _ a b) = f a $! f b z\n    foldr\' f z (Node3 _ a b c) = f a $! f b $! f c z\n    {-# INLINE foldr\' #-}\n\n    foldl\' f z (Node2 _ a b) = (f $! f z a) b\n    foldl\' f z (Node3 _ a b c) = (f $! (f $! f z a) b) c\n    {-# INLINE foldl\' #-}\n\ninstance Functor Node where\n    {-# INLINE fmap #-}\n    fmap f (Node2 v a b) = Node2 v (f a) (f b)\n    fmap f (Node3 v a b c) = Node3 v (f a) (f b) (f c)\n\ninstance Traversable Node where\n    {-# INLINE traverse #-}\n    traverse f (Node2 v a b) = liftA2 (Node2 v) (f a) (f b)\n    traverse f (Node3 v a b c) = liftA3 (Node3 v) (f a) (f b) (f c)\n\ninstance NFData a => NFData (Node a) where\n    rnf (Node2 _ a b) = rnf a `seq` rnf b\n    rnf (Node3 _ a b c) = rnf a `seq` rnf b `seq` rnf c\n\ninstance Sized (Node a) where\n    size (Node2 v _ _)      = v\n    size (Node3 v _ _ _)    = v\n\n{-# INLINE node2 #-}\nnode2           :: Sized a => a -> a -> Node a\nnode2 a b       =  Node2 (size a + size b) a b\n\n{-# INLINE node3 #-}\nnode3           :: Sized a => a -> a -> a -> Node a\nnode3 a b c     =  Node3 (size a + size b + size c) a b c\n\nnodeToDigit :: Node a -> Digit a\nnodeToDigit (Node2 _ a b) = Two a b\nnodeToDigit (Node3 _ a b c) = Three a b c\n\n-- Elements\n\nnewtype Elem a  =  Elem { getElem :: a }\n#ifdef TESTING\n    deriving Show\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.6.1\nderiving instance Generic1 Elem\n\n-- | @since 0.6.1\nderiving instance Generic (Elem a)\n#endif\n\ninstance Sized (Elem a) where\n    size _ = 1\n\ninstance Functor Elem where\n#ifdef __GLASGOW_HASKELL__\n-- This cuts the time for <*> by around a fifth.\n    fmap = coerce\n#else\n    fmap f (Elem x) = Elem (f x)\n#endif\n\ninstance Foldable Elem where\n    foldr f z (Elem x) = f x z\n#ifdef __GLASGOW_HASKELL__\n    foldMap = coerce\n    foldl = coerce\n    foldl\' = coerce\n#else\n    foldMap f (Elem x) = f x\n    foldl f z (Elem x) = f z x\n    foldl\' f z (Elem x) = f z x\n#endif\n\ninstance Traversable Elem where\n    traverse f (Elem x) = Elem <$> f x\n\ninstance NFData a => NFData (Elem a) where\n    rnf (Elem x) = rnf x\n\n-------------------------------------------------------\n-- Applicative construction\n-------------------------------------------------------\n\n-- | \'applicativeTree\' takes an Applicative-wrapped construction of a\n-- piece of a FingerTree, assumed to always have the same size (which\n-- is put in the second argument), and replicates it as many times as\n-- specified.  This is a generalization of \'replicateA\', which itself\n-- is a generalization of many Data.Sequence methods.\n{-# SPECIALIZE applicativeTree :: Int -> Int -> State s a -> State s (FingerTree a) #-}\n{-# SPECIALIZE applicativeTree :: Int -> Int -> Identity a -> Identity (FingerTree a) #-}\n-- Special note: the Identity specialization automatically does node sharing,\n-- reducing memory usage of the resulting tree to \\(O(\\log n)\\).\napplicativeTree :: Applicative f => Int -> Int -> f a -> f (FingerTree a)\napplicativeTree n !mSize m = case n of\n    0 -> pure EmptyT\n    1 -> fmap Single m\n    2 -> deepA one emptyTree one\n    3 -> deepA two emptyTree one\n    4 -> deepA two emptyTree two\n    5 -> deepA three emptyTree two\n    6 -> deepA three emptyTree three\n    _ -> case n `quotRem` 3 of\n           (q,0) -> deepA three (applicativeTree (q - 2) mSize\' n3) three\n           (q,1) -> deepA two (applicativeTree (q - 1) mSize\' n3) two\n           (q,_) -> deepA three (applicativeTree (q - 1) mSize\' n3) two\n      where !mSize\' = 3 * mSize\n            n3 = liftA3 (Node3 mSize\') m m m\n  where\n    one = fmap One m\n    two = liftA2 Two m m\n    three = liftA3 Three m m m\n    deepA = liftA3 (Deep (n * mSize))\n    emptyTree = pure EmptyT\n\ndata RCountMid a = RCountMid\n  !(Node a)  -- End of the first\n  !Int -- Number of units in the middle\n  !(Node a)  -- Beginning of the last\n\n{-\nWe could generalize beforeSeq quite easily to\n\n  beforeSeq :: (a -> c) -> Seq a -> Seq b -> Seq c\n\nThis would let us add a rewrite rule\n\n  fmap f xs <* ys  ==>  beforeSeq f xs ys\n\nWe don\'t currently bother because I don\'t yet know of a practical use for (<*)\nfor sequences; a rewrite rule to optimize it seems like extreme overkill.\n-}\n\nbeforeSeq :: Seq a -> Seq b -> Seq a\nbeforeSeq xs ys = replicateEach (length ys) xs\n\n-- | Replicate each element of a sequence the given number of times.\n--\n-- @replicateEach 3 [1,2] = [1,1,1,2,2,2]@\n-- @replicateEach n xs = xs >>= replicate n@\nreplicateEach :: Int -> Seq a -> Seq a\n-- The main idea is that we construct a function that takes an element and\n-- produces a 2-3 tree representing that element replicated lenys times. We map\n-- that function over the sequence to (mostly) produce the desired fingertree. But\n-- if we *just* did that, we\'d end up with a fingertree of 2-3 trees of the given\n-- size, not of elements. So we need to work our way down to the appropriate\n-- level by building the left side of the fingertree corresponding to the first\n-- 2-3 tree and the right side corresponding to the last one, along with the\n-- 2-3 trees corresponding to the right side of the first and the left side of\n-- the last.\nreplicateEach lenys xs = case viewl xs of\n  EmptyL -> empty\n  firstx :< xs\' -> case viewr xs\' of\n    EmptyR -> replicate lenys firstx\n    Seq midxs :> lastx -> case lenys of\n      0 -> empty\n      1 -> xs\n      2 ->\n        Seq $ rep2EachFT fxE midxs lxE\n      3 ->\n        Seq $ rep3EachFT fxE midxs lxE\n      _ -> Seq $ case lenys `quotRem` 3 of  -- lenys > 3\n             (q,0) -> Deep (lenys * length xs) fd3\n               (repEachMiddle_ lift_elem (RCountMid fn3 (q - 2) ln3))\n               ld3\n                   where\n                    lift_elem a = let n3a = n3 a in (n3a, n3a, n3a)\n             (q,1) -> Deep (lenys * length xs) fd2\n               (repEachMiddle_ lift_elem (RCountMid fn2 (q - 1) ln2))\n               ld2\n                   where\n                    lift_elem a = let n2a = n2 a in (n2a, n3 a, n2a)\n             (q,_) -> Deep (lenys * length xs) fd3\n               (repEachMiddle_ lift_elem (RCountMid fn2 (q - 1) ln3))\n               ld2\n                   where\n                    lift_elem a = let n3a = n3 a in (n3a, n3a, n2 a)\n        where\n          repEachMiddle_ = repEachMiddle midxs lenys 3 fn3 ln3\n          fd2 = Two fxE fxE\n          fd3 = Three fxE fxE fxE\n          ld2 = Two lxE lxE\n          ld3 = Three lxE lxE lxE\n          fn2 = Node2 2 fxE fxE\n          fn3 = Node3 3 fxE fxE fxE\n          ln2 = Node2 2 lxE lxE\n          ln3 = Node3 3 lxE lxE lxE\n          n3 a = Node3 3 (Elem a) (Elem a) (Elem a)\n          n2 a = Node2 2 (Elem a) (Elem a)\n      where\n          fxE = Elem firstx\n          lxE = Elem lastx\n\nrep2EachFT :: Elem a -> FingerTree (Elem a) -> Elem a -> FingerTree (Elem a)\nrep2EachFT firstx xs lastx =\n                 Deep (size xs * 2 + 4)\n                      (Two firstx firstx)\n                      (mapMulFT 2 (\\ex -> Node2 2 ex ex) xs)\n                      (Two lastx lastx)\n\nrep3EachFT :: Elem a -> FingerTree (Elem a) -> Elem a -> FingerTree (Elem a)\nrep3EachFT firstx xs lastx =\n                 Deep (size xs * 3 + 6)\n                      (Three firstx firstx firstx)\n                      (mapMulFT 3 (\\ex -> Node3 3 ex ex ex) xs)\n                      (Three lastx lastx lastx)\n\n-- Invariants for repEachMiddle:\n--\n-- 1. midxs is constant: the middle bit in the original sequence (xs = (first <: Seq midxs :> last))\n-- 2. lenys is constant: the length of ys\n-- 3. firstx and pr repeat the same element: the first one in the original sequence xs\n-- 4. lastx  and sf repeat the same element: the last  one in the original sequence xs\n-- 5. sizec = size firstx = size lastx\n-- 6. lenys = deep_count * sizec + size pr + size pf\n-- 7. let (lft, fill, rght) = fill23 x, for any x:\n--      7a. All three sequences repeat the element x\n--      7b. size fill = sizec\n--      7c. size lft  = size sf\n--      7d. size rght = size pr\n-- 8. size result = deep_count * sizec + lenys * (size midxs + 1)\nrepEachMiddle\n  :: FingerTree (Elem a)  -- midxs\n  -> Int                  -- lenys\n  -> Int                  -- sizec\n  -> Node c               -- firstx\n  -> Node c               -- lastx\n  -> (a -> (Node c, Node c, Node c))  -- fill23\n  -> RCountMid c          -- (RCountMid pr deep_count sf)\n  -> FingerTree (Node c)  -- result\n\n-- At the bottom\n\nrepEachMiddle midxs lenys\n            !_sizec\n            _firstx\n            _lastx\n            fill23\n            (RCountMid pr 0 sf)\n     = Deep (lenys * (size midxs + 1))\n            (One pr)\n            (mapMulFT lenys fill23_final midxs)\n            (One sf)\n   where\n     -- fill23_final ::  Elem a -> Node (Node c)\n     fill23_final (Elem a) = case fill23 a of\n        -- See the note on lift_fill23 for an explanation of this\n        -- lazy pattern.\n        ~(lft, _fill, rght) -> Node2 (size pr + size sf) lft rght\n\nrepEachMiddle midxs lenys\n            !sizec\n            firstx\n            lastx\n            fill23\n            (RCountMid pr 1 sf)\n     = Deep (sizec + lenys * (size midxs + 1))\n            (Two pr firstx)\n            (mapMulFT lenys fill23_final midxs)\n            (Two lastx sf)\n   where\n     -- fill23_final ::  Elem a -> Node (Node c)\n     fill23_final (Elem a) = case fill23 a of\n        -- See the note on lift_fill23 for an explanation of this\n        -- lazy pattern.\n        ~(lft, fill, rght) -> Node3 (size pr + size sf + sizec) lft fill rght\n\n-- Not at the bottom yet\n\nrepEachMiddle midxs lenys\n            !sizec\n            firstx\n            lastx\n            fill23\n            (RCountMid pr deep_count sf)  -- deep_count > 1\n  = case deep_count `quotRem` 3 of\n      (q,0)\n       -> deep\'\n        (Two firstx firstx)\n        (repEachMiddle_\n           (lift_fill23 TOT3 TOT2 fill23)\n           (RCountMid pr\' (q - 1) sf\'))\n        (One lastx)\n       where\n        pr\' = node2 firstx pr\n        sf\' = node3 lastx lastx sf\n      (q,1)\n       -> deep\'\n        (Two firstx firstx)\n        (repEachMiddle_\n           (lift_fill23 TOT3 TOT3 fill23)\n           (RCountMid pr\' (q - 1) sf\'))\n        (Two lastx lastx)\n       where\n        pr\' = node3 firstx firstx pr\n        sf\' = node3 lastx lastx sf\n      (q,_) -- the remainder is 2\n       -> deep\'\n        (One firstx)\n        (repEachMiddle_\n           (lift_fill23 TOT2 TOT2 fill23)\n           (RCountMid pr\' q sf\'))\n        (One lastx)\n       where\n        pr\' = node2 firstx pr\n        sf\' = node2 lastx sf\n\n  where\n    deep\' = Deep (deep_count * sizec + lenys * (size midxs + 1))\n    repEachMiddle_ = repEachMiddle midxs lenys sizec\' fn3 ln3\n    sizec\' = 3 * sizec\n    fn3 = Node3 sizec\' firstx firstx firstx\n    ln3 = Node3 sizec\' lastx lastx lastx\n    spr = size pr\n    ssf = size sf\n    lift_fill23\n      :: TwoOrThree\n      -> TwoOrThree\n      -> (a -> (b, b, b))\n      -> a -> (Node b, Node b, Node b)\n    lift_fill23 !tl !tr f a = (lft\', fill\', rght\')\n      where\n        -- We use a strict pattern match on the recursive call.  This means\n        -- that we build the 2-3 trees from the *bottom up* instead of from the\n        -- *top down*. We do it this way for two reasons:\n        --\n        -- 1. The trees are never very deep, so we don\'t get much locality\n        -- benefit from building them lazily.\n        --\n        -- 2. Building the trees lazily would require us to build four thunks\n        -- at each level of each tree, which seems just a bit pricy.\n        --\n        -- Does this break the incremental optimality? I don\'t believe it does.\n        -- As far as I can tell, each sequence operation that inspects one of\n        -- these trees either inspects only its root (to get its size for\n        -- indexing purposes) or descends all the way to the bottom. So we\'re\n        -- strict here, and lazy in the construction of\n        -- the root in fill23_final.\n        !(lft, fill, rght) = f a\n        !fill\' = Node3 (3 * sizec) fill fill fill\n        !lft\' = case tl of\n          TOT2 -> Node2 (ssf + sizec) lft fill\n          TOT3 -> Node3 (ssf + 2 * sizec) lft fill fill\n        !rght\' = case tr of\n          TOT2 -> Node2 (spr + sizec) rght fill\n          TOT3 -> Node3 (spr + 2 * sizec) rght fill fill\n\ndata TwoOrThree = TOT2 | TOT3\n\n------------------------------------------------------------------------\n-- Construction\n------------------------------------------------------------------------\n\n-- | \\( O(1) \\). The empty sequence.\nempty           :: Seq a\nempty           =  Seq EmptyT\n\n-- | \\( O(1) \\). A singleton sequence.\nsingleton       :: a -> Seq a\nsingleton x     =  Seq (Single (Elem x))\n\n-- | \\( O(\\log n) \\). @replicate n x@ is a sequence consisting of @n@ copies of @x@.\nreplicate       :: Int -> a -> Seq a\nreplicate n x\n  | n >= 0      = runIdentity (replicateA n (Identity x))\n  | otherwise   = error "replicate takes a nonnegative integer argument"\n\n-- | \'replicateA\' is an \'Applicative\' version of \'replicate\', and makes\n-- \\( O(\\log n) \\) calls to \'liftA2\' and \'pure\'.\n--\n-- > replicateA n x = sequenceA (replicate n x)\nreplicateA :: Applicative f => Int -> f a -> f (Seq a)\nreplicateA n x\n  | n >= 0      = Seq <$> applicativeTree n 1 (Elem <$> x)\n  | otherwise   = error "replicateA takes a nonnegative integer argument"\n{-# SPECIALIZE replicateA :: Int -> State a b -> State a (Seq b) #-}\n\n-- | \'replicateM\' is a sequence counterpart of \'Control.Monad.replicateM\'.\n--\n-- > replicateM n x = sequence (replicate n x)\n--\n-- For @base >= 4.8.0@ and @containers >= 0.5.11@, \'replicateM\'\n-- is a synonym for \'replicateA\'.\nreplicateM :: Applicative m => Int -> m a -> m (Seq a)\nreplicateM = replicateA\n\n-- | \\(O(\\log k)\\). @\'cycleTaking\' k xs@ forms a sequence of length @k@ by\n-- repeatedly concatenating @xs@ with itself. @xs@ may only be empty if\n-- @k@ is 0.\n--\n-- prop> cycleTaking k = fromList . take k . cycle . toList\n\n-- If you wish to concatenate a possibly empty sequence @xs@ with\n-- itself precisely @k@ times, use @\'stimes\' k xs@ instead of this\n-- function.\n--\n-- @since 0.5.8\ncycleTaking :: Int -> Seq a -> Seq a\ncycleTaking n !_xs | n <= 0 = empty\ncycleTaking _n xs  | null xs = error "cycleTaking cannot take a positive number of elements from an empty cycle."\ncycleTaking n xs = cycleNTimes reps xs >< take final xs\n  where\n    (reps, final) = n `quotRem` length xs\n\n-- \\( O(\\log(kn)) \\). @\'cycleNTimes\' k xs@ concatenates @k@ copies of @xs@. This\n-- operation uses time and additional space logarithmic in the size of its\n-- result.\ncycleNTimes :: Int -> Seq a -> Seq a\ncycleNTimes n !xs\n  | n <= 0    = empty\n  | n == 1    = xs\ncycleNTimes n (Seq xsFT) = case rigidify xsFT of\n             RigidEmpty -> empty\n             RigidOne (Elem x) -> replicate n x\n             RigidTwo x1 x2 -> Seq $\n               Deep (n*2) pair\n                    (runIdentity $ applicativeTree (n-2) 2 (Identity (node2 x1 x2)))\n                    pair\n               where pair = Two x1 x2\n             RigidThree x1 x2 x3 -> Seq $\n               Deep (n*3) triple\n                    (runIdentity $ applicativeTree (n-2) 3 (Identity (node3 x1 x2 x3)))\n                    triple\n               where triple = Three x1 x2 x3\n             RigidFull r@(Rigid s pr _m sf) -> Seq $\n                   Deep (n*s)\n                        (nodeToDigit pr)\n                        (cycleNMiddle (n-2) r)\n                        (nodeToDigit sf)\n\ncycleNMiddle\n  :: Int\n     -> Rigid c\n     -> FingerTree (Node c)\n\n-- Not at the bottom yet\n\ncycleNMiddle !n\n           (Rigid s pr (DeepTh sm prm mm sfm) sf)\n    = Deep (sm + s * (n + 1)) -- note: sm = s - size pr - size sf\n           (digit12ToDigit prm)\n           (cycleNMiddle n\n                       (Rigid s (squashL pr prm) mm (squashR sfm sf)))\n           (digit12ToDigit sfm)\n\n-- At the bottom\n\ncycleNMiddle n\n           (Rigid s pr EmptyTh sf)\n     = deep\n            (One sf)\n            (runIdentity $ applicativeTree n s (Identity converted))\n            (One pr)\n   where converted = node2 pr sf\n\ncycleNMiddle n\n           (Rigid s pr (SingleTh q) sf)\n     = deep\n            (Two q sf)\n            (runIdentity $ applicativeTree n s (Identity converted))\n            (Two pr q)\n   where converted = node3 pr q sf\n\n\n-- | \\( O(1) \\). Add an element to the left end of a sequence.\n-- Mnemonic: a triangle with the single element at the pointy end.\n(<|)            :: a -> Seq a -> Seq a\nx <| Seq xs     =  Seq (Elem x `consTree` xs)\n\n{-# SPECIALIZE consTree :: Elem a -> FingerTree (Elem a) -> FingerTree (Elem a) #-}\n{-# SPECIALIZE consTree :: Node a -> FingerTree (Node a) -> FingerTree (Node a) #-}\nconsTree        :: Sized a => a -> FingerTree a -> FingerTree a\nconsTree a EmptyT       = Single a\nconsTree a (Single b)   = deep (One a) EmptyT (One b)\n-- As described in the paper, we force the middle of a tree\n-- *before* consing onto it; this preserves the amortized\n-- bounds but prevents repeated consing from building up\n-- gigantic suspensions.\nconsTree a (Deep s (Four b c d e) m sf) = m `seq`\n    Deep (size a + s) (Two a b) (node3 c d e `consTree` m) sf\nconsTree a (Deep s (Three b c d) m sf) =\n    Deep (size a + s) (Four a b c d) m sf\nconsTree a (Deep s (Two b c) m sf) =\n    Deep (size a + s) (Three a b c) m sf\nconsTree a (Deep s (One b) m sf) =\n    Deep (size a + s) (Two a b) m sf\n\ncons\' :: a -> Seq a -> Seq a\ncons\' x (Seq xs) = Seq (Elem x `consTree\'` xs)\n\nsnoc\' :: Seq a -> a -> Seq a\nsnoc\' (Seq xs) x = Seq (xs `snocTree\'` Elem x)\n\n{-# SPECIALIZE consTree\' :: Elem a -> FingerTree (Elem a) -> FingerTree (Elem a) #-}\n{-# SPECIALIZE consTree\' :: Node a -> FingerTree (Node a) -> FingerTree (Node a) #-}\nconsTree\'        :: Sized a => a -> FingerTree a -> FingerTree a\nconsTree\' a EmptyT       = Single a\nconsTree\' a (Single b)   = deep (One a) EmptyT (One b)\n-- As described in the paper, we force the middle of a tree\n-- *before* consing onto it; this preserves the amortized\n-- bounds but prevents repeated consing from building up\n-- gigantic suspensions.\nconsTree\' a (Deep s (Four b c d e) m sf) =\n    Deep (size a + s) (Two a b) m\' sf\n  where !m\' = abc `consTree\'` m\n        !abc = node3 c d e\nconsTree\' a (Deep s (Three b c d) m sf) =\n    Deep (size a + s) (Four a b c d) m sf\nconsTree\' a (Deep s (Two b c) m sf) =\n    Deep (size a + s) (Three a b c) m sf\nconsTree\' a (Deep s (One b) m sf) =\n    Deep (size a + s) (Two a b) m sf\n\n-- | \\( O(1) \\). Add an element to the right end of a sequence.\n-- Mnemonic: a triangle with the single element at the pointy end.\n(|>)            :: Seq a -> a -> Seq a\nSeq xs |> x     =  Seq (xs `snocTree` Elem x)\n\n{-# SPECIALIZE snocTree :: FingerTree (Elem a) -> Elem a -> FingerTree (Elem a) #-}\n{-# SPECIALIZE snocTree :: FingerTree (Node a) -> Node a -> FingerTree (Node a) #-}\nsnocTree        :: Sized a => FingerTree a -> a -> FingerTree a\nsnocTree EmptyT a       =  Single a\nsnocTree (Single a) b   =  deep (One a) EmptyT (One b)\n-- See note on `seq` in `consTree`.\nsnocTree (Deep s pr m (Four a b c d)) e = m `seq`\n    Deep (s + size e) pr (m `snocTree` node3 a b c) (Two d e)\nsnocTree (Deep s pr m (Three a b c)) d =\n    Deep (s + size d) pr m (Four a b c d)\nsnocTree (Deep s pr m (Two a b)) c =\n    Deep (s + size c) pr m (Three a b c)\nsnocTree (Deep s pr m (One a)) b =\n    Deep (s + size b) pr m (Two a b)\n\n{-# SPECIALIZE snocTree\' :: FingerTree (Elem a) -> Elem a -> FingerTree (Elem a) #-}\n{-# SPECIALIZE snocTree\' :: FingerTree (Node a) -> Node a -> FingerTree (Node a) #-}\nsnocTree\'        :: Sized a => FingerTree a -> a -> FingerTree a\nsnocTree\' EmptyT a       =  Single a\nsnocTree\' (Single a) b   =  deep (One a) EmptyT (One b)\n-- See note on `seq` in `consTree`.\nsnocTree\' (Deep s pr m (Four a b c d)) e =\n    Deep (s + size e) pr m\' (Two d e)\n  where !m\' = m `snocTree\'` abc\n        !abc = node3 a b c\nsnocTree\' (Deep s pr m (Three a b c)) d =\n    Deep (s + size d) pr m (Four a b c d)\nsnocTree\' (Deep s pr m (Two a b)) c =\n    Deep (s + size c) pr m (Three a b c)\nsnocTree\' (Deep s pr m (One a)) b =\n    Deep (s + size b) pr m (Two a b)\n\n-- | \\( O(\\log(\\min(n_1,n_2))) \\). Concatenate two sequences.\n(><)            :: Seq a -> Seq a -> Seq a\nSeq xs >< Seq ys = Seq (appendTree0 xs ys)\n\n-- The appendTree/addDigits gunk below was originally machine generated via mkappend.hs,\n-- but has since been manually edited to include strictness annotations.\n\nappendTree0 :: FingerTree (Elem a) -> FingerTree (Elem a) -> FingerTree (Elem a)\nappendTree0 EmptyT xs =\n    xs\nappendTree0 xs EmptyT =\n    xs\nappendTree0 (Single x) xs =\n    x `consTree` xs\nappendTree0 xs (Single x) =\n    xs `snocTree` x\nappendTree0 (Deep s1 pr1 m1 sf1) (Deep s2 pr2 m2 sf2) =\n    Deep (s1 + s2) pr1 m sf2\n  where !m = addDigits0 m1 sf1 pr2 m2\n\naddDigits0 :: FingerTree (Node (Elem a)) -> Digit (Elem a) -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> FingerTree (Node (Elem a))\naddDigits0 m1 (One a) (One b) m2 =\n    appendTree1 m1 (node2 a b) m2\naddDigits0 m1 (One a) (Two b c) m2 =\n    appendTree1 m1 (node3 a b c) m2\naddDigits0 m1 (One a) (Three b c d) m2 =\n    appendTree2 m1 (node2 a b) (node2 c d) m2\naddDigits0 m1 (One a) (Four b c d e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits0 m1 (Two a b) (One c) m2 =\n    appendTree1 m1 (node3 a b c) m2\naddDigits0 m1 (Two a b) (Two c d) m2 =\n    appendTree2 m1 (node2 a b) (node2 c d) m2\naddDigits0 m1 (Two a b) (Three c d e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits0 m1 (Two a b) (Four c d e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits0 m1 (Three a b c) (One d) m2 =\n    appendTree2 m1 (node2 a b) (node2 c d) m2\naddDigits0 m1 (Three a b c) (Two d e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits0 m1 (Three a b c) (Three d e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits0 m1 (Three a b c) (Four d e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits0 m1 (Four a b c d) (One e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits0 m1 (Four a b c d) (Two e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits0 m1 (Four a b c d) (Three e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits0 m1 (Four a b c d) (Four e f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\n\nappendTree1 :: FingerTree (Node a) -> Node a -> FingerTree (Node a) -> FingerTree (Node a)\nappendTree1 EmptyT !a xs =\n    a `consTree` xs\nappendTree1 xs !a EmptyT =\n    xs `snocTree` a\nappendTree1 (Single x) !a xs =\n    x `consTree` a `consTree` xs\nappendTree1 xs !a (Single x) =\n    xs `snocTree` a `snocTree` x\nappendTree1 (Deep s1 pr1 m1 sf1) a (Deep s2 pr2 m2 sf2) =\n    Deep (s1 + size a + s2) pr1 m sf2\n  where !m = addDigits1 m1 sf1 a pr2 m2\n\naddDigits1 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))\naddDigits1 m1 (One a) b (One c) m2 =\n    appendTree1 m1 (node3 a b c) m2\naddDigits1 m1 (One a) b (Two c d) m2 =\n    appendTree2 m1 (node2 a b) (node2 c d) m2\naddDigits1 m1 (One a) b (Three c d e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits1 m1 (One a) b (Four c d e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits1 m1 (Two a b) c (One d) m2 =\n    appendTree2 m1 (node2 a b) (node2 c d) m2\naddDigits1 m1 (Two a b) c (Two d e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits1 m1 (Two a b) c (Three d e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits1 m1 (Two a b) c (Four d e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits1 m1 (Three a b c) d (One e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits1 m1 (Three a b c) d (Two e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits1 m1 (Three a b c) d (Three e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits1 m1 (Three a b c) d (Four e f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits1 m1 (Four a b c d) e (One f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits1 m1 (Four a b c d) e (Two f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits1 m1 (Four a b c d) e (Three f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits1 m1 (Four a b c d) e (Four f g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\n\nappendTree2 :: FingerTree (Node a) -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)\nappendTree2 EmptyT !a !b xs =\n    a `consTree` b `consTree` xs\nappendTree2 xs !a !b EmptyT =\n    xs `snocTree` a `snocTree` b\nappendTree2 (Single x) a b xs =\n    x `consTree` a `consTree` b `consTree` xs\nappendTree2 xs a b (Single x) =\n    xs `snocTree` a `snocTree` b `snocTree` x\nappendTree2 (Deep s1 pr1 m1 sf1) a b (Deep s2 pr2 m2 sf2) =\n    Deep (s1 + size a + size b + s2) pr1 m sf2\n  where !m = addDigits2 m1 sf1 a b pr2 m2\n\naddDigits2 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))\naddDigits2 m1 (One a) b c (One d) m2 =\n    appendTree2 m1 (node2 a b) (node2 c d) m2\naddDigits2 m1 (One a) b c (Two d e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits2 m1 (One a) b c (Three d e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits2 m1 (One a) b c (Four d e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits2 m1 (Two a b) c d (One e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits2 m1 (Two a b) c d (Two e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits2 m1 (Two a b) c d (Three e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits2 m1 (Two a b) c d (Four e f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits2 m1 (Three a b c) d e (One f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits2 m1 (Three a b c) d e (Two f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits2 m1 (Three a b c) d e (Three f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits2 m1 (Three a b c) d e (Four f g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits2 m1 (Four a b c d) e f (One g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits2 m1 (Four a b c d) e f (Two g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits2 m1 (Four a b c d) e f (Three g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits2 m1 (Four a b c d) e f (Four g h i j) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2\n\nappendTree3 :: FingerTree (Node a) -> Node a -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)\nappendTree3 EmptyT !a !b !c xs =\n    a `consTree` b `consTree` c `consTree` xs\nappendTree3 xs !a !b !c EmptyT =\n    xs `snocTree` a `snocTree` b `snocTree` c\nappendTree3 (Single x) a b c xs =\n    x `consTree` a `consTree` b `consTree` c `consTree` xs\nappendTree3 xs a b c (Single x) =\n    xs `snocTree` a `snocTree` b `snocTree` c `snocTree` x\nappendTree3 (Deep s1 pr1 m1 sf1) a b c (Deep s2 pr2 m2 sf2) =\n    Deep (s1 + size a + size b + size c + s2) pr1 m sf2\n  where !m = addDigits3 m1 sf1 a b c pr2 m2\n\naddDigits3 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))\naddDigits3 m1 (One a) !b !c !d (One e) m2 =\n    appendTree2 m1 (node3 a b c) (node2 d e) m2\naddDigits3 m1 (One a) b c d (Two e f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits3 m1 (One a) b c d (Three e f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits3 m1 (One a) b c d (Four e f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits3 m1 (Two a b) !c !d !e (One f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits3 m1 (Two a b) c d e (Two f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits3 m1 (Two a b) c d e (Three f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits3 m1 (Two a b) c d e (Four f g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits3 m1 (Three a b c) !d !e !f (One g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits3 m1 (Three a b c) d e f (Two g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits3 m1 (Three a b c) d e f (Three g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits3 m1 (Three a b c) d e f (Four g h i j) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2\naddDigits3 m1 (Four a b c d) !e !f !g (One h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits3 m1 (Four a b c d) e f g (Two h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits3 m1 (Four a b c d) e f g (Three h i j) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2\naddDigits3 m1 (Four a b c d) e f g (Four h i j k) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2\n\nappendTree4 :: FingerTree (Node a) -> Node a -> Node a -> Node a -> Node a -> FingerTree (Node a) -> FingerTree (Node a)\nappendTree4 EmptyT !a !b !c !d xs =\n    a `consTree` b `consTree` c `consTree` d `consTree` xs\nappendTree4 xs !a !b !c !d EmptyT =\n    xs `snocTree` a `snocTree` b `snocTree` c `snocTree` d\nappendTree4 (Single x) a b c d xs =\n    x `consTree` a `consTree` b `consTree` c `consTree` d `consTree` xs\nappendTree4 xs a b c d (Single x) =\n    xs `snocTree` a `snocTree` b `snocTree` c `snocTree` d `snocTree` x\nappendTree4 (Deep s1 pr1 m1 sf1) a b c d (Deep s2 pr2 m2 sf2) =\n    Deep (s1 + size a + size b + size c + size d + s2) pr1 m sf2\n  where !m = addDigits4 m1 sf1 a b c d pr2 m2\n\naddDigits4 :: FingerTree (Node (Node a)) -> Digit (Node a) -> Node a -> Node a -> Node a -> Node a -> Digit (Node a) -> FingerTree (Node (Node a)) -> FingerTree (Node (Node a))\naddDigits4 m1 (One a) !b !c !d !e (One f) m2 =\n    appendTree2 m1 (node3 a b c) (node3 d e f) m2\naddDigits4 m1 (One a) b c d e (Two f g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits4 m1 (One a) b c d e (Three f g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits4 m1 (One a) b c d e (Four f g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits4 m1 (Two a b) !c !d !e !f (One g) m2 =\n    appendTree3 m1 (node3 a b c) (node2 d e) (node2 f g) m2\naddDigits4 m1 (Two a b) c d e f (Two g h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits4 m1 (Two a b) c d e f (Three g h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits4 m1 (Two a b) c d e f (Four g h i j) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2\naddDigits4 m1 (Three a b c) !d !e !f !g (One h) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node2 g h) m2\naddDigits4 m1 (Three a b c) d e f g (Two h i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits4 m1 (Three a b c) d e f g (Three h i j) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2\naddDigits4 m1 (Three a b c) d e f g (Four h i j k) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2\naddDigits4 m1 (Four a b c d) !e !f !g !h (One i) m2 =\n    appendTree3 m1 (node3 a b c) (node3 d e f) (node3 g h i) m2\naddDigits4 m1 (Four a b c d) !e !f !g !h (Two i j) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node2 g h) (node2 i j) m2\naddDigits4 m1 (Four a b c d) !e !f !g !h (Three i j k) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node2 j k) m2\naddDigits4 m1 (Four a b c d) !e !f !g !h (Four i j k l) m2 =\n    appendTree4 m1 (node3 a b c) (node3 d e f) (node3 g h i) (node3 j k l) m2\n\n-- | Builds a sequence from a seed value.  Takes time linear in the\n-- number of generated elements.  /WARNING:/ If the number of generated\n-- elements is infinite, this method will not terminate.\nunfoldr :: (b -> Maybe (a, b)) -> b -> Seq a\nunfoldr f = unfoldr\' empty\n  -- uses tail recursion rather than, for instance, the List implementation.\n  where unfoldr\' !as b = maybe as (\\ (a, b\') -> unfoldr\' (as `snoc\'` a) b\') (f b)\n\n-- | @\'unfoldl\' f x@ is equivalent to @\'reverse\' (\'unfoldr\' (\'fmap\' swap . f) x)@.\nunfoldl :: (b -> Maybe (b, a)) -> b -> Seq a\nunfoldl f = unfoldl\' empty\n  where unfoldl\' !as b = maybe as (\\ (b\', a) -> unfoldl\' (a `cons\'` as) b\') (f b)\n\n-- | \\( O(n) \\).  Constructs a sequence by repeated application of a function\n-- to a seed value.\n--\n-- > iterateN n f x = fromList (Prelude.take n (Prelude.iterate f x))\niterateN :: Int -> (a -> a) -> a -> Seq a\niterateN n f x\n  | n >= 0      = replicateA n (State (\\ y -> (f y, y))) `execState` x\n  | otherwise   = error "iterateN takes a nonnegative integer argument"\n\n------------------------------------------------------------------------\n-- Deconstruction\n------------------------------------------------------------------------\n\n-- | \\( O(1) \\). Is this the empty sequence?\nnull            :: Seq a -> Bool\nnull (Seq EmptyT) = True\nnull _            =  False\n\n-- | \\( O(1) \\). The number of elements in the sequence.\nlength          :: Seq a -> Int\nlength (Seq xs) =  size xs\n\n-- Views\n\ndata ViewLTree a = ConsLTree a (FingerTree a) | EmptyLTree\ndata ViewRTree a = SnocRTree (FingerTree a) a | EmptyRTree\n\n-- | View of the left end of a sequence.\ndata ViewL a\n    = EmptyL        -- ^ empty sequence\n    | a :< Seq a    -- ^ leftmost element and the rest of the sequence\n    deriving (Eq, Ord, Show, Read)\n\n#ifdef __GLASGOW_HASKELL__\nderiving instance Data a => Data (ViewL a)\n\n-- | @since 0.5.8\nderiving instance Generic1 ViewL\n\n-- | @since 0.5.8\nderiving instance Generic (ViewL a)\n\n-- | @since 0.6.6\nderiving instance TH.Lift a => TH.Lift (ViewL a)\n#endif\n\ninstance Functor ViewL where\n    {-# INLINE fmap #-}\n    fmap _ EmptyL       = EmptyL\n    fmap f (x :< xs)    = f x :< fmap f xs\n\ninstance Foldable ViewL where\n    foldMap _ EmptyL = mempty\n    foldMap f (x :< xs) = f x <> foldMap f xs\n\n    foldr _ z EmptyL = z\n    foldr f z (x :< xs) = f x (foldr f z xs)\n\n    foldl _ z EmptyL = z\n    foldl f z (x :< xs) = foldl f (f z x) xs\n\n    foldl1 _ EmptyL = error "foldl1: empty view"\n    foldl1 f (x :< xs) = foldl f x xs\n\n    null EmptyL = True\n    null (_ :< _) = False\n\n    length EmptyL = 0\n    length (_ :< xs) = 1 + length xs\n\ninstance Traversable ViewL where\n    traverse _ EmptyL       = pure EmptyL\n    traverse f (x :< xs)    = liftA2 (:<) (f x) (traverse f xs)\n\n-- | \\( O(1) \\). Analyse the left end of a sequence.\nviewl           ::  Seq a -> ViewL a\nviewl (Seq xs)  =  case viewLTree xs of\n    EmptyLTree -> EmptyL\n    ConsLTree (Elem x) xs\' -> x :< Seq xs\'\n\n{-# SPECIALIZE viewLTree :: FingerTree (Elem a) -> ViewLTree (Elem a) #-}\n{-# SPECIALIZE viewLTree :: FingerTree (Node a) -> ViewLTree (Node a) #-}\nviewLTree       :: Sized a => FingerTree a -> ViewLTree a\nviewLTree EmptyT                = EmptyLTree\nviewLTree (Single a)            = ConsLTree a EmptyT\nviewLTree (Deep s (One a) m sf) = ConsLTree a (pullL (s - size a) m sf)\nviewLTree (Deep s (Two a b) m sf) =\n    ConsLTree a (Deep (s - size a) (One b) m sf)\nviewLTree (Deep s (Three a b c) m sf) =\n    ConsLTree a (Deep (s - size a) (Two b c) m sf)\nviewLTree (Deep s (Four a b c d) m sf) =\n    ConsLTree a (Deep (s - size a) (Three b c d) m sf)\n\n-- | View of the right end of a sequence.\ndata ViewR a\n    = EmptyR        -- ^ empty sequence\n    | Seq a :> a    -- ^ the sequence minus the rightmost element,\n            -- and the rightmost element\n    deriving (Eq, Ord, Show, Read)\n\n#ifdef __GLASGOW_HASKELL__\nderiving instance Data a => Data (ViewR a)\n\n-- | @since 0.5.8\nderiving instance Generic1 ViewR\n\n-- | @since 0.5.8\nderiving instance Generic (ViewR a)\n\n-- | @since 0.6.6\nderiving instance TH.Lift a => TH.Lift (ViewR a)\n#endif\n\ninstance Functor ViewR where\n    {-# INLINE fmap #-}\n    fmap _ EmptyR       = EmptyR\n    fmap f (xs :> x)    = fmap f xs :> f x\n\ninstance Foldable ViewR where\n    foldMap _ EmptyR = mempty\n    foldMap f (xs :> x) = foldMap f xs <> f x\n\n    foldr _ z EmptyR = z\n    foldr f z (xs :> x) = foldr f (f x z) xs\n\n    foldl _ z EmptyR = z\n    foldl f z (xs :> x) = foldl f z xs `f` x\n\n    foldr1 _ EmptyR = error "foldr1: empty view"\n    foldr1 f (xs :> x) = foldr f x xs\n\n    null EmptyR = True\n    null (_ :> _) = False\n\n    length EmptyR = 0\n    length (xs :> _) = length xs + 1\n\ninstance Traversable ViewR where\n    traverse _ EmptyR       = pure EmptyR\n    traverse f (xs :> x)    = liftA2 (:>) (traverse f xs) (f x)\n\n-- | \\( O(1) \\). Analyse the right end of a sequence.\nviewr           ::  Seq a -> ViewR a\nviewr (Seq xs)  =  case viewRTree xs of\n    EmptyRTree -> EmptyR\n    SnocRTree xs\' (Elem x) -> Seq xs\' :> x\n\n{-# SPECIALIZE viewRTree :: FingerTree (Elem a) -> ViewRTree (Elem a) #-}\n{-# SPECIALIZE viewRTree :: FingerTree (Node a) -> ViewRTree (Node a) #-}\nviewRTree       :: Sized a => FingerTree a -> ViewRTree a\nviewRTree EmptyT                = EmptyRTree\nviewRTree (Single z)            = SnocRTree EmptyT z\nviewRTree (Deep s pr m (One z)) = SnocRTree (pullR (s - size z) pr m) z\nviewRTree (Deep s pr m (Two y z)) =\n    SnocRTree (Deep (s - size z) pr m (One y)) z\nviewRTree (Deep s pr m (Three x y z)) =\n    SnocRTree (Deep (s - size z) pr m (Two x y)) z\nviewRTree (Deep s pr m (Four w x y z)) =\n    SnocRTree (Deep (s - size z) pr m (Three w x y)) z\n\n------------------------------------------------------------------------\n-- Scans\n--\n-- These are not particularly complex applications of the Traversable\n-- functor, though making the correspondence with Data.List exact\n-- requires the use of (<|) and (|>).\n--\n-- Note that save for the single (<|) or (|>), we maintain the original\n-- structure of the Seq, not having to do any restructuring of our own.\n--\n-- wasserman.louis@gmail.com, 5/23/09\n------------------------------------------------------------------------\n\n-- | \'scanl\' is similar to \'foldl\', but returns a sequence of reduced\n-- values from the left:\n--\n-- > scanl f z (fromList [x1, x2, ...]) = fromList [z, z `f` x1, (z `f` x1) `f` x2, ...]\nscanl :: (a -> b -> a) -> a -> Seq b -> Seq a\nscanl f z0 xs = z0 <| snd (mapAccumL (\\ x z -> let x\' = f x z in (x\', x\')) z0 xs)\n\n-- | \'scanl1\' is a variant of \'scanl\' that has no starting value argument:\n--\n-- > scanl1 f (fromList [x1, x2, ...]) = fromList [x1, x1 `f` x2, ...]\nscanl1 :: (a -> a -> a) -> Seq a -> Seq a\nscanl1 f xs = case viewl xs of\n    EmptyL          -> error "scanl1 takes a nonempty sequence as an argument"\n    x :< xs\'        -> scanl f x xs\'\n\n-- | \'scanr\' is the right-to-left dual of \'scanl\'.\nscanr :: (a -> b -> b) -> b -> Seq a -> Seq b\nscanr f z0 xs = snd (mapAccumR (\\ z x -> let z\' = f x z in (z\', z\')) z0 xs) |> z0\n\n-- | \'scanr1\' is a variant of \'scanr\' that has no starting value argument.\nscanr1 :: (a -> a -> a) -> Seq a -> Seq a\nscanr1 f xs = case viewr xs of\n    EmptyR          -> error "scanr1 takes a nonempty sequence as an argument"\n    xs\' :> x        -> scanr f x xs\'\n\n-- Indexing\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). The element at the specified position,\n-- counting from 0.  The argument should thus be a non-negative\n-- integer less than the size of the sequence.\n-- If the position is out of range, \'index\' fails with an error.\n--\n-- prop> xs `index` i = toList xs !! i\n--\n-- Caution: \'index\' necessarily delays retrieving the requested\n-- element until the result is forced. It can therefore lead to a space\n-- leak if the result is stored, unforced, in another structure. To retrieve\n-- an element immediately without forcing it, use \'lookup\' or \'(!?)\'.\nindex           :: Seq a -> Int -> a\nindex (Seq xs) i\n  -- See note on unsigned arithmetic in splitAt\n  | fromIntegral i < (fromIntegral (size xs) :: Word) = case lookupTree i xs of\n                Place _ (Elem x) -> x\n  | otherwise   =\n      error $ "index out of bounds in call to: Data.Sequence.index " ++ show i\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). The element at the specified position,\n-- counting from 0. If the specified position is negative or at\n-- least the length of the sequence, \'lookup\' returns \'Nothing\'.\n--\n-- prop> 0 <= i < length xs ==> lookup i xs == Just (toList xs !! i)\n-- prop> i < 0 || i >= length xs ==> lookup i xs = Nothing\n--\n-- Unlike \'index\', this can be used to retrieve an element without\n-- forcing it. For example, to insert the fifth element of a sequence\n-- @xs@ into a \'Data.Map.Lazy.Map\' @m@ at key @k@, you could use\n--\n-- @\n-- case lookup 5 xs of\n--   Nothing -> m\n--   Just x -> \'Data.Map.Lazy.insert\' k x m\n-- @\n--\n-- @since 0.5.8\nlookup            :: Int -> Seq a -> Maybe a\nlookup i (Seq xs)\n  -- Note: we perform the lookup *before* applying the Just constructor\n  -- to ensure that we don\'t hold a reference to the whole sequence in\n  -- a thunk. If we applied the Just constructor around the case, the\n  -- actual lookup wouldn\'t be performed unless and until the value was\n  -- forced.\n  | fromIntegral i < (fromIntegral (size xs) :: Word) = case lookupTree i xs of\n                Place _ (Elem x) -> Just x\n  | otherwise = Nothing\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). A flipped, infix version of `lookup`.\n--\n-- @since 0.5.8\n(!?) ::           Seq a -> Int -> Maybe a\n(!?) = flip lookup\n\ndata Place a = Place {-# UNPACK #-} !Int a\n#ifdef TESTING\n    deriving Show\n#endif\n\n{-# SPECIALIZE lookupTree :: Int -> FingerTree (Elem a) -> Place (Elem a) #-}\n{-# SPECIALIZE lookupTree :: Int -> FingerTree (Node a) -> Place (Node a) #-}\nlookupTree :: Sized a => Int -> FingerTree a -> Place a\nlookupTree !_ EmptyT = error "lookupTree of empty tree"\nlookupTree i (Single x) = Place i x\nlookupTree i (Deep _ pr m sf)\n  | i < spr     =  lookupDigit i pr\n  | i < spm     =  case lookupTree (i - spr) m of\n                   Place i\' xs -> lookupNode i\' xs\n  | otherwise   =  lookupDigit (i - spm) sf\n  where\n    spr     = size pr\n    spm     = spr + size m\n\n{-# SPECIALIZE lookupNode :: Int -> Node (Elem a) -> Place (Elem a) #-}\n{-# SPECIALIZE lookupNode :: Int -> Node (Node a) -> Place (Node a) #-}\nlookupNode :: Sized a => Int -> Node a -> Place a\nlookupNode i (Node2 _ a b)\n  | i < sa      = Place i a\n  | otherwise   = Place (i - sa) b\n  where\n    sa      = size a\nlookupNode i (Node3 _ a b c)\n  | i < sa      = Place i a\n  | i < sab     = Place (i - sa) b\n  | otherwise   = Place (i - sab) c\n  where\n    sa      = size a\n    sab     = sa + size b\n\n{-# SPECIALIZE lookupDigit :: Int -> Digit (Elem a) -> Place (Elem a) #-}\n{-# SPECIALIZE lookupDigit :: Int -> Digit (Node a) -> Place (Node a) #-}\nlookupDigit :: Sized a => Int -> Digit a -> Place a\nlookupDigit i (One a) = Place i a\nlookupDigit i (Two a b)\n  | i < sa      = Place i a\n  | otherwise   = Place (i - sa) b\n  where\n    sa      = size a\nlookupDigit i (Three a b c)\n  | i < sa      = Place i a\n  | i < sab     = Place (i - sa) b\n  | otherwise   = Place (i - sab) c\n  where\n    sa      = size a\n    sab     = sa + size b\nlookupDigit i (Four a b c d)\n  | i < sa      = Place i a\n  | i < sab     = Place (i - sa) b\n  | i < sabc    = Place (i - sab) c\n  | otherwise   = Place (i - sabc) d\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). Replace the element at the specified position.\n-- If the position is out of range, the original sequence is returned.\nupdate          :: Int -> a -> Seq a -> Seq a\nupdate i x (Seq xs)\n  -- See note on unsigned arithmetic in splitAt\n  | fromIntegral i < (fromIntegral (size xs) :: Word) = Seq (updateTree (Elem x) i xs)\n  | otherwise   = Seq xs\n\n-- It seems a shame to copy the implementation of the top layer of\n-- `adjust` instead of just using `update i x = adjust (const x) i`.\n-- With the latter implementation, updating the same position many\n-- times could lead to silly thunks building up around that position.\n-- The thunks will each look like @const v a@, where @v@ is the new\n-- value and @a@ the old.\nupdateTree      :: Elem a -> Int -> FingerTree (Elem a) -> FingerTree (Elem a)\nupdateTree _ !_ EmptyT = EmptyT -- Unreachable\nupdateTree v _i (Single _) = Single v\nupdateTree v i (Deep s pr m sf)\n  | i < spr     = Deep s (updateDigit v i pr) m sf\n  | i < spm     = let !m\' = adjustTree (updateNode v) (i - spr) m\n                  in Deep s pr m\' sf\n  | otherwise   = Deep s pr m (updateDigit v (i - spm) sf)\n  where\n    spr     = size pr\n    spm     = spr + size m\n\nupdateNode      :: Elem a -> Int -> Node (Elem a) -> Node (Elem a)\nupdateNode v i (Node2 s a b)\n  | i < sa      = Node2 s v b\n  | otherwise   = Node2 s a v\n  where\n    sa      = size a\nupdateNode v i (Node3 s a b c)\n  | i < sa      = Node3 s v b c\n  | i < sab     = Node3 s a v c\n  | otherwise   = Node3 s a b v\n  where\n    sa      = size a\n    sab     = sa + size b\n\nupdateDigit     :: Elem a -> Int -> Digit (Elem a) -> Digit (Elem a)\nupdateDigit v !_i (One _) = One v\nupdateDigit v i (Two a b)\n  | i < sa      = Two v b\n  | otherwise   = Two a v\n  where\n    sa      = size a\nupdateDigit v i (Three a b c)\n  | i < sa      = Three v b c\n  | i < sab     = Three a v c\n  | otherwise   = Three a b v\n  where\n    sa      = size a\n    sab     = sa + size b\nupdateDigit v i (Four a b c d)\n  | i < sa      = Four v b c d\n  | i < sab     = Four a v c d\n  | i < sabc    = Four a b v d\n  | otherwise   = Four a b c v\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). Update the element at the specified position.  If\n-- the position is out of range, the original sequence is returned.  \'adjust\'\n-- can lead to poor performance and even memory leaks, because it does not\n-- force the new value before installing it in the sequence. \'adjust\'\' should\n-- usually be preferred.\n--\n-- @since 0.5.8\nadjust          :: (a -> a) -> Int -> Seq a -> Seq a\nadjust f i (Seq xs)\n  -- See note on unsigned arithmetic in splitAt\n  | fromIntegral i < (fromIntegral (size xs) :: Word) = Seq (adjustTree (`seq` fmap f) i xs)\n  | otherwise   = Seq xs\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). Update the element at the specified position.\n-- If the position is out of range, the original sequence is returned.\n-- The new value is forced before it is installed in the sequence.\n--\n-- @\n-- adjust\' f i xs =\n--  case xs !? i of\n--    Nothing -> xs\n--    Just x -> let !x\' = f x\n--              in update i x\' xs\n-- @\n--\n-- @since 0.5.8\nadjust\'          :: forall a . (a -> a) -> Int -> Seq a -> Seq a\n#ifdef __GLASGOW_HASKELL__\nadjust\' f i xs\n  -- See note on unsigned arithmetic in splitAt\n  | fromIntegral i < (fromIntegral (length xs) :: Word) =\n      coerce $ adjustTree (\\ !_k (ForceBox a) -> ForceBox (f a)) i (coerce xs)\n  | otherwise   = xs\n#else\n-- This is inefficient, but fixing it would take a lot of fuss and bother\n-- for little immediate gain. We can deal with that when we have another\n-- Haskell implementation to worry about.\nadjust\' f i xs =\n  case xs !? i of\n    Nothing -> xs\n    Just x -> let !x\' = f x\n              in update i x\' xs\n#endif\n\n{-# SPECIALIZE adjustTree :: (Int -> ForceBox a -> ForceBox a) -> Int -> FingerTree (ForceBox a) -> FingerTree (ForceBox a) #-}\n{-# SPECIALIZE adjustTree :: (Int -> Elem a -> Elem a) -> Int -> FingerTree (Elem a) -> FingerTree (Elem a) #-}\n{-# SPECIALIZE adjustTree :: (Int -> Node a -> Node a) -> Int -> FingerTree (Node a) -> FingerTree (Node a) #-}\nadjustTree      :: (Sized a, MaybeForce a) => (Int -> a -> a) ->\n             Int -> FingerTree a -> FingerTree a\nadjustTree _ !_ EmptyT = EmptyT -- Unreachable\nadjustTree f i (Single x) = Single $!? f i x\nadjustTree f i (Deep s pr m sf)\n  | i < spr     = Deep s (adjustDigit f i pr) m sf\n  | i < spm     = let !m\' = adjustTree (adjustNode f) (i - spr) m\n                  in Deep s pr m\' sf\n  | otherwise   = Deep s pr m (adjustDigit f (i - spm) sf)\n  where\n    spr     = size pr\n    spm     = spr + size m\n\n{-# SPECIALIZE adjustNode :: (Int -> Elem a -> Elem a) -> Int -> Node (Elem a) -> Node (Elem a) #-}\n{-# SPECIALIZE adjustNode :: (Int -> Node a -> Node a) -> Int -> Node (Node a) -> Node (Node a) #-}\nadjustNode      :: (Sized a, MaybeForce a) => (Int -> a -> a) -> Int -> Node a -> Node a\nadjustNode f i (Node2 s a b)\n  | i < sa      = let fia = f i a in fia `mseq` Node2 s fia b\n  | otherwise   = let fisab = f (i - sa) b in fisab `mseq` Node2 s a fisab\n  where\n    sa      = size a\nadjustNode f i (Node3 s a b c)\n  | i < sa      = let fia = f i a in fia `mseq` Node3 s fia b c\n  | i < sab     = let fisab = f (i - sa) b in fisab `mseq` Node3 s a fisab c\n  | otherwise   = let fisabc = f (i - sab) c in fisabc `mseq` Node3 s a b fisabc\n  where\n    sa      = size a\n    sab     = sa + size b\n\n{-# SPECIALIZE adjustDigit :: (Int -> Elem a -> Elem a) -> Int -> Digit (Elem a) -> Digit (Elem a) #-}\n{-# SPECIALIZE adjustDigit :: (Int -> Node a -> Node a) -> Int -> Digit (Node a) -> Digit (Node a) #-}\nadjustDigit     :: (Sized a, MaybeForce a) => (Int -> a -> a) -> Int -> Digit a -> Digit a\nadjustDigit f !i (One a) = One $!? f i a\nadjustDigit f i (Two a b)\n  | i < sa      = let fia = f i a in fia `mseq` Two fia b\n  | otherwise   = let fisab = f (i - sa) b in fisab `mseq` Two a fisab\n  where\n    sa      = size a\nadjustDigit f i (Three a b c)\n  | i < sa      = let fia = f i a in fia `mseq` Three fia b c\n  | i < sab     = let fisab = f (i - sa) b in fisab `mseq` Three a fisab c\n  | otherwise   = let fisabc = f (i - sab) c in fisabc `mseq` Three a b fisabc\n  where\n    sa      = size a\n    sab     = sa + size b\nadjustDigit f i (Four a b c d)\n  | i < sa      = let fia = f i a in fia `mseq` Four fia b c d\n  | i < sab     = let fisab = f (i - sa) b in fisab `mseq` Four a fisab c d\n  | i < sabc    = let fisabc = f (i - sab) c in fisabc `mseq` Four a b fisabc d\n  | otherwise   = let fisabcd = f (i - sabc) d in fisabcd `mseq` Four a b c fisabcd\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). @\'insertAt\' i x xs@ inserts @x@ into @xs@\n-- at the index @i@, shifting the rest of the sequence over.\n--\n-- @\n-- insertAt 2 x (fromList [a,b,c,d]) = fromList [a,b,x,c,d]\n-- insertAt 4 x (fromList [a,b,c,d]) = insertAt 10 x (fromList [a,b,c,d])\n--                                   = fromList [a,b,c,d,x]\n-- @\n--\n-- prop> insertAt i x xs = take i xs >< singleton x >< drop i xs\n--\n-- @since 0.5.8\ninsertAt :: Int -> a -> Seq a -> Seq a\ninsertAt i a s@(Seq xs)\n  | fromIntegral i < (fromIntegral (size xs) :: Word)\n      = Seq (insTree (`seq` InsTwo (Elem a)) i xs)\n  | i <= 0 = a <| s\n  | otherwise = s |> a\n\ndata Ins a = InsOne a | InsTwo a a\n\n{-# SPECIALIZE insTree :: (Int -> Elem a -> Ins (Elem a)) -> Int -> FingerTree (Elem a) -> FingerTree (Elem a) #-}\n{-# SPECIALIZE insTree :: (Int -> Node a -> Ins (Node a)) -> Int -> FingerTree (Node a) -> FingerTree (Node a) #-}\ninsTree      :: Sized a => (Int -> a -> Ins a) ->\n             Int -> FingerTree a -> FingerTree a\ninsTree _ !_ EmptyT = EmptyT -- Unreachable\ninsTree f i (Single x) = case f i x of\n  InsOne x\' -> Single x\'\n  InsTwo m n -> deep (One m) EmptyT (One n)\ninsTree f i (Deep s pr m sf)\n  | i < spr     = case insLeftDigit f i pr of\n     InsLeftDig pr\' -> Deep (s + 1) pr\' m sf\n     InsDigNode pr\' n -> m `seq` Deep (s + 1) pr\' (n `consTree` m) sf\n  | i < spm     = let !m\' = insTree (insNode f) (i - spr) m\n                  in Deep (s + 1) pr m\' sf\n  | otherwise   = case insRightDigit f (i - spm) sf of\n     InsRightDig sf\' -> Deep (s + 1) pr m sf\'\n     InsNodeDig n sf\' -> m `seq` Deep (s + 1) pr (m `snocTree` n) sf\'\n  where\n    spr     = size pr\n    spm     = spr + size m\n\n{-# SPECIALIZE insNode :: (Int -> Elem a -> Ins (Elem a)) -> Int -> Node (Elem a) -> Ins (Node (Elem a)) #-}\n{-# SPECIALIZE insNode :: (Int -> Node a -> Ins (Node a)) -> Int -> Node (Node a) -> Ins (Node (Node a)) #-}\ninsNode :: Sized a => (Int -> a -> Ins a) -> Int -> Node a -> Ins (Node a)\ninsNode f i (Node2 s a b)\n  | i < sa = case f i a of\n      InsOne n -> InsOne $ Node2 (s + 1) n b\n      InsTwo m n -> InsOne $ Node3 (s + 1) m n b\n  | otherwise = case f (i - sa) b of\n      InsOne n -> InsOne $ Node2 (s + 1) a n\n      InsTwo m n -> InsOne $ Node3 (s + 1) a m n\n  where sa = size a\ninsNode f i (Node3 s a b c)\n  | i < sa = case f i a of\n      InsOne n -> InsOne $ Node3 (s + 1) n b c\n      InsTwo m n -> InsTwo (Node2 (sa + 1) m n) (Node2 (s - sa) b c)\n  | i < sab = case f (i - sa) b of\n      InsOne n -> InsOne $ Node3 (s + 1) a n c\n      InsTwo m n -> InsTwo am nc\n        where !am = node2 a m\n              !nc = node2 n c\n  | otherwise = case f (i - sab) c of\n      InsOne n -> InsOne $ Node3 (s + 1) a b n\n      InsTwo m n -> InsTwo (Node2 sab a b) (Node2 (s - sab + 1) m n)\n  where sa = size a\n        sab = sa + size b\n\ndata InsDigNode a = InsLeftDig !(Digit a) | InsDigNode !(Digit a) !(Node a)\n{-# SPECIALIZE insLeftDigit :: (Int -> Elem a -> Ins (Elem a)) -> Int -> Digit (Elem a) -> InsDigNode (Elem a) #-}\n{-# SPECIALIZE insLeftDigit :: (Int -> Node a -> Ins (Node a)) -> Int -> Digit (Node a) -> InsDigNode (Node a) #-}\ninsLeftDigit :: Sized a => (Int -> a -> Ins a) -> Int -> Digit a -> InsDigNode a\ninsLeftDigit f !i (One a) = case f i a of\n  InsOne a\' -> InsLeftDig $ One a\'\n  InsTwo a1 a2 -> InsLeftDig $ Two a1 a2\ninsLeftDigit f i (Two a b)\n  | i < sa = case f i a of\n     InsOne a\' -> InsLeftDig $ Two a\' b\n     InsTwo a1 a2 -> InsLeftDig $ Three a1 a2 b\n  | otherwise = case f (i - sa) b of\n     InsOne b\' -> InsLeftDig $ Two a b\'\n     InsTwo b1 b2 -> InsLeftDig $ Three a b1 b2\n  where sa = size a\ninsLeftDigit f i (Three a b c)\n  | i < sa = case f i a of\n     InsOne a\' -> InsLeftDig $ Three a\' b c\n     InsTwo a1 a2 -> InsLeftDig $ Four a1 a2 b c\n  | i < sab = case f (i - sa) b of\n     InsOne b\' -> InsLeftDig $ Three a b\' c\n     InsTwo b1 b2 -> InsLeftDig $ Four a b1 b2 c\n  | otherwise = case f (i - sab) c of\n     InsOne c\' -> InsLeftDig $ Three a b c\'\n     InsTwo c1 c2 -> InsLeftDig $ Four a b c1 c2\n  where sa = size a\n        sab = sa + size b\ninsLeftDigit f i (Four a b c d)\n  | i < sa = case f i a of\n     InsOne a\' -> InsLeftDig $ Four a\' b c d\n     InsTwo a1 a2 -> InsDigNode (Two a1 a2) (node3 b c d)\n  | i < sab = case f (i - sa) b of\n     InsOne b\' -> InsLeftDig $ Four a b\' c d\n     InsTwo b1 b2 -> InsDigNode (Two a b1) (node3 b2 c d)\n  | i < sabc = case f (i - sab) c of\n     InsOne c\' -> InsLeftDig $ Four a b c\' d\n     InsTwo c1 c2 -> InsDigNode (Two a b) (node3 c1 c2 d)\n  | otherwise = case f (i - sabc) d of\n     InsOne d\' -> InsLeftDig $ Four a b c d\'\n     InsTwo d1 d2 -> InsDigNode (Two a b) (node3 c d1 d2)\n  where sa = size a\n        sab = sa + size b\n        sabc = sab + size c\n\ndata InsNodeDig a = InsRightDig !(Digit a) | InsNodeDig !(Node a) !(Digit a)\n{-# SPECIALIZE insRightDigit :: (Int -> Elem a -> Ins (Elem a)) -> Int -> Digit (Elem a) -> InsNodeDig (Elem a) #-}\n{-# SPECIALIZE insRightDigit :: (Int -> Node a -> Ins (Node a)) -> Int -> Digit (Node a) -> InsNodeDig (Node a) #-}\ninsRightDigit :: Sized a => (Int -> a -> Ins a) -> Int -> Digit a -> InsNodeDig a\ninsRightDigit f !i (One a) = case f i a of\n  InsOne a\' -> InsRightDig $ One a\'\n  InsTwo a1 a2 -> InsRightDig $ Two a1 a2\ninsRightDigit f i (Two a b)\n  | i < sa = case f i a of\n     InsOne a\' -> InsRightDig $ Two a\' b\n     InsTwo a1 a2 -> InsRightDig $ Three a1 a2 b\n  | otherwise = case f (i - sa) b of\n     InsOne b\' -> InsRightDig $ Two a b\'\n     InsTwo b1 b2 -> InsRightDig $ Three a b1 b2\n  where sa = size a\ninsRightDigit f i (Three a b c)\n  | i < sa = case f i a of\n     InsOne a\' -> InsRightDig $ Three a\' b c\n     InsTwo a1 a2 -> InsRightDig $ Four a1 a2 b c\n  | i < sab = case f (i - sa) b of\n     InsOne b\' -> InsRightDig $ Three a b\' c\n     InsTwo b1 b2 -> InsRightDig $ Four a b1 b2 c\n  | otherwise = case f (i - sab) c of\n     InsOne c\' -> InsRightDig $ Three a b c\'\n     InsTwo c1 c2 -> InsRightDig $ Four a b c1 c2\n  where sa = size a\n        sab = sa + size b\ninsRightDigit f i (Four a b c d)\n  | i < sa = case f i a of\n     InsOne a\' -> InsRightDig $ Four a\' b c d\n     InsTwo a1 a2 -> InsNodeDig (node3 a1 a2 b) (Two c d)\n  | i < sab = case f (i - sa) b of\n     InsOne b\' -> InsRightDig $ Four a b\' c d\n     InsTwo b1 b2 -> InsNodeDig (node3 a b1 b2) (Two c d)\n  | i < sabc = case f (i - sab) c of\n     InsOne c\' -> InsRightDig $ Four a b c\' d\n     InsTwo c1 c2 -> InsNodeDig (node3 a b c1) (Two c2 d)\n  | otherwise = case f (i - sabc) d of\n     InsOne d\' -> InsRightDig $ Four a b c d\'\n     InsTwo d1 d2 -> InsNodeDig (node3 a b c) (Two d1 d2)\n  where sa = size a\n        sab = sa + size b\n        sabc = sab + size c\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). Delete the element of a sequence at a given\n-- index. Return the original sequence if the index is out of range.\n--\n-- @\n-- deleteAt 2 [a,b,c,d] = [a,b,d]\n-- deleteAt 4 [a,b,c,d] = deleteAt (-1) [a,b,c,d] = [a,b,c,d]\n-- @\n--\n-- @since 0.5.8\ndeleteAt :: Int -> Seq a -> Seq a\ndeleteAt i (Seq xs)\n  | fromIntegral i < (fromIntegral (size xs) :: Word) = Seq $ delTreeE i xs\n  | otherwise = Seq xs\n\ndelTreeE :: Int -> FingerTree (Elem a) -> FingerTree (Elem a)\ndelTreeE !_i EmptyT = EmptyT -- Unreachable\ndelTreeE _i Single{} = EmptyT\ndelTreeE i (Deep s pr m sf)\n  | i < spr = delLeftDigitE i s pr m sf\n  | i < spm = case delTree delNodeE (i - spr) m of\n     FullTree m\' -> Deep (s - 1) pr m\' sf\n     DefectTree e -> delRebuildMiddle (s - 1) pr e sf\n  | otherwise = delRightDigitE (i - spm) s pr m sf\n  where spr = size pr\n        spm = spr + size m\n\ndelNodeE :: Int -> Node (Elem a) -> Del (Elem a)\ndelNodeE i (Node3 _ a b c) = case i of\n  0 -> Full $ Node2 2 b c\n  1 -> Full $ Node2 2 a c\n  _ -> Full $ Node2 2 a b\ndelNodeE i (Node2 _ a b) = case i of\n  0 -> Defect b\n  _ -> Defect a\n\n\ndelLeftDigitE :: Int -> Int -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> FingerTree (Elem a)\ndelLeftDigitE !_i s One{} m sf = pullL (s - 1) m sf\ndelLeftDigitE i s (Two a b) m sf\n  | i == 0 = Deep (s - 1) (One b) m sf\n  | otherwise = Deep (s - 1) (One a) m sf\ndelLeftDigitE i s (Three a b c) m sf\n  | i == 0 = Deep (s - 1) (Two b c) m sf\n  | i == 1 = Deep (s - 1) (Two a c) m sf\n  | otherwise = Deep (s - 1) (Two a b) m sf\ndelLeftDigitE i s (Four a b c d) m sf\n  | i == 0 = Deep (s - 1) (Three b c d) m sf\n  | i == 1 = Deep (s - 1) (Three a c d) m sf\n  | i == 2 = Deep (s - 1) (Three a b d) m sf\n  | otherwise = Deep (s - 1) (Three a b c) m sf\n\ndelRightDigitE :: Int -> Int -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) -> FingerTree (Elem a)\ndelRightDigitE !_i s pr m One{} = pullR (s - 1) pr m\ndelRightDigitE i s pr m (Two a b)\n  | i == 0 = Deep (s - 1) pr m (One b)\n  | otherwise = Deep (s - 1) pr m (One a)\ndelRightDigitE i s pr m (Three a b c)\n  | i == 0 = Deep (s - 1) pr m (Two b c)\n  | i == 1 = Deep (s - 1) pr m (Two a c)\n  | otherwise = deep pr m (Two a b)\ndelRightDigitE i s pr m (Four a b c d)\n  | i == 0 = Deep (s - 1) pr m (Three b c d)\n  | i == 1 = Deep (s - 1) pr m (Three a c d)\n  | i == 2 = Deep (s - 1) pr m (Three a b d)\n  | otherwise = Deep (s - 1) pr m (Three a b c)\n\ndata DelTree a = FullTree !(FingerTree (Node a)) | DefectTree a\n\n{-# SPECIALIZE delTree :: (Int -> Node (Elem a) -> Del (Elem a)) -> Int -> FingerTree (Node (Elem a)) -> DelTree (Elem a) #-}\n{-# SPECIALIZE delTree :: (Int -> Node (Node a) -> Del (Node a)) -> Int -> FingerTree (Node (Node a)) -> DelTree (Node a) #-}\ndelTree :: Sized a => (Int -> Node a -> Del a) -> Int -> FingerTree (Node a) -> DelTree a\ndelTree _f !_i EmptyT = FullTree EmptyT -- Unreachable\ndelTree f i (Single a) = case f i a of\n  Full a\' -> FullTree (Single a\')\n  Defect e -> DefectTree e\ndelTree f i (Deep s pr m sf)\n  | i < spr = case delDigit f i pr of\n     FullDig pr\' -> FullTree $ Deep (s - 1) pr\' m sf\n     DefectDig e -> case viewLTree m of\n                      EmptyLTree -> FullTree $ delRebuildRightDigit (s - 1) e sf\n                      ConsLTree n m\' -> FullTree $ delRebuildLeftSide (s - 1) e n m\' sf\n  | i < spm = case delTree (delNode f) (i - spr) m of\n     FullTree m\' -> FullTree (Deep (s - 1) pr m\' sf)\n     DefectTree e -> FullTree $ delRebuildMiddle (s - 1) pr e sf\n  | otherwise = case delDigit f (i - spm) sf of\n     FullDig sf\' -> FullTree $ Deep (s - 1) pr m sf\'\n     DefectDig e -> case viewRTree m of\n                      EmptyRTree -> FullTree $ delRebuildLeftDigit (s - 1) pr e\n                      SnocRTree m\' n -> FullTree $ delRebuildRightSide (s - 1) pr m\' n e\n  where spr = size pr\n        spm = spr + size m\n\ndata Del a = Full !(Node a) | Defect a\n\n{-# SPECIALIZE delNode :: (Int -> Node (Elem a) -> Del (Elem a)) -> Int -> Node (Node (Elem a)) -> Del (Node (Elem a)) #-}\n{-# SPECIALIZE delNode :: (Int -> Node (Node a) -> Del (Node a)) -> Int -> Node (Node (Node a)) -> Del (Node (Node a)) #-}\ndelNode :: Sized a => (Int -> Node a -> Del a) -> Int -> Node (Node a) -> Del (Node a)\ndelNode f i (Node3 s a b c)\n  | i < sa = case f i a of\n     Full a\' -> Full $ Node3 (s - 1) a\' b c\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> Full $ Node3 (s - 1) (Node2 (se + sx) e x) (Node2 (sxyz - sx) y z) c\n         where !sx = size x\n       Node2 sxy x y -> Full $ Node2 (s - 1) (Node3 (sxy + se) e x y) c\n  | i < sab = case f (i - sa) b of\n     Full b\' -> Full $ Node3 (s - 1) a b\' c\n     Defect e -> let !se = size e in case a of\n       Node3 sxyz x y z -> Full $ Node3 (s - 1) (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e) c\n         where !sz = size z\n       Node2 sxy x y -> Full $ Node2 (s - 1) (Node3 (sxy + se) x y e) c\n  | otherwise = case f (i - sab) c of\n     Full c\' -> Full $ Node3 (s - 1) a b c\'\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> Full $ Node3 (s - 1) a (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e)\n         where !sz = size z\n       Node2 sxy x y -> Full $ Node2 (s - 1) a (Node3 (sxy + se) x y e)\n  where sa = size a\n        sab = sa + size b\ndelNode f i (Node2 s a b)\n  | i < sa = case f i a of\n     Full a\' -> Full $ Node2 (s - 1) a\' b\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> Full $ Node2 (s - 1) (Node2 (se + sx) e x) (Node2 (sxyz - sx) y z)\n        where !sx = size x\n       Node2 _ x y -> Defect $ Node3 (s - 1) e x y\n  | otherwise = case f (i - sa) b of\n     Full b\' -> Full $ Node2 (s - 1) a b\'\n     Defect e -> let !se = size e in case a of\n       Node3 sxyz x y z -> Full $ Node2 (s - 1) (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e)\n         where !sz = size z\n       Node2 _ x y -> Defect $ Node3 (s - 1) x y e\n  where sa = size a\n\n{-# SPECIALIZE delRebuildRightDigit :: Int -> Elem a -> Digit (Node (Elem a)) -> FingerTree (Node (Elem a)) #-}\n{-# SPECIALIZE delRebuildRightDigit :: Int -> Node a -> Digit (Node (Node a)) -> FingerTree (Node (Node a)) #-}\ndelRebuildRightDigit :: Sized a => Int -> a -> Digit (Node a) -> FingerTree (Node a)\ndelRebuildRightDigit s p (One a) = let !sp = size p in case a of\n  Node3 sxyz x y z -> Deep s (One (Node2 (sp + sx) p x)) EmptyT (One (Node2 (sxyz - sx) y z))\n    where !sx = size x\n  Node2 sxy x y -> Single (Node3 (sp + sxy) p x y)\ndelRebuildRightDigit s p (Two a b) = let !sp = size p in case a of\n  Node3 sxyz x y z -> Deep s (Two (Node2 (sp + sx) p x) (Node2 (sxyz - sx) y z)) EmptyT (One b)\n    where !sx = size x\n  Node2 sxy x y -> Deep s (One (Node3 (sp + sxy) p x y)) EmptyT (One b)\ndelRebuildRightDigit s p (Three a b c) = let !sp = size p in case a of\n  Node3 sxyz x y z -> Deep s (Two (Node2 (sp + sx) p x) (Node2 (sxyz - sx) y z)) EmptyT (Two b c)\n    where !sx = size x\n  Node2 sxy x y -> Deep s (Two (Node3 (sp + sxy) p x y) b) EmptyT (One c)\ndelRebuildRightDigit s p (Four a b c d) = let !sp = size p in case a of\n  Node3 sxyz x y z -> Deep s (Three (Node2 (sp + sx) p x) (Node2 (sxyz - sx) y z) b) EmptyT (Two c d)\n    where !sx = size x\n  Node2 sxy x y -> Deep s (Two (Node3 (sp + sxy) p x y) b) EmptyT (Two c d)\n\n{-# SPECIALIZE delRebuildLeftDigit :: Int -> Digit (Node (Elem a)) -> Elem a -> FingerTree (Node (Elem a)) #-}\n{-# SPECIALIZE delRebuildLeftDigit :: Int -> Digit (Node (Node a)) -> Node a -> FingerTree (Node (Node a)) #-}\ndelRebuildLeftDigit :: Sized a => Int -> Digit (Node a) -> a -> FingerTree (Node a)\ndelRebuildLeftDigit s (One a) p = let !sp = size p in case a of\n  Node3 sxyz x y z -> Deep s (One (Node2 (sxyz - sz) x y)) EmptyT (One (Node2 (sz + sp) z p))\n    where !sz = size z\n  Node2 sxy x y -> Single (Node3 (sxy + sp) x y p)\ndelRebuildLeftDigit s (Two a b) p = let !sp = size p in case b of\n  Node3 sxyz x y z -> Deep s (Two a (Node2 (sxyz - sz) x y)) EmptyT (One (Node2 (sz + sp) z p))\n    where !sz = size z\n  Node2 sxy x y -> Deep s (One a) EmptyT (One (Node3 (sxy + sp) x y p))\ndelRebuildLeftDigit s (Three a b c) p = let !sp = size p in case c of\n  Node3 sxyz x y z -> Deep s (Two a b) EmptyT (Two (Node2 (sxyz - sz) x y) (Node2 (sz + sp) z p))\n    where !sz = size z\n  Node2 sxy x y -> Deep s (Two a b) EmptyT (One (Node3 (sxy + sp) x y p))\ndelRebuildLeftDigit s (Four a b c d) p = let !sp = size p in case d of\n  Node3 sxyz x y z -> Deep s (Three a b c) EmptyT (Two (Node2 (sxyz - sz) x y) (Node2 (sz + sp) z p))\n    where !sz = size z\n  Node2 sxy x y -> Deep s (Two a b) EmptyT (Two c (Node3 (sxy + sp) x y p))\n\ndelRebuildLeftSide :: Sized a\n                   => Int -> a -> Node (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a)\n                   -> FingerTree (Node a)\ndelRebuildLeftSide s p (Node2 _ a b) m sf = let !sp = size p in case a of\n  Node2 sxy x y -> Deep s (Two (Node3 (sp + sxy) p x y) b) m sf\n  Node3 sxyz x y z -> Deep s (Three (Node2 (sp + sx) p x) (Node2 (sxyz - sx) y z) b) m sf\n    where !sx = size x\ndelRebuildLeftSide s p (Node3 _ a b c) m sf = let !sp = size p in case a of\n  Node2 sxy x y -> Deep s (Three (Node3 (sp + sxy) p x y) b c) m sf\n  Node3 sxyz x y z -> Deep s (Four (Node2 (sp + sx) p x) (Node2 (sxyz - sx) y z) b c) m sf\n    where !sx = size x\n\ndelRebuildRightSide :: Sized a\n                    => Int -> Digit (Node a) -> FingerTree (Node (Node a)) -> Node (Node a) -> a\n                    -> FingerTree (Node a)\ndelRebuildRightSide s pr m (Node2 _ a b) p = let !sp = size p in case b of\n  Node2 sxy x y -> Deep s pr m (Two a (Node3 (sxy + sp) x y p))\n  Node3 sxyz x y z -> Deep s pr m (Three a (Node2 (sxyz - sz) x y) (Node2 (sz + sp) z p))\n    where !sz = size z\ndelRebuildRightSide s pr m (Node3 _ a b c) p = let !sp = size p in case c of\n  Node2 sxy x y -> Deep s pr m (Three a b (Node3 (sxy + sp) x y p))\n  Node3 sxyz x y z -> Deep s pr m (Four a b (Node2 (sxyz - sz) x y) (Node2 (sz + sp) z p))\n    where !sz = size z\n\ndelRebuildMiddle :: Sized a\n                 => Int -> Digit a -> a -> Digit a\n                 -> FingerTree a\ndelRebuildMiddle s (One a) e sf = Deep s (Two a e) EmptyT sf\ndelRebuildMiddle s (Two a b) e sf = Deep s (Three a b e) EmptyT sf\ndelRebuildMiddle s (Three a b c) e sf = Deep s (Four a b c e) EmptyT sf\ndelRebuildMiddle s (Four a b c d) e sf = Deep s (Two a b) (Single (node3 c d e)) sf\n\ndata DelDig a = FullDig !(Digit (Node a)) | DefectDig a\n\n{-# SPECIALIZE delDigit :: (Int -> Node (Elem a) -> Del (Elem a)) -> Int -> Digit (Node (Elem a)) -> DelDig (Elem a) #-}\n{-# SPECIALIZE delDigit :: (Int -> Node (Node a) -> Del (Node a)) -> Int -> Digit (Node (Node a)) -> DelDig (Node a) #-}\ndelDigit :: Sized a => (Int -> Node a -> Del a) -> Int -> Digit (Node a) -> DelDig a\ndelDigit f !i (One a) = case f i a of\n  Full a\' -> FullDig $ One a\'\n  Defect e -> DefectDig e\ndelDigit f i (Two a b)\n  | i < sa = case f i a of\n     Full a\' -> FullDig $ Two a\' b\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> FullDig $ Two (Node2 (se + sx) e x) (Node2 (sxyz - sx) y z)\n         where !sx = size x\n       Node2 sxy x y -> FullDig $ One (Node3 (se + sxy) e x y)\n  | otherwise = case f (i - sa) b of\n     Full b\' -> FullDig $ Two a b\'\n     Defect e -> let !se = size e in case a of\n       Node3 sxyz x y z -> FullDig $ Two (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e)\n         where !sz = size z\n       Node2 sxy x y -> FullDig $ One (Node3 (sxy + se) x y e)\n  where sa = size a\ndelDigit f i (Three a b c)\n  | i < sa = case f i a of\n     Full a\' -> FullDig $ Three a\' b c\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> FullDig $ Three (Node2 (se + sx) e x) (Node2 (sxyz - sx) y z) c\n         where !sx = size x\n       Node2 sxy x y -> FullDig $ Two (Node3 (se + sxy) e x y) c\n  | i < sab = case f (i - sa) b of\n     Full b\' -> FullDig $ Three a b\' c\n     Defect e -> let !se = size e in case a of\n       Node3 sxyz x y z -> FullDig $ Three (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e) c\n         where !sz = size z\n       Node2 sxy x y -> FullDig $ Two (Node3 (sxy + se) x y e) c\n  | otherwise = case f (i - sab) c of\n     Full c\' -> FullDig $ Three a b c\'\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> FullDig $ Three a (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e)\n         where !sz = size z\n       Node2 sxy x y -> FullDig $ Two a (Node3 (sxy + se) x y e)\n  where sa = size a\n        sab = sa + size b\ndelDigit f i (Four a b c d)\n  | i < sa = case f i a of\n     Full a\' -> FullDig $ Four a\' b c d\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> FullDig $ Four (Node2 (se + sx) e x) (Node2 (sxyz - sx) y z) c d\n         where !sx = size x\n       Node2 sxy x y -> FullDig $ Three (Node3 (se + sxy) e x y) c d\n  | i < sab = case f (i - sa) b of\n     Full b\' -> FullDig $ Four a b\' c d\n     Defect e -> let !se = size e in case a of\n       Node3 sxyz x y z -> FullDig $ Four (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e) c d\n         where !sz = size z\n       Node2 sxy x y -> FullDig $ Three (Node3 (sxy + se) x y e) c d\n  | i < sabc = case f (i - sab) c of\n     Full c\' -> FullDig $ Four a b c\' d\n     Defect e -> let !se = size e in case b of\n       Node3 sxyz x y z -> FullDig $ Four a (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e) d\n         where !sz = size z\n       Node2 sxy x y -> FullDig $ Three a (Node3 (sxy + se) x y e) d\n  | otherwise = case f (i - sabc) d of\n     Full d\' -> FullDig $ Four a b c d\'\n     Defect e -> let !se = size e in case c of\n       Node3 sxyz x y z -> FullDig $ Four a b (Node2 (sxyz - sz) x y) (Node2 (sz + se) z e)\n         where !sz = size z\n       Node2 sxy x y -> FullDig $ Three a b (Node3 (sxy + se) x y e)\n  where sa = size a\n        sab = sa + size b\n        sabc = sab + size c\n\n\n-- | A generalization of \'fmap\', \'mapWithIndex\' takes a mapping\n-- function that also depends on the element\'s index, and applies it to every\n-- element in the sequence.\nmapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b\nmapWithIndex f\' (Seq xs\') = Seq $ mapWithIndexTree (\\s (Elem a) -> Elem (f\' s a)) 0 xs\'\n where\n  {-# SPECIALIZE mapWithIndexTree :: (Int -> Elem y -> b) -> Int -> FingerTree (Elem y) -> FingerTree b #-}\n  {-# SPECIALIZE mapWithIndexTree :: (Int -> Node y -> b) -> Int -> FingerTree (Node y) -> FingerTree b #-}\n  mapWithIndexTree :: Sized a => (Int -> a -> b) -> Int -> FingerTree a -> FingerTree b\n  mapWithIndexTree _ !_s EmptyT = EmptyT\n  mapWithIndexTree f s (Single xs) = Single $ f s xs\n  mapWithIndexTree f s (Deep n pr m sf) =\n          Deep n\n               (mapWithIndexDigit f s pr)\n               (mapWithIndexTree (mapWithIndexNode f) sPspr m)\n               (mapWithIndexDigit f sPsprm sf)\n    where\n      !sPspr = s + size pr\n      !sPsprm = sPspr + size m\n\n  {-# SPECIALIZE mapWithIndexDigit :: (Int -> Elem y -> b) -> Int -> Digit (Elem y) -> Digit b #-}\n  {-# SPECIALIZE mapWithIndexDigit :: (Int -> Node y -> b) -> Int -> Digit (Node y) -> Digit b #-}\n  mapWithIndexDigit :: Sized a => (Int -> a -> b) -> Int -> Digit a -> Digit b\n  mapWithIndexDigit f !s (One a) = One (f s a)\n  mapWithIndexDigit f s (Two a b) = Two (f s a) (f sPsa b)\n    where\n      !sPsa = s + size a\n  mapWithIndexDigit f s (Three a b c) =\n                                      Three (f s a) (f sPsa b) (f sPsab c)\n    where\n      !sPsa = s + size a\n      !sPsab = sPsa + size b\n  mapWithIndexDigit f s (Four a b c d) =\n                          Four (f s a) (f sPsa b) (f sPsab c) (f sPsabc d)\n    where\n      !sPsa = s + size a\n      !sPsab = sPsa + size b\n      !sPsabc = sPsab + size c\n\n  {-# SPECIALIZE mapWithIndexNode :: (Int -> Elem y -> b) -> Int -> Node (Elem y) -> Node b #-}\n  {-# SPECIALIZE mapWithIndexNode :: (Int -> Node y -> b) -> Int -> Node (Node y) -> Node b #-}\n  mapWithIndexNode :: Sized a => (Int -> a -> b) -> Int -> Node a -> Node b\n  mapWithIndexNode f s (Node2 ns a b) = Node2 ns (f s a) (f sPsa b)\n    where\n      !sPsa = s + size a\n  mapWithIndexNode f s (Node3 ns a b c) =\n                                     Node3 ns (f s a) (f sPsa b) (f sPsab c)\n    where\n      !sPsa = s + size a\n      !sPsab = sPsa + size b\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] mapWithIndex #-}\n{-# RULES\n"mapWithIndex/mapWithIndex" forall f g xs . mapWithIndex f (mapWithIndex g xs) =\n  mapWithIndex (\\k a -> f k (g k a)) xs\n"mapWithIndex/fmapSeq" forall f g xs . mapWithIndex f (fmapSeq g xs) =\n  mapWithIndex (\\k a -> f k (g a)) xs\n"fmapSeq/mapWithIndex" forall f g xs . fmapSeq f (mapWithIndex g xs) =\n  mapWithIndex (\\k a -> f (g k a)) xs\n #-}\n#endif\n\n{-# INLINE foldWithIndexDigit #-}\nfoldWithIndexDigit :: Sized a => (b -> b -> b) -> (Int -> a -> b) -> Int -> Digit a -> b\nfoldWithIndexDigit _ f !s (One a) = f s a\nfoldWithIndexDigit (<+>) f s (Two a b) = f s a <+> f sPsa b\n  where\n    !sPsa = s + size a\nfoldWithIndexDigit (<+>) f s (Three a b c) = f s a <+> f sPsa b <+> f sPsab c\n  where\n    !sPsa = s + size a\n    !sPsab = sPsa + size b\nfoldWithIndexDigit (<+>) f s (Four a b c d) =\n    f s a <+> f sPsa b <+> f sPsab c <+> f sPsabc d\n  where\n    !sPsa = s + size a\n    !sPsab = sPsa + size b\n    !sPsabc = sPsab + size c\n\n{-# INLINE foldWithIndexNode #-}\nfoldWithIndexNode :: Sized a => (m -> m -> m) -> (Int -> a -> m) -> Int -> Node a -> m\nfoldWithIndexNode (<+>) f !s (Node2 _ a b) = f s a <+> f sPsa b\n  where\n    !sPsa = s + size a\nfoldWithIndexNode (<+>) f s (Node3 _ a b c) = f s a <+> f sPsa b <+> f sPsab c\n  where\n    !sPsa = s + size a\n    !sPsab = sPsa + size b\n\n-- A generalization of \'foldMap\', \'foldMapWithIndex\' takes a folding\n-- function that also depends on the element\'s index, and applies it to every\n-- element in the sequence.\n--\n-- @since 0.5.8\nfoldMapWithIndex :: Monoid m => (Int -> a -> m) -> Seq a -> m\nfoldMapWithIndex f\' (Seq xs\') = foldMapWithIndexTreeE (lift_elem f\') 0 xs\'\n where\n  lift_elem :: (Int -> a -> m) -> (Int -> Elem a -> m)\n#ifdef __GLASGOW_HASKELL__\n  lift_elem g = coerce g\n#else\n  lift_elem g = \\s (Elem a) -> g s a\n#endif\n  {-# INLINE lift_elem #-}\n-- We have to specialize these functions by hand, unfortunately, because\n-- GHC does not specialize until *all* instances are determined.\n-- Although the Sized instance is known at compile time, the Monoid\n-- instance generally is not.\n  foldMapWithIndexTreeE :: Monoid m => (Int -> Elem a -> m) -> Int -> FingerTree (Elem a) -> m\n  foldMapWithIndexTreeE _ !_s EmptyT = mempty\n  foldMapWithIndexTreeE f s (Single xs) = f s xs\n  foldMapWithIndexTreeE f s (Deep _ pr m sf) =\n               foldMapWithIndexDigitE f s pr <>\n               foldMapWithIndexTreeN (foldMapWithIndexNodeE f) sPspr m <>\n               foldMapWithIndexDigitE f sPsprm sf\n    where\n      !sPspr = s + size pr\n      !sPsprm = sPspr + size m\n\n  foldMapWithIndexTreeN :: Monoid m => (Int -> Node a -> m) -> Int -> FingerTree (Node a) -> m\n  foldMapWithIndexTreeN _ !_s EmptyT = mempty\n  foldMapWithIndexTreeN f s (Single xs) = f s xs\n  foldMapWithIndexTreeN f s (Deep _ pr m sf) =\n               foldMapWithIndexDigitN f s pr <>\n               foldMapWithIndexTreeN (foldMapWithIndexNodeN f) sPspr m <>\n               foldMapWithIndexDigitN f sPsprm sf\n    where\n      !sPspr = s + size pr\n      !sPsprm = sPspr + size m\n\n  foldMapWithIndexDigitE :: Monoid m => (Int -> Elem a -> m) -> Int -> Digit (Elem a) -> m\n  foldMapWithIndexDigitE f i t = foldWithIndexDigit (<>) f i t\n\n  foldMapWithIndexDigitN :: Monoid m => (Int -> Node a -> m) -> Int -> Digit (Node a) -> m\n  foldMapWithIndexDigitN f i t = foldWithIndexDigit (<>) f i t\n\n  foldMapWithIndexNodeE :: Monoid m => (Int -> Elem a -> m) -> Int -> Node (Elem a) -> m\n  foldMapWithIndexNodeE f i t = foldWithIndexNode (<>) f i t\n\n  foldMapWithIndexNodeN :: Monoid m => (Int -> Node a -> m) -> Int -> Node (Node a) -> m\n  foldMapWithIndexNodeN f i t = foldWithIndexNode (<>) f i t\n\n#if __GLASGOW_HASKELL__\n{-# INLINABLE foldMapWithIndex #-}\n#endif\n\n-- | \'traverseWithIndex\' is a version of \'traverse\' that also offers\n-- access to the index of each element.\n--\n-- @since 0.5.8\ntraverseWithIndex :: Applicative f => (Int -> a -> f b) -> Seq a -> f (Seq b)\ntraverseWithIndex f\' (Seq xs\') = Seq <$> traverseWithIndexTreeE (\\s (Elem a) -> Elem <$> f\' s a) 0 xs\'\n where\n-- We have to specialize these functions by hand, unfortunately, because\n-- GHC does not specialize until *all* instances are determined.\n-- Although the Sized instance is known at compile time, the Applicative\n-- instance generally is not.\n  traverseWithIndexTreeE :: Applicative f => (Int -> Elem a -> f b) -> Int -> FingerTree (Elem a) -> f (FingerTree b)\n  traverseWithIndexTreeE _ !_s EmptyT = pure EmptyT\n  traverseWithIndexTreeE f s (Single xs) = Single <$> f s xs\n  traverseWithIndexTreeE f s (Deep n pr m sf) =\n          liftA3 (Deep n)\n               (traverseWithIndexDigitE f s pr)\n               (traverseWithIndexTreeN (traverseWithIndexNodeE f) sPspr m)\n               (traverseWithIndexDigitE f sPsprm sf)\n    where\n      !sPspr = s + size pr\n      !sPsprm = sPspr + size m\n\n  traverseWithIndexTreeN :: Applicative f => (Int -> Node a -> f b) -> Int -> FingerTree (Node a) -> f (FingerTree b)\n  traverseWithIndexTreeN _ !_s EmptyT = pure EmptyT\n  traverseWithIndexTreeN f s (Single xs) = Single <$> f s xs\n  traverseWithIndexTreeN f s (Deep n pr m sf) =\n          liftA3 (Deep n)\n               (traverseWithIndexDigitN f s pr)\n               (traverseWithIndexTreeN (traverseWithIndexNodeN f) sPspr m)\n               (traverseWithIndexDigitN f sPsprm sf)\n    where\n      !sPspr = s + size pr\n      !sPsprm = sPspr + size m\n\n  traverseWithIndexDigitE :: Applicative f => (Int -> Elem a -> f b) -> Int -> Digit (Elem a) -> f (Digit b)\n  traverseWithIndexDigitE f i t = traverseWithIndexDigit f i t\n\n  traverseWithIndexDigitN :: Applicative f => (Int -> Node a -> f b) -> Int -> Digit (Node a) -> f (Digit b)\n  traverseWithIndexDigitN f i t = traverseWithIndexDigit f i t\n\n  {-# INLINE traverseWithIndexDigit #-}\n  traverseWithIndexDigit :: (Applicative f, Sized a) => (Int -> a -> f b) -> Int -> Digit a -> f (Digit b)\n  traverseWithIndexDigit f !s (One a) = One <$> f s a\n  traverseWithIndexDigit f s (Two a b) = liftA2 Two (f s a) (f sPsa b)\n    where\n      !sPsa = s + size a\n  traverseWithIndexDigit f s (Three a b c) =\n                                      liftA3 Three (f s a) (f sPsa b) (f sPsab c)\n    where\n      !sPsa = s + size a\n      !sPsab = sPsa + size b\n  traverseWithIndexDigit f s (Four a b c d) =\n                          liftA3 Four (f s a) (f sPsa b) (f sPsab c) <*> f sPsabc d\n    where\n      !sPsa = s + size a\n      !sPsab = sPsa + size b\n      !sPsabc = sPsab + size c\n\n  traverseWithIndexNodeE :: Applicative f => (Int -> Elem a -> f b) -> Int -> Node (Elem a) -> f (Node b)\n  traverseWithIndexNodeE f i t = traverseWithIndexNode f i t\n\n  traverseWithIndexNodeN :: Applicative f => (Int -> Node a -> f b) -> Int -> Node (Node a) -> f (Node b)\n  traverseWithIndexNodeN f i t = traverseWithIndexNode f i t\n\n  {-# INLINE traverseWithIndexNode #-}\n  traverseWithIndexNode :: (Applicative f, Sized a) => (Int -> a -> f b) -> Int -> Node a -> f (Node b)\n  traverseWithIndexNode f !s (Node2 ns a b) = liftA2 (Node2 ns) (f s a) (f sPsa b)\n    where\n      !sPsa = s + size a\n  traverseWithIndexNode f s (Node3 ns a b c) =\n                           liftA3 (Node3 ns) (f s a) (f sPsa b) (f sPsab c)\n    where\n      !sPsa = s + size a\n      !sPsab = sPsa + size b\n\n\n#ifdef __GLASGOW_HASKELL__\n{-# INLINABLE [1] traverseWithIndex #-}\n#else\n{-# INLINE [1] traverseWithIndex #-}\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n{-# RULES\n"travWithIndex/mapWithIndex" forall f g xs . traverseWithIndex f (mapWithIndex g xs) =\n  traverseWithIndex (\\k a -> f k (g k a)) xs\n"travWithIndex/fmapSeq" forall f g xs . traverseWithIndex f (fmapSeq g xs) =\n  traverseWithIndex (\\k a -> f k (g a)) xs\n #-}\n#endif\n{-\nIt might be nice to be able to rewrite\n\ntraverseWithIndex f (fromFunction i g)\nto\nreplicateAWithIndex i (\\k -> f k (g k))\nand\ntraverse f (fromFunction i g)\nto\nreplicateAWithIndex i (f . g)\n\nbut we don\'t have replicateAWithIndex as yet.\n\nWe might wish for a rule like\n"fmapSeq/travWithIndex" forall f g xs . fmapSeq f <$> traverseWithIndex g xs =\n  traverseWithIndex (\\k a -> f <$> g k a) xs\nUnfortunately, this rule could screw up the inliner\'s treatment of\nfmap in general, and it also relies on the arbitrary Functor being\nvalid.\n-}\n\n\n-- | \\( O(n) \\). Convert a given sequence length and a function representing that\n-- sequence into a sequence.\n--\n-- @since 0.5.6.2\nfromFunction :: Int -> (Int -> a) -> Seq a\nfromFunction len f | len < 0 = error "Data.Sequence.fromFunction called with negative len"\n                   | len == 0 = empty\n                   | otherwise = Seq $ create (lift_elem f) 1 0 len\n  where\n    create :: (Int -> a) -> Int -> Int -> Int -> FingerTree a\n    create b{-tree_builder-} !s{-tree_size-} !i{-start_index-} trees = case trees of\n       1 -> Single $ b i\n       2 -> Deep (2*s) (One (b i)) EmptyT (One (b (i+s)))\n       3 -> Deep (3*s) (createTwo i) EmptyT (One (b (i+2*s)))\n       4 -> Deep (4*s) (createTwo i) EmptyT (createTwo (i+2*s))\n       5 -> Deep (5*s) (createThree i) EmptyT (createTwo (i+3*s))\n       6 -> Deep (6*s) (createThree i) EmptyT (createThree (i+3*s))\n       _ -> case trees `quotRem` 3 of\n           (trees\', 1) -> Deep (trees*s) (createTwo i)\n                              (create mb (3*s) (i+2*s) (trees\'-1))\n                              (createTwo (i+(2+3*(trees\'-1))*s))\n           (trees\', 2) -> Deep (trees*s) (createThree i)\n                              (create mb (3*s) (i+3*s) (trees\'-1))\n                              (createTwo (i+(3+3*(trees\'-1))*s))\n           (trees\', _) -> Deep (trees*s) (createThree i)\n                              (create mb (3*s) (i+3*s) (trees\'-2))\n                              (createThree (i+(3+3*(trees\'-2))*s))\n      where\n        createTwo j = Two (b j) (b (j + s))\n        {-# INLINE createTwo #-}\n        createThree j = Three (b j) (b (j + s)) (b (j + 2*s))\n        {-# INLINE createThree #-}\n        mb j = Node3 (3*s) (b j) (b (j + s)) (b (j + 2*s))\n        {-# INLINE mb #-}\n\n    lift_elem :: (Int -> a) -> (Int -> Elem a)\n#ifdef __GLASGOW_HASKELL__\n    lift_elem g = coerce g\n#else\n    lift_elem g = Elem . g\n#endif\n    {-# INLINE lift_elem #-}\n\n-- | \\( O(n) \\). Create a sequence consisting of the elements of an \'Array\'.\n-- Note that the resulting sequence elements may be evaluated lazily (as on GHC),\n-- so you must force the entire structure to be sure that the original array\n-- can be garbage-collected.\n--\n-- @since 0.5.6.2\nfromArray :: Ix i => Array i a -> Seq a\n#ifdef __GLASGOW_HASKELL__\nfromArray a = fromFunction (GHC.Arr.numElements a) (GHC.Arr.unsafeAt a)\n where\n  -- The following definition uses an (Ix i) constraint, which is needed for\n  -- the other fromArray definition.\n  _ = Data.Array.rangeSize (Data.Array.bounds a)\n#else\nfromArray a = fromList2 (Data.Array.rangeSize (Data.Array.bounds a)) (Data.Array.elems a)\n#endif\n\n-- Splitting\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). The first @i@ elements of a sequence.\n-- If @i@ is negative, @\'take\' i s@ yields the empty sequence.\n-- If the sequence contains fewer than @i@ elements, the whole sequence\n-- is returned.\ntake :: Int -> Seq a -> Seq a\ntake i xs@(Seq t)\n    -- See note on unsigned arithmetic in splitAt\n  | fromIntegral i - 1 < (fromIntegral (length xs) - 1 :: Word) =\n      Seq (takeTreeE i t)\n  | i <= 0 = empty\n  | otherwise = xs\n\ntakeTreeE :: Int -> FingerTree (Elem a) -> FingerTree (Elem a)\ntakeTreeE !_i EmptyT = EmptyT\ntakeTreeE i t@(Single _)\n   | i <= 0 = EmptyT\n   | otherwise = t\ntakeTreeE i (Deep s pr m sf)\n  | i < spr     = takePrefixE i pr\n  | i < spm     = case takeTreeN im m of\n            ml :*: xs -> takeMiddleE (im - size ml) spr pr ml xs\n  | otherwise   = takeSuffixE (i - spm) s pr m sf\n  where\n    spr     = size pr\n    spm     = spr + size m\n    im      = i - spr\n\ntakeTreeN :: Int -> FingerTree (Node a) -> StrictPair (FingerTree (Node a)) (Node a)\ntakeTreeN !_i EmptyT = error "takeTreeN of empty tree"\ntakeTreeN _i (Single x) = EmptyT :*: x\ntakeTreeN i (Deep s pr m sf)\n  | i < spr     = takePrefixN i pr\n  | i < spm     = case takeTreeN im m of\n            ml :*: xs -> takeMiddleN (im - size ml) spr pr ml xs\n  | otherwise   = takeSuffixN (i - spm) s pr m sf  where\n    spr     = size pr\n    spm     = spr + size m\n    im      = i - spr\n\ntakeMiddleN :: Int -> Int\n             -> Digit (Node a) -> FingerTree (Node (Node a)) -> Node (Node a)\n             -> StrictPair (FingerTree (Node a)) (Node a)\ntakeMiddleN i spr pr ml (Node2 _ a b)\n  | i < sa      = pullR sprml pr ml :*: a\n  | otherwise   = Deep sprmla pr ml (One a) :*: b\n  where\n    sa      = size a\n    sprml   = spr + size ml\n    sprmla  = sa + sprml\ntakeMiddleN i spr pr ml (Node3 _ a b c)\n  | i < sa      = pullR sprml pr ml :*: a\n  | i < sab     = Deep sprmla pr ml (One a) :*: b\n  | otherwise   = Deep sprmlab pr ml (Two a b) :*: c\n  where\n    sa      = size a\n    sab     = sa + size b\n    sprml   = spr + size ml\n    sprmla  = sa + sprml\n    sprmlab = sprmla + size b\n\ntakeMiddleE :: Int -> Int\n             -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Node (Elem a)\n             -> FingerTree (Elem a)\ntakeMiddleE i spr pr ml (Node2 _ a _)\n  | i < 1       = pullR sprml pr ml\n  | otherwise   = Deep sprmla pr ml (One a)\n  where\n    sprml   = spr + size ml\n    sprmla  = 1 + sprml\ntakeMiddleE i spr pr ml (Node3 _ a b _)\n  | i < 1       = pullR sprml pr ml\n  | i < 2       = Deep sprmla pr ml (One a)\n  | otherwise   = Deep sprmlab pr ml (Two a b)\n  where\n    sprml   = spr + size ml\n    sprmla  = 1 + sprml\n    sprmlab = sprmla + 1\n\ntakePrefixE :: Int -> Digit (Elem a) -> FingerTree (Elem a)\ntakePrefixE !_i (One _) = EmptyT\ntakePrefixE i (Two a _)\n  | i < 1       = EmptyT\n  | otherwise   = Single a\ntakePrefixE i (Three a b _)\n  | i < 1       = EmptyT\n  | i < 2       = Single a\n  | otherwise   = Deep 2 (One a) EmptyT (One b)\ntakePrefixE i (Four a b c _)\n  | i < 1       = EmptyT\n  | i < 2       = Single a\n  | i < 3       = Deep 2 (One a) EmptyT (One b)\n  | otherwise   = Deep 3 (Two a b) EmptyT (One c)\n\ntakePrefixN :: Int -> Digit (Node a)\n                    -> StrictPair (FingerTree (Node a)) (Node a)\ntakePrefixN !_i (One a) = EmptyT :*: a\ntakePrefixN i (Two a b)\n  | i < sa      = EmptyT :*: a\n  | otherwise   = Single a :*: b\n  where\n    sa      = size a\ntakePrefixN i (Three a b c)\n  | i < sa      = EmptyT :*: a\n  | i < sab     = Single a :*: b\n  | otherwise   = Deep sab (One a) EmptyT (One b) :*: c\n  where\n    sa      = size a\n    sab     = sa + size b\ntakePrefixN i (Four a b c d)\n  | i < sa      = EmptyT :*: a\n  | i < sab     = Single a :*: b\n  | i < sabc    = Deep sab (One a) EmptyT (One b) :*: c\n  | otherwise   = Deep sabc (Two a b) EmptyT (One c) :*: d\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n\ntakeSuffixE :: Int -> Int -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) ->\n   FingerTree (Elem a)\ntakeSuffixE !_i !s pr m (One _) = pullR (s - 1) pr m\ntakeSuffixE i s pr m (Two a _)\n  | i < 1      = pullR (s - 2) pr m\n  | otherwise  = Deep (s - 1) pr m (One a)\ntakeSuffixE i s pr m (Three a b _)\n  | i < 1      = pullR (s - 3) pr m\n  | i < 2      = Deep (s - 2) pr m (One a)\n  | otherwise  = Deep (s - 1) pr m (Two a b)\ntakeSuffixE i s pr m (Four a b c _)\n  | i < 1      = pullR (s - 4) pr m\n  | i < 2      = Deep (s - 3) pr m (One a)\n  | i < 3      = Deep (s - 2) pr m (Two a b)\n  | otherwise  = Deep (s - 1) pr m (Three a b c)\n\ntakeSuffixN :: Int -> Int -> Digit (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a) ->\n   StrictPair (FingerTree (Node a)) (Node a)\ntakeSuffixN !_i !s pr m (One a) = pullR (s - size a) pr m :*: a\ntakeSuffixN i s pr m (Two a b)\n  | i < sa      = pullR (s - sa - size b) pr m :*: a\n  | otherwise   = Deep (s - size b) pr m (One a) :*: b\n  where\n    sa      = size a\ntakeSuffixN i s pr m (Three a b c)\n  | i < sa      = pullR (s - sab - size c) pr m :*: a\n  | i < sab     = Deep (s - size b - size c) pr m (One a) :*: b\n  | otherwise   = Deep (s - size c) pr m (Two a b) :*: c\n  where\n    sa      = size a\n    sab     = sa + size b\ntakeSuffixN i s pr m (Four a b c d)\n  | i < sa      = pullR (s - sa - sbcd) pr m :*: a\n  | i < sab     = Deep (s - sbcd) pr m (One a) :*: b\n  | i < sabc    = Deep (s - scd) pr m (Two a b) :*: c\n  | otherwise   = Deep (s - sd) pr m (Three a b c) :*: d\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n    sd      = size d\n    scd     = size c + sd\n    sbcd    = size b + scd\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). Elements of a sequence after the first @i@.\n-- If @i@ is negative, @\'drop\' i s@ yields the whole sequence.\n-- If the sequence contains fewer than @i@ elements, the empty sequence\n-- is returned.\ndrop            :: Int -> Seq a -> Seq a\ndrop i xs@(Seq t)\n    -- See note on unsigned arithmetic in splitAt\n  | fromIntegral i - 1 < (fromIntegral (length xs) - 1 :: Word) =\n      Seq (takeTreeER (length xs - i) t)\n  | i <= 0 = xs\n  | otherwise = empty\n\n-- We implement `drop` using a "take from the rear" strategy.  There\'s no\n-- particular technical reason for this; it just lets us reuse the arithmetic\n-- from `take` (which itself reuses the arithmetic from `splitAt`) instead of\n-- figuring it out from scratch and ending up with lots of off-by-one errors.\ntakeTreeER :: Int -> FingerTree (Elem a) -> FingerTree (Elem a)\ntakeTreeER !_i EmptyT = EmptyT\ntakeTreeER i t@(Single _)\n   | i <= 0 = EmptyT\n   | otherwise = t\ntakeTreeER i (Deep s pr m sf)\n  | i < ssf     = takeSuffixER i sf\n  | i < ssm     = case takeTreeNR im m of\n            xs :*: mr -> takeMiddleER (im - size mr) ssf xs mr sf\n  | otherwise   = takePrefixER (i - ssm) s pr m sf\n  where\n    ssf     = size sf\n    ssm     = ssf + size m\n    im      = i - ssf\n\ntakeTreeNR :: Int -> FingerTree (Node a) -> StrictPair (Node a) (FingerTree (Node a))\ntakeTreeNR !_i EmptyT = error "takeTreeNR of empty tree"\ntakeTreeNR _i (Single x) = x :*: EmptyT\ntakeTreeNR i (Deep s pr m sf)\n  | i < ssf     = takeSuffixNR i sf\n  | i < ssm     = case takeTreeNR im m of\n            xs :*: mr -> takeMiddleNR (im - size mr) ssf xs mr sf\n  | otherwise   = takePrefixNR (i - ssm) s pr m sf  where\n    ssf     = size sf\n    ssm     = ssf + size m\n    im      = i - ssf\n\ntakeMiddleNR :: Int -> Int\n             -> Node (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a)\n             -> StrictPair (Node a) (FingerTree (Node a))\ntakeMiddleNR i ssf (Node2 _ a b) mr sf\n  | i < sb      = b :*: pullL ssfmr mr sf\n  | otherwise   = a :*: Deep ssfmrb (One b) mr sf\n  where\n    sb      = size b\n    ssfmr   = ssf + size mr\n    ssfmrb  = sb + ssfmr\ntakeMiddleNR i ssf (Node3 _ a b c) mr sf\n  | i < sc      = c :*: pullL ssfmr mr sf\n  | i < sbc     = b :*: Deep ssfmrc (One c) mr sf\n  | otherwise   = a :*: Deep ssfmrbc (Two b c) mr sf\n  where\n    sc      = size c\n    sbc     = sc + size b\n    ssfmr   = ssf + size mr\n    ssfmrc  = sc + ssfmr\n    ssfmrbc = ssfmrc + size b\n\ntakeMiddleER :: Int -> Int\n             -> Node (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a)\n             -> FingerTree (Elem a)\ntakeMiddleER i ssf (Node2 _ _ b) mr sf\n  | i < 1       = pullL ssfmr mr sf\n  | otherwise   = Deep ssfmrb (One b) mr sf\n  where\n    ssfmr   = ssf + size mr\n    ssfmrb  = 1 + ssfmr\ntakeMiddleER i ssf (Node3 _ _ b c) mr sf\n  | i < 1       = pullL ssfmr mr sf\n  | i < 2       = Deep ssfmrc (One c) mr sf\n  | otherwise   = Deep ssfmrbc (Two b c) mr sf\n  where\n    ssfmr   = ssf + size mr\n    ssfmrc  = 1 + ssfmr\n    ssfmrbc = ssfmr + 2\n\ntakeSuffixER :: Int -> Digit (Elem a) -> FingerTree (Elem a)\ntakeSuffixER !_i (One _) = EmptyT\ntakeSuffixER i (Two _ b)\n  | i < 1       = EmptyT\n  | otherwise   = Single b\ntakeSuffixER i (Three _ b c)\n  | i < 1       = EmptyT\n  | i < 2       = Single c\n  | otherwise   = Deep 2 (One b) EmptyT (One c)\ntakeSuffixER i (Four _ b c d)\n  | i < 1       = EmptyT\n  | i < 2       = Single d\n  | i < 3       = Deep 2 (One c) EmptyT (One d)\n  | otherwise   = Deep 3 (Two b c) EmptyT (One d)\n\ntakeSuffixNR :: Int -> Digit (Node a)\n                    -> StrictPair (Node a) (FingerTree (Node a))\ntakeSuffixNR !_i (One a) = a :*: EmptyT\ntakeSuffixNR i (Two a b)\n  | i < sb      = b :*: EmptyT\n  | otherwise   = a :*: Single b\n  where\n    sb      = size b\ntakeSuffixNR i (Three a b c)\n  | i < sc      = c :*: EmptyT\n  | i < sbc     = b :*: Single c\n  | otherwise   = a :*: Deep sbc (One b) EmptyT (One c)\n  where\n    sc      = size c\n    sbc     = sc + size b\ntakeSuffixNR i (Four a b c d)\n  | i < sd      = d :*: EmptyT\n  | i < scd     = c :*: Single d\n  | i < sbcd    = b :*: Deep scd (One c) EmptyT (One d)\n  | otherwise   = a :*: Deep sbcd (Two b c) EmptyT (One d)\n  where\n    sd      = size d\n    scd     = sd + size c\n    sbcd    = scd + size b\n\ntakePrefixER :: Int -> Int -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) ->\n   FingerTree (Elem a)\ntakePrefixER !_i !s (One _) m sf = pullL (s - 1) m sf\ntakePrefixER i s (Two _ b) m sf\n  | i < 1      = pullL (s - 2) m sf\n  | otherwise  = Deep (s - 1) (One b) m sf\ntakePrefixER i s (Three _ b c) m sf\n  | i < 1      = pullL (s - 3) m sf\n  | i < 2      = Deep (s - 2) (One c) m sf\n  | otherwise  = Deep (s - 1) (Two b c) m sf\ntakePrefixER i s (Four _ b c d) m sf\n  | i < 1      = pullL (s - 4) m sf\n  | i < 2      = Deep (s - 3) (One d) m sf\n  | i < 3      = Deep (s - 2) (Two c d) m sf\n  | otherwise  = Deep (s - 1) (Three b c d) m sf\n\ntakePrefixNR :: Int -> Int -> Digit (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a) ->\n   StrictPair (Node a) (FingerTree (Node a))\ntakePrefixNR !_i !s (One a) m sf = a :*: pullL (s - size a) m sf\ntakePrefixNR i s (Two a b) m sf\n  | i < sb      = b :*: pullL (s - sb - size a) m sf\n  | otherwise   = a :*: Deep (s - size a) (One b) m sf\n  where\n    sb      = size b\ntakePrefixNR i s (Three a b c) m sf\n  | i < sc      = c :*: pullL (s - sbc - size a) m sf\n  | i < sbc     = b :*: Deep (s - size b - size a) (One c) m sf\n  | otherwise   = a :*: Deep (s - size a) (Two b c) m sf\n  where\n    sc      = size c\n    sbc     = sc + size b\ntakePrefixNR i s (Four a b c d) m sf\n  | i < sd      = d :*: pullL (s - sd - sabc) m sf\n  | i < scd     = c :*: Deep (s - sabc) (One d) m sf\n  | i < sbcd    = b :*: Deep (s - sab) (Two c d) m sf\n  | otherwise   = a :*: Deep (s - sa) (Three b c d) m sf\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n    sd      = size d\n    scd     = size c + sd\n    sbcd    = size b + scd\n\n-- | \\( O(\\log(\\min(i,n-i))) \\). Split a sequence at a given position.\n-- @\'splitAt\' i s = (\'take\' i s, \'drop\' i s)@.\nsplitAt                  :: Int -> Seq a -> (Seq a, Seq a)\nsplitAt i xs@(Seq t)\n  -- We use an unsigned comparison to make the common case\n  -- faster. This only works because our representation of\n  -- sizes as (signed) Ints gives us a free high bit to play\n  -- with. Note also that there\'s no sharing to lose in the\n  -- case that the length is 0.\n  | fromIntegral i - 1 < (fromIntegral (length xs) - 1 :: Word) =\n      case splitTreeE i t of\n        l :*: r -> (Seq l, Seq r)\n  | i <= 0 = (empty, xs)\n  | otherwise = (xs, empty)\n\n-- | \\( O(\\log(\\min(i,n-i))) \\) A version of \'splitAt\' that does not attempt to\n-- enhance sharing when the split point is less than or equal to 0, and that\n-- gives completely wrong answers when the split point is at least the length\n-- of the sequence, unless the sequence is a singleton. This is used to\n-- implement zipWith and chunksOf, which are extremely sensitive to the cost of\n-- splitting very short sequences. There is just enough of a speed increase to\n-- make this worth the trouble.\nuncheckedSplitAt :: Int -> Seq a -> (Seq a, Seq a)\nuncheckedSplitAt i (Seq xs) = case splitTreeE i xs of\n  l :*: r -> (Seq l, Seq r)\n\ndata Split a = Split !(FingerTree (Node a)) !(Node a) !(FingerTree (Node a))\n#ifdef TESTING\n    deriving Show\n#endif\n\nsplitTreeE :: Int -> FingerTree (Elem a) -> StrictPair (FingerTree (Elem a)) (FingerTree (Elem a))\nsplitTreeE !_i EmptyT = EmptyT :*: EmptyT\nsplitTreeE i t@(Single _)\n   | i <= 0 = EmptyT :*: t\n   | otherwise = t :*: EmptyT\nsplitTreeE i (Deep s pr m sf)\n  | i < spr     = splitPrefixE i s pr m sf\n  | i < spm     = case splitTreeN im m of\n            Split ml xs mr -> splitMiddleE (im - size ml) s spr pr ml xs mr sf\n  | otherwise   = splitSuffixE (i - spm) s pr m sf\n  where\n    spr     = size pr\n    spm     = spr + size m\n    im      = i - spr\n\nsplitTreeN :: Int -> FingerTree (Node a) -> Split a\nsplitTreeN !_i EmptyT = error "splitTreeN of empty tree"\nsplitTreeN _i (Single x) = Split EmptyT x EmptyT\nsplitTreeN i (Deep s pr m sf)\n  | i < spr     = splitPrefixN i s pr m sf\n  | i < spm     = case splitTreeN im m of\n            Split ml xs mr -> splitMiddleN (im - size ml) s spr pr ml xs mr sf\n  | otherwise   = splitSuffixN (i - spm) s pr m sf  where\n    spr     = size pr\n    spm     = spr + size m\n    im      = i - spr\n\nsplitMiddleN :: Int -> Int -> Int\n             -> Digit (Node a) -> FingerTree (Node (Node a)) -> Node (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a)\n             -> Split a\nsplitMiddleN i s spr pr ml (Node2 _ a b) mr sf\n  | i < sa      = Split (pullR sprml pr ml) a (Deep (s - sprmla) (One b) mr sf)\n  | otherwise   = Split (Deep sprmla pr ml (One a)) b (pullL (s - sprmla - size b) mr sf)\n  where\n    sa      = size a\n    sprml   = spr + size ml\n    sprmla  = sa + sprml\nsplitMiddleN i s spr pr ml (Node3 _ a b c) mr sf\n  | i < sa      = Split (pullR sprml pr ml) a (Deep (s - sprmla) (Two b c) mr sf)\n  | i < sab     = Split (Deep sprmla pr ml (One a)) b (Deep (s - sprmlab) (One c) mr sf)\n  | otherwise   = Split (Deep sprmlab pr ml (Two a b)) c (pullL (s - sprmlab - size c) mr sf)\n  where\n    sa      = size a\n    sab     = sa + size b\n    sprml   = spr + size ml\n    sprmla  = sa + sprml\n    sprmlab = sprmla + size b\n\nsplitMiddleE :: Int -> Int -> Int\n             -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Node (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a)\n             -> StrictPair (FingerTree (Elem a)) (FingerTree (Elem a))\nsplitMiddleE i s spr pr ml (Node2 _ a b) mr sf\n  | i < 1       = pullR sprml pr ml :*: Deep (s - sprml) (Two a b) mr sf\n  | otherwise   = Deep sprmla pr ml (One a) :*: Deep (s - sprmla) (One b) mr sf\n  where\n    sprml   = spr + size ml\n    sprmla  = 1 + sprml\nsplitMiddleE i s spr pr ml (Node3 _ a b c) mr sf = case i of\n  0 -> pullR sprml pr ml :*: Deep (s - sprml) (Three a b c) mr sf\n  1 -> Deep sprmla pr ml (One a) :*: Deep (s - sprmla) (Two b c) mr sf\n  _ -> Deep sprmlab pr ml (Two a b) :*: Deep (s - sprmlab) (One c) mr sf\n  where\n    sprml   = spr + size ml\n    sprmla  = 1 + sprml\n    sprmlab = sprmla + 1\n\nsplitPrefixE :: Int -> Int -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) ->\n                    StrictPair (FingerTree (Elem a)) (FingerTree (Elem a))\nsplitPrefixE !_i !s (One a) m sf = EmptyT :*: Deep s (One a) m sf\nsplitPrefixE i s (Two a b) m sf = case i of\n  0 -> EmptyT :*: Deep s (Two a b) m sf\n  _ -> Single a :*: Deep (s - 1) (One b) m sf\nsplitPrefixE i s (Three a b c) m sf = case i of\n  0 -> EmptyT :*: Deep s (Three a b c) m sf\n  1 -> Single a :*: Deep (s - 1) (Two b c) m sf\n  _ -> Deep 2 (One a) EmptyT (One b) :*: Deep (s - 2) (One c) m sf\nsplitPrefixE i s (Four a b c d) m sf = case i of\n  0 -> EmptyT :*: Deep s (Four a b c d) m sf\n  1 -> Single a :*: Deep (s - 1) (Three b c d) m sf\n  2 -> Deep 2 (One a) EmptyT (One b) :*: Deep (s - 2) (Two c d) m sf\n  _ -> Deep 3 (Two a b) EmptyT (One c) :*: Deep (s - 3) (One d) m sf\n\nsplitPrefixN :: Int -> Int -> Digit (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a) ->\n                    Split a\nsplitPrefixN !_i !s (One a) m sf = Split EmptyT a (pullL (s - size a) m sf)\nsplitPrefixN i s (Two a b) m sf\n  | i < sa      = Split EmptyT a (Deep (s - sa) (One b) m sf)\n  | otherwise   = Split (Single a) b (pullL (s - sa - size b) m sf)\n  where\n    sa      = size a\nsplitPrefixN i s (Three a b c) m sf\n  | i < sa      = Split EmptyT a (Deep (s - sa) (Two b c) m sf)\n  | i < sab     = Split (Single a) b (Deep (s - sab) (One c) m sf)\n  | otherwise   = Split (Deep sab (One a) EmptyT (One b)) c (pullL (s - sab - size c) m sf)\n  where\n    sa      = size a\n    sab     = sa + size b\nsplitPrefixN i s (Four a b c d) m sf\n  | i < sa      = Split EmptyT a $ Deep (s - sa) (Three b c d) m sf\n  | i < sab     = Split (Single a) b $ Deep (s - sab) (Two c d) m sf\n  | i < sabc    = Split (Deep sab (One a) EmptyT (One b)) c $ Deep (s - sabc) (One d) m sf\n  | otherwise   = Split (Deep sabc (Two a b) EmptyT (One c)) d $ pullL (s - sabc - size d) m sf\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n\nsplitSuffixE :: Int -> Int -> Digit (Elem a) -> FingerTree (Node (Elem a)) -> Digit (Elem a) ->\n   StrictPair (FingerTree (Elem a)) (FingerTree (Elem a))\nsplitSuffixE !_i !s pr m (One a) = pullR (s - 1) pr m :*: Single a\nsplitSuffixE i s pr m (Two a b) = case i of\n  0 -> pullR (s - 2) pr m :*: Deep 2 (One a) EmptyT (One b)\n  _ -> Deep (s - 1) pr m (One a) :*: Single b\nsplitSuffixE i s pr m (Three a b c) = case i of\n  0 -> pullR (s - 3) pr m :*: Deep 3 (Two a b) EmptyT (One c)\n  1 -> Deep (s - 2) pr m (One a) :*: Deep 2 (One b) EmptyT (One c)\n  _ -> Deep (s - 1) pr m (Two a b) :*: Single c\nsplitSuffixE i s pr m (Four a b c d) = case i of\n  0 -> pullR (s - 4) pr m :*: Deep 4 (Two a b) EmptyT (Two c d)\n  1 -> Deep (s - 3) pr m (One a) :*: Deep 3 (Two b c) EmptyT (One d)\n  2 -> Deep (s - 2) pr m (Two a b) :*: Deep 2 (One c) EmptyT (One d)\n  _ -> Deep (s - 1) pr m (Three a b c) :*: Single d\n\nsplitSuffixN :: Int -> Int -> Digit (Node a) -> FingerTree (Node (Node a)) -> Digit (Node a) ->\n   Split a\nsplitSuffixN !_i !s pr m (One a) = Split (pullR (s - size a) pr m) a EmptyT\nsplitSuffixN i s pr m (Two a b)\n  | i < sa      = Split (pullR (s - sa - size b) pr m) a (Single b)\n  | otherwise   = Split (Deep (s - size b) pr m (One a)) b EmptyT\n  where\n    sa      = size a\nsplitSuffixN i s pr m (Three a b c)\n  | i < sa      = Split (pullR (s - sab - size c) pr m) a (deep (One b) EmptyT (One c))\n  | i < sab     = Split (Deep (s - size b - size c) pr m (One a)) b (Single c)\n  | otherwise   = Split (Deep (s - size c) pr m (Two a b)) c EmptyT\n  where\n    sa      = size a\n    sab     = sa + size b\nsplitSuffixN i s pr m (Four a b c d)\n  | i < sa      = Split (pullR (s - sa - sbcd) pr m) a (Deep sbcd (Two b c) EmptyT (One d))\n  | i < sab     = Split (Deep (s - sbcd) pr m (One a)) b (Deep scd (One c) EmptyT (One d))\n  | i < sabc    = Split (Deep (s - scd) pr m (Two a b)) c (Single d)\n  | otherwise   = Split (Deep (s - sd) pr m (Three a b c)) d EmptyT\n  where\n    sa      = size a\n    sab     = sa + size b\n    sabc    = sab + size c\n    sd      = size d\n    scd     = size c + sd\n    sbcd    = size b + scd\n\n-- | \\(O \\Bigl(\\bigl(\\frac{n}{c}\\bigr) \\log c\\Bigr)\\). @chunksOf c xs@ splits @xs@ into chunks of size @c>0@.\n-- If @c@ does not divide the length of @xs@ evenly, then the last element\n-- of the result will be short.\n--\n-- Side note: the given performance bound is missing some messy terms that only\n-- really affect edge cases. Performance degrades smoothly from \\( O(1) \\) (for\n-- \\( c = n \\)) to \\( O(n) \\) (for \\( c = 1 \\)). The true bound is more like\n-- \\( O \\Bigl( \\bigl(\\frac{n}{c} - 1\\bigr) (\\log (c + 1)) + 1 \\Bigr) \\)\n--\n-- @since 0.5.8\nchunksOf :: Int -> Seq a -> Seq (Seq a)\nchunksOf n xs | n <= 0 =\n  if null xs\n    then empty\n    else error "chunksOf: A non-empty sequence can only be broken up into positively-sized chunks."\nchunksOf 1 s = fmap singleton s\nchunksOf n s = splitMap (uncheckedSplitAt . (*n)) const most (replicate numReps ())\n                 >< if null end then empty else singleton end\n  where\n    (numReps, endLength) = length s `quotRem` n\n    (most, end) = splitAt (length s - endLength) s\n\n-- | \\( O(n) \\).  Returns a sequence of all suffixes of this sequence,\n-- longest first.  For example,\n--\n-- > tails (fromList "abc") = fromList [fromList "abc", fromList "bc", fromList "c", fromList ""]\n--\n-- Evaluating the \\( i \\)th suffix takes \\( O(\\log(\\min(i, n-i))) \\), but evaluating\n-- every suffix in the sequence takes \\( O(n) \\) due to sharing.\ntails                   :: Seq a -> Seq (Seq a)\ntails (Seq xs)          = Seq (tailsTree (Elem . Seq) xs) |> empty\n\n-- | \\( O(n) \\).  Returns a sequence of all prefixes of this sequence,\n-- shortest first.  For example,\n--\n-- > inits (fromList "abc") = fromList [fromList "", fromList "a", fromList "ab", fromList "abc"]\n--\n-- Evaluating the \\( i \\)th prefix takes \\( O(\\log(\\min(i, n-i))) \\), but evaluating\n-- every prefix in the sequence takes \\( O(n) \\) due to sharing.\ninits                   :: Seq a -> Seq (Seq a)\ninits (Seq xs)          = empty <| Seq (initsTree (Elem . Seq) xs)\n\n-- This implementation of tails (and, analogously, inits) has the\n-- following algorithmic advantages:\n--      Evaluating each tail in the sequence takes linear total time,\n--      which is better than we could say for\n--              @fromList [drop n xs | n <- [0..length xs]]@.\n--      Evaluating any individual tail takes logarithmic time, which is\n--      better than we can say for either\n--              @scanr (<|) empty xs@ or @iterateN (length xs + 1) (\\ xs -> let _ :< xs\' = viewl xs in xs\') xs@.\n--\n-- Moreover, if we actually look at every tail in the sequence, the\n-- following benchmarks demonstrate that this implementation is modestly\n-- faster than any of the above:\n--\n-- Times (ms)\n--               min      mean    +/-sd    median    max\n-- Seq.tails:   21.986   24.961   10.169   22.417   86.485\n-- scanr:       85.392   87.942    2.488   87.425  100.217\n-- iterateN:       29.952   31.245    1.574   30.412   37.268\n--\n-- The algorithm for tails (and, analogously, inits) is as follows:\n--\n-- A Node in the FingerTree of tails is constructed by evaluating the\n-- corresponding tail of the FingerTree of Nodes, considering the first\n-- Node in this tail, and constructing a Node in which each tail of this\n-- Node is made to be the prefix of the remaining tree.  This ends up\n-- working quite elegantly, as the remainder of the tail of the FingerTree\n-- of Nodes becomes the middle of a new tail, the suffix of the Node is\n-- the prefix, and the suffix of the original tree is retained.\n--\n-- In particular, evaluating the /i/th tail involves making as\n-- many partial evaluations as the Node depth of the /i/th element.\n-- In addition, when we evaluate the /i/th tail, and we also evaluate\n-- the /j/th tail, and /m/ Nodes are on the path to both /i/ and /j/,\n-- each of those /m/ evaluations are shared between the computation of\n-- the /i/th and /j/th tails.\n--\n-- wasserman.louis@gmail.com, 7/16/09\n\ntailsDigit :: Digit a -> Digit (Digit a)\ntailsDigit (One a) = One (One a)\ntailsDigit (Two a b) = Two (Two a b) (One b)\ntailsDigit (Three a b c) = Three (Three a b c) (Two b c) (One c)\ntailsDigit (Four a b c d) = Four (Four a b c d) (Three b c d) (Two c d) (One d)\n\ninitsDigit :: Digit a -> Digit (Digit a)\ninitsDigit (One a) = One (One a)\ninitsDigit (Two a b) = Two (One a) (Two a b)\ninitsDigit (Three a b c) = Three (One a) (Two a b) (Three a b c)\ninitsDigit (Four a b c d) = Four (One a) (Two a b) (Three a b c) (Four a b c d)\n\ntailsNode :: Node a -> Node (Digit a)\ntailsNode (Node2 s a b) = Node2 s (Two a b) (One b)\ntailsNode (Node3 s a b c) = Node3 s (Three a b c) (Two b c) (One c)\n\ninitsNode :: Node a -> Node (Digit a)\ninitsNode (Node2 s a b) = Node2 s (One a) (Two a b)\ninitsNode (Node3 s a b c) = Node3 s (One a) (Two a b) (Three a b c)\n\n{-# SPECIALIZE tailsTree :: (FingerTree (Elem a) -> Elem b) -> FingerTree (Elem a) -> FingerTree (Elem b) #-}\n{-# SPECIALIZE tailsTree :: (FingerTree (Node a) -> Node b) -> FingerTree (Node a) -> FingerTree (Node b) #-}\n-- | Given a function to apply to tails of a tree, applies that function\n-- to every tail of the specified tree.\ntailsTree :: Sized a => (FingerTree a -> b) -> FingerTree a -> FingerTree b\ntailsTree _ EmptyT = EmptyT\ntailsTree f (Single x) = Single (f (Single x))\ntailsTree f (Deep n pr m sf) =\n    Deep n (fmap (\\ pr\' -> f (deep pr\' m sf)) (tailsDigit pr))\n        (tailsTree f\' m)\n        (fmap (f . digitToTree) (tailsDigit sf))\n  where\n    f\' ms = let ConsLTree node m\' = viewLTree ms in\n        fmap (\\ pr\' -> f (deep pr\' m\' sf)) (tailsNode node)\n\n{-# SPECIALIZE initsTree :: (FingerTree (Elem a) -> Elem b) -> FingerTree (Elem a) -> FingerTree (Elem b) #-}\n{-# SPECIALIZE initsTree :: (FingerTree (Node a) -> Node b) -> FingerTree (Node a) -> FingerTree (Node b) #-}\n-- | Given a function to apply to inits of a tree, applies that function\n-- to every init of the specified tree.\ninitsTree :: Sized a => (FingerTree a -> b) -> FingerTree a -> FingerTree b\ninitsTree _ EmptyT = EmptyT\ninitsTree f (Single x) = Single (f (Single x))\ninitsTree f (Deep n pr m sf) =\n    Deep n (fmap (f . digitToTree) (initsDigit pr))\n        (initsTree f\' m)\n        (fmap (f . deep pr m) (initsDigit sf))\n  where\n    f\' ms =  let SnocRTree m\' node = viewRTree ms in\n             fmap (\\ sf\' -> f (deep pr m\' sf\')) (initsNode node)\n\n{-# INLINE foldlWithIndex #-}\n-- | \'foldlWithIndex\' is a version of \'foldl\' that also provides access\n-- to the index of each element.\nfoldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b\nfoldlWithIndex f z xs = foldl (\\ g x !i -> f (g (i - 1)) i x) (const z) xs (length xs - 1)\n\n{-# INLINE foldrWithIndex #-}\n-- | \'foldrWithIndex\' is a version of \'foldr\' that also provides access\n-- to the index of each element.\nfoldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b\nfoldrWithIndex f z xs = foldr (\\ x g !i -> f i x (g (i+1))) (const z) xs 0\n\n{-# INLINE listToMaybe\' #-}\n-- \'listToMaybe\\\'\' is a good consumer version of \'listToMaybe\'.\nlistToMaybe\' :: [a] -> Maybe a\nlistToMaybe\' = foldr (\\ x _ -> Just x) Nothing\n\n-- | \\( O(i) \\) where \\( i \\) is the prefix length. \'takeWhileL\', applied\n-- to a predicate @p@ and a sequence @xs@, returns the longest prefix\n-- (possibly empty) of @xs@ of elements that satisfy @p@.\ntakeWhileL :: (a -> Bool) -> Seq a -> Seq a\ntakeWhileL p = fst . spanl p\n\n-- | \\( O(i) \\) where \\( i \\) is the suffix length.  \'takeWhileR\', applied\n-- to a predicate @p@ and a sequence @xs@, returns the longest suffix\n-- (possibly empty) of @xs@ of elements that satisfy @p@.\n--\n-- @\'takeWhileR\' p xs@ is equivalent to @\'reverse\' (\'takeWhileL\' p (\'reverse\' xs))@.\ntakeWhileR :: (a -> Bool) -> Seq a -> Seq a\ntakeWhileR p = fst . spanr p\n\n-- | \\( O(i) \\) where \\( i \\) is the prefix length.  @\'dropWhileL\' p xs@ returns\n-- the suffix remaining after @\'takeWhileL\' p xs@.\ndropWhileL :: (a -> Bool) -> Seq a -> Seq a\ndropWhileL p = snd . spanl p\n\n-- | \\( O(i) \\) where \\( i \\) is the suffix length.  @\'dropWhileR\' p xs@ returns\n-- the prefix remaining after @\'takeWhileR\' p xs@.\n--\n-- @\'dropWhileR\' p xs@ is equivalent to @\'reverse\' (\'dropWhileL\' p (\'reverse\' xs))@.\ndropWhileR :: (a -> Bool) -> Seq a -> Seq a\ndropWhileR p = snd . spanr p\n\n-- | \\( O(i) \\) where \\( i \\) is the prefix length.  \'spanl\', applied to\n-- a predicate @p@ and a sequence @xs@, returns a pair whose first\n-- element is the longest prefix (possibly empty) of @xs@ of elements that\n-- satisfy @p@ and the second element is the remainder of the sequence.\nspanl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\nspanl p = breakl (not . p)\n\n-- | \\( O(i) \\) where \\( i \\) is the suffix length.  \'spanr\', applied to a\n-- predicate @p@ and a sequence @xs@, returns a pair whose /first/ element\n-- is the longest /suffix/ (possibly empty) of @xs@ of elements that\n-- satisfy @p@ and the second element is the remainder of the sequence.\nspanr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\nspanr p = breakr (not . p)\n\n{-# INLINE breakl #-}\n-- | \\( O(i) \\) where \\( i \\) is the breakpoint index.  \'breakl\', applied to a\n-- predicate @p@ and a sequence @xs@, returns a pair whose first element\n-- is the longest prefix (possibly empty) of @xs@ of elements that\n-- /do not satisfy/ @p@ and the second element is the remainder of\n-- the sequence.\n--\n-- @\'breakl\' p@ is equivalent to @\'spanl\' (not . p)@.\nbreakl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\nbreakl p xs = foldr (\\ i _ -> splitAt i xs) (xs, empty) (findIndicesL p xs)\n\n{-# INLINE breakr #-}\n-- | @\'breakr\' p@ is equivalent to @\'spanr\' (not . p)@.\nbreakr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\nbreakr p xs = foldr (\\ i _ -> flipPair (splitAt (i + 1) xs)) (xs, empty) (findIndicesR p xs)\n  where flipPair (x, y) = (y, x)\n\n-- | \\( O(n) \\).  The \'partition\' function takes a predicate @p@ and a\n-- sequence @xs@ and returns sequences of those elements which do and\n-- do not satisfy the predicate.\npartition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)\npartition p = toPair . foldl\' part (empty :*: empty)\n  where\n    part (xs :*: ys) x\n      | p x         = (xs `snoc\'` x) :*: ys\n      | otherwise   = xs :*: (ys `snoc\'` x)\n\n-- | \\( O(n) \\).  The \'filter\' function takes a predicate @p@ and a sequence\n-- @xs@ and returns a sequence of those elements which satisfy the\n-- predicate.\nfilter :: (a -> Bool) -> Seq a -> Seq a\nfilter p = foldl\' (\\ xs x -> if p x then xs `snoc\'` x else xs) empty\n\n-- Indexing sequences\n\n-- | \'elemIndexL\' finds the leftmost index of the specified element,\n-- if it is present, and otherwise \'Nothing\'.\nelemIndexL :: Eq a => a -> Seq a -> Maybe Int\nelemIndexL x = findIndexL (x ==)\n\n-- | \'elemIndexR\' finds the rightmost index of the specified element,\n-- if it is present, and otherwise \'Nothing\'.\nelemIndexR :: Eq a => a -> Seq a -> Maybe Int\nelemIndexR x = findIndexR (x ==)\n\n-- | \'elemIndicesL\' finds the indices of the specified element, from\n-- left to right (i.e. in ascending order).\nelemIndicesL :: Eq a => a -> Seq a -> [Int]\nelemIndicesL x = findIndicesL (x ==)\n\n-- | \'elemIndicesR\' finds the indices of the specified element, from\n-- right to left (i.e. in descending order).\nelemIndicesR :: Eq a => a -> Seq a -> [Int]\nelemIndicesR x = findIndicesR (x ==)\n\n-- | @\'findIndexL\' p xs@ finds the index of the leftmost element that\n-- satisfies @p@, if any exist.\nfindIndexL :: (a -> Bool) -> Seq a -> Maybe Int\nfindIndexL p = listToMaybe\' . findIndicesL p\n\n-- | @\'findIndexR\' p xs@ finds the index of the rightmost element that\n-- satisfies @p@, if any exist.\nfindIndexR :: (a -> Bool) -> Seq a -> Maybe Int\nfindIndexR p = listToMaybe\' . findIndicesR p\n\n{-# INLINE findIndicesL #-}\n-- | @\'findIndicesL\' p@ finds all indices of elements that satisfy @p@,\n-- in ascending order.\nfindIndicesL :: (a -> Bool) -> Seq a -> [Int]\n#if __GLASGOW_HASKELL__\nfindIndicesL p xs = build (\\ c n -> let g i x z = if p x then c i z else z in\n                foldrWithIndex g n xs)\n#else\nfindIndicesL p xs = foldrWithIndex g [] xs\n  where g i x is = if p x then i:is else is\n#endif\n\n{-# INLINE findIndicesR #-}\n-- | @\'findIndicesR\' p@ finds all indices of elements that satisfy @p@,\n-- in descending order.\nfindIndicesR :: (a -> Bool) -> Seq a -> [Int]\n#if __GLASGOW_HASKELL__\nfindIndicesR p xs = build (\\ c n ->\n    let g z i x = if p x then c i z else z in foldlWithIndex g n xs)\n#else\nfindIndicesR p xs = foldlWithIndex g [] xs\n  where g is i x = if p x then i:is else is\n#endif\n\n------------------------------------------------------------------------\n-- Lists\n------------------------------------------------------------------------\n\n-- The implementation below is based on an idea by Ross Paterson and\n-- implemented by Lennart Spitzner. It avoids the rebuilding the original\n-- (|>)-based implementation suffered from. It also avoids the excessive pair\n-- allocations Paterson\'s implementation suffered from.\n--\n-- David Feuer suggested building in nine-element chunks, which reduces\n-- intermediate conses from around (1/2)*n to around (1/8)*n with a concomitant\n-- improvement in benchmark constant factors. In fact, it should be even\n-- better to work in chunks of 27 `Elem`s and chunks of three `Node`s, rather\n-- than nine of each, but it seems hard to avoid a code explosion with\n-- such large chunks.\n--\n-- Paterson\'s code can be seen, for example, in\n-- https://github.com/haskell/containers/blob/74034b3244fa4817c7bef1202e639b887a975d9e/Data/Sequence.hs#L3532\n--\n-- Given a list\n--\n-- [1..302]\n--\n-- the original code forms Three 1 2 3 | [node3 4 5 6, node3 7 8 9, node3 10 11\n-- 12, ...] | Two 301 302\n--\n-- Then it recurses on the middle list. The middle lists become successively\n-- shorter as their elements become successively deeper nodes.\n--\n-- The original implementation of the list shortener, getNodes, included the\n-- recursive step\n\n--     getNodes s x1 (x2:x3:x4:xs) = (Node3 s x1 x2 x3:ns, d)\n--            where (ns, d) = getNodes s x4 xs\n\n-- This allocates a cons and a lazy pair at each 3-element step. It relies on\n-- the Haskell implementation using Wadler\'s technique, described in "Fixing\n-- some space leaks with a garbage collector"\n-- http://homepages.inf.ed.ac.uk/wadler/papers/leak/leak.ps.gz, to repeatedly\n-- simplify the `d` thunk. Although GHC uses this GC trick, heap profiling at\n-- least appears to indicate that the pair constructors and conses build up\n-- with this implementation.\n--\n-- Spitzner\'s implementation uses a similar approach, but replaces the middle\n-- list, in each level, with a customized stream type that finishes off with\n-- the final digit in that level and (since it works in nines) in the one\n-- above. To work around the nested tree structure, the overall computation is\n-- structured using continuation-passing style, with a function that, at the\n-- bottom of the tree, deals with a stream that terminates in a nested-pair\n-- representation of the entire right side of the tree. Perhaps someone will\n-- eventually find a less mind-bending way to accomplish this.\n\n-- | \\( O(n) \\). Create a sequence from a finite list of elements.\n-- There is a function \'toList\' in the opposite direction for all\n-- instances of the \'Foldable\' class, including \'Seq\'.\nfromList        :: [a] -> Seq a\n-- Note: we can avoid map_elem if we wish by scattering\n-- Elem applications throughout mkTreeE and getNodesE, but\n-- it gets a bit hard to read.\nfromList = Seq . mkTree . map_elem\n  where\n#ifdef __GLASGOW_HASKELL__\n    mkTree :: forall a\' . [Elem a\'] -> FingerTree (Elem a\')\n#else\n    mkTree :: [Elem a] -> FingerTree (Elem a)\n#endif\n    mkTree [] = EmptyT\n    mkTree [x1] = Single x1\n    mkTree [x1, x2] = Deep 2 (One x1) EmptyT (One x2)\n    mkTree [x1, x2, x3] = Deep 3 (Two x1 x2) EmptyT (One x3)\n    mkTree [x1, x2, x3, x4] = Deep 4 (Two x1 x2) EmptyT (Two x3 x4)\n    mkTree [x1, x2, x3, x4, x5] = Deep 5 (Three x1 x2 x3) EmptyT (Two x4 x5)\n    mkTree [x1, x2, x3, x4, x5, x6] =\n      Deep 6 (Three x1 x2 x3) EmptyT (Three x4 x5 x6)\n    mkTree [x1, x2, x3, x4, x5, x6, x7] =\n      Deep 7 (Two x1 x2) (Single (Node3 3 x3 x4 x5)) (Two x6 x7)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8] =\n      Deep 8 (Three x1 x2 x3) (Single (Node3 3 x4 x5 x6)) (Two x7 x8)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, x9] =\n      Deep 9 (Three x1 x2 x3) (Single (Node3 3 x4 x5 x6)) (Three x7 x8 x9)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, y0, y1] =\n      Deep 10 (Two x1 x2)\n              (Deep 6 (One (Node3 3 x3 x4 x5)) EmptyT (One (Node3 3 x6 x7 x8)))\n              (Two y0 y1)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, x9, y0, y1] =\n      Deep 11 (Three x1 x2 x3)\n              (Deep 6 (One (Node3 3 x4 x5 x6)) EmptyT (One (Node3 3 x7 x8 x9)))\n              (Two y0 y1)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, x9, y0, y1, y2] =\n      Deep 12 (Three x1 x2 x3)\n              (Deep 6 (One (Node3 3 x4 x5 x6)) EmptyT (One (Node3 3 x7 x8 x9)))\n              (Three y0 y1 y2)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, y0, y1, y2, y3, y4] =\n      Deep 13 (Two x1 x2)\n              (Deep 9 (Two (Node3 3 x3 x4 x5) (Node3 3 x6 x7 x8)) EmptyT (One (Node3 3 y0 y1 y2)))\n              (Two y3 y4)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, x9, y0, y1, y2, y3, y4] =\n      Deep 14 (Three x1 x2 x3)\n              (Deep 9 (Two (Node3 3 x4 x5 x6) (Node3 3 x7 x8 x9)) EmptyT (One (Node3 3 y0 y1 y2)))\n              (Two y3 y4)\n    mkTree [x1, x2, x3, x4, x5, x6, x7, x8, x9, y0, y1, y2, y3, y4, y5] =\n      Deep 15 (Three x1 x2 x3)\n              (Deep 9 (Two (Node3 3 x4 x5 x6) (Node3 3 x7 x8 x9)) EmptyT (One (Node3 3 y0 y1 y2)))\n              (Three y3 y4 y5)\n    mkTree (x1:x2:x3:x4:x5:x6:x7:x8:x9:y0:y1:y2:y3:y4:y5:y6:xs) =\n        mkTreeC cont 9 (getNodes 3 (Node3 3 y3 y4 y5) y6 xs)\n      where\n        d2 = Three x1 x2 x3\n        d1 = Three (Node3 3 x4 x5 x6) (Node3 3 x7 x8 x9) (Node3 3 y0 y1 y2)\n#ifdef __GLASGOW_HASKELL__\n        cont :: (Digit (Node (Elem a\')), Digit (Elem a\')) -> FingerTree (Node (Node (Elem a\'))) -> FingerTree (Elem a\')\n#endif\n        cont (!r1, !r2) !sub =\n          let !sub1 = Deep (9 + size r1 + size sub) d1 sub r1\n          in Deep (3 + size r2 + size sub1) d2 sub1 r2\n\n    getNodes :: forall a . Int\n             -> Node a\n             -> a\n             -> [a]\n             -> ListFinal (Node (Node a)) (Digit (Node a), Digit a)\n    getNodes !_ n1 x1 [] = LFinal (One n1, One x1)\n    getNodes _ n1 x1 [x2] = LFinal (One n1, Two x1 x2)\n    getNodes _ n1 x1 [x2, x3] = LFinal (One n1, Three x1 x2 x3)\n    getNodes s n1 x1 [x2, x3, x4] = LFinal (Two n1 (Node3 s x1 x2 x3), One x4)\n    getNodes s n1 x1 [x2, x3, x4, x5] = LFinal (Two n1 (Node3 s x1 x2 x3), Two x4 x5)\n    getNodes s n1 x1 [x2, x3, x4, x5, x6] = LFinal (Two n1 (Node3 s x1 x2 x3), Three x4 x5 x6)\n    getNodes s n1 x1 [x2, x3, x4, x5, x6, x7] = LFinal (Three n1 (Node3 s x1 x2 x3) (Node3 s x4 x5 x6), One x7)\n    getNodes s n1 x1 [x2, x3, x4, x5, x6, x7, x8] = LFinal (Three n1 (Node3 s x1 x2 x3) (Node3 s x4 x5 x6), Two x7 x8)\n    getNodes s n1 x1 [x2, x3, x4, x5, x6, x7, x8, x9] = LFinal (Three n1 (Node3 s x1 x2 x3) (Node3 s x4 x5 x6), Three x7 x8 x9)\n    getNodes s n1 x1 (x2:x3:x4:x5:x6:x7:x8:x9:x10:xs) = LCons n10 (getNodes s (Node3 s x7 x8 x9) x10 xs)\n      where !n2 = Node3 s x1 x2 x3\n            !n3 = Node3 s x4 x5 x6\n            !n10 = Node3 (3*s) n1 n2 n3\n\n    mkTreeC ::\n#ifdef __GLASGOW_HASKELL__\n               forall a b c .\n#endif\n               (b -> FingerTree (Node a) -> c)\n            -> Int\n            -> ListFinal (Node a) b\n            -> c\n    mkTreeC cont !_ (LFinal b) =\n      cont b EmptyT\n    mkTreeC cont _ (LCons x1 (LFinal b)) =\n      cont b (Single x1)\n    mkTreeC cont s (LCons x1 (LCons x2 (LFinal b))) =\n      cont b (Deep (2*s) (One x1) EmptyT (One x2))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LFinal b)))) =\n      cont b (Deep (3*s) (Two x1 x2) EmptyT (One x3))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LFinal b))))) =\n      cont b (Deep (4*s) (Two x1 x2) EmptyT (Two x3 x4))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LFinal b)))))) =\n      cont b (Deep (5*s) (Three x1 x2 x3) EmptyT (Two x4 x5))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LFinal b))))))) =\n      cont b (Deep (6*s) (Three x1 x2 x3) EmptyT (Three x4 x5 x6))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LFinal b)))))))) =\n      cont b (Deep (7*s) (Two x1 x2) (Single (Node3 (3*s) x3 x4 x5)) (Two x6 x7))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LFinal b))))))))) =\n      cont b (Deep (8*s) (Three x1 x2 x3) (Single (Node3 (3*s) x4 x5 x6)) (Two x7 x8))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LFinal b)))))))))) =\n      cont b (Deep (9*s) (Three x1 x2 x3) (Single (Node3 (3*s) x4 x5 x6)) (Three x7 x8 x9))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons y0 (LCons y1 (LFinal b))))))))))) =\n      cont b (Deep (10*s) (Two x1 x2) (Deep (6*s) (One (Node3 (3*s) x3 x4 x5)) EmptyT (One (Node3 (3*s) x6 x7 x8))) (Two y0 y1))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LCons y0 (LCons y1 (LFinal b)))))))))))) =\n      cont b (Deep (11*s) (Three x1 x2 x3) (Deep (6*s) (One (Node3 (3*s) x4 x5 x6)) EmptyT (One (Node3 (3*s) x7 x8 x9))) (Two y0 y1))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LCons y0 (LCons y1 (LCons y2 (LFinal b))))))))))))) =\n      cont b (Deep (12*s) (Three x1 x2 x3) (Deep (6*s) (One (Node3 (3*s) x4 x5 x6)) EmptyT (One (Node3 (3*s) x7 x8 x9))) (Three y0 y1 y2))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons y0 (LCons y1 (LCons y2 (LCons y3 (LCons y4 (LFinal b)))))))))))))) =\n      cont b (Deep (13*s) (Two x1 x2) (Deep (9*s) (Two (Node3 (3*s) x3 x4 x5) (Node3 (3*s) x6 x7 x8)) EmptyT (One (Node3 (3*s) y0 y1 y2))) (Two y3 y4))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LCons y0 (LCons y1 (LCons y2 (LCons y3 (LCons y4 (LFinal b))))))))))))))) =\n      cont b (Deep (14*s) (Three x1 x2 x3) (Deep (9*s) (Two (Node3 (3*s) x4 x5 x6) (Node3 (3*s) x7 x8 x9)) EmptyT (One (Node3 (3*s) y0 y1 y2))) (Two y3 y4))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LCons y0 (LCons y1 (LCons y2 (LCons y3 (LCons y4 (LCons y5 (LFinal b)))))))))))))))) =\n      cont b (Deep (15*s) (Three x1 x2 x3) (Deep (9*s) (Two (Node3 (3*s) x4 x5 x6) (Node3 (3*s) x7 x8 x9)) EmptyT (One (Node3 (3*s) y0 y1 y2))) (Three y3 y4 y5))\n    mkTreeC cont s (LCons x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LCons y0 (LCons y1 (LCons y2 (LCons y3 (LCons y4 (LCons y5 (LCons y6 xs)))))))))))))))) =\n      mkTreeC cont2 (9*s) (getNodesC (3*s) (Node3 (3*s) y3 y4 y5) y6 xs)\n      where\n#ifdef __GLASGOW_HASKELL__\n        cont2 :: (b, Digit (Node (Node a)), Digit (Node a)) -> FingerTree (Node (Node (Node a))) -> c\n#endif\n        cont2 (b, r1, r2) !sub =\n          let d2 = Three x1 x2 x3\n              d1 = Three (Node3 (3*s) x4 x5 x6) (Node3 (3*s) x7 x8 x9) (Node3 (3*s) y0 y1 y2)\n              !sub1 = Deep (9*s + size r1 + size sub) d1 sub r1\n          in cont b $! Deep (3*s + size r2 + size sub1) d2 sub1 r2\n\n    getNodesC :: Int\n              -> Node a\n              -> a\n              -> ListFinal a b\n              -> ListFinal (Node (Node a)) (b, Digit (Node a), Digit a)\n    getNodesC !_ n1 x1 (LFinal b) = LFinal $ (b, One n1, One x1)\n    getNodesC _  n1  x1 (LCons x2 (LFinal b)) = LFinal $ (b, One n1, Two x1 x2)\n    getNodesC _  n1  x1 (LCons x2 (LCons x3 (LFinal b))) = LFinal $ (b, One n1, Three x1 x2 x3)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LFinal b)))) =\n      let !n2 = Node3 s x1 x2 x3\n      in LFinal $ (b, Two n1 n2, One x4)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LFinal b))))) =\n      let !n2 = Node3 s x1 x2 x3\n      in LFinal $ (b, Two n1 n2, Two x4 x5)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LFinal b)))))) =\n      let !n2 = Node3 s x1 x2 x3\n      in LFinal $ (b, Two n1 n2, Three x4 x5 x6)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LFinal b))))))) =\n      let !n2 = Node3 s x1 x2 x3\n          !n3 = Node3 s x4 x5 x6\n      in LFinal $ (b, Three n1 n2 n3, One x7)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LFinal b)))))))) =\n      let !n2 = Node3 s x1 x2 x3\n          !n3 = Node3 s x4 x5 x6\n      in LFinal $ (b, Three n1 n2 n3, Two x7 x8)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LFinal b))))))))) =\n      let !n2 = Node3 s x1 x2 x3\n          !n3 = Node3 s x4 x5 x6\n      in LFinal $ (b, Three n1 n2 n3, Three x7 x8 x9)\n    getNodesC s  n1  x1 (LCons x2 (LCons x3 (LCons x4 (LCons x5 (LCons x6 (LCons x7 (LCons x8 (LCons x9 (LCons x10 xs))))))))) =\n        LCons n10 $ getNodesC s (Node3 s x7 x8 x9) x10 xs\n      where !n2 = Node3 s x1 x2 x3\n            !n3 = Node3 s x4 x5 x6\n            !n10 = Node3 (3*s) n1 n2 n3\n\n    map_elem :: [a] -> [Elem a]\n#ifdef __GLASGOW_HASKELL__\n    map_elem xs = coerce xs\n#else\n    map_elem xs = Data.List.map Elem xs\n#endif\n    {-# INLINE map_elem #-}\n\n-- essentially: Free ((,) a) b.\ndata ListFinal a cont = LFinal !cont | LCons !a (ListFinal a cont)\n\n#ifdef __GLASGOW_HASKELL__\ninstance GHC.Exts.IsList (Seq a) where\n    type Item (Seq a) = a\n    fromList = fromList\n    fromListN = fromList2\n    toList = toList\n#endif\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.5.7\ninstance a ~ Char => IsString (Seq a) where\n    fromString = fromList\n#endif\n\n------------------------------------------------------------------------\n-- Reverse\n------------------------------------------------------------------------\n\n-- | \\( O(n) \\). The reverse of a sequence.\nreverse :: Seq a -> Seq a\nreverse (Seq xs) = Seq (fmapReverseTree id xs)\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] reverse #-}\n\n-- | \\( O(n) \\). Reverse a sequence while mapping over it. This is not\n-- currently exported, but is used in rewrite rules.\nfmapReverse :: (a -> b) -> Seq a -> Seq b\nfmapReverse f (Seq xs) = Seq (fmapReverseTree (lift_elem f) xs)\n  where\n    lift_elem :: (a -> b) -> (Elem a -> Elem b)\n#ifdef __GLASGOW_HASKELL__\n    lift_elem = coerce\n#else\n    lift_elem g (Elem a) = Elem (g a)\n#endif\n\n-- If we\'re mapping over a sequence, we can reverse it at the same time\n-- at no extra charge.\n{-# RULES\n"fmapSeq/reverse" forall f xs . fmapSeq f (reverse xs) = fmapReverse f xs\n"reverse/fmapSeq" forall f xs . reverse (fmapSeq f xs) = fmapReverse f xs\n #-}\n#endif\n\nfmapReverseTree :: (a -> b) -> FingerTree a -> FingerTree b\nfmapReverseTree _ EmptyT = EmptyT\nfmapReverseTree f (Single x) = Single (f x)\nfmapReverseTree f (Deep s pr m sf) =\n    Deep s (reverseDigit f sf)\n        (fmapReverseTree (reverseNode f) m)\n        (reverseDigit f pr)\n\n{-# INLINE reverseDigit #-}\nreverseDigit :: (a -> b) -> Digit a -> Digit b\nreverseDigit f (One a) = One (f a)\nreverseDigit f (Two a b) = Two (f b) (f a)\nreverseDigit f (Three a b c) = Three (f c) (f b) (f a)\nreverseDigit f (Four a b c d) = Four (f d) (f c) (f b) (f a)\n\nreverseNode :: (a -> b) -> Node a -> Node b\nreverseNode f (Node2 s a b) = Node2 s (f b) (f a)\nreverseNode f (Node3 s a b c) = Node3 s (f c) (f b) (f a)\n\n------------------------------------------------------------------------\n-- Mapping with a splittable value\n------------------------------------------------------------------------\n\n-- For zipping, it is useful to build a result by\n-- traversing a sequence while splitting up something else.  For zipping, we\n-- traverse the first sequence while splitting up the second.\n--\n-- What makes all this crazy code a good idea:\n--\n-- Suppose we zip together two sequences of the same length:\n--\n-- zs = zip xs ys\n--\n-- We want to get reasonably fast indexing into zs immediately, rather than\n-- needing to construct the entire thing first, as the previous implementation\n-- required. The first aspect is that we build the result "outside-in" or\n-- "top-down", rather than left to right. That gives us access to both ends\n-- quickly. But that\'s not enough, by itself, to give immediate access to the\n-- center of zs. For that, we need to be able to skip over larger segments of\n-- zs, delaying their construction until we actually need them. The way we do\n-- this is to traverse xs, while splitting up ys according to the structure of\n-- xs. If we have a Deep _ pr m sf, we split ys into three pieces, and hand off\n-- one piece to the prefix, one to the middle, and one to the suffix of the\n-- result. The key point is that we don\'t need to actually do anything further\n-- with those pieces until we actually need them; the computations to split\n-- them up further and zip them with their matching pieces can be delayed until\n-- they\'re actually needed. We do the same thing for Digits (splitting into\n-- between one and four pieces) and Nodes (splitting into two or three). The\n-- ultimate result is that we can index into, or split at, any location in zs\n-- in polylogarithmic time *immediately*, while still being able to force all\n-- the thunks in O(n) time.\n--\n-- Benchmark info, and alternatives:\n--\n-- The old zipping code used mapAccumL to traverse the first sequence while\n-- cutting down the second sequence one piece at a time.\n--\n-- An alternative way to express that basic idea is to convert both sequences\n-- to lists, zip the lists, and then convert the result back to a sequence.\n-- I\'ll call this the "listy" implementation.\n--\n-- I benchmarked two operations: Each started by zipping two sequences\n-- constructed with replicate and/or fromList. The first would then immediately\n-- index into the result. The second would apply deepseq to force the entire\n-- result.  The new implementation worked much better than either of the others\n-- on the immediate indexing test, as expected. It also worked better than the\n-- old implementation for all the deepseq tests. For short sequences, the listy\n-- implementation outperformed all the others on the deepseq test. However, the\n-- splitting implementation caught up and surpassed it once the sequences grew\n-- long enough. It seems likely that by avoiding rebuilding, it interacts\n-- better with the cache hierarchy.\n--\n-- David Feuer, with some guidance from Carter Schonwald, December 2014\n\n-- | \\( O(n) \\). Constructs a new sequence with the same structure as an existing\n-- sequence using a user-supplied mapping function along with a splittable\n-- value and a way to split it. The value is split up lazily according to the\n-- structure of the sequence, so one piece of the value is distributed to each\n-- element of the sequence. The caller should provide a splitter function that\n-- takes a number, @n@, and a splittable value, breaks off a chunk of size @n@\n-- from the value, and returns that chunk and the remainder as a pair. The\n-- following examples will hopefully make the usage clear:\n--\n-- > zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\n-- > zipWith f s1 s2 = splitMap splitAt (\\b a -> f a (b `index` 0)) s2\' s1\'\n-- >   where\n-- >     minLen = min (length s1) (length s2)\n-- >     s1\' = take minLen s1\n-- >     s2\' = take minLen s2\n--\n-- > mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b\n-- > mapWithIndex f = splitMap (\\n i -> (i, n+i)) f 0\n#ifdef __GLASGOW_HASKELL__\n-- We use ScopedTypeVariables to improve performance and make\n-- performance less sensitive to minor changes.\n\n-- We INLINE this so GHC can see that the function passed in is\n-- strict in its Int argument.\n{-# INLINE splitMap #-}\nsplitMap :: forall s a\' b\' . (Int -> s -> (s,s)) -> (s -> a\' -> b\') -> s -> Seq a\' -> Seq b\'\nsplitMap splt f0 s0 (Seq xs0) = Seq $ splitMapTreeE (\\s\' (Elem a) -> Elem (f0 s\' a)) s0 xs0\n  where\n    {-# INLINE splitMapTreeE #-}\n    splitMapTreeE :: (s -> Elem y -> b) -> s -> FingerTree (Elem y) -> FingerTree b\n    splitMapTreeE  _ _ EmptyT = EmptyT\n    splitMapTreeE  f s (Single xs) = Single $ f s xs\n    splitMapTreeE  f s (Deep n pr m sf) = Deep n (splitMapDigit f prs pr) (splitMapTreeN (\\eta1 eta2 -> splitMapNode f eta1 eta2) ms m) (splitMapDigit f sfs sf)\n          where\n            !spr = size pr\n            !sm = n - spr - size sf\n            (prs, r) = splt spr s\n            (ms, sfs) = splt sm r\n\n    splitMapTreeN :: (s -> Node a -> b) -> s -> FingerTree (Node a) -> FingerTree b\n    splitMapTreeN _ _ EmptyT = EmptyT\n    splitMapTreeN f s (Single xs) = Single $ f s xs\n    splitMapTreeN f s (Deep n pr m sf) = Deep n (splitMapDigit f prs pr) (splitMapTreeN (\\eta1 eta2 -> splitMapNode f eta1 eta2) ms m) (splitMapDigit f sfs sf)\n          where\n            (prs, r) = splt (size pr) s\n            (ms, sfs) = splt (size m) r\n\n    {-# INLINE splitMapDigit #-}\n    splitMapDigit :: Sized a => (s -> a -> b) -> s -> Digit a -> Digit b\n    splitMapDigit f s (One a) = One (f s a)\n    splitMapDigit f s (Two a b) = Two (f first a) (f second b)\n      where\n        (first, second) = splt (size a) s\n    splitMapDigit f s (Three a b c) = Three (f first a) (f second b) (f third c)\n      where\n        (first, r) = splt (size a) s\n        (second, third) = splt (size b) r\n    splitMapDigit f s (Four a b c d) = Four (f first a) (f second b) (f third c) (f fourth d)\n      where\n        (first, s\') = splt (size a) s\n        (middle, fourth) = splt (size b + size c) s\'\n        (second, third) = splt (size b) middle\n\n    {-# INLINE splitMapNode #-}\n    splitMapNode :: Sized a => (s -> a -> b) -> s -> Node a -> Node b\n    splitMapNode f s (Node2 ns a b) = Node2 ns (f first a) (f second b)\n      where\n        (first, second) = splt (size a) s\n    splitMapNode f s (Node3 ns a b c) = Node3 ns (f first a) (f second b) (f third c)\n      where\n        (first, r) = splt (size a) s\n        (second, third) = splt (size b) r\n\n#else\n-- Implementation without ScopedTypeVariables--somewhat slower,\n-- and much more sensitive to minor changes in various places.\n\n{-# INLINE splitMap #-}\nsplitMap :: (Int -> s -> (s,s)) -> (s -> a -> b) -> s -> Seq a -> Seq b\nsplitMap splt\' f0 s0 (Seq xs0) = Seq $ splitMapTreeE splt\' (\\s\' (Elem a) -> Elem (f0 s\' a)) s0 xs0\n\n{-# INLINE splitMapTreeE #-}\nsplitMapTreeE :: (Int -> s -> (s,s)) -> (s -> Elem y -> b) -> s -> FingerTree (Elem y) -> FingerTree b\nsplitMapTreeE _    _ _ EmptyT = EmptyT\nsplitMapTreeE _    f s (Single xs) = Single $ f s xs\nsplitMapTreeE splt f s (Deep n pr m sf) = Deep n (splitMapDigit splt f prs pr) (splitMapTreeN splt (\\eta1 eta2 -> splitMapNode splt f eta1 eta2) ms m) (splitMapDigit splt f sfs sf)\n      where\n        !spr = size pr\n        sm = n - spr - size sf\n        (prs, r) = splt spr s\n        (ms, sfs) = splt sm r\n\nsplitMapTreeN :: (Int -> s -> (s,s)) -> (s -> Node a -> b) -> s -> FingerTree (Node a) -> FingerTree b\nsplitMapTreeN _    _ _ EmptyT = EmptyT\nsplitMapTreeN _    f s (Single xs) = Single $ f s xs\nsplitMapTreeN splt f s (Deep n pr m sf) = Deep n (splitMapDigit splt f prs pr) (splitMapTreeN splt (\\eta1 eta2 -> splitMapNode splt f eta1 eta2) ms m) (splitMapDigit splt f sfs sf)\n      where\n        (prs, r) = splt (size pr) s\n        (ms, sfs) = splt (size m) r\n\n{-# INLINE splitMapDigit #-}\nsplitMapDigit :: Sized a => (Int -> s -> (s,s)) -> (s -> a -> b) -> s -> Digit a -> Digit b\nsplitMapDigit _    f s (One a) = One (f s a)\nsplitMapDigit splt f s (Two a b) = Two (f first a) (f second b)\n  where\n    (first, second) = splt (size a) s\nsplitMapDigit splt f s (Three a b c) = Three (f first a) (f second b) (f third c)\n  where\n    (first, r) = splt (size a) s\n    (second, third) = splt (size b) r\nsplitMapDigit splt f s (Four a b c d) = Four (f first a) (f second b) (f third c) (f fourth d)\n  where\n    (first, s\') = splt (size a) s\n    (middle, fourth) = splt (size b + size c) s\'\n    (second, third) = splt (size b) middle\n\n{-# INLINE splitMapNode #-}\nsplitMapNode :: Sized a => (Int -> s -> (s,s)) -> (s -> a -> b) -> s -> Node a -> Node b\nsplitMapNode splt f s (Node2 ns a b) = Node2 ns (f first a) (f second b)\n  where\n    (first, second) = splt (size a) s\nsplitMapNode splt f s (Node3 ns a b c) = Node3 ns (f first a) (f second b) (f third c)\n  where\n    (first, r) = splt (size a) s\n    (second, third) = splt (size b) r\n#endif\n\n------------------------------------------------------------------------\n-- Zipping\n------------------------------------------------------------------------\n\n-- We use a custom definition of munzip to avoid retaining\n-- memory longer than necessary. Using the default definition, if\n-- we write\n--\n-- let (xs,ys) = munzip zs\n-- in xs `deepseq` (... ys ...)\n--\n-- then ys will retain the entire zs sequence until ys itself is fully forced.\n-- This implementation uses the selector thunk optimization to prevent that.\n-- Unfortunately, that optimization is fragile, so we can\'t actually guarantee\n-- anything.\n\n-- | @ \'mzipWith\' = \'zipWith\' @\n--\n-- @ \'munzip\' = \'unzip\' @\n--\n-- @since 0.5.10.1\ninstance MonadZip Seq where\n  mzipWith = zipWith\n  munzip = unzip\n\n-- | Unzip a sequence of pairs.\n--\n-- @\n-- unzip ps = ps ``seq`` (\'fmap\' \'fst\' ps) (\'fmap\' \'snd\' ps)\n-- @\n--\n-- Example:\n--\n-- @\n-- unzip $ fromList [(1,"a"), (2,"b"), (3,"c")] =\n--   (fromList [1,2,3], fromList ["a", "b", "c"])\n-- @\n--\n-- See the note about efficiency at \'unzipWith\'.\n--\n-- @since 0.5.11\nunzip :: Seq (a, b) -> (Seq a, Seq b)\nunzip xs = unzipWith id xs\n\n-- | \\( O(n) \\). Unzip a sequence using a function to divide elements.\n--\n-- @ unzipWith f xs == \'unzip\' (\'fmap\' f xs) @\n--\n-- Efficiency note:\n--\n-- @unzipWith@ produces its two results in lockstep. If you calculate\n-- @ unzipWith f xs @ and fully force /either/ of the results, then the\n-- entire structure of the /other/ one will be built as well. This\n-- behavior allows the garbage collector to collect each calculated\n-- pair component as soon as it dies, without having to wait for its mate\n-- to die. If you do not need this behavior, you may be better off simply\n-- calculating the sequence of pairs and using \'fmap\' to extract each\n-- component sequence.\n--\n-- @since 0.5.11\nunzipWith :: (a -> (b, c)) -> Seq a -> (Seq b, Seq c)\nunzipWith f = unzipWith\' (\\x ->\n  let\n    {-# NOINLINE fx #-}\n    fx = f x\n    (y,z) = fx\n  in (y,z))\n-- Why do we lazify `f`? Because we don\'t want the strictness to depend\n-- on exactly how the sequence is balanced. For example, what do we want\n-- from\n--\n-- unzip [(1,2), undefined, (5,6)]?\n--\n-- The argument could be represented as\n--\n-- Seq $ Deep 3 (One (Elem (1,2))) EmptyT (Two undefined (Elem (5,6)))\n--\n-- or as\n--\n-- Seq $ Deep 3 (Two (Elem (1,2)) undefined) EmptyT (One (Elem (5,6)))\n--\n-- We don\'t want the tree balance to determine whether we get\n--\n-- ([1, undefined, undefined], [2, undefined, undefined])\n--\n-- or\n--\n-- ([undefined, undefined, 5], [undefined, undefined, 6])\n--\n-- so we pretty much have to be completely lazy in the elements.\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] unzipWith #-}\n\n-- We don\'t need a special rule for unzip:\n--\n-- unzip (fmap f xs) = unzipWith id f xs,\n--\n-- which rewrites to unzipWith (id . f) xs\n--\n-- It\'s true that if GHC doesn\'t know the arity of `f` then\n-- it won\'t reduce further, but that doesn\'t seem like too\n-- big a deal here.\n{-# RULES\n"unzipWith/fmapSeq" forall f g xs. unzipWith f (fmapSeq g xs) =\n                                     unzipWith (f . g) xs\n #-}\n#endif\n\nclass UnzipWith f where\n  unzipWith\' :: (x -> (a, b)) -> f x -> (f a, f b)\n\n-- This instance is only used at the very top of the tree;\n-- the rest of the elements are handled by unzipWithNodeElem\ninstance UnzipWith Elem where\n#ifdef __GLASGOW_HASKELL__\n  unzipWith\' = coerce\n#else\n  unzipWith\' f (Elem a) = case f a of (x, y) -> (Elem x, Elem y)\n#endif\n\n-- We\'re very lazy here for the sake of efficiency. We want to be able to\n-- reach any element of either result in logarithmic time. If we pattern\n-- match strictly, we\'ll end up building entire 2-3 trees at once, which\n-- would take linear time.\n--\n-- However, we\'re not *entirely* lazy! We are careful to build pieces\n-- of each sequence as the corresponding pieces of the *other* sequence\n-- are demanded. This allows the garbage collector to get rid of each\n-- *component* of each result pair as soon as it is dead.\n--\n-- Note that this instance is used only for *internal* nodes. Nodes\n-- containing elements are handled by \'unzipWithNodeElem\'\ninstance UnzipWith Node where\n  unzipWith\' f (Node2 s x y) =\n    ( Node2 s x1 y1\n    , Node2 s x2 y2)\n    where\n      {-# NOINLINE fx #-}\n      {-# NOINLINE fy #-}\n      fx = strictifyPair (f x)\n      fy = strictifyPair (f y)\n      (x1, x2) = fx\n      (y1, y2) = fy\n  unzipWith\' f (Node3 s x y z) =\n    ( Node3 s x1 y1 z1\n    , Node3 s x2 y2 z2)\n    where\n      {-# NOINLINE fx #-}\n      {-# NOINLINE fy #-}\n      {-# NOINLINE fz #-}\n      fx = strictifyPair (f x)\n      fy = strictifyPair (f y)\n      fz = strictifyPair (f z)\n      (x1, x2) = fx\n      (y1, y2) = fy\n      (z1, z2) = fz\n\n-- Force both elements of a pair\nstrictifyPair :: (a, b) -> (a, b)\nstrictifyPair (!x, !y) = (x, y)\n\n-- We\'re strict here for the sake of efficiency. The Node instance\n-- is lazy, so we don\'t particularly need to add an extra thunk on top\n-- of each node.\ninstance UnzipWith Digit where\n  unzipWith\' f (One x)\n    | (x1, x2) <- f x\n    = (One x1, One x2)\n  unzipWith\' f (Two x y)\n    | (x1, x2) <- f x\n    , (y1, y2) <- f y\n    = ( Two x1 y1\n      , Two x2 y2)\n  unzipWith\' f (Three x y z)\n    | (x1, x2) <- f x\n    , (y1, y2) <- f y\n    , (z1, z2) <- f z\n    = ( Three x1 y1 z1\n      , Three x2 y2 z2)\n  unzipWith\' f (Four x y z w)\n    | (x1, x2) <- f x\n    , (y1, y2) <- f y\n    , (z1, z2) <- f z\n    , (w1, w2) <- f w\n    = ( Four x1 y1 z1 w1\n      , Four x2 y2 z2 w2)\n\ninstance UnzipWith FingerTree where\n  unzipWith\' _ EmptyT = (EmptyT, EmptyT)\n  unzipWith\' f (Single x)\n    | (x1, x2) <- f x\n    = (Single x1, Single x2)\n  unzipWith\' f (Deep s pr m sf)\n    | (!pr1, !pr2) <- unzipWith\' f pr\n    , (!sf1, !sf2) <- unzipWith\' f sf\n    = (Deep s pr1 m1 sf1, Deep s pr2 m2 sf2)\n    where\n      {-# NOINLINE m1m2 #-}\n      m1m2 = strictifyPair $ unzipWith\' (unzipWith\' f) m\n      (m1, m2) = m1m2\n\ninstance UnzipWith Seq where\n  unzipWith\' _ (Seq EmptyT) = (empty, empty)\n  unzipWith\' f (Seq (Single (Elem x)))\n    | (x1, x2) <- f x\n    = (singleton x1, singleton x2)\n  unzipWith\' f (Seq (Deep s pr m sf))\n    | (!pr1, !pr2) <- unzipWith\' (unzipWith\' f) pr\n    , (!sf1, !sf2) <- unzipWith\' (unzipWith\' f) sf\n    = (Seq (Deep s pr1 m1 sf1), Seq (Deep s pr2 m2 sf2))\n    where\n      {-# NOINLINE m1m2 #-}\n      m1m2 = strictifyPair $ unzipWith\' (unzipWithNodeElem f) m\n      (m1, m2) = m1m2\n\n-- Here we need to be lazy in the children (because they\'re\n-- Elems), but we can afford to be strict in the results\n-- of `f` because it\'s sure to return a pair immediately\n-- (unzipWith lazifies the function it\'s passed).\nunzipWithNodeElem :: (x -> (a, b))\n       -> Node (Elem x) -> (Node (Elem a), Node (Elem b))\nunzipWithNodeElem f (Node2 s (Elem x) (Elem y))\n  | (x1, x2) <- f x\n  , (y1, y2) <- f y\n  = ( Node2 s (Elem x1) (Elem y1)\n    , Node2 s (Elem x2) (Elem y2))\nunzipWithNodeElem f (Node3 s (Elem x) (Elem y) (Elem z))\n  | (x1, x2) <- f x\n  , (y1, y2) <- f y\n  , (z1, z2) <- f z\n  = ( Node3 s (Elem x1) (Elem y1) (Elem z1)\n    , Node3 s (Elem x2) (Elem y2) (Elem z2))\n\n-- | \\( O(\\min(n_1,n_2)) \\).  \'zip\' takes two sequences and returns a sequence\n-- of corresponding pairs.  If one input is short, excess elements are\n-- discarded from the right end of the longer sequence.\nzip :: Seq a -> Seq b -> Seq (a, b)\nzip = zipWith (,)\n\n-- | \\( O(\\min(n_1,n_2)) \\).  \'zipWith\' generalizes \'zip\' by zipping with the\n-- function given as the first argument, instead of a tupling function.\n-- For example, @zipWith (+)@ is applied to two sequences to take the\n-- sequence of corresponding sums.\nzipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\nzipWith f s1 s2 = zipWith\' f s1\' s2\'\n  where\n    minLen = min (length s1) (length s2)\n    s1\' = take minLen s1\n    s2\' = take minLen s2\n\n-- | A version of zipWith that assumes the sequences have the same length.\nzipWith\' :: (a -> b -> c) -> Seq a -> Seq b -> Seq c\nzipWith\' f s1 s2 = splitMap uncheckedSplitAt goLeaf s2 s1\n  where\n    goLeaf (Seq (Single (Elem b))) a = f a b\n    goLeaf _ _ = error "Data.Sequence.zipWith\'.goLeaf internal error: not a singleton"\n\n-- | \\( O(\\min(n_1,n_2,n_3)) \\).  \'zip3\' takes three sequences and returns a\n-- sequence of triples, analogous to \'zip\'.\nzip3 :: Seq a -> Seq b -> Seq c -> Seq (a,b,c)\nzip3 = zipWith3 (,,)\n\n-- | \\( O(\\min(n_1,n_2,n_3)) \\).  \'zipWith3\' takes a function which combines\n-- three elements, as well as three sequences and returns a sequence of\n-- their point-wise combinations, analogous to \'zipWith\'.\nzipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d\nzipWith3 f s1 s2 s3 = zipWith\' ($) (zipWith\' f s1\' s2\') s3\'\n  where\n    minLen = minimum [length s1, length s2, length s3]\n    s1\' = take minLen s1\n    s2\' = take minLen s2\n    s3\' = take minLen s3\n\nzipWith3\' :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d\nzipWith3\' f s1 s2 s3 = zipWith\' ($) (zipWith\' f s1 s2) s3\n\n-- | \\( O(\\min(n_1,n_2,n_3,n_4)) \\).  \'zip4\' takes four sequences and returns a\n-- sequence of quadruples, analogous to \'zip\'.\nzip4 :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a,b,c,d)\nzip4 = zipWith4 (,,,)\n\n-- | \\( O(\\min(n_1,n_2,n_3,n_4)) \\).  \'zipWith4\' takes a function which combines\n-- four elements, as well as four sequences and returns a sequence of\n-- their point-wise combinations, analogous to \'zipWith\'.\nzipWith4 :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e\nzipWith4 f s1 s2 s3 s4 = zipWith\' ($) (zipWith3\' f s1\' s2\' s3\') s4\'\n  where\n    minLen = minimum [length s1, length s2, length s3, length s4]\n    s1\' = take minLen s1\n    s2\' = take minLen s2\n    s3\' = take minLen s3\n    s4\' = take minLen s4\n\n-- | fromList2, given a list and its length, constructs a completely\n-- balanced Seq whose elements are that list using the replicateA\n-- generalization.\nfromList2 :: Int -> [a] -> Seq a\nfromList2 n = execState (replicateA n (State ht))\n  where\n    ht (x:xs) = (xs, x)\n    ht []     = error "fromList2: short list"\n'