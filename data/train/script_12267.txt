b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n#ifdef __GLASGOW_HASKELL__\n{-# LANGUAGE Trustworthy #-}\n#endif\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Containers.ListUtils\n-- Copyright   :  (c) Gershom Bazerman 2018\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- This module provides efficient containers-based functions on the list type.\n--\n-- In the documentation, \\(n\\) is the number of elements in the list while\n-- \\(d\\) is the number of distinct elements in the list. \\(W\\) is the number\n-- of bits in an \'Int\'.\n--\n-- @since 0.6.0.1\n-----------------------------------------------------------------------------\n\nmodule Data.Containers.ListUtils (\n       nubOrd,\n       nubOrdOn,\n       nubInt,\n       nubIntOn\n       ) where\n\nimport Data.Set (Set)\nimport qualified Data.Set as Set\nimport qualified Data.IntSet as IntSet\nimport Data.IntSet (IntSet)\n#ifdef __GLASGOW_HASKELL__\nimport GHC.Exts ( build )\n#endif\n\n-- *** Ord-based nubbing ***\n\n\n-- | \\( O(n \\log d) \\). The @nubOrd@ function removes duplicate elements from a\n-- list. In particular, it keeps only the first occurrence of each element. By\n-- using a \'Set\' internally it has better asymptotics than the standard\n-- \'Data.List.nub\' function.\n--\n-- ==== Strictness\n--\n-- @nubOrd@ is strict in the elements of the list.\n--\n-- ==== Efficiency note\n--\n-- When applicable, it is almost always better to use \'nubInt\' or \'nubIntOn\'\n-- instead of this function, although it can be a little worse in certain\n-- pathological cases. For example, to nub a list of characters, use\n--\n-- @ nubIntOn fromEnum xs @\n--\n-- @since 0.6.0.1\nnubOrd :: Ord a => [a] -> [a]\nnubOrd = nubOrdOn id\n{-# INLINE nubOrd #-}\n\n-- | The @nubOrdOn@ function behaves just like \'nubOrd\' except it performs\n-- comparisons not on the original datatype, but a user-specified projection\n-- from that datatype.\n--\n-- ==== Strictness\n--\n-- @nubOrdOn@ is strict in the values of the function applied to the\n-- elements of the list.\n--\n-- @since 0.6.0.1\nnubOrdOn :: Ord b => (a -> b) -> [a] -> [a]\n-- For some reason we need to write an explicit lambda here to allow this\n-- to inline when only applied to a function.\nnubOrdOn f = \\xs -> nubOrdOnExcluding f Set.empty xs\n{-# INLINE nubOrdOn #-}\n\n-- Splitting nubOrdOn like this means that we don\'t have to worry about\n-- matching specifically on Set.empty in the rewrite-back rule.\nnubOrdOnExcluding :: Ord b => (a -> b) -> Set b -> [a] -> [a]\nnubOrdOnExcluding f = go\n  where\n    go _ [] = []\n    go s (x:xs)\n      | fx `Set.member` s = go s xs\n      | otherwise = x : go (Set.insert fx s) xs\n      where !fx = f x\n\n#ifdef __GLASGOW_HASKELL__\n-- We want this inlinable to specialize to the necessary Ord instance.\n{-# INLINABLE [1] nubOrdOnExcluding #-}\n\n{-# RULES\n-- Rewrite to a fusible form.\n"nubOrdOn" [~1] forall f as s. nubOrdOnExcluding  f s as =\n  build (\\c n -> foldr (nubOrdOnFB f c) (constNubOn n) as s)\n\n-- Rewrite back to a plain form\n"nubOrdOnList" [1] forall f as s.\n    foldr (nubOrdOnFB f (:)) (constNubOn []) as s =\n       nubOrdOnExcluding f s as\n #-}\n\nnubOrdOnFB :: Ord b\n           => (a -> b)\n           -> (a -> r -> r)\n           -> a\n           -> (Set b -> r)\n           -> Set b\n           -> r\nnubOrdOnFB f c x r s\n  | fx `Set.member` s = r s\n  | otherwise = x `c` r (Set.insert fx s)\n  where !fx = f x\n{-# INLINABLE [0] nubOrdOnFB #-}\n\nconstNubOn :: a -> b -> a\nconstNubOn x _ = x\n{-# INLINE [0] constNubOn #-}\n#endif\n\n\n-- *** Int-based nubbing ***\n\n\n-- | \\( O(n \\min(d,W)) \\). The @nubInt@ function removes duplicate \'Int\'\n-- values from a list. In particular, it keeps only the first occurrence\n-- of each element. By using an \'IntSet\' internally, it attains better\n-- asymptotics than the standard \'Data.List.nub\' function.\n--\n-- See also \'nubIntOn\', a more widely applicable generalization.\n--\n-- ==== Strictness\n--\n-- @nubInt@ is strict in the elements of the list.\n--\n-- @since 0.6.0.1\nnubInt :: [Int] -> [Int]\nnubInt = nubIntOn id\n{-# INLINE nubInt #-}\n\n-- | The @nubIntOn@ function behaves just like \'nubInt\' except it performs\n-- comparisons not on the original datatype, but a user-specified projection\n-- from that datatype. For example, @nubIntOn \'fromEnum\'@ can be used to\n-- nub characters and typical fixed-with numerical types efficiently.\n--\n-- ==== Strictness\n--\n-- @nubIntOn@ is strict in the values of the function applied to the\n-- elements of the list.\n--\n-- @since 0.6.0.1\nnubIntOn :: (a -> Int) -> [a] -> [a]\n-- For some reason we need to write an explicit lambda here to allow this\n-- to inline when only applied to a function.\nnubIntOn f = \\xs -> nubIntOnExcluding f IntSet.empty xs\n{-# INLINE nubIntOn #-}\n\n-- Splitting nubIntOn like this means that we don\'t have to worry about\n-- matching specifically on IntSet.empty in the rewrite-back rule.\nnubIntOnExcluding :: (a -> Int) -> IntSet -> [a] -> [a]\nnubIntOnExcluding f = go\n  where\n    go _ [] = []\n    go s (x:xs)\n      | fx `IntSet.member` s = go s xs\n      | otherwise = x : go (IntSet.insert fx s) xs\n      where !fx = f x\n\n#ifdef __GLASGOW_HASKELL__\n-- We don\'t mark this INLINABLE because it doesn\'t seem obviously useful\n-- to inline it anywhere; the elements the function operates on are actually\n-- pulled from a list and installed in a list; the situation is very different\n-- when fusion occurs. In this case, we let GHC make the call.\n{-# NOINLINE [1] nubIntOnExcluding #-}\n\n{-# RULES\n"nubIntOn" [~1] forall f as s. nubIntOnExcluding  f s as =\n  build (\\c n -> foldr (nubIntOnFB f c) (constNubOn n) as s)\n"nubIntOnList" [1] forall f as s. foldr (nubIntOnFB f (:)) (constNubOn []) as s =\n  nubIntOnExcluding f s as\n #-}\n\nnubIntOnFB :: (a -> Int)\n           -> (a -> r -> r)\n           -> a\n           -> (IntSet -> r)\n           -> IntSet\n           -> r\nnubIntOnFB f c x r s\n  | fx `IntSet.member` s = r s\n  | otherwise = x `c` r (IntSet.insert fx s)\n  where !fx = f x\n{-# INLINABLE [0] nubIntOnFB #-}\n#endif\n'