b'{-# LANGUAGE CPP #-}\n-- The following warning id disabled so that we do not see warnings during\n-- compilation caused by the intentional use of ListT.\n#if __GLASGOW_HASKELL__ < 800\n{-# OPTIONS_GHC -fno-warn-warnings-deprecations #-}\n#else\n{-# OPTIONS_GHC -Wno-deprecations #-}\n#endif\n-- |\n-- Copyright  : (c) Ivan Perez and Manuel Baerenz, 2016\n-- License    : BSD3\n-- Maintainer : ivan.perez@keera.co.uk\n--\n-- \'MSF\'s with a list monadic layer.\n--\n-- This module contains functions to work with MSFs that include a \'ListT\'\n-- monadic layer. MSFs on a list monad may produce multiple outputs and\n-- continuations, or none. This enables the possibility for spawning new MSFs,\n-- or stopping MSFs, at will.\n--\n-- A common use case is to be able to dynamically spawn new interactive\n-- elements in applications (e.g., a game object that splits in two, or that\n-- fires to an enemy).\n--\n-- WARNING: the ListT transformer is considered dangerous, and imposes\n-- additional constraints on the inner monad in order for the combination of\n-- the monad and the transformer to be a monad. Use at your own risk.\nmodule Control.Monad.Trans.MSF.List\n    {-# WARNING "This module uses the ListT transformer, which is considered deprecated." #-}\n    ( module Control.Monad.Trans.MSF.List\n    , module Control.Monad.Trans.List\n    )\n  where\n\n-- External imports\n#if !MIN_VERSION_base(4,8,0)\nimport Control.Applicative ((<$>))\n#endif\n\nimport Control.Monad.Trans.List hiding (liftCallCC, liftCatch)\n\n-- Internal imports\nimport Data.MonadicStreamFunction.InternalCore (MSF (MSF, unMSF))\n\n-- * List monad\n\n-- | Run an \'MSF\' in the \'ListT\' transformer (i.e., multiple MSFs producing\n-- each producing one output), by applying the input stream to each MSF in the\n-- list transformer and concatenating the outputs of the MSFs together.\n--\n-- An MSF in the ListT transformer can spawn into more than one MSF, or none,\n-- so the outputs produced at each individual step are not guaranteed to all\n-- have the same length.\nwidthFirst :: (Functor m, Monad m) => MSF (ListT m) a b -> MSF m a [b]\nwidthFirst msf = widthFirst\' [msf]\n  where\n    widthFirst\' msfs = MSF $ \\a -> do\n      (bs, msfs\') <- unzip . concat <$> mapM (runListT . flip unMSF a) msfs\n      return (bs, widthFirst\' msfs\')\n\n-- | Build an \'MSF\' in the \'ListT\' transformer by broadcasting the input stream\n-- value to each MSF in a given list.\nsequenceS :: Monad m => [MSF m a b] -> MSF (ListT m) a b\nsequenceS msfs = MSF $ \\a -> ListT $ sequence $ apply a <$> msfs\n  where\n    apply a msf = do\n      (b, msf\') <- unMSF msf a\n      return (b, sequenceS [msf\'])\n\n-- | Apply an \'MSF\' to every input.\nmapMSF :: Monad m => MSF m a b -> MSF m [a] [b]\nmapMSF = MSF . consume\n  where\n    consume :: Monad m => MSF m a t -> [a] -> m ([t], MSF m [a] [t])\n    consume sf []     = return ([], mapMSF sf)\n    consume sf (a:as) = do\n      (b, sf\')   <- unMSF sf a\n      (bs, sf\'\') <- consume sf\' as\n      b `seq` return (b:bs, sf\'\')\n'