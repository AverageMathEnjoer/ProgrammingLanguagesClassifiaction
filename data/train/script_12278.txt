b'\xef\xbb\xbf// UVa437 The Tower of Babylon\n// Rujia Liu\n// \xe7\xae\x97\xe6\xb3\x95\xef\xbc\x9aDAG\xe4\xb8\x8a\xe7\x9a\x84\xe6\x9c\x80\xe9\x95\xbf\xe8\xb7\xaf\xef\xbc\x8c\xe7\x8a\xb6\xe6\x80\x81\xe4\xb8\xba(idx, k)\xef\xbc\x8c\xe5\x8d\xb3\xe5\xbd\x93\xe5\x89\x8d\xe9\xa1\xb6\xe9\x9d\xa2\xe4\xb8\xba\xe7\xab\x8b\xe6\x96\xb9\xe4\xbd\x93idx\xef\xbc\x8c\xe5\x85\xb6\xe4\xb8\xad\xe7\xac\xack\xe6\x9d\xa1\xe8\xbe\xb9\xef\xbc\x88\xe6\x8e\x92\xe5\xba\x8f\xe5\x90\x8e\xef\xbc\x89\xe4\xb8\xba\xe9\xab\x98\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (n); i++)\n\nconst int maxn = 30 + 5;\nint n, blocks[maxn][3], d[maxn][3];\n\nvoid get_dimensions(int* v, int b, int dim) {\n  int idx = 0;\n  REP(i,3) if(i != dim) v[idx++] = blocks[b][i];\n}\n\nint dp(int i, int j) {\n  int& ans = d[i][j];\n  if(ans > 0) return ans;\n  ans = 0;\n  int v[2], v2[2];\n  get_dimensions(v, i, j);\n  REP(a,n) REP(b,3) {\n    get_dimensions(v2, a, b);\n    if(v2[0] < v[0] && v2[1] < v[1]) ans = max(ans, dp(a,b));\n  }\n  ans += blocks[i][j];\n  return ans;\n}\n\nint main() {\n  int kase = 0;\n  while(scanf("%d", &n) == 1 && n) {\n    REP(i,n) {\n      REP(j,3) scanf("%d", &blocks[i][j]);\n      sort(blocks[i], blocks[i]+3);\n    }\n    memset(d, 0, sizeof(d));\n    int ans = 0;\n    REP(i,n) REP(j,3) ans = max(ans, dp(i,j));\n    printf("Case %d: maximum height = %d\\n", ++kase, ans);\n  }\n  return 0;\n}\n'