b'{-# LANGUAGE CPP #-}\nmodule Tree where\n\nimport Control.Parallel\nimport Control.Parallel.Strategies\n\ndata Tree a = Branch a [Tree a] deriving Show\n\nrepTree :: (a->[a]) -> (a->[a])-> a -> (Tree a)\nrepTree f g a = Branch a (map (repTree g f) (f a))\n\n#define SEQ\n\n#ifndef SEQ\n\nmapTree :: (a -> b) -> Tree a -> Tree b\nmapTree f (Branch a l) \n   = fa `par` Branch fa (map (mapTree f) l `using` myParList)\n   where fa = f a\n\n#else \n\nmapTree :: (a -> b) -> (Tree a) -> (Tree b)\nmapTree f (Branch a l) = Branch (f a) (map (mapTree f) l)\n\n#endif\n\nmyParList [] = ()\nmyParList (x:xs) = x `par` myParList xs\n\nmySeqList [] = ()\nmySeqList (x:xs) = x `seq` mySeqList xs\n\nparTree :: Int -> Tree a -> ()\nparTree 0 (Branch a xs) = ()\nparTree n (Branch a xs) = a `par` mySeqList (map (parTree (n-1)) xs)\n\nprune :: Int -> (Tree a) -> (Tree a)\nprune 0 (Branch a l) = Branch a []\nprune n (Branch a l) = Branch a (map (prune (n-1)) l)\n\n'