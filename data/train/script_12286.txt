b'{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Pdf.Document.Pdf\n(\n  Pdf,\n  withPdfFile,\n  fromFile,\n  fromHandle,\n  fromBytes,\n  document,\n  lookupObject,\n  streamContent,\n  rawStreamContent,\n  deref,\n  isEncrypted,\n  setUserPassword,\n  defaultUserPassword,\n  EncryptedError (..),\n  enableCache,\n  disableCache,\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Stream (knownFilters)\nimport Pdf.Core.File (File)\nimport qualified Pdf.Core.File as File\nimport Pdf.Core.Encryption (defaultUserPassword)\n\nimport Pdf.Document.Internal.Types\n\nimport Data.Typeable\nimport Data.IORef\nimport Data.ByteString (ByteString)\nimport Data.Text (Text)\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception hiding (throw)\nimport System.IO (Handle)\nimport System.IO.Streams (InputStream)\n\nwithPdfFile :: FilePath -> (Pdf -> IO a) -> IO a\nwithPdfFile path action = File.withPdfFile path $ \\f -> do\n  pdf <- fromFile f\n  action pdf\n\n-- | Make Pdf with interface to pdf file\nfromFile :: File -> IO Pdf\nfromFile f = Pdf f\n  <$> newIORef (False, HashMap.empty)\n\n-- | Make Pdf with seekable handle\nfromHandle :: Handle -> IO Pdf\nfromHandle h = do\n  File.fromHandle knownFilters h >>= fromFile\n\n-- | Make Pdf from a ByteString\nfromBytes :: ByteString -> IO Pdf\nfromBytes h = do\n  File.fromBytes knownFilters h >>= fromFile\n\nfile :: Pdf -> File\nfile (Pdf f _) = f\n\n-- | Get PDF document\ndocument :: Pdf -> IO Document\ndocument pdf = do\n  status <- File.encryptionStatus (file pdf)\n  case status of\n    File.Encrypted -> throwIO $\n      EncryptedError "File is encrypted, use \'setUserPassword\'"\n    File.Decrypted -> return ()\n    File.Plain -> return ()\n\n  Document pdf <$> File.lastTrailer (file pdf)\n\n-- | Find object by it\'s reference\nlookupObject :: Pdf -> Ref -> IO Object\nlookupObject pdf ref = do\n  let Pdf _ cacheRef = pdf\n  (useCache, cache) <- readIORef cacheRef\n  case HashMap.lookup ref cache of\n    Just obj -> return obj\n    Nothing -> do\n      obj <- File.findObject (file pdf) ref\n      when useCache $\n        writeIORef cacheRef (useCache, HashMap.insert ref obj cache)\n      return obj\n\n-- | Cache object for future lookups\nenableCache :: Pdf -> IO ()\nenableCache (Pdf _ cacheRef) = do\n  (_, cache) <- readIORef cacheRef\n  writeIORef cacheRef (True, cache)\n\n-- | Don\'t cache object for future lookups\ndisableCache :: Pdf -> IO ()\ndisableCache (Pdf _ cacheRef) = do\n  (_, cache) <- readIORef cacheRef\n  writeIORef cacheRef (False, cache)\n\n-- | Get stream content, decoded and decrypted\n--\n-- Note: length of the content may differ from the raw one\nstreamContent :: Pdf\n              -> Ref\n              -> Stream\n              -> IO (InputStream ByteString)\nstreamContent pdf ref s =\n  File.streamContent (file pdf) ref s\n\n-- | Get stream content without decoding it\nrawStreamContent\n  :: Pdf\n  -> Ref\n  -> Stream\n  -> IO (InputStream ByteString)\nrawStreamContent pdf ref s =\n  File.rawStreamContent (file pdf) ref s\n\n-- | Whether the PDF document it encrypted\nisEncrypted :: Pdf -> IO Bool\nisEncrypted pdf = do\n  status <- File.encryptionStatus (file pdf)\n  return $ case status of\n    File.Encrypted -> True\n    File.Decrypted -> True\n    File.Plain -> False\n\n-- | Set the password to be user for decryption\n--\n-- Returns False when the password is wrong\nsetUserPassword :: Pdf -> ByteString -> IO Bool\nsetUserPassword pdf password =\n  File.setUserPassword (file pdf) password\n\nderef :: Pdf -> Object -> IO Object\nderef pdf (Ref r) = lookupObject pdf r\nderef _ o = return o\n\n-- | File is enctypted\ndata EncryptedError = EncryptedError Text\n  deriving (Show, Typeable)\n\ninstance Exception EncryptedError\n'