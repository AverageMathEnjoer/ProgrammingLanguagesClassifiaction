b'\xef\xbb\xbfusing System;\nusing System.Text;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace qqzengIP\n{\n    public class IPEntity\n    {\n        public string IP { get; set; }\n        public string Country { get; set; }\n        public string Local { get; set; }\n    }\n\n    public class IPSearch\n    {\n        static Encoding encoding = Encoding.GetEncoding("GB2312");\n\n        private byte[] data;\n        int firstStartIpOffset;\n        int lastStartIpOffset;\n        int ipCount;\n\n        public int Count { get { return ipCount; } }\n\n        public IPSearch(string dataPath)\n        {\n            using (FileStream fs = new FileStream(dataPath, FileMode.Open, FileAccess.Read, FileShare.Read))\n            {\n                data = new byte[fs.Length];\n                fs.Read(data, 0, data.Length);\n            }\n\n            firstStartIpOffset = (int)data[0] + (((int)data[1]) << 8) + (((int)data[2]) << 16) + (((int)data[3]) << 24);\n            lastStartIpOffset = (int)data[4] + (((int)data[5]) << 8) + (((int)data[6]) << 16) + (((int)data[7]) << 24);\n            ipCount = (lastStartIpOffset - firstStartIpOffset) / 7 + 1;\n\n            if (ipCount <= 1)\n            {\n                throw new ArgumentException("\xe6\x96\x87\xe4\xbb\xb6\xe9\x94\x99\xe8\xaf\xaf");\n            }\n        }\n\n        public static uint IpToInt(string ip)\n        {\n            byte[] bytes = IPAddress.Parse(ip).GetAddressBytes();\n            return (uint)bytes[3] + (((uint)bytes[2]) << 8) + (((uint)bytes[1]) << 16) + (((uint)bytes[0]) << 24);\n        }\n\n        public static string IntToIP(uint ip_Int)\n        {\n            return new IPAddress(ip_Int).ToString();\n        }\n\n        public IPEntity Query(string ip)\n        {\n            IPAddress address = IPAddress.Parse(ip);\n            if (address.AddressFamily != AddressFamily.InterNetwork)\n            {\n                throw new ArgumentException("\xe4\xb8\x8d\xe6\x94\xaf\xe6\x8c\x81\xe9\x9d\x9eIPV4\xe7\x9a\x84\xe5\x9c\xb0\xe5\x9d\x80");\n            }\n            if (IPAddress.IsLoopback(address))\n            {\n                return new IPEntity() { IP = ip, Country = "\xe6\x9c\xac\xe6\x9c\xba\xe5\x86\x85\xe9\x83\xa8\xe7\x8e\xaf\xe5\x9b\x9e\xe5\x9c\xb0\xe5\x9d\x80", Local = string.Empty };\n            }\n            long intIP = IpToInt(ip);\n\n\n            IPEntity ipLocation = new IPEntity() { IP = ip };\n\n            uint right = (uint)ipCount;\n            uint left = 0;\n            uint middle = 0;\n            uint startIp = 0;\n            uint endIpOff = 0;\n            uint endIp = 0;\n            int countryFlag = 0;\n\n            while (left < (right - 1))\n            {\n                middle = (right + left) / 2;\n                startIp = GetStartIp(middle, out endIpOff);\n                if (intIP == startIp)\n                {\n                    left = middle;\n                    break;\n                }\n                if (intIP > startIp)\n                {\n                    left = middle;\n                }\n                else\n                {\n                    right = middle;\n                }\n            }\n            startIp = GetStartIp(left, out endIpOff);\n            endIp = GetEndIp(endIpOff, out countryFlag);\n            if ((startIp <= intIP) && (endIp >= intIP))\n            {\n                string local;\n                ipLocation.Country = GetCountry(endIpOff, countryFlag, out local);\n                ipLocation.Local = local;\n            }\n            else\n            {\n                ipLocation.Country = "\xe6\x9c\xaa\xe7\x9f\xa5";\n                ipLocation.Local = string.Empty;\n            }\n            return ipLocation;\n        }\n\n        private uint GetStartIp(uint left, out uint endIpOff)\n        {\n            int leftOffset = (int)(firstStartIpOffset + (left * 7));\n            endIpOff = (uint)data[4 + leftOffset] + (((uint)data[5 + leftOffset]) << 8) + (((uint)data[6 + leftOffset]) << 16);\n            return (uint)data[leftOffset] + (((uint)data[1 + leftOffset]) << 8) + (((uint)data[2 + leftOffset]) << 16) + (((uint)data[3 + leftOffset]) << 24);\n        }\n\n        private uint GetEndIp(uint endIpOff, out int countryFlag)\n        {\n            countryFlag = data[4 + endIpOff];\n            return (uint)data[endIpOff] + (((uint)data[1 + endIpOff]) << 8) + (((uint)data[2 + endIpOff]) << 16) + (((uint)data[3 + endIpOff]) << 24);\n        }\n\n\t\t\n\t\t//\xe5\x8e\x9f\xe5\x88\x99\xef\xbc\x9a\xe6\xa8\xa1\xe5\xbc\x8f1\xe7\x9a\x84\xe5\x9b\xbd\xe5\xae\xb6\xe8\xae\xb0\xe5\xbd\x95\xe5\x90\x8e\xe9\x9d\xa2\xe4\xb8\x8d\xe4\xbc\x9a\xe5\x86\x8d\xe6\x9c\x89\xe5\x9c\xb0\xe5\x8c\xba\xe8\xae\xb0\xe5\xbd\x95\xef\xbc\x8c\xe6\xa8\xa1\xe5\xbc\x8f2\xe7\x9a\x84\xe5\x9b\xbd\xe5\xae\xb6\xe8\xae\xb0\xe5\xbd\x95\xe5\x90\x8e\xe4\xbc\x9a\xe6\x9c\x89\xe5\x9c\xb0\xe5\x8c\xba\xe8\xae\xb0\xe5\xbd\x95\n\t\t\n\t\t/// <summary>\n        /// \xe3\x80\x90\xe6\x96\xb0\xe7\x89\x88\xe3\x80\x91\xe8\x8e\xb7\xe5\x8f\x96\xe5\x9b\xbd\xe5\xae\xb6 \xe4\xbb\xa5\xe5\x8f\x8a\xe5\x85\xb6\xe4\xbb\x96\xe5\xad\x97\xe6\xae\xb5\xe4\xbf\xa1\xe6\x81\xaf \xe5\x85\xa8\xe7\x90\x83\xe7\x89\x88  \xe5\x9b\xbd\xe5\x86\x85\xe7\xb2\xbe\xe5\x8d\x8e\xe7\x89\x88 \xe5\x9b\xbd\xe5\xa4\x96\xe7\x89\x88 \n        /// </summary>\n        /// <param name="endIpOff">\xe7\xbb\x93\xe6\x9d\x9fip\xe4\xbd\x8d\xe7\xbd\xae</param>\n        /// <param name="countryFlag">\xe6\xa8\xa1\xe5\xbc\x8f</param>\n        /// <param name="local">\xe8\xbf\x94\xe5\x9b\x9e \xe7\x9c\x81\xe5\xb8\x82\xe5\x8c\xba \xe8\xbf\x90\xe8\x90\xa5\xe5\x95\x86 \xe7\xbb\x8f\xe7\xba\xac\xe5\xba\xa6 \xe7\xad\x89</param>\n        /// <returns>\xe5\x9b\xbd\xe5\xae\xb6</returns>\n        private string GetCountry(uint endIpOff, int countryFlag, out string local)\n        {\n            string country = string.Empty;\n            uint offset = endIpOff + 4;\n            country = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n            if (countryFlag == 1)\n            {\n                local = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n            }\n            else\n            {\n                offset = endIpOff + 8;\n                local = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n            }\n            return country;\n        }\n\t\t\n\t\t\n\t\t\n        /// <summary>\n        /// \xe8\x8e\xb7\xe5\x8f\x96\xe5\x9b\xbd\xe5\xae\xb6\n        /// </summary>\n        /// <param name="endIpOff">\xe7\xbb\x93\xe6\x9d\x9fip\xe4\xbd\x8d\xe7\xbd\xae</param>\n        /// <param name="countryFlag">\xe6\xa8\xa1\xe5\xbc\x8f</param>\n        /// <param name="local">\xe8\xbf\x94\xe5\x9b\x9e \xe7\x9c\x81\xe5\xb8\x82\xe5\x8c\xba \xe8\xbf\x90\xe8\x90\xa5\xe5\x95\x86</param>\n        /// <returns>\xe5\x9b\xbd\xe5\xae\xb6</returns>\n        private string GetCountry(uint endIpOff, int countryFlag, out string local)\n        {\n            string country = string.Empty;\n            uint offset = endIpOff + 4;\n            switch (countryFlag)\n            {\n                case 1:\n                    country = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n                    offset = endIpOff + 8;\n                    local = (1 == countryFlag) ? string.Empty : GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n              \n                    break;\n                case 2:\n                    country = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n                    offset = endIpOff + 8;\n                    local = (1 == countryFlag) ? string.Empty : GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n                    break;\n                default:\n                    country = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n                    local = GetFlagStr(ref offset, ref countryFlag, ref endIpOff);\n                    break;\n            }\n            return country;\n        }\n\t\t\n\n        private string GetFlagStr(ref uint offset, ref int countryFlag, ref uint endIpOff)\n        {\n            int flag = 0;\n            while (true)\n            {\n                flag = data[offset];\n                //\xe6\xb2\xa1\xe6\x9c\x89\xe9\x87\x8d\xe5\xae\x9a\xe5\x90\x91\n                if (flag != 1 && flag != 2)\n                {\n                    break;\n                }\n                if (flag == 2)\n                {\n                    countryFlag = 2;\n                    endIpOff = offset - 4;\n                }\n                offset = (uint)data[1 + offset] + (((uint)data[2 + offset]) << 8) + (((uint)data[3 + offset]) << 16);\n            }\n            if (offset < 12)\n            {\n                return string.Empty;\n            }\n            return GetStr(ref offset);\n        }\n\n        /// <summary>\n        /// \xe8\xaf\xbb\xe5\x8f\x96\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2...\n        /// </summary>\n        /// <param name="offset"></param>\n        /// <returns></returns>\n        private string GetStr(ref uint offset)\n        {\n            byte lowByte = 0;\n            byte highByte = 0;\n            StringBuilder stringBuilder = new StringBuilder(16);\n            while (true)\n            {\n                lowByte = data[offset++];\n                if (lowByte == 0)\n                {\n                    return stringBuilder.ToString();\n                }\n                if (lowByte > 0x7f)\n                {\n                    highByte = data[offset++];\n                    if (highByte == 0)\n                    {\n                        return stringBuilder.ToString();\n                    }\n                    stringBuilder.Append(encoding.GetString(new byte[] { lowByte, highByte }));\n                }\n                else\n                {\n                    stringBuilder.Append((char)lowByte);\n                }\n            }\n        }\n    }\n}\n'