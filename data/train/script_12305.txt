b'// Copyright (c) 2021-2022 Manuel Schneider\n\n#include "levenshtein.h"\n#include <algorithm>\n#include <iostream>\n#include <limits>\nusing namespace std;\n\nstatic constexpr uint8_t max_edit_distance = numeric_limits<uint8_t>().max();\n\nuint Levenshtein::computePrefixEditDistanceWithLimit(const QString &prefix, const QString &string, uint k)\n{\n    if (k == 0)\n        return string.startsWith(prefix) ? 0 : 1;\n\n    if (prefix.size() > string.size()+k)\n        return k+1;\n\n    uint rows = prefix.size() + 1;\n    uint cols = min(prefix.size() + (qsizetype)k + 1, string.size() + 1);\n\n    expand_matrix_if_necessary(rows, cols);\n\n    //  Example distance d=2\n    //        a   b   _   e   f   g   h   i   j\n    //  \xe2\x94\x8c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x90\n    //  \xe2\x94\x82 0 \xe2\x94\x82 1   2   3   4   5   6   7 \xe2\x94\x82 8   9 \xe2\x94\x82\n    //  \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n    //a \xe2\x94\x82 1 \xe2\x94\x82(0)  1   2                 \xe2\x94\x82       \xe2\x94\x82\n    //  \xe2\x94\x82   \xe2\x94\x82                           \xe2\x94\x82       d  r-1<d\n    //b \xe2\x94\x82 2 \xe2\x94\x82 1  (0)  1   2             \xe2\x94\x82       \xe2\x94\x82\n    //  \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80d\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n    //c \xe2\x94\x82 3 \xe2\x94\x82 2   1  (1)  2   3         \xe2\x94\x82       \xe2\x94\x82\n    //  \xe2\x94\x82   \xe2\x94\x82                           \xe2\x94\x82       \xe2\x94\x82\n    //d \xe2\x94\x82 4 \xe2\x94\x82     2  (2)  2   3   4     \xe2\x94\x82       \xe2\x94\x82\n    //  \xe2\x94\x82   \xe2\x94\x82                           \xe2\x94\x82       \xe2\x94\x82\n    //e \xe2\x94\x82 5 \xe2\x94\x82         3  (2)  3   4   5 \xe2\x94\x82       \xe2\x94\x82\n    //  \xe2\x94\x82   \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80d\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n    //f \xe2\x94\x82 6 \xe2\x94\x82             3  (2)  3   4 \xe2\x94\x82 5     \xe2\x94\x82\n    //  \xe2\x94\x82   \xe2\x94\x82                           \xe2\x94\x82       d\n    //g \xe2\x94\x82 7 \xe2\x94\x82                 3  (2)  3 \xe2\x94\x82 4   5 \xe2\x94\x82\n    //  \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x98\n\n    uint8_t edit_distance;\n    for (uint r=1; r < rows; ++r) {\n        edit_distance = max_edit_distance;\n\n        if (r>k)\n            edit_distance = min(\n                edit_distance,\n                cell(r, r - k) = min({cell(r - 1, r - k - 1) + (prefix[r-1] == string[r - k-1] ? 0u : 1u),\n                                      cell(r - 1, r - k) + 1u}));\n\n        uint end = min(cols, r+k);\n        for (uint c = (uint)max(1,1+(int)r-(int)k); c < end; ++c)\n            edit_distance = min(\n                edit_distance,\n                cell(r,c) = min({cell(r - 1, c - 1) + (prefix[r - 1] == string[c - 1] ? 0u : 1u),\n                                 cell(r - 1, c) + 1u, cell(r, c - 1) + 1u})\n            );\n\n        if (r<cols-k)\n            edit_distance = min(\n                edit_distance,\n                cell(r, r + k) = min({cell(r - 1, r + k - 1) + (prefix[r-1] == string[r + k-1] ? 0u : 1u),\n                                      cell(r, r + k - 1) + 1u})\n            );\n        if (edit_distance > k)\n            return edit_distance;\n    }\n\n//    cout << "k" << k << endl;\n//    print_matrix(prefix, string);\n//    print_matrix_view(prefix, string, rows, cols);\n\n    return edit_distance;\n}\n\n\nconst uint8_t &Levenshtein::cell(uint r, uint c) const\n{\n    return matrix[(r)*matrix_cols + c];\n}\n\nuint8_t &Levenshtein::cell(uint r, uint c)\n{\n    return matrix[(r)*matrix_cols + c];\n}\n\n\nvoid Levenshtein::expand_matrix_if_necessary(uint rows, uint cols)\n{\n    // if space needed expand and init matrix\n    if (matrix_rows < rows || matrix_cols < cols){\n        matrix_rows = max(matrix_rows, rows);\n        matrix_cols = max(matrix_cols, cols);\n        matrix.resize(matrix_rows*matrix_cols);\n        for (uint r = 0; r < matrix_rows; ++r)\n            cell(r, 0) = r;\n        for (uint c = 0; c < matrix_cols; ++c)\n            cell(0, c) = c;\n    }\n}\n\nvoid Levenshtein::print_matrix_view(const QString &prefix, const QString &string, uint rows, uint cols) const\n{\n    cout << qPrintable(prefix) << endl;\n    cout << qPrintable(string) << endl;\n    cout << "   " ;\n    for (int r = 0; r < string.size(); ++r)\n        cout << " " << qPrintable(string)[r];\n    cout  << endl;\n    for (uint r = 0; r < rows; ++r){\n        cout << qPrintable(QString(" %1").arg(prefix))[r];\n        for (uint c = 0; c < cols; ++c){\n            cout << " " << (int)cell(r,c);\n        }\n        cout << \'\\n\';\n    }\n}\n\nvoid Levenshtein::print_matrix(const QString &prefix, const QString &string) const\n{\n    cout << qPrintable(prefix) << endl;\n    cout << qPrintable(string) << endl;\n    cout << "   " ;\n    for (int r = 0; r < string.size(); ++r)\n        cout << " " << qPrintable(string)[r];\n    cout  << endl;\n    for (uint r = 0; r < matrix_rows; ++r){\n        cout << qPrintable(QString(" %1").arg(prefix))[r];\n        for (uint c = 0; c < matrix_cols; ++c){\n            cout << " " << (int)cell(r,c);\n        }\n        cout << endl;\n    }\n}\n/// Returns true if delta is not exceeded\nbool Levenshtein::checkPrefixEditDistance_Legacy(const QString &prefix, const QString &str, uint delta)\n{\n    uint row_count = prefix.size() + 1;\n    uint col_count = min(prefix.size() + (qsizetype)delta + 1, str.size() + 1);\n\n    uint* table = new uint[row_count * col_count];\n\n    // Initialize left and top row.\n    for (uint r = 0; r < row_count; ++r) { table[r * col_count + 0] = r; }\n    for (uint c = 0; c < col_count; ++c) { table[c] = c; }\n\n    // Now fill the matrix. TODO column-first algo break if <= delta\n    for (uint r = 1; r < row_count; ++r)\n        for (uint c = 1; c < col_count; ++c) // TODO c<=r?\n            table[r * col_count + c] =\n                    min({table[(r - 1) * col_count + c - 1] + (prefix[r - 1] == str[c - 1] ? 0 : 1),  // substitution\n                         table[r * col_count + c - 1] + 1,  // deletion\n                         table[(r - 1) * col_count + c] + 1});  // insertion\n\n    // Check the last row if there is an entry <= delta.\n    bool result = false;\n    for (uint j = 0; j < col_count; ++j) {\n        if (table[(row_count - 1) * col_count + j] <= delta) {\n            result = true;\n            break;\n        }\n    }\n\n    delete[] table;\n    return result;\n}\n'