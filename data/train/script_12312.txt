b'{-# LANGUAGE RankNTypes, ImpredicativeTypes, MultiParamTypeClasses, CPP #-}\n\n-- | This is a sequential implementation of the Par monad.\n--\n--   It only works for the subset of programs in which a\n--   top-to-bottom/left-to-right execution of the program writes all\n--   IVars before reading them.  It is analogous to the Cilk notion of\n--   a \\"serial elision\\" -- eliding the parallel annotations and\n--   running in serial.\n--\n--   This module can be used for debugging as well as for establishing a\n--   serial baseline performance.\n--\n\nmodule Control.Monad.Par.Scheds.SerialElision (\n    Par, IVar, runPar, fork,\n    new, newFull, newFull_,\n    get, put, put_,\n    spawn, spawn_, spawnP\n  ) where\n\nimport qualified Control.Monad.Par.Class as PC\nimport Control.Exception\nimport Control.DeepSeq\nimport Control.Monad.ST\n-- import Data.STRef\nimport Data.IORef\nimport Debug.Trace\nimport GHC.IO\n\n--------------------------------------------------------------------------------\n-- Central type definitions:\nnewtype Par a = P (IO a)\nnewtype IVar a = I (IORef (Maybe a))\n\nunP (P x) = x\n\n-- The newtype\'s above were necessary for the \'ParIVar\'/\'ParFuture\'\n-- instance below and thus we need a Monad instance as well:\ninstance Monad Par where\n  (P m) >>= f = P (m >>= unP . f)\n  return x = P (return x)\n\n--------------------------------------------------------------------------------\n\nfork :: Par () -> Par ()\nnew  :: Par (IVar a)\nget  :: IVar a -> Par a\nput  :: NFData a => IVar a -> a -> Par ()\nput_ :: IVar a -> a -> Par ()\n\nnewFull :: NFData a => a -> Par (IVar a)\nnewFull_ :: a -> Par (IVar a)\nrunPar :: Par a -> a\n\n--------------------------------------------------------------------------------\n\nfork (P m) = P$ do m; return ()\n\nnew = P$ newIORef Nothing                     >>= return . I\nnewFull  x = rnf x `seq` P (newIORef (Just x) >>= return . I)\nnewFull_ x = P$ newIORef (Just x)             >>= return . I\n\nget (I r) = P$\n        do x <- readIORef r\n\t   case x of\n             -- TODO: Could keep track of pedigree for better errors:\n\t     Nothing -> error "IVar read before written!"\n\t     Just y  -> return y\n\nput  (I r) x = rnf x `seq` P (writeIORef r (Just x))\nput_ (I r) x = P$ writeIORef r (Just x)\n\nrunPar (P m) =\n  trace ("ParElision: Running with unsafeIO...")\n  unsafePerformIO m\n\n\n----------------------------------------------------------------------------------------------------\n-- TEMP: Factor out this boilerplate somehow.\n-- <boilerplate>\nspawn  :: NFData a => Par a -> Par (IVar a)\nspawn_ :: Par a -> Par (IVar a)\nspawnP :: NFData a => a -> Par (IVar a)\n\nspawn p  = do r <- new;  fork (p >>= put r);   return r\nspawn_ p = do r <- new;  fork (p >>= put_ r);  return r\nspawnP a = spawn (return a)\n\ninstance PC.ParFuture IVar Par  where\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance PC.ParIVar IVar Par  where\n  fork = fork\n  new  = new\n  put_ = put_\n  newFull = newFull\n  newFull_ = newFull_\n-- </boilerplate>\n--------------------------------------------------------------------------------\n'