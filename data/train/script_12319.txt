b'-- Part of this code is taken and adapted from:\n-- https://wiki.haskell.org/WxHaskell/Quick_start#Hello_world_in_wxHaskell\nmodule Main where\n\nimport Prelude hiding ((.))\nimport Control.Category\nimport Control.Monad\nimport Data.IORef\nimport Data.MonadicStreamFunction\nimport Data.MonadicStreamFunction.InternalCore\nimport Graphics.UI.WX\n\nmain :: IO ()\nmain = start $ do\n  f      <- frame      []\n  lenLbl <- staticText f [ text := "0" ]\n  entry  <- textEntry  f []\n  quit   <- button     f [ text := "Quit", on command := close f ]\n\n  -- Reactive network\n  let appMSF = labelTextSk lenLbl . arr (show.length) . textEntryTextSg entry\n\n  -- appMSF =\n  --   textEntryTextSg entry >>> arr (show.length) >>> labelTextSk lenLbl\n\n  hndlr <- pushReactimate_ appMSF\n\n  set entry [ on update := hndlr ]\n\n  set f [layout := margin 10 (column 5 [ floatCentre (widget lenLbl)\n                                       , floatCentre (widget entry)\n                                       , floatCentre (widget quit)\n                                       ] )]\n\n\n-- * Auxiliary definitions\n\n-- ** Adhoc Dunai-WX backend\ntextEntryTextSg :: TextCtrl a -> MStream IO String\ntextEntryTextSg entry = constM (get entry text)\n\nlabelTextSk :: StaticText a -> MSink IO String\nlabelTextSk lbl = arrM $ setJust lbl text\n  -- (\\t -> set lbl [ text := t ])\n\n-- ** MSF-related definitions and extensions\n\n-- | Run an MSF on an input sample step by step, using an IORef to store the\n-- continuation.\npushReactimate :: MSF IO a b -> IO (a -> IO b)\npushReactimate msf = do\n  msfRef <- newIORef msf\n  return $ \\a -> do\n              msf\' <- readIORef msfRef\n              (b, msf\'\') <- unMSF msf\' a\n              writeIORef msfRef msf\'\'\n              return b\n\n-- | Run one step of an MSF on () streams, internally storing the\n-- continuation.\npushReactimate_ :: MSF IO () () -> IO (IO ())\npushReactimate_ msf = do\n  f <- pushReactimate msf\n  return (void (f ()))\n\n-- ** Auxiliary WX functions\nsetJust :: widget -> Attr widget attr -> attr -> IO ()\nsetJust c p v = set c [ p := v ]\n'