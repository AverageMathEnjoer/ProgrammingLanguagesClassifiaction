b'{-# LANGUAGE\n    DeriveDataTypeable\n  , DeriveGeneric\n  , LambdaCase\n  , OverloadedStrings\n  , ScopedTypeVariables\n  #-}\nmodule Api.Test\n  ( resource\n  , WithText\n  , Err (..)\n  , Ok (..)\n  ) where\n\nimport Control.Monad.Except\nimport Control.Monad.Reader\nimport Data.Aeson\nimport Data.ByteString.Lazy (ByteString)\nimport Data.Data\nimport Data.JSON.Schema\nimport Data.Maybe\nimport Data.Text (Text)\nimport GHC.Generics\nimport Generics.Generic.Aeson\nimport Generics.XmlPickler\nimport Safe\nimport Text.XML.HXT.Arrow.Pickle\n\nimport Rest\nimport Rest.Dictionary\nimport qualified Rest.Driver.Perform as Driver (accept)\nimport qualified Rest.Resource       as R\n\nimport ApiTypes\nimport qualified Api.Test.Err2 as E2\n\n-- | User extends the root of the API with a reader containing the ways to identify a user in our URLs.\n-- Currently only by the user name.\ntype WithText = ReaderT Text BlogApi\n\ndata Err = Err deriving (Generic, Show, Typeable)\ninstance ToJSON     Err where toJSON    = gtoJson\ninstance FromJSON   Err where parseJSON = gparseJson\ninstance JSONSchema Err where schema    = gSchema\ninstance XmlPickler Err where xpickle   = gxpickle\n\ninstance ToResponseCode Err where\n  toResponseCode _ = 400\n\ndata Ok = Ok deriving (Generic, Show, Typeable)\ninstance XmlPickler Ok where xpickle = gxpickle\ninstance ToJSON     Ok where toJSON    = gtoJson\ninstance FromJSON   Ok where parseJSON = gparseJson\ninstance JSONSchema Ok where schema    = gSchema\n\nresource :: Resource BlogApi WithText Text Void Void\nresource = mkResourceReader\n  { R.name    = "test"\n  , R.actions = [ ("noResponse"         , noResponse         )\n                , ("onlyError"          , onlyError          )\n                , ("differentFormats"   , differentFormats   )\n                , ("intersectedFormats" , intersectedFormats )\n                , ("intersectedFormats2", intersectedFormats2)\n                , ("rawXmlIO"           , rawXmlIO           )\n                , ("rawJsonIO"          , rawJsonIO          )\n                , ("rawJsonAndXmlI"     , rawJsonAndXmlI_    )\n                , ("rawJsonAndXmlO"     , rawJsonAndXmlO_    )\n                , ("noError"            , noError            )\n                , ("justStringO"        , justStringO        )\n                , ("preferJson"         , preferJson         )\n                , ("octetStreamOut"     , octetStreamOut     )\n                , ("onlyInput"          , onlyInput          )\n                ]\n  }\n\nnoResponse :: Handler WithText\nnoResponse = mkConstHandler id $ return ()\n\nonlyError :: Handler WithText\nonlyError = mkConstHandler jsonE $\n  throwError $ domainReason Err\n\ndifferentFormats :: Handler WithText\ndifferentFormats = mkInputHandler (jsonE . xmlO . stringI) $\n  \\case\n    "error" -> throwError $ domainReason Err\n    _       -> return Ok\n\nintersectedFormats :: Handler WithText\nintersectedFormats = mkInputHandler (jsonE . xmlO . jsonO . stringI) $\n  \\case\n    "error" -> throwError $ domainReason Err\n    _       -> return Ok\n\nintersectedFormats2 :: Handler WithText\nintersectedFormats2 = mkInputHandler (xmlE . xmlO . jsonO . stringI) $\n  \\case\n    "error" -> throwError $ domainReason Err\n    _       -> return Ok\n\nrawXmlIO :: Handler WithText\nrawXmlIO = mkIdHandler (rawXmlI . rawXmlO . xmlE) $ \\s _ ->\n  case s of\n    "<error/>" -> throwError $ domainReason E2.Err\n    _          -> return "<ok/>"\n\nrawJsonIO :: Handler WithText\nrawJsonIO = mkIdHandler (rawJsonI . rawJsonO . jsonE) $ \\s _ ->\n  case s of\n    "\\"error\\"" -> throwError $ domainReason E2.Err\n    _           -> return "\\"ok\\""\n\nrawJsonAndXmlI_ :: Handler WithText\nrawJsonAndXmlI_ = mkInputHandler (stringO . rawJsonAndXmlI) handler\n  where\n    handler :: Either Json Xml -> ExceptT Reason_ WithText String\n    handler = return . \\case\n      Left (Json _) -> "json input"\n      Right (Xml _) -> "xml input"\n\nrawJsonAndXmlO_ :: Handler WithText\nrawJsonAndXmlO_ = mkHandler (addHeader contentType . mkHeader accept . mkPar typeParam . rawJsonAndXmlO) handler\n  where\n    handler :: Env (Maybe String, Maybe String) (Maybe String) () -> ExceptT Reason_ WithText ByteString\n    handler (Env (mContentType, mAccept) mType ()) = do\n      let accs = Driver.accept mAccept mContentType mType\n      if JsonFormat `elem` accs\n        then return "\\"json\\""\n        else if XmlFormat `elem` accs\n          then return "<xml/>"\n          else throwError . OutputError $ UnsupportedFormat "Only json and xml accept headers are allowed"\n    contentType :: Header (Maybe String)\n    contentType  = Header ["Content-Type"] (return . headMay . catMaybes)\n    typeParam   :: Param (Maybe String)\n    typeParam    = Param ["type"] (return . headMay . catMaybes)\n    accept      :: Header (Maybe String)\n    accept       = Header ["Accept"] (return . headMay . catMaybes)\n\nnoError :: Handler WithText\nnoError = mkConstHandler jsonO $ return Ok\n\njustStringO :: Handler WithText\njustStringO = mkConstHandler stringO $ return "Ok"\n\npreferJson :: Handler WithText\npreferJson = mkInputHandler (xmlJsonO . xmlJsonE . stringI) $\n  \\case\n    "error" -> throwError $ domainReason Err\n    _       -> return Ok\n\noctetStreamOut :: Handler WithText\noctetStreamOut = mkInputHandler (fileI . fileO . xmlJsonE) $\n  \\case\n    "error" -> throwError $ domainReason Err\n    _       -> return ("ok", "ok", False)\n\nonlyInput :: Handler WithText\nonlyInput = mkInputHandler jsonI $ \\() -> throwError NotFound\n'