b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE NoImplicitPrelude   #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Course.ValidationSpec where\n\nimport qualified Prelude               as P (either, fmap)\nimport           Test.Hspec               (Spec, describe, it, shouldBe)\nimport           Test.Hspec.QuickCheck    (prop)\nimport Test.QuickCheck (Arbitrary(..), (===), (.||.))\n\nimport           Course.Core\nimport           Course.Validation\n\ninstance Arbitrary a => Arbitrary (Validation a) where\n  arbitrary = P.fmap (P.either Error Value) arbitrary\n\nspec :: Spec\nspec = do\n  describe "isError" $ do\n    it "true for errors" $\n      isError (Error "Message") `shouldBe` True\n    it "false for values" $\n      isError (Value "7") `shouldBe` False\n    prop "not the same as isValue" $\n      \\(x :: Validation Int) -> isError x /= isValue x\n\n  describe "isValue" $ do\n    it "false for errors" $\n      isValue (Error "Message") `shouldBe` False\n    it "false for values" $\n      isValue (Value "7") `shouldBe` True\n    prop "not the same as isValue" $\n      \\(x :: Validation Int) -> isValue x /= isError x\n\n  describe "mapValidation" $ do\n    it "errors unchanged" $\n      mapValidation (+ 10) (Error "message") `shouldBe` Error "message"\n    it "values changed" $\n      mapValidation (+ 10) (Value 7) `shouldBe` Value 17\n    prop "map with id causes no change" $\n      \\(x :: Validation Int) -> mapValidation id x === x\n\n  let\n    f n =\n      if even n\n      then Value (n + 10)\n      else Error "odd"\n  describe "bindValidation" $ do\n    it "error unchanged" $\n      bindValidation f (Error "message") `shouldBe` Error "message"\n    it "odd value" $\n      bindValidation f (Value 7) `shouldBe` Error "odd"\n    it "even value" $\n      bindValidation f (Value 8) `shouldBe` Value 18\n    prop "bind with Value causes no change" $\n      \\(x :: Validation Int) -> bindValidation Value x === x\n\n  describe "valueOr" $ do\n    it "falls through for errors" $\n      valueOr (Error "message") "foo" `shouldBe` "foo"\n    it "unwraps values" $\n      valueOr (Value "foo") "bar" `shouldBe` "foo"\n    prop "isValue or valueOr falls through" $\n      \\(x :: Validation Int) n -> isValue x .||. valueOr x n === n\n\n  describe "errorOr" $ do\n    it "unwraps errors" $\n      errorOr (Error "message") "q" `shouldBe` "message"\n    it "falls through for values" $\n      errorOr (Value (7 :: Integer)) "q" `shouldBe` "q"\n    prop "isError or errorOr falls through" $\n      \\(x :: Validation Int) n -> isError x .||. errorOr x n === n\n'