b'#include "AppContext.h"\n#include <InternalBundleReplacer.h>\n#include <assert.h>\n#include <tuple>\n#include <filesystem>\n#include "../libStringConverter/convert.h"\n\nAppContext::FileOpenTask::FileOpenTask(AppContext *pContext, std::shared_ptr<IAssetsReader> _pReader, bool readerIsModified, const std::string &path,\n\tunsigned int parentFileID, unsigned int directoryEntryIdx,\n\tbool tryAsBundle, bool tryAsAssets, bool tryAsResources, bool tryAsGeneric) :\n\tpContext(pContext), pReader(std::move(_pReader)), readerIsModified(readerIsModified), filePath(path), pFileContext(nullptr),\n\tparentFileID(parentFileID), directoryEntryIdx(directoryEntryIdx),\n\ttryAsBundle(tryAsBundle), tryAsAssets(tryAsAssets), tryAsResources(tryAsResources), tryAsGeneric(tryAsGeneric)\n{\n\tname = "Open file: " + path;\n}\nvoid AppContext::FileOpenTask::setParentContextInfo(std::shared_ptr<BundleFileContextInfo> &pContextInfo)\n{\n\tthis->pParentContextInfo = pContextInfo;\n}\nconst std::string &AppContext::FileOpenTask::getName()\n{\n\treturn name;\n}\nTaskResult AppContext::FileOpenTask::execute(TaskProgressManager &progressManager)\n{\n\t//TODO (maybe) : make this task cancelable\n\tthis->pFileContext = nullptr;\n\tthis->bundleOpenStatus = (EBundleFileOpenStatus)0;\n\tthis->assetsOpenStatus = (EAssetsFileOpenStatus)0;\n\tif (tryAsBundle)\n\t{\n\t\tprogressManager.setProgressDesc("Opening as a bundle file");\n\t\tBundleFileContext *pBundleContext = new BundleFileContext(filePath, pReader, readerIsModified);\n\t\tEBundleFileOpenStatus bundleOpenStatus = pBundleContext->OpenInsideTask(&progressManager, 0, 200);\n\t\tif (bundleOpenStatus >= 0 && bundleOpenStatus != BundleFileOpenStatus_Pend)\n\t\t{\n\t\t\tprogressManager.setProgress(200, 200);\n\t\t\tthis->pFileContext = pBundleContext;\n\t\t\tthis->bundleOpenStatus = bundleOpenStatus;\n\t\t\treturn 1;\n\t\t}\n\t\tdelete pBundleContext;\n\t}\n\tif (tryAsAssets)\n\t{\n\t\tprogressManager.setProgressDesc("Opening as a .assets file");\n\t\tAssetsFileContext *pAssetsContext = new AssetsFileContext(filePath, pReader, readerIsModified);\n\t\tEAssetsFileOpenStatus assetsOpenStatus = pAssetsContext->OpenInsideTask(&progressManager, true, 100, 200);\n\t\tif (assetsOpenStatus >= 0 && assetsOpenStatus != AssetsFileOpenStatus_Pend)\n\t\t{\n\t\t\tprogressManager.setProgress(200, 200);\n\t\t\tthis->pFileContext = pAssetsContext;\n\t\t\tthis->assetsOpenStatus = assetsOpenStatus;\n\t\t\treturn 2;\n\t\t}\n\t\tdelete pAssetsContext;\n\t}\n\tif (tryAsResources/* && ((filePath.size() >= 5 && !filePath.compare(filePath.size() - 5, std::string::npos, ".resS"))\n\t\t|| (filePath.size() >= 9 && !filePath.compare(filePath.size() - 9, std::string::npos, ".resource"))\n\t\t|| (filePath.size() >= 10 && !filePath.compare(filePath.size() - 10, std::string::npos, ".resources")))*/)\n\t{\n\t\tprogressManager.setProgressDesc("Opening as a resources file");\n\t\tResourcesFileContext *pResourcesContext = new ResourcesFileContext(filePath, pReader, readerIsModified);\n\t\tEResourcesFileOpenStatus resourcesOpenStatus = pResourcesContext->Open();\n\t\tif (resourcesOpenStatus >= 0)\n\t\t{\n\t\t\tprogressManager.setProgress(200, 200);\n\t\t\tthis->pFileContext = pResourcesContext;\n\t\t\treturn 3;\n\t\t}\n\t\tdelete pResourcesContext;\n\t}\n\tif (tryAsGeneric)\n\t{\n\t\tprogressManager.setProgressDesc("Opening as a generic file");\n\t\tGenericFileContext *pGenericContext = new GenericFileContext(filePath, pReader, readerIsModified);\n\t\tEGenericFileOpenStatus genericOpenStatus = pGenericContext->Open();\n\t\tif (genericOpenStatus >= 0)\n\t\t{\n\t\t\tprogressManager.setProgress(200, 200);\n\t\t\tthis->pFileContext = pGenericContext;\n\t\t\treturn 4;\n\t\t}\n\t\tdelete pGenericContext;\n\t}\n\tthis->pReader.reset();\n\treturn -1;\n}\n\nAppContext::AppContext()\n\t: taskManager(1), maxFileID(0), lastError(0), autoDetectDependencies(true)\n{\n\ttaskManager.addCallback(this);\n}\nAppContext::~AppContext(void)\n{\n\t//contextInfo.clear();\n\t//contextInfoByFileID.clear();\n}\n\nvoid AppContext::OnCompletion(std::shared_ptr<ITask> &pTask, TaskResult result)\n{\n\tif (std::shared_ptr<FileOpenTask> pFileOpenTask = std::dynamic_pointer_cast<FileOpenTask>(pTask))\n\t{\n\t\tswitch (result)\n\t\t{\n\t\tcase -1:\n\t\t\tsignalMainThread(AppContextMsg_OnFileOpenFail, new std::shared_ptr<FileOpenTask>(pFileOpenTask));\n\t\t\tbreak;\n\t\tcase 1: //bundle\n\t\t\tsignalMainThread(AppContextMsg_OnFileOpenAsBundle, new std::shared_ptr<FileOpenTask>(pFileOpenTask));\n\t\t\tbreak;\n\t\tcase 2: //.assets\n\t\t\tsignalMainThread(AppContextMsg_OnFileOpenAsAssets, new std::shared_ptr<FileOpenTask>(pFileOpenTask));\n\t\t\tbreak;\n\t\tcase 3: //resources\n\t\t\tsignalMainThread(AppContextMsg_OnFileOpenAsResources, new std::shared_ptr<FileOpenTask>(pFileOpenTask));\n\t\t\tbreak;\n\t\tcase 4: //generic\n\t\t\tsignalMainThread(AppContextMsg_OnFileOpenAsGeneric, new std::shared_ptr<FileOpenTask>(pFileOpenTask));\n\t\t\tbreak;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\telse if (auto pContainersTask = std::dynamic_pointer_cast<AssetsFileContextInfo::ContainersTask>(pTask))\n\t{\n\t\tsignalMainThread(AppContextMsg_OnContainersLoaded, new std::shared_ptr<AssetsFileContextInfo::ContainersTask>(pContainersTask));\n\t}\n\telse if (auto pDecompressTask = std::dynamic_pointer_cast<BundleFileContextInfo::DecompressTask>(pTask))\n\t{\n\t\tsignalMainThread(AppContextMsg_OnBundleDecompressed,\n\t\t\tnew std::tuple<std::shared_ptr<BundleFileContextInfo::DecompressTask>,TaskResult>(pDecompressTask, result));\n\t}\n}\nbool AppContext::processMessage(EAppContextMsg message, void *args)\n{\n\tswitch (message)\n\t{\n\tcase AppContextMsg_OnFileOpenFail:\n\t\t{\n\t\t\tauto ppTask = (std::shared_ptr<FileOpenTask>*)args;\n\t\t\tthis->OnFileOpenFail(*ppTask, (*ppTask)->logText);\n\t\t\tdelete ppTask;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnFileOpenAsBundle:\n\t\t{\n\t\t\tauto ppTask = (std::shared_ptr<FileOpenTask>*)args;\n\t\t\tFileOpenTask *_pTask = (*ppTask).get();\n\t\t\tthis->OnFileOpenAsBundle(*ppTask, (BundleFileContext*)_pTask->pFileContext, _pTask->bundleOpenStatus, _pTask->parentFileID, _pTask->directoryEntryIdx);\n\t\t\tdelete ppTask;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnFileOpenAsAssets:\n\t\t{\n\t\t\tauto ppTask = (std::shared_ptr<FileOpenTask>*)args;\n\t\t\tFileOpenTask *_pTask = (*ppTask).get();\n\t\t\tthis->OnFileOpenAsAssets(*ppTask, (AssetsFileContext*)_pTask->pFileContext, _pTask->assetsOpenStatus, _pTask->parentFileID, _pTask->directoryEntryIdx);\n\t\t\tdelete ppTask;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnFileOpenAsResources:\n\t\t{\n\t\t\tauto ppTask = (std::shared_ptr<FileOpenTask>*)args;\n\t\t\tFileOpenTask *_pTask = (*ppTask).get();\n\t\t\tthis->OnFileOpenAsResources(*ppTask, (ResourcesFileContext*)_pTask->pFileContext, _pTask->parentFileID, _pTask->directoryEntryIdx);\n\t\t\tdelete ppTask;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnFileOpenAsGeneric:\n\t\t{\n\t\t\tauto ppTask = (std::shared_ptr<FileOpenTask>*)args;\n\t\t\tFileOpenTask *_pTask = (*ppTask).get();\n\t\t\tthis->OnFileOpenAsGeneric(*ppTask, (GenericFileContext*)_pTask->pFileContext, _pTask->parentFileID, _pTask->directoryEntryIdx);\n\t\t\tdelete ppTask;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnContainersLoaded:\n\t\t{\n\t\t\tauto ppTask = (std::shared_ptr<AssetsFileContextInfo::ContainersTask>*)args;\n\t\t\tOnGenerateContainers((*ppTask)->getFileContextInfo());\n\t\t\tdelete ppTask;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnBundleDecompressed:\n\t\t{\n\t\t\tauto *pInfo = (std::tuple<std::shared_ptr<BundleFileContextInfo::DecompressTask>,TaskResult>*)args;\n\t\t\tauto pTask = std::get<0>(*pInfo);\n\t\t\tOnDecompressBundle(pTask.get(), std::get<1>(*pInfo));\n\t\t\tdelete pInfo;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnAssetChanged:\n\t\t{\n\t\t\tauto *pInfo = (std::tuple<unsigned int,pathid_t,bool>*)args;\n\t\t\tstd::shared_lock contextInfoMapLock(this->contextInfoMapMutex);\n\t\t\tauto contextInfoIt = contextInfoByFileID.find(std::get<0>(*pInfo));\n\t\t\tif (contextInfoIt != contextInfoByFileID.end())\n\t\t\t{\n\t\t\t\tstd::shared_ptr<AssetsFileContextInfo> pFile = std::dynamic_pointer_cast<AssetsFileContextInfo>(contextInfoIt->second);\n\t\t\t\tcontextInfoMapLock.unlock();\n\t\t\t\tassert(pFile);\n\t\t\t\tif (pFile)\n\t\t\t\t\tOnChangeAsset(pFile.get(), std::get<1>(*pInfo), std::get<2>(*pInfo));\n\t\t\t}\n\t\t\tdelete pInfo;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_DoMainThreadCallback:\n\t\t{\n\t\t\tauto *pInfo = (std::tuple<void(*)(uintptr_t,uintptr_t), uintptr_t, uintptr_t>*)args;\n\t\t\tstd::get<0>(*pInfo)(std::get<1>(*pInfo), std::get<2>(*pInfo));\n\t\t\tdelete pInfo;\n\t\t}\n\t\treturn true;\n\tcase AppContextMsg_OnBundleEntryChanged:\n\t\t{\n\t\t\tauto *pInfo = (std::tuple<unsigned int,size_t>*)args;\n\t\t\tstd::shared_lock contextInfoMapLock(this->contextInfoMapMutex);\n\t\t\tauto contextInfoIt = contextInfoByFileID.find(std::get<0>(*pInfo));\n\t\t\tif (contextInfoIt != contextInfoByFileID.end())\n\t\t\t{\n\t\t\t\tstd::shared_ptr<BundleFileContextInfo> pFile = std::dynamic_pointer_cast<BundleFileContextInfo>(contextInfoIt->second);\n\t\t\t\tcontextInfoMapLock.unlock();\n\t\t\t\tassert(pFile);\n\t\t\t\tif (pFile)\n\t\t\t\t\tOnChangeBundleEntry(pFile.get(), std::get<1>(*pInfo));\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontextInfoMapLock.unlock();\n\t\t\tdelete pInfo;\n\t\t}\n\t\treturn true;\n\tdefault:\n#ifdef _DEBUG\n\t\tassert(false);\n#endif\n\t\treturn false;\n\t}\n}\nvoid AppContext::OnDecompressBundle(BundleFileContextInfo::DecompressTask *pTask, TaskResult result)\n{}\nstd::shared_ptr<FileContextInfo> AppContext::OnFileOpenAsBundle(std::shared_ptr<FileOpenTask> pTask, BundleFileContext *pContext, EBundleFileOpenStatus openStatus, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tBundleFileContextInfo *pBundleInfo = new BundleFileContextInfo(pContext, 0, parentFileID);\n\tstd::shared_ptr<FileContextInfo> pInfo(pBundleInfo);\n\t\n\t//Carry on the VisibleFileEntry from the FileOpenTask.\n\t//-> The bundle file itself applies the replacer modifications\n\tpBundleInfo->modificationsToApply = std::move(pTask->modificationsToApply);\n\n\tAddContextInfo(pInfo, directoryEntryIdx);\n\treturn pInfo;\n}\nstd::shared_ptr<FileContextInfo> AppContext::OnFileOpenAsAssets(std::shared_ptr<FileOpenTask> pTask, AssetsFileContext *pContext, EAssetsFileOpenStatus openStatus, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tAssetsFileContextInfo *pAssetsInfo = new AssetsFileContextInfo(pContext, 0, parentFileID);\n\tstd::shared_ptr<FileContextInfo> pInfo(pAssetsInfo);\n\n\t//Apply all AssetsReplacers for this file from a VisibleFileEntry, if existent.\n\tfor (size_t i = 0; pTask->modificationsToApply && i < pTask->modificationsToApply->replacers.size(); ++i)\n\t{\n\t\tstd::shared_ptr<GenericReplacer> &pGenericReplacer = pTask->modificationsToApply->replacers[i].pReplacer;\n\t\tif (std::shared_ptr<AssetsReplacer> pAssetsReplacer = std::dynamic_pointer_cast<AssetsReplacer>(pGenericReplacer))\n\t\t{\n\t\t\tif (pAssetsReplacer->GetType() == AssetsReplacement_AddOrModify\n\t\t\t\t|| pAssetsReplacer->GetType() == AssetsReplacement_Remove)\n\t\t\t{\n\t\t\t\tpAssetsInfo->addReplacer(std::reinterpret_pointer_cast<AssetsEntryReplacer>(pAssetsReplacer), *this, true, false);\n\t\t\t}\n\t\t\telse if (pAssetsReplacer->GetType() == AssetsReplacement_Dependencies)\n\t\t\t{\n\t\t\t\tAssetsDependenciesReplacer *pReplacer = reinterpret_cast<AssetsDependenciesReplacer*>(pAssetsReplacer.get());\n\t\t\t\tauto refLock = pAssetsInfo->lockReferencesWrite();\n\t\t\t\tconst std::vector<AssetsFileDependency> &dependencies = pReplacer->GetDependencies();\n\t\t\t\tpAssetsInfo->getDependenciesWrite(refLock) = dependencies;\n\t\t\t\tpAssetsInfo->getReferencesWrite(refLock).clear();\n\t\t\t\tpAssetsInfo->getReferencesWrite(refLock).resize(dependencies.size(), 0);\n\t\t\t\tpAssetsInfo->setDependenciesChanged();\n\t\t\t}\n\t\t}\n\t}\n\n\tAddContextInfo(pInfo, directoryEntryIdx);\n\treturn pInfo;\n}\nstd::shared_ptr<FileContextInfo> AppContext::OnFileOpenAsResources(std::shared_ptr<FileOpenTask> pTask, ResourcesFileContext *pContext, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tResourcesFileContextInfo *pResourcesInfo = new ResourcesFileContextInfo(pContext, 0, parentFileID);\n\tstd::shared_ptr<FileContextInfo> pInfo(pResourcesInfo);\n\n\t//Apply the BundleEntryModifierByResources for this file from a VisibleFileEntry, if existent.\n\tif (pTask->modificationsToApply && pTask->modificationsToApply->replacers.size() == 1\n\t\t&& dynamic_cast<BundleEntryModifierByResources*>(pTask->modificationsToApply->replacers[0].pReplacer.get()) != nullptr)\n\t{\n\t\tstd::shared_ptr<GenericReplacer> pGenericReplacer = pTask->modificationsToApply->replacers[0].pReplacer;\n\t\tbool result = pResourcesInfo->setByReplacer(*this, reinterpret_cast<BundleReplacer*>(pGenericReplacer.get()));\n\t\tassert(result);\n\t}\n\n\tAddContextInfo(pInfo, directoryEntryIdx);\n\treturn pInfo;\n}\nstd::shared_ptr<FileContextInfo> AppContext::OnFileOpenAsGeneric(std::shared_ptr<FileOpenTask> pTask, GenericFileContext *pContext, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tGenericFileContextInfo *pGenericInfo = new GenericFileContextInfo(pContext, 0, parentFileID);\n\tstd::shared_ptr<FileContextInfo> pInfo(pGenericInfo);\n\n\tAddContextInfo(pInfo, directoryEntryIdx);\n\treturn pInfo;\n}\nvoid AppContext::OnFileOpenFail(std::shared_ptr<FileOpenTask> pTask, std::string &logText)\n{\n}\nstd::shared_ptr<ITask> AppContext::CreateFileOpenTask(const std::string &path, bool basedOnExistingFile)\n{\n\tstd::string actualPath = path;\n\tstd::shared_ptr<IAssetsReader> pReader;\n\tif (actualPath.size() >= 7 && !actualPath.compare(actualPath.size() - 7, std::string::npos, ".split0"))\n\t{\n\t\tactualPath = actualPath.substr(0, actualPath.size() - 7);\n\t\tpReader = std::shared_ptr<IAssetsReader>(\n\t\t\tCreate_AssetsReaderFromSplitFile(actualPath.c_str(), true, false, RWOpenFlags_Immediately), \n\t\t\tFree_AssetsReader);\n\t}\n\telse\n\t{\n\t\tpReader = std::shared_ptr<IAssetsReader>(\n\t\t\tCreate_AssetsReaderFromFile(actualPath.c_str(), true, RWOpenFlags_Immediately), \n\t\t\tFree_AssetsReader);\n\t\tif (!pReader)\n\t\t{\n\t\t\tstd::string splitPath = path + ".split0";\n\t\t\tpReader = std::shared_ptr<IAssetsReader>(\n\t\t\t\tCreate_AssetsReaderFromSplitFile(splitPath.c_str(), true, false, RWOpenFlags_Immediately), \n\t\t\t\tFree_AssetsReader);\n\t\t}\n\t}\n\tif (!pReader && !basedOnExistingFile)\n\t{\n\t\t//Create an empty reader.\n\t\tpReader = std::shared_ptr<IAssetsReader>(\n\t\t\tCreate_AssetsReaderFromMemory(nullptr, 0, false, nullptr),\n\t\t\tFree_AssetsReader);\n\t}\n\tif (!pReader)\n\t{\n\t\tlastError = AppContextErr_FileNotFound;\n\t\treturn nullptr;\n\t}\n\tbool tryAsResources = false;\n\tif ((actualPath.size() >= 5 && !strnicmp(&path.data()[path.size() - 5], ".ress", 5))\n\t\t|| (actualPath.size() >= 10 && !strnicmp(&path.data()[path.size() - 10], ".resources", 10))\n\t\t|| (actualPath.size() >= 9 && !strnicmp(&path.data()[path.size() - 9], ".resource", 9)))\n\t\ttryAsResources = true;\n\treturn std::shared_ptr<ITask>(new FileOpenTask(this, std::move(pReader), false, path, 0, 0, true, true, tryAsResources, false));\n}\nstd::shared_ptr<ITask> AppContext::CreateBundleEntryOpenTask(std::shared_ptr<BundleFileContextInfo> &pBundleContextInfo, unsigned int directoryEntryIdx)\n{\n\t{\n\t\tBundleFileContext *pBundleContext = pBundleContextInfo->getBundleFileContext();\n\t\tstd::string entryName = pBundleContextInfo->getNewEntryName(directoryEntryIdx);\n\t\t//pBundleContextInfo->modificationsToApply.replacers\n\t\tbool readerIsModified = false;\n\t\tstd::shared_ptr<IAssetsReader> pChildReader = pBundleContextInfo->makeEntryReader(directoryEntryIdx, readerIsModified);\n\t\tif (!pChildReader)\n\t\t\treturn nullptr;\n\t\tbool tryAsResources = false;\n\t\tif ((entryName.size() >= 5 && !entryName.compare(entryName.size() - 5, std::string::npos, ".resS"))\n\t\t\t|| (entryName.size() >= 9 && !entryName.compare(entryName.size() - 9, std::string::npos, ".resource"))\n\t\t\t|| (entryName.size() >= 10 && !entryName.compare(entryName.size() - 10, std::string::npos, ".resources")))\n\t\t\ttryAsResources = true;\n\t\tFileOpenTask *ret = new FileOpenTask(this, std::move(pChildReader), readerIsModified, entryName, pBundleContextInfo->getFileID(), directoryEntryIdx, true, true, tryAsResources, true);\n\t\tret->setParentContextInfo(pBundleContextInfo);\n\t\t\n\t\tif (pBundleContextInfo->modificationsToApply != nullptr)\n\t\t{\n\t\t\t//If we have a matching subFile in the VisibleFileEntry, move it to the entry open task.\n\t\t\t// -> Each subFile entry is generated by parsing a BundleReplacer based on an existing file:\n\t\t\t//    => BundleEntryModifierFromAssets\n\t\t\t//    => BundleEntryModifierFromBundle\n\t\t\t//    => BundleEntryModifierByResources if at least one resource has fromOriginalFile set to true.\n\t\t\t// -> Note: BundleFileContextInfo::onDirectoryReady handles BundleEntryModifierByResources replacer entries\n\t\t\t//          by creating a bundle directory entry with an empty reader\n\t\t\t//          and then adding a new subFile entry to modificationsToApply with the same replacer.\n\t\t\t//TODO: Put some faster name lookup table in the BundleFileContextInfo (running this loop for every bundle entry -> O(N\xb2) time).\n\t\t\tfor (size_t _i = pBundleContextInfo->modificationsToApply->subFiles.size(); _i > 0; --_i)\n\t\t\t{\n\t\t\t\tsize_t i = _i - 1;\n\t\t\t\tVisibleFileEntry &subFile = pBundleContextInfo->modificationsToApply->subFiles[i];\n\t\t\t\tif (!stricmp(entryName.c_str(), subFile.pathNull ? subFile.newName.c_str() : subFile.pathOrName.c_str()))\n\t\t\t\t{\n\t\t\t\t\tthis->OpenTask_SetModifications(ret, std::make_unique<VisibleFileEntry>(std::move(subFile)));\n\t\t\t\t\tpBundleContextInfo->modificationsToApply->subFiles.erase(pBundleContextInfo->modificationsToApply->subFiles.begin() + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn std::shared_ptr<ITask>(ret);\n\t}\n\treturn nullptr;\n}\nvoid AppContext::OpenTask_SetModifications(ITask *pTask, std::unique_ptr<class VisibleFileEntry> modificationsToApply) \n{\n\tFileOpenTask *pFileOpenTask = dynamic_cast<FileOpenTask*>(pTask);\n\tif (pFileOpenTask == nullptr)\n\t\tthrow std::invalid_argument("OpenTask_SetModifications: pTask is not a FileOpenTask.");\n\tpFileOpenTask->modificationsToApply = std::move(modificationsToApply);\n}\nstatic const char *getDependencyFileName(const char *dependency)\n{\n\tconst char *fileName = dependency;\n\t//if (!strncmp(dependency, "archive:/", 9))\n\t//\tfileName = &dependency[9];\n\tconst char *subFileName = strrchr(fileName, \'/\');\n\tif (subFileName != nullptr)\n\t\tfileName = subFileName + 1;\n\treturn fileName;\n}\nunsigned int AppContext::TryResolveDependency(AssetsFileContextInfo* pFileFrom, const AssetsFileDependency& dependency, bool allowSeveral)\n{\n\tif (dependency.type != 0)\n\t\treturn 0;\n\tconst char* depFileName = getDependencyFileName(dependency.assetPath);\n\tbool hasSeveralCandidates = false;\n\tsize_t candidateIdx = (size_t)-1;\n\tfor (size_t k = 0; k < contextInfo.size(); k++)\n\t{\n\t\tIFileContext* pFileContext = contextInfo[k]->getFileContext();\n\t\tif (pFileContext->getType() == FileContext_Assets &&\n\t\t\t!stricmp(depFileName, contextInfo[k]->getFileName().c_str()))\n\t\t{\n\t\t\tif (candidateIdx != (size_t)-1)\n\t\t\t{\n\t\t\t\thasSeveralCandidates = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidateIdx = k;\n\t\t}\n\t}\n\t//Only resolve the dependency if there is exactly one match.\n\tif (candidateIdx != (size_t)-1 && (!hasSeveralCandidates || allowSeveral))\n\t{\n\t\treturn contextInfo[candidateIdx]->getFileID();\n\t}\n\treturn 0;\n}\nbool AppContext::AddContextInfo(std::shared_ptr<FileContextInfo> &info, unsigned int directoryEntryIdx)\n{\n\tstd::vector<std::pair<AssetsFileContextInfo*,size_t>> dependencyCallbackArgs; //Receives arguments for OnUpdateDependencies calls.\n\tbool ret = true;\n\tinfo->fileID = ++maxFileID;\n\tif (autoDetectDependencies && info->getFileContext() && info->getFileContext()->getType() == FileContext_Assets\n\t\t&& static_cast<AssetsFileContext*>(info->getFileContext())->getAssetsFile())\n\t{\n\t\tif (AssetsFileContextInfo *pNewAssetsInfo = dynamic_cast<AssetsFileContextInfo*>(info.get()))\n\t\t{\n\t\t\tauto refLock = pNewAssetsInfo->lockReferencesWrite();\n\t\t\tstd::vector<unsigned int> &references = pNewAssetsInfo->getReferencesWrite(refLock);\n\t\t\tconst std::vector<AssetsFileDependency> &dependencies = pNewAssetsInfo->getDependenciesWrite(refLock);\n\t\t\tassert(references.size() == dependencies.size());\n\t\t\t//Resolve references for the newly loaded file.\n\t\t\tfor (size_t i = 0; i < dependencies.size(); i++)\n\t\t\t{\n\t\t\t\t//For each dependency, look for a previously loaded file that matches the name.\n\t\t\t\tif (i >= references.size())\n\t\t\t\t\tbreak;\n\t\t\t\tconst AssetsFileDependency *pDependency = &dependencies[i];\n\t\t\t\treferences[i] = TryResolveDependency(pNewAssetsInfo, dependencies[i], false);\n\t\t\t}\n\t\t\trefLock.unlock();\n\n\t\t\t//Resolve references for previously loaded files.\n\t\t\tstd::string newFileName = info->getFileName();\n\t\t\tfor (size_t iContext = 0; iContext < contextInfo.size(); iContext++)\n\t\t\t{\n\t\t\t\t//For each loaded Assets file context, check if the new file resolves a missing dependency.\n\t\t\t\tIFileContext *pPrevFileContext = contextInfo[iContext]->getFileContext();\n\t\t\t\tif (pPrevFileContext->getType() != FileContext_Assets\n\t\t\t\t\t|| !static_cast<AssetsFileContext*>(pPrevFileContext)->getAssetsFile())\n\t\t\t\t\tcontinue;\n\t\t\t\tif (AssetsFileContextInfo *pPrevAssetsInfo = dynamic_cast<AssetsFileContextInfo*>(contextInfo[iContext].get()))\n\t\t\t\t{\n\t\t\t\t\tauto prevRefLock = pPrevAssetsInfo->lockReferencesWrite();\n\t\t\t\t\tstd::vector<unsigned int> &prevReferences = pPrevAssetsInfo->getReferencesWrite(prevRefLock);\n\t\t\t\t\tconst std::vector<AssetsFileDependency> &prevDependencies = pPrevAssetsInfo->getDependenciesWrite(prevRefLock);\n\t\t\t\t\tassert(prevReferences.size() == prevDependencies.size());\n\t\t\t\t\tfor (size_t iRef = 0; iRef < prevReferences.size(); iRef++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (iRef >= prevDependencies.size())\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tconst AssetsFileDependency *pDependency = &prevDependencies[iRef];\n\t\t\t\t\t\tif (pDependency->type != 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tbool issueDependencyCallback = false;\n\t\t\t\t\t\tif (prevReferences[iRef] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Only update references that aren\'t set already.\n\t\t\t\t\t\t\tif (contextInfoByFileID.find(prevReferences[iRef]) == contextInfoByFileID.end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//References may be set to a closed file. In that case, treat it like it isn\'t set.\n\t\t\t\t\t\t\t\tprevReferences[iRef] = 0; //While we\'re at it, set it to 0.\n\t\t\t\t\t\t\t\tissueDependencyCallback = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbool solvesReference = false;\n\t\t\t\t\t\tconst char *depFileName = getDependencyFileName(pDependency->assetPath);\n\t\t\t\t\t\tif (!stricmp(newFileName.c_str(), depFileName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprevReferences[iRef] = info->fileID; //Assign the new file as a dependency.\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//Mark the dependant file as a container source, if it has any containers.\n\t\t\t\t\t\t\tAssetContainerList &prevContainers = pPrevAssetsInfo->lockContainersRead();\n\t\t\t\t\t\t\tif (prevContainers.getContainerCount() > 0)\n\t\t\t\t\t\t\t\tpNewAssetsInfo->getContainerSources().push_back(pPrevAssetsInfo->getFileID());\n\t\t\t\t\t\t\tpPrevAssetsInfo->unlockContainersRead();\n\n\t\t\t\t\t\t\tissueDependencyCallback = true;\n\t\t\t\t\t\t\tsolvesReference = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (issueDependencyCallback)\n\t\t\t\t\t\t\tdependencyCallbackArgs.push_back(std::make_pair(pPrevAssetsInfo, iRef));\n\t\t\t\t\t\tif (solvesReference)\n\t\t\t\t\t\t\tbreak; //Each assets file should only have one entry per dependency\n\t\t\t\t\t}\n\t\t\t\t\tprevRefLock.unlock();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcontextInfo.push_back(info);\n\tstd::unique_lock contextInfoMapLock(this->contextInfoMapMutex);\n\tif (info->parentFileID == 0)\n\t{\n\t\tcontextInfoByFileID[info->fileID] = info;\n\t\tif (info->getFileContext())\n\t\t{\n\t\t\tinfo->lastFileName = info->getFileName();\n\t\t\tcontextInfoByFileName.insert({ info->lastFileName, info });\n\t\t}\n\t\tcontextInfoMapLock.unlock();\n\t}\n\telse\n\t{\n\t\tauto parentIt = contextInfoByFileID.find(info->parentFileID);\n\t\tif (parentIt != contextInfoByFileID.end())\n\t\t{\n\t\t\t//contextInfo still keeps a FileContextInfo reference for the main thread.\n\t\t\tFileContextInfo *pContextInfo = parentIt->second.get();\n\t\t\tcontextInfoByFileID[info->fileID] = info;\n\t\t\tif (info->getFileContext())\n\t\t\t{\n\t\t\t\tinfo->lastFileName = info->getFileName();\n\t\t\t\tcontextInfoByFileName.insert({ info->lastFileName, info });\n\t\t\t}\n\t\t\tcontextInfoMapLock.unlock();\n\t\t\tif (pContextInfo->getFileContext()->getType() == FileContext_Bundle)\n\t\t\t{\n\t\t\t\tBundleFileContextInfo *pBundleContextInfo = (BundleFileContextInfo*)pContextInfo;\n\t\t\t\tcontextInfoMapLock.lock();\n\t\t\t\tif (directoryEntryIdx < pBundleContextInfo->directoryRefs.size())\n\t\t\t\t{\n\t\t\t\t\tpBundleContextInfo->directoryRefs[directoryEntryIdx].fileID = info->fileID;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tassert(false);\n\t\t\t\tcontextInfoMapLock.unlock();\n\t\t\t}\n\t\t\telse\n\t\t\t\tassert(false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Parent file has closed already.\n\t\t\treturn false;\n\t\t}\n\t}\n\tassert(!contextInfoMapLock.owns_lock());\n\t//Call the dependency callbacks after the file has been registered properly.\n\tfor (auto it = dependencyCallbackArgs.begin(); it != dependencyCallbackArgs.end(); ++it)\n\t\tthis->OnUpdateDependencies(it->first, it->second, it->second);\n\treturn true;\n}\nvoid AppContext::RemoveContextInfo(FileContextInfo *info)\n{\n\tstd::unique_lock contextInfoMapLock(this->contextInfoMapMutex);\n\tif (info->parentFileID != 0)\n\t{\n\t\tauto parentIt = contextInfoByFileID.find(info->parentFileID);\n\t\tif (parentIt != contextInfoByFileID.end())\n\t\t{\n\t\t\tparentIt->second->onCloseChild(info->getFileID());\n\t\t}\n\t}\n\tcontextInfoByFileID.erase(info->getFileID());\n\tauto fileMapEntryIt = contextInfoByFileName.end();\n\tif (info->getFileContext())\n\t{\n\t\tauto rangeItPair = contextInfoByFileName.equal_range(info->lastFileName);\n\t\tfor (auto it = rangeItPair.first; it != rangeItPair.second; ++it)\n\t\t{\n\t\t\tif (it->second.get() == info)\n\t\t\t{\n\t\t\t\tfileMapEntryIt = it;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (fileMapEntryIt == contextInfoByFileName.end())\n\t{\n\t\tfor (auto it = contextInfoByFileName.begin(); it != contextInfoByFileName.end(); ++it)\n\t\t{\n\t\t\tif (it->second.get() == info)\n\t\t\t{\n\t\t\t\tfileMapEntryIt = it;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (fileMapEntryIt != contextInfoByFileName.end())\n\t\tcontextInfoByFileName.erase(fileMapEntryIt);\n\tcontextInfoMapLock.unlock();\n\tfor (size_t i = 0; i < contextInfo.size(); i++)\n\t{\n\t\tif (contextInfo[i].get() == info)\n\t\t{\n\t\t\tcontextInfo.erase(contextInfo.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nvoid AppContext::OnGenerateContainers(AssetsFileContextInfo *info)\n{\n\tOnUpdateContainers(info);\n\tconst std::vector<unsigned int> references = info->getReferences();\n\tfor (size_t i = 0; i < references.size(); i++)\n\t{\n\t\tstd::shared_lock contextInfoMapLock(this->contextInfoMapMutex);\n\t\tauto ref = contextInfoByFileID.find(references[i]);\n\t\tFileContextInfo *pContextInfo = nullptr;\n\t\tif (ref != contextInfoByFileID.end())\n\t\t\tpContextInfo = ref->second.get();\n\t\tcontextInfoMapLock.unlock();\n\t\tif (pContextInfo && pContextInfo->getFileContext()->getType() == FileContext_Assets)\n\t\t{\n\t\t\tAssetsFileContextInfo *pTarget = static_cast<AssetsFileContextInfo*>(pContextInfo);\n\t\t\tbool addAsSource = true;\n\t\t\tfor (size_t k = 0; k < pTarget->containerSources.size(); k++)\n\t\t\t{\n\t\t\t\tif (pTarget->containerSources[k] == info->getFileID())\n\t\t\t\t{\n\t\t\t\t\taddAsSource = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (addAsSource)\n\t\t\t\tpTarget->containerSources.push_back(info->getFileID());\n\t\t\tOnUpdateContainers(pTarget);\n\t\t}\n\t}\n}\nvoid AppContext::OnChangeAsset_Async(AssetsFileContextInfo *info, pathid_t pathID, bool removed)\n{\n\tsignalMainThread(AppContextMsg_OnAssetChanged, new std::tuple<unsigned int, pathid_t, bool>(info->getFileID(), pathID, removed));\n}\nvoid AppContext::OnChangeBundleEntry_Async(BundleFileContextInfo *info, size_t index)\n{\n\tsignalMainThread(AppContextMsg_OnBundleEntryChanged, new std::tuple<unsigned int, size_t>(info->getFileID(), index));\n}\nFileContextInfo_ptr AppContext::getContextInfo(unsigned int fileID)\n{\n\tif (fileID == 0)\n\t\treturn nullptr;\n\tstd::shared_ptr<FileContextInfo> ret(nullptr);\n\tstd::shared_lock contextInfoMapLock(this->contextInfoMapMutex);\n\tauto ref = contextInfoByFileID.find(fileID);\n\tif (ref != contextInfoByFileID.end())\n\t\tret = ref->second;\n\treturn ret;\n}\nstd::vector<FileContextInfo_ptr> AppContext::getContextInfo(const std::string& relFileName, FileContextInfo* pFileFrom)\n{\n\tif (relFileName.starts_with("archive:/"))\n\t{\n\t\tsize_t lastSlashPos = relFileName.rfind(\'/\', std::string::npos);\n\t\tif (lastSlashPos == std::string::npos || lastSlashPos == 0)\n\t\t{\n\t\t\tassert(false); //"archive:/" contains a \'/\'\n\t\t\treturn {};\n\t\t}\n\t\t//Find all candidates (file name match).\n\t\tstd::vector<FileContextInfo_ptr> ret_unfiltered = getContextInfo(relFileName.substr(lastSlashPos + 1));\n\t\tstd::vector<FileContextInfo_ptr> ret;\n\t\tfor (size_t i = 0; i < ret_unfiltered.size(); ++i)\n\t\t{\n\t\t\tFileContextInfo_ptr pCurFile = ret_unfiltered[i];\n\t\t\tsize_t cutoffPos = lastSlashPos;\n\t\t\tsize_t searchPos = lastSlashPos;\n\t\t\tbool success = true;\n\t\t\twhile ((searchPos = relFileName.rfind(\'/\', searchPos - 1)) != std::string::npos && searchPos != 0)\n\t\t\t{\n\t\t\t\tunsigned int parentFileID = pCurFile->getParentFileID();\n\t\t\t\tFileContextInfo_ptr pParentFile;\n\t\t\t\tif (parentFileID == 0\n\t\t\t\t\t|| (pParentFile = getContextInfo(parentFileID)) == nullptr)\n\t\t\t\t{\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstd::string parentFileName;\n\t\t\t\tif (pParentFile->getFileContext() && pParentFile->getFileContext()->getType() == FileContext_Bundle)\n\t\t\t\t{\n\t\t\t\t\t//Bundle name is determined based on its first directory entry.\n\t\t\t\t\tauto pBundleParent = reinterpret_cast<BundleFileContextInfo*>(pParentFile.get());\n\t\t\t\t\tparentFileName = pBundleParent->getBundlePathName();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Shouldn\'t normally happen (Unity appears to use "archive:/" references only for bundled files).\n\t\t\t\t\tparentFileName = pParentFile->getFileName();\n\t\t\t\t}\n\t\t\t\t//Weird error in Debug: "cannot seek string iterator because the iterator was invalidated" when incrementing the string iterator?\n\t\t\t\t//-> string::data() should do for now.\n\t\t\t\tif (!std::equal(relFileName.data() + (searchPos + 1), relFileName.data() + cutoffPos, parentFileName.begin(), parentFileName.end()))\n\t\t\t\t{\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcutoffPos = searchPos;\n\t\t\t}\n\t\t\tif (success)\n\t\t\t\tret.push_back(std::move(ret_unfiltered[i]));\n\t\t}\n\t\treturn ret;\n\t}\n\tstd::shared_lock contextInfoMapLock(this->contextInfoMapMutex);\n\tstd::vector<FileContextInfo_ptr> candidates;\n\tauto range = contextInfoByFileName.equal_range(relFileName);\n\t//Only place the value (i.e. second) of each contextInfoByFileName iterator in ret.\n\tstd::transform(range.first, range.second, std::back_inserter(candidates), [](auto x) {return x.second; });\n\n\tif (pFileFrom == nullptr || pFileFrom->getFileContext() == nullptr)\n\t\treturn candidates;\n\n\t//Search relative to a given file context.\n\tif (candidates.empty())\n\t\treturn {};\n\tconst std::string& fromFilePathStr = pFileFrom->getFileContext()->getFilePath();\n\t//char8_t: Interpret string as UTF-8 even on Win32.\n\tstd::filesystem::path fromFilePath(\n\t\treinterpret_cast<const char8_t*>(&fromFilePathStr.data()[0]),\n\t\treinterpret_cast<const char8_t*>(&fromFilePathStr.data()[fromFilePathStr.size()]));\n\tstd::vector<FileContextInfo_ptr> ret;\n\tfor (size_t i = 0; i < candidates.size(); ++i)\n\t{\n\t\tif (candidates[i]->getParentFileID() != 0\n\t\t\t|| candidates[i]->getFileContext() == nullptr)\n\t\t\tcontinue;\n\t\tconst std::string& candidateFilePathStr = candidates[i]->getFileContext()->getFilePath();\n\t\tstd::filesystem::path candidateFilePath(\n\t\t\treinterpret_cast<const char8_t*>(&candidateFilePathStr.data()[0]),\n\t\t\treinterpret_cast<const char8_t*>(&candidateFilePathStr.data()[candidateFilePathStr.size()]));\n\t\tif (std::filesystem::equivalent(fromFilePath.parent_path(), candidateFilePath.parent_path()))\n\t\t\tret.push_back(std::move(candidates[i]));\n\t}\n\treturn ret;\n}\nvoid AppContext::OnUpdateContainers(AssetsFileContextInfo *info) {}\nvoid AppContext::OnUpdateDependencies(AssetsFileContextInfo *info, size_t from, size_t to) {} //from/to: indices for info->references\nvoid AppContext::OnChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved) {}\nvoid AppContext::OnChangeBundleEntry(BundleFileContextInfo *pFile, size_t index)\n{\n\t// Locate the opened child file (if present).\n\tstd::vector<unsigned int> childFileIDs;\n\tpFile->getChildFileIDs(childFileIDs);\n\tFileContextInfo_ptr pChildInfo = nullptr;\n\tif (childFileIDs.size() > index && childFileIDs[index] != 0\n\t\t&& (pChildInfo = getContextInfo(childFileIDs[index])))\n\t{\n\t\tauto newFileName = pChildInfo->getFileName();\n\t\tbool nameChanged = newFileName != pChildInfo->lastFileName;\n\t\tstd::shared_lock contextInfoMapLock(this->contextInfoMapMutex);\n\t\tif (nameChanged)\n\t\t{\n\t\t\t//Erase the existing entry for the renamed file.\n\t\t\tauto range = contextInfoByFileName.equal_range(pChildInfo->lastFileName);\n\t\t\tfor (auto it = range.first; it != range.second; ++it)\n\t\t\t{\n\t\t\t\tif (it->second.get() == pChildInfo.get())\n\t\t\t\t{\n\t\t\t\t\tcontextInfoByFileName.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nameChanged)\n\t\t{\n\t\t\t//Insert a new entry for the renamed file.\n\t\t\tpChildInfo->lastFileName = std::move(newFileName);\n\t\t\tif (!pChildInfo->lastFileName.empty())\n\t\t\t\tcontextInfoByFileName.insert({ pChildInfo->lastFileName, pChildInfo });\n\t\t}\n\t}\n}\n\nbool AppContext::LoadClassDatabasePackage(const std::string &appBaseDir, std::string &errorMessage)\n{\n\tbool ret = true;\n\tIAssetsReader *pDatabaseFileReader = Create_AssetsReaderFromFile("classdata.tpk", true, RWOpenFlags_Immediately);\n\tif (pDatabaseFileReader == NULL)\n\t{\n\t\tstd::string targetDir = appBaseDir + "classdata.tpk";\n\t\tpDatabaseFileReader = Create_AssetsReaderFromFile(targetDir.c_str(), true, RWOpenFlags_Immediately);\n\t}\n\tif (pDatabaseFileReader != NULL)\n\t{\n\t\tif (!classPackage.Read(pDatabaseFileReader))\n\t\t{\n\t\t\tret = false;\n\t\t\terrorMessage = "Invalid type database package!";\n\t\t}\n\t\tFree_AssetsReader(pDatabaseFileReader);\n\t}\n\telse\n\t{\n\t\tret = false;\n\t\terrorMessage = "Unable to open the class database package file!";\n\t}\n\treturn ret;\n}\n'