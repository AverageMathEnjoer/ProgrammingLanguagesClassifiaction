b'using System;\nusing System.Diagnostics;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code to implement a pseudo-random number\n    ** generator (PRNG) for SQLite.\n    **\n    ** Random numbers are used by some of the database backends in order\n    ** to generate random integer keys for tables or random filenames.\n    **\n    ** $Id: random.c,v 1.29 2008/12/10 19:26:24 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n\n    /* All threads share a single random number generator.\n    ** This structure is the current state of the generator.\n    */\n    public class sqlite3PrngType\n    {\n      public bool isInit;      /* True if initialized */\n      public int i;\n      public int j;            /* State variables */\n      public u8[] s = new u8[256];          /* State variables */\n\n      public sqlite3PrngType Copy()\n      {\n        sqlite3PrngType cp = (sqlite3PrngType)MemberwiseClone();\n        cp.s = new u8[s.Length];\n        Array.Copy( s, cp.s, s.Length );\n        return cp;\n      }\n    }\n    public static sqlite3PrngType sqlite3Prng = new sqlite3PrngType();\n    /*\n    ** Get a single 8-bit random value from the RC4 PRNG.  The Mutex\n    ** must be held while executing this routine.\n    **\n    ** Why not just use a library random generator like lrand48() for this?\n    ** Because the OP_NewRowid opcode in the VDBE depends on having a very\n    ** good source of random numbers.  The lrand48() library function may\n    ** well be good enough.  But maybe not.  Or maybe lrand48() has some\n    ** subtle problems on some systems that could cause problems.  It is hard\n    ** to know.  To minimize the risk of problems due to bad lrand48()\n    ** implementations, SQLite uses this random number generator based\n    ** on RC4, which we know works very well.\n    **\n    ** (Later):  Actually, OP_NewRowid does not depend on a good source of\n    ** randomness any more.  But we will leave this code in all the same.\n    */\n    static u8 randomu8()\n    {\n      u8 t;\n\n      /* The "wsdPrng" macro will resolve to the pseudo-random number generator\n      ** state vector.  If writable static data is unsupported on the target,\n      ** we have to locate the state vector at run-time.  In the more common\n      ** case where writable static data is supported, wsdPrng can refer directly\n      ** to the "sqlite3Prng" state vector declared above.\n      */\n#if SQLITE_OMIT_WSD\nstruct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);\n//# define wsdPrng p[0]\n#else\n      //# define wsdPrng sqlite3Prng\n      sqlite3PrngType wsdPrng = sqlite3Prng;\n#endif\n\n\n      /* Initialize the state of the random number generator once,\n** the first time this routine is called.  The seed value does\n** not need to contain a lot of randomness since we are not\n** trying to do secure encryption or anything like that...\n**\n** Nothing in this file or anywhere else in SQLite does any kind of\n** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random\n** number generator) not as an encryption device.\n*/\n      if ( !wsdPrng.isInit )\n      {\n        int i;\n        u8[] k = new u8[256];\n        wsdPrng.j = 0;\n        wsdPrng.i = 0;\n        sqlite3OsRandomness( sqlite3_vfs_find( "" ), 256, ref k );\n        for ( i = 0 ; i < 255 ; i++ )\n        {\n          wsdPrng.s[i] = (u8)i;\n        }\n        for ( i = 0 ; i < 255 ; i++ )\n        {\n          wsdPrng.j = (u8)( wsdPrng.j + wsdPrng.s[i] + k[i] );\n          t = wsdPrng.s[wsdPrng.j];\n          wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];\n          wsdPrng.s[i] = t;\n        }\n        wsdPrng.isInit = true;\n      }\n\n      /* Generate and return single random u8\n      */\n      wsdPrng.i++;\n      t = wsdPrng.s[(u8)wsdPrng.i];\n      wsdPrng.j = (u8)( wsdPrng.j + t );\n      wsdPrng.s[(u8)wsdPrng.i] = wsdPrng.s[wsdPrng.j];\n      wsdPrng.s[wsdPrng.j] = t;\n      t += wsdPrng.s[(u8)wsdPrng.i];\n      return wsdPrng.s[t];\n    }\n\n    /*\n    ** Return N random u8s.\n    */\n    static void sqlite3_randomness( int N, ref i64 pBuf )\n    {\n      //u8[] zBuf = new u8[N];\n      pBuf = 0;\n#if SQLITE_THREADSAFE\nsqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_PRNG );\n#endif\n      sqlite3_mutex_enter( mutex );\n      while ( N-- > 0 )\n      {\n        pBuf = (u32)( ( pBuf << 8 ) + randomu8() );//  zBuf[N] = randomu8();\n      }\n      sqlite3_mutex_leave( mutex );\n    }\n\n#if !SQLITE_OMIT_BUILTIN_TEST\n    /*\n** For testing purposes, we sometimes want to preserve the state of\n** PRNG and restore the PRNG to its saved state at a later time, or\n** to reset the PRNG to its initial state.  These routines accomplish\n** those tasks.\n**\n** The sqlite3_test_control() interface calls these routines to\n** control the PRNG.\n*/\n    static sqlite3PrngType sqlite3SavedPrng = null;\n    static void sqlite3PrngSaveState()\n    {\n      sqlite3SavedPrng = sqlite3Prng.Copy();\n      //      memcpy(\n      //  &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),\n      //  &GLOBAL(struct sqlite3PrngType, sqlite3Prng),\n      //  sizeof(sqlite3Prng)\n      //);\n    }\n    static void sqlite3PrngRestoreState()\n    {\n      sqlite3Prng = sqlite3SavedPrng.Copy();\n      //memcpy(\n      //  &GLOBAL(struct sqlite3PrngType, sqlite3Prng),\n      //  &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),\n      //  sizeof(sqlite3Prng)\n      //);\n    }\n    static void sqlite3PrngResetState()\n    {\n      sqlite3Prng.isInit = false;//  GLOBAL(struct sqlite3PrngType, sqlite3Prng).isInit = 0;\n    }\n#endif //* SQLITE_OMIT_BUILTIN_TEST */\n  }\n}\n'