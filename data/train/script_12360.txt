b'{-# LANGUAGE\n    CPP\n  , DeriveDataTypeable\n  , EmptyDataDecls\n  , RankNTypes\n  , TypeFamilies\n  #-}\n#if __GLASGOW_HASKELL__ >= 800\n{-# LANGUAGE DataKinds #-}\n#endif\nmodule Rest.Types.Void (Void (..)) where\n\nimport Data.Aeson (FromJSON (..), ToJSON (..))\nimport Data.JSON.Schema (JSONSchema (..), Schema(Choice))\nimport Data.Typeable (Typeable)\nimport GHC.Generics\nimport Text.XML.HXT.Arrow.Pickle (XmlPickler (..), PU (..))\nimport Text.XML.HXT.Arrow.Pickle.Schema (Schema(Alt))\nimport Text.XML.HXT.Arrow.Pickle.Xml (Unpickler (UP))\n\n-- * The @Void@ type.\n\n-- | The \'Void\' type is used as the identifier for resources that\n-- can\'t be routed to. It contains no values apart from bottom.\n\nnewtype Void = Void { magic :: forall a. a } deriving (Typeable)\n\n-- This instance is needed for generated API clients.\n\ninstance FromJSON Void where\n  parseJSON = fail "Cannot parse Void in FromJSON."\n\ninstance ToJSON Void where\n  toJSON = magic\n\ninstance JSONSchema Void where\n  schema _ = Choice []\n\ninstance XmlPickler Void where\n  xpickle = PU magic (UP (\\st -> (Left ("Cannot unpickle Void.", st), st))) (Alt [])\n\ninstance Show Void where\n  show = magic\n\ninstance Eq Void where\n  x == _ = magic x\n\ninstance Ord Void where\n  compare x _ = magic x\n\ninstance Read Void where\n  readsPrec _ _ = []\n\n-- | Generic. Can\'t derive it, sadly.\n\ninstance Generic Void where\n#if __GLASGOW_HASKELL__ >= 800\n  type Rep Void = D1 (\'MetaData "Void" "Rest.Types.Void" "rest-types" \'False) V1\n#else\n  type Rep Void = D1 D1Void V1\n#endif\n  from = magic\n  to (M1 x) = x `seq` Void (error "Impossible: constructing a Void in Generic instance.")\n\n#if __GLASGOW_HASKELL__ < 800\ndata D1Void\n\ninstance Datatype D1Void where\n  datatypeName _ = "Void"\n  moduleName _ = "Rest.Types.Void"\n#endif\n'