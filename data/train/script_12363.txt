b'module Database.Beam.Migrate.Tool.Log where\n\nimport           Database.Beam\nimport           Database.Beam.Migrate.Log\nimport           Database.Beam.Migrate.Backend\nimport           Database.Beam.Migrate.Tool.Backend\nimport           Database.Beam.Migrate.Tool.CmdLine\nimport           Database.Beam.Migrate.Tool.Diff\nimport           Database.Beam.Migrate.Tool.Registry\nimport           Database.Beam.Migrate.Tool.Status\n\nimport           Control.Exception\nimport           Control.Monad\n\nimport qualified Data.Text as T\nimport           Text.Read (readMaybe)\n\ndisplayLog :: MigrateCmdLine -> IO ()\ndisplayLog MigrateCmdLine { migrateDatabase = Nothing } =\n  fail "No database specified"\ndisplayLog cmdLine@MigrateCmdLine { migrateDatabase = Just dbName } = do\n  reg <- lookupRegistry cmdLine\n\n  (db, _, SomeBeamMigrationBackend (be :: BeamMigrationBackend be m)) <-\n    loadBackend cmdLine reg dbName\n\n  case be of\n    BeamMigrationBackend { backendTransact = transact } -> do\n      res <- transact (migrationDbConnString db) $\n             runSelectReturningList $ select $\n             orderBy_ (desc_ . _logEntryId) $\n             all_ (_beamMigrateLogEntries (beamMigrateDb @be @m))\n      case res of\n        Left err -> throwIO (CouldNotFetchLog err)\n        Right entries ->\n          forM_ entries $ \\logEntry ->\n          let sch = do\n                commitId <- readMaybe (T.unpack (_logEntryCommitId logEntry))\n                lookupSchema commitId [] reg\n          in case sch of\n               Nothing -> throwIO (InvalidCommitId (_logEntryCommitId logEntry))\n               Just sch\' -> do\n                 showCommit (_logEntryDate logEntry) sch\'\n'