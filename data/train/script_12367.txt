b'{-# LANGUAGE DataKinds, FlexibleInstances, FlexibleContexts, UndecidableInstances,\n     KindSignatures, TypeFamilies, CPP #-}\n\n#if !defined(TESTING)\n{-# LANGUAGE Safe #-}\n#endif\n\n-- | Unsatisfiable constraints for functions being removed.\n\nmodule Utils.Containers.Internal.TypeError where\nimport GHC.TypeLits\n\n-- | The constraint @Whoops s@ is unsatisfiable for every \'Symbol\' @s@.  Trying\n-- to use a function with a @Whoops s@ constraint will lead to a pretty type\n-- error explaining how to fix the problem.\n--\n-- ==== Example\n--\n-- @\n-- oldFunction :: Whoops "oldFunction is gone now. Use newFunction."\n--             => Int -> IntMap a -> IntMap a\n-- @\nclass Whoops (a :: Symbol)\n\ninstance TypeError (\'Text a) => Whoops a\n\n-- Why don\'t we just use\n--\n-- type Whoops a = TypeError (\'Text a) ?\n--\n-- When GHC sees the type signature of oldFunction, it will see that it\n-- has an unsatisfiable constraint and reject it out of hand.\n--\n-- It seems possible to hack around that with a type family:\n--\n-- type family Whoops a where\n--   Whoops a = TypeError (\'Text a)\n--\n-- but I don\'t really trust that to work reliably. What we actually\n-- do is pretty much guaranteed to work. Despite the fact that there\n-- is a totally polymorphic instance in scope, GHC will refrain from\n-- reducing the constraint because it knows someone could (theoretically)\n-- define an overlapping instance of Whoops. It doesn\'t commit to\n-- the polymorphic one until it has to, at the call site.\n'