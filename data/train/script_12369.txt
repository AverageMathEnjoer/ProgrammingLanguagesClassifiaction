b"import Data.Array\n\ntestData :: [Int]\ntestData = [51, 38, 29, 51, 63, 38]\n\nranking1 :: [Int]\nranking1 = [3, 1, 3, 0, 1] \n\nranking2 :: [Int]\nranking2 = [2, 0, 3, 4, 0]\n\ntails :: [a] -> [[a]]\ntails [] = []\ntails xs = xs : tails (tail xs)\n\nrank :: Ord a => [a] -> [Int]\nrank xs = map (\\x -> length (filter (< x) xs)) xs\n\n-- This function isn't actually used in the algorithm.\nrats :: Ord a => Int -> [a] -> [Int]\nrats k = rank . map (take k) . tails\n\n(<<) :: Ord a => [a] -> [a] -> [Int]\nxs << ys = rank (zip xs ys)\n\nshiftBy :: Int -> [Int] -> [Int]\nshiftBy k rs = map (+k) (drop k rs) ++ [k-1, k-2 .. 0]\n\nranktails :: Ord a => [a] -> [Int]\nranktails = applyUntil isperm rerankings .rank\n\nrerankings :: [[Int] -> [Int]]\nrerankings = map rerank (iterate (*2) 1)\n\nrerank :: Int -> [Int] -> [Int]\nrerank k rs = rs << shiftBy k rs\n\napplyUntil :: (a -> Bool) -> [a -> a] -> a -> a\napplyUntil p (f:fs) x = if p x then x else applyUntil p fs (f x)\n\nisperm :: [Int] -> Bool\nisperm is = and (elems\n            (accumArray (||) False (0, n - 1) (zip is (repeat True))))\n            where n = length is\n\n\n"