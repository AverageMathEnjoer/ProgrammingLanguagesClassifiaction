b'#define SQLITE_MAX_EXPR_DEPTH\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nusing Bitmask = System.UInt64;\nusing i16 = System.Int16;\nusing i64 = System.Int64;\nusing sqlite3_int64 = System.Int64;\n\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\nusing unsigned = System.UInt64;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** Internal interface definitions for SQLite.\n    **\n    ** @(#) $Id: sqliteInt.h,v 1.898 2009/08/10 03:57:58 shane Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#if !_SQLITEINT_H_\n    //#define _SQLITEINT_H_\n\n    /*\n    ** Include the configuration header output by \'configure\' if we\'re using the\n    ** autoconf-based build\n    */\n#if _HAVE_SQLITE_CONFIG_H\n//#include "config.h"\n#endif\n    //#include "sqliteLimit.h"\n\n    /* Disable nuisance warnings on Borland compilers */\n    //#if defined(__BORLANDC__)\n    //#pragma warn -rch /* unreachable code */\n    //#pragma warn -ccc /* Condition is always true or false */\n    //#pragma warn -aus /* Assigned value is never used */\n    //#pragma warn -csu /* Comparing signed and unsigned */\n    //#pragma warn -spa /* Suspicious pointer arithmetic */\n    //#endif\n\n    /* Needed for various definitions... */\n    //#if !_GNU_SOURCE\n    //#define _GNU_SOURCE\n    //#endif\n    /*\n    ** Include standard header files as necessary\n    */\n#if HAVE_STDINT_H\n//#include <stdint.h>\n#endif\n#if HAVE_INTTYPES_H\n//#include <inttypes.h>\n#endif\n\n    /*\n** This macro is used to "hide" some ugliness in casting an int\n** value to a ptr value under the MSVC 64-bit compiler.   Casting\n** non 64-bit values to ptr types results in a "hard" error with\n** the MSVC 64-bit compiler which this attempts to avoid.\n**\n** A simple compiler pragma or casting sequence could not be found\n** to correct this in all situations, so this macro was introduced.\n**\n** It could be argued that the intptr_t type could be used in this\n** case, but that type is not available on all compilers, or\n** requires the #include of specific headers which differs between\n** platforms.\n**\n** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes on\n** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).\n** So we have to define the macros in different ways depending on the\n** compiler.\n*/\n    //#if defined(__GNUC__)\n    //# if defined(HAVE_STDINT_H)\n    //#   define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))\n    //#   define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))\n    //# else\n    //#   define SQLITE_INT_TO_PTR(X)  ((void*)(X))\n    //#   define SQLITE_PTR_TO_INT(X)  ((int)(X))\n    //# endif\n    //#else\n    //# define SQLITE_INT_TO_PTR(X)   ((void*)&((char*)0)[X])\n    //# define SQLITE_PTR_TO_INT(X)   ((int)(((char*)X)-(char*)0))\n    //#endif\n\n    /*\n    ** These #defines should enable >2GB file support on POSIX if the\n    ** underlying operating system supports it.  If the OS lacks\n    ** large file support, or if the OS is windows, these should be no-ops.\n    **\n    ** Ticket #2739:  The _LARGEFILE_SOURCE macro must appear before any\n    ** system #includes.  Hence, this block of code must be the very first\n    ** code in all source files.\n    **\n    ** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch\n    ** on the compiler command line.  This is necessary if you are compiling\n    ** on a recent machine (ex: RedHat 7.2) but you want your code to work\n    ** on an older machine (ex: RedHat 6.0).  If you compile on RedHat 7.2\n    ** without this option, LFS is enable.  But LFS does not exist in the kernel\n    ** in RedHat 6.0, so the code won\'t work.  Hence, for maximum binary\n    ** portability you should omit LFS.\n    **\n    ** Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.\n    */\n#if !SQLITE_DISABLE_LFS\nconst int _LARGE_FILE = 1;//# define _LARGE_FILE       1\n#if !_FILE_OFFSET_BITS\nconst int _FILE_OFFSET_BITS = 64;//#   define _FILE_OFFSET_BITS 64\n# endif\nconst int _LARGEFILE_SOURCE = 1; //# define _LARGEFILE_SOURCE 1\n#endif\n\n\n\n\n    /*\n** The SQLITE_THREADSAFE macro must be defined as either 0 or 1.\n** Older versions of SQLite used an optional THREADSAFE macro.\n** We support that for legacy\n*/\n#if !SQLITE_THREADSAFE\n#if THREADSAFE\n//# define SQLITE_THREADSAFE THREADSAFE\n#else\n    //# define SQLITE_THREADSAFE 1\n    const int SQLITE_THREADSAFE = 1;\n#endif\n#else\nconst int SQLITE_THREADSAFE = 1;\n#endif\n\n    /*\n** The SQLITE_DEFAULT_MEMSTATUS macro must be defined as either 0 or 1.\n** It determines whether or not the features related to\n** SQLITE_CONFIG_MEMSTATUS are available by default or not. This value can\n** be overridden at runtime using the sqlite3_config() API.\n*/\n#if !(SQLITE_DEFAULT_MEMSTATUS)\n    //# define SQLITE_DEFAULT_MEMSTATUS 1\n    const int SQLITE_DEFAULT_MEMSTATUS = 1;\n#endif\n\n    /*\n** Exactly one of the following macros must be defined in order to\n** specify which memory allocation subsystem to use.\n**\n**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()\n**     SQLITE_MEMDEBUG               // Debugging version of system malloc()\n**     SQLITE_MEMORY_SIZE            // internal allocator #1\n**     SQLITE_MMAP_HEAP_SIZE         // internal mmap() allocator\n**     SQLITE_POW2_MEMORY_SIZE       // internal power-of-two allocator\n**\n** If none of the above are defined, then set SQLITE_SYSTEM_MALLOC as\n** the default.\n*/\n    //#if defined(SQLITE_SYSTEM_MALLOC)+defined(SQLITE_MEMDEBUG)+\\\n    //    defined(SQLITE_MEMORY_SIZE)+defined(SQLITE_MMAP_HEAP_SIZE)+\\\n    //    defined(SQLITE_POW2_MEMORY_SIZE)>1\n    //# error "At most one of the following compile-time configuration options\\\n    // is allows: SQLITE_SYSTEM_MALLOC, SQLITE_MEMDEBUG, SQLITE_MEMORY_SIZE,\\\n    // SQLITE_MMAP_HEAP_SIZE, SQLITE_POW2_MEMORY_SIZE"\n    //#endif\n    //#if defined(SQLITE_SYSTEM_MALLOC)+defined(SQLITE_MEMDEBUG)+\\\n    //    defined(SQLITE_MEMORY_SIZE)+defined(SQLITE_MMAP_HEAP_SIZE)+\\\n    //    defined(SQLITE_POW2_MEMORY_SIZE)==0\n    //# define SQLITE_SYSTEM_MALLOC 1\n    //#endif\n\n    /*\n    ** If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep the\n    ** sizes of memory allocations below this value where possible.\n    */\n#if !(SQLITE_MALLOC_SOFT_LIMIT)\n    const int SQLITE_MALLOC_SOFT_LIMIT = 1024;\n#endif\n\n    /*\n** We need to define _XOPEN_SOURCE as follows in order to enable\n** recursive mutexes on most Unix systems.  But Mac OS X is different.\n** The _XOPEN_SOURCE define causes problems for Mac OS X we are told,\n** so it is omitted there.  See ticket #2673.\n**\n** Later we learn that _XOPEN_SOURCE is poorly or incorrectly\n** implemented on some systems.  So we avoid defining it at all\n** if it is already defined or if it is unneeded because we are\n** not doing a threadsafe build.  Ticket #2681.\n**\n** See also ticket #2741.\n*/\n#if !_XOPEN_SOURCE && !__DARWIN__ && !__APPLE__ && SQLITE_THREADSAFE\nconst int _XOPEN_SOURCE = 500;//#define _XOPEN_SOURCE 500  /* Needed to enable pthread recursive mutexes */\n#endif\n\n    /*\n** The TCL headers are only needed when compiling the TCL bindings.\n*/\n#if SQLITE_TCL || TCLSH\n//# include <tcl.h>\n#endif\n\n    /*\n** Many people are failing to set -DNDEBUG=1 when compiling SQLite.\n** Setting NDEBUG makes the code smaller and run faster.  So the following\n** lines are added to automatically set NDEBUG unless the -DSQLITE_DEBUG=1\n** option is set.  Thus NDEBUG becomes an opt-in rather than an opt-out\n** feature.\n*/\n#if !NDEBUG && !SQLITE_DEBUG\nconst int NDEBUG = 1;//# define NDEBUG 1\n#endif\n\n    /*\n** The testcase() macro is used to aid in coverage testing.  When\n** doing coverage testing, the condition inside the argument to\n** testcase() must be evaluated both true and false in order to\n** get full branch coverage.  The testcase() macro is inserted\n** to help ensure adequate test coverage in places where simple\n** condition/decision coverage is inadequate.  For example, testcase()\n** can be used to make sure boundary values are tested.  For\n** bitmask tests, testcase() can be used to make sure each bit\n** is significant and used at least once.  On switch statements\n** where multiple cases go to the same block of code, testcase()\n** can insure that all cases are evaluated.\n**\n*/\n#if SQLITE_COVERAGE_TEST\nvoid sqlite3Coverage(int);\n//# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }\n#else\n    //# define testcase(X)\n    static void testcase<T>( T X ) { }\n#endif\n\n    /*\n** The TESTONLY macro is used to enclose variable declarations or\n** other bits of code that are needed to support the arguments\n** within testcase() and assert() macros.\n*/\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n    //# define TESTONLY(X)  X\n    // -- Need workaround for C#, since inline macros don\'t exist\n#else\n//# define TESTONLY(X)\n#endif\n\n    /*\n** Sometimes we need a small amount of code such as a variable initialization\n** to setup for a later assert() statement.  We do not want this code to\n** appear when assert() is disabled.  The following macro is therefore\n** used to contain that setup code.  The "VVA" acronym stands for\n** "Verification, Validation, and Accreditation".  In other words, the\n** code within VVA_ONLY() will only run during verification processes.\n*/\n#if !NDEBUG\n    //# define VVA_ONLY(X)  X\n#else\n//# define VVA_ONLY(X)\n#endif\n\n    /*\n** The ALWAYS and NEVER macros surround boolean expressions which\n** are intended to always be true or false, respectively.  Such\n** expressions could be omitted from the code completely.  But they\n** are included in a few cases in order to enhance the resilience\n** of SQLite to unexpected behavior - to make the code "self-healing"\n** or "ductile" rather than being "brittle" and crashing at the first\n** hint of unplanned behavior.\n**\n** In other words, ALWAYS and NEVER are added for defensive code.\n**\n** When doing coverage testing ALWAYS and NEVER are hard-coded to\n** be true and false so that the unreachable code then specify will\n** not be counted as untested code.\n*/\n#if SQLITE_COVERAGE_TEST\n//# define ALWAYS(X)      (1)\n//# define NEVER(X)       (0)\n#elif !NDEBUG\n    //# define ALWAYS(X)      ((X)?1:(assert(0),0))\n    static bool ALWAYS( bool X ) { if ( X != true ) Debug.Assert( false ); return true; }\n    static int ALWAYS( int X ) { if ( X == 0 ) Debug.Assert( false ); return 1; }\n    static bool ALWAYS<T>( T X ) { if ( X == null ) Debug.Assert( false ); return true; }\n\n    //# define NEVER(X)       ((X)?(assert(0),1):0)\n    static bool NEVER( bool X ) { if ( X == true ) Debug.Assert( false ); return false; }\n    static byte NEVER( byte X ) { if ( X != 0 ) Debug.Assert( false ); return 0; }\n    static int NEVER( int X ) { if ( X != 0 ) Debug.Assert( false ); return 0; }\n    static bool NEVER<T>( T X ) { if ( X != null ) Debug.Assert( false ); return false; }\n#else\n//# define ALWAYS(X)      (X)\n    static bool ALWAYS(bool X) { return X; }\n    static byte ALWAYS(byte X) { return X; }\n    static int ALWAYS(int X) { return X; }\nstatic bool ALWAYS<T>( T X ) { return true; }\n\n//# define NEVER(X)       (X)\nstatic bool NEVER(bool X) { return X; }\nstatic byte NEVER(byte X) { return X; }\nstatic int NEVER(int X) { return X; }\nstatic bool NEVER<T>(T X) { return false; }\n#endif\n\n    /*\n** The macro unlikely() is a hint that surrounds a boolean\n** expression that is usually false.  Macro likely() surrounds\n** a boolean expression that is usually true.  GCC is able to\n** use these hints to generate better code, sometimes.\n*/\n#if (__GNUC__) && FALSE\n//# define likely(X)    __builtin_expect((X),1)\n//# define unlikely(X)  __builtin_expect((X),0)\n#else\n    //# define likely(X)    !!(X)\n    static bool likely( bool X ) { return !!X; }\n    //# define unlikely(X)  !!(X)\n    static bool unlikely( bool X ) { return !!X; }\n#endif\n\n    //#include "sqlite3.h"\n    //#include "hash.h"\n    //#include "parse.h"\n    //#include <stdio.h>\n    //#include <stdlib.h>\n    //#include <string.h>\n    //#include <assert.h>\n    //#include <stddef.h>\n\n    /*\n    ** If compiling for a processor that lacks floating point support,\n    ** substitute integer for floating-point\n    */\n#if SQLITE_OMIT_FLOATING_POINT\n//# define double sqlite_int64\n//# define LONGDOUBLE_TYPE sqlite_int64\n//#if !SQLITE_BIG_DBL\n//#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<60)\n//# endif\n//# define SQLITE_OMIT_DATETIME_FUNCS 1\n//# define SQLITE_OMIT_TRACE 1\n//# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n//# undef SQLITE_HAVE_ISNAN\n#endif\n#if !SQLITE_BIG_DBL\n    const double SQLITE_BIG_DBL = ( ( (sqlite3_int64)1 ) << 60 );//# define SQLITE_BIG_DBL (1e99)\n#endif\n\n    /*\n** OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0\n** afterward. Having this macro allows us to cause the C compiler\n** to omit code used by TEMP tables without messy #if !statements.\n*/\n#if SQLITE_OMIT_TEMPDB\n//#define OMIT_TEMPDB 1\n#else\n    static int OMIT_TEMPDB = 0;\n#endif\n\n    /*\n** If the following macro is set to 1, then NULL values are considered\n** distinct when determining whether or not two entries are the same\n** in a UNIQUE index.  This is the way PostgreSQL, Oracle, DB2, MySQL,\n** OCELOT, and Firebird all work.  The SQL92 spec explicitly says this\n** is the way things are suppose to work.\n**\n** If the following macro is set to 0, the NULLs are indistinct for\n** a UNIQUE index.  In this mode, you can only have a single NULL entry\n** for a column declared UNIQUE.  This is the way Informix and SQL Server\n** work.\n*/\n    const int NULL_DISTINCT_FOR_UNIQUE = 1;\n\n    /*\n    ** The "file format" number is an integer that is incremented whenever\n    ** the VDBE-level file format changes.  The following macros define the\n    ** the default file format for new databases and the maximum file format\n    ** that the library can read.\n    */\n    public static int SQLITE_MAX_FILE_FORMAT = 4;//#define SQLITE_MAX_FILE_FORMAT 4\n#if !SQLITE_DEFAULT_FILE_FORMAT\n    static int SQLITE_DEFAULT_FILE_FORMAT = 1;//# define SQLITE_DEFAULT_FILE_FORMAT 1\n#endif\n\n    /*\n** Provide a default value for SQLITE_TEMP_STORE in case it is not specified\n** on the command-line\n*/\n#if !SQLITE_TEMP_STORE\n    static int SQLITE_TEMP_STORE = 1;//#define SQLITE_TEMP_STORE 1\n#endif\n\n    /*\n** GCC does not define the offsetof() macro so we\'ll have to do it\n** ourselves.\n*/\n#if !offsetof\n    //#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))\n#endif\n\n    /*\n** Check to see if this machine uses EBCDIC.  (Yes, believe it or\n** not, there are still machines out there that use EBCDIC.)\n*/\n#if FALSE //\'A\' == \'\\301\'\n//# define SQLITE_EBCDIC 1\n#else\n    const int SQLITE_ASCII = 1;//#define SQLITE_ASCII 1\n#endif\n\n    /*\n** Integers of known sizes.  These typedefs might change for architectures\n** where the sizes very.  Preprocessor macros are available so that the\n** types can be conveniently redefined at compile-type.  Like this:\n**\n**         cc \'-Du32PTR_TYPE=long long int\' ...\n*/\n    //#if !u32_TYPE\n    //# ifdef HAVE_u32_T\n    //#  define u32_TYPE u32_t\n    //# else\n    //#  define u32_TYPE unsigned int\n    //# endif\n    //#endif\n    //#if !u3216_TYPE\n    //# ifdef HAVE_u3216_T\n    //#  define u3216_TYPE u3216_t\n    //# else\n    //#  define u3216_TYPE unsigned short int\n    //# endif\n    //#endif\n    //#if !INT16_TYPE\n    //# ifdef HAVE_INT16_T\n    //#  define INT16_TYPE int16_t\n    //# else\n    //#  define INT16_TYPE short int\n    //# endif\n    //#endif\n    //#if !u328_TYPE\n    //# ifdef HAVE_u328_T\n    //#  define u328_TYPE u328_t\n    //# else\n    //#  define u328_TYPE unsigned char\n    //# endif\n    //#endif\n    //#if !INT8_TYPE\n    //# ifdef HAVE_INT8_T\n    //#  define INT8_TYPE int8_t\n    //# else\n    //#  define INT8_TYPE signed char\n    //# endif\n    //#endif\n    //#if !LONGDOUBLE_TYPE\n    //# define LONGDOUBLE_TYPE long double\n    //#endif\n    //typedef sqlite_int64 i64;          /* 8-byte signed integer */\n    //typedef sqlite_u3264 u64;         /* 8-byte unsigned integer */\n    //typedef u32_TYPE u32;           /* 4-byte unsigned integer */\n    //typedef u3216_TYPE u16;           /* 2-byte unsigned integer */\n    //typedef INT16_TYPE i16;            /* 2-byte signed integer */\n    //typedef u328_TYPE u8;             /* 1-byte unsigned integer */\n    //typedef INT8_TYPE i8;              /* 1-byte signed integer */\n\n    /*\n    ** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value\n    ** that can be stored in a u32 without loss of data.  The value\n    ** is 0x00000000ffffffff.  But because of quirks of some compilers, we\n    ** have to specify the value in the less intuitive manner shown:\n    */\n    //#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)\n    const u32 SQLITE_MAX_U32 = (u32)( ( ( (u64)1 ) << 32 ) - 1 );\n\n\n    /*\n    ** Macros to determine whether the machine is big or little endian,\n    ** evaluated at runtime.\n    */\n#if SQLITE_AMALGAMATION\n//const int sqlite3one = 1;\n#else\n    const bool sqlite3one = true;\n#endif\n#if i386 || __i386__ || _M_IX86\nconst int ;//#define SQLITE_BIGENDIAN    0\nconst int ;//#define SQLITE_LITTLEENDIAN 1\nconst int ;//#define SQLITE_UTF16NATIVE  SQLITE_UTF16LE\n#else\n    static u8 SQLITE_BIGENDIAN = 0;//#define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)\n    static u8 SQLITE_LITTLEENDIAN = 1;//#define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)\n    static u8 SQLITE_UTF16NATIVE = ( SQLITE_BIGENDIAN != 0 ? SQLITE_UTF16BE : SQLITE_UTF16LE );//#define SQLITE_UTF16NATIVE (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)\n#endif\n\n    /*\n** Constants for the largest and smallest possible 64-bit signed integers.\n** These macros are designed to work correctly on both 32-bit and 64-bit\n** compilers.\n*/\n    //#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))\n    //#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)\n    const i64 LARGEST_INT64 = i64.MaxValue;//( 0xffffffff | ( ( (i64)0x7fffffff ) << 32 ) );\n    const i64 SMALLEST_INT64 = i64.MinValue;//( ( ( i64 ) - 1 ) - LARGEST_INT64 );\n\n    /*\n    ** Round up a number to the next larger multiple of 8.  This is used\n    ** to force 8-byte alignment on 64-bit architectures.\n    */\n    //#define ROUND8(x)     (((x)+7)&~7)\n    static int ROUND8( int x ) { return ( x + 7 ) & ~7; }\n\n    /*\n    ** Round down to the nearest multiple of 8\n    */\n    //#define ROUNDDOWN8(x) ((x)&~7)\n    static int ROUNDDOWN8( int x ) { return x & ~7; }\n\n    /*\n    ** Assert that the pointer X is aligned to an 8-byte boundary.\n    */\n    //#define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)\n\n    /*\n    ** An instance of the following structure is used to store the busy-handler\n    ** callback for a given sqlite handle.\n    **\n    ** The sqlite.busyHandler member of the sqlite struct contains the busy\n    ** callback for the database handle. Each pager opened via the sqlite\n    ** handle is passed a pointer to sqlite.busyHandler. The busy-handler\n    ** callback is currently invoked only from within pager.c.\n    */\n    //typedef struct BusyHandler BusyHandler;\n    public class BusyHandler\n    {\n      public dxBusy xFunc;//)(void *,int);  /* The busy callback */\n      public object pArg;                   /* First arg to busy callback */\n      public int nBusy;                     /* Incremented with each busy call */\n    };\n\n    /*\n    ** Name of the master database table.  The master database table\n    ** is a special table that holds the names and attributes of all\n    ** user tables and indices.\n    */\n    const string MASTER_NAME = "sqlite_master";//#define MASTER_NAME       "sqlite_master"\n    const string TEMP_MASTER_NAME = "sqlite_temp_master";//#define TEMP_MASTER_NAME  "sqlite_temp_master"\n\n    /*\n    ** The root-page of the master database table.\n    */\n    const int MASTER_ROOT = 1;//#define MASTER_ROOT       1\n\n    /*\n    ** The name of the schema table.\n    */\n    static string SCHEMA_TABLE( int x ) //#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)\n    { return ( ( OMIT_TEMPDB == 0 ) && ( x == 1 ) ? TEMP_MASTER_NAME : MASTER_NAME ); }\n\n    /*\n    ** A convenience macro that returns the number of elements in\n    ** an array.\n    */\n    //#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))\n    static int ArraySize<T>( T[] x ) { return x.Length; }\n\n    /*\n    ** The following value as a destructor means to use //sqlite3DbFree().\n    ** This is an internal extension to SQLITE_STATIC and SQLITE_TRANSIENT.\n    */\n    //#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)//sqlite3DbFree)\n    static dxDel SQLITE_DYNAMIC;\n\n    /*\n    ** When SQLITE_OMIT_WSD is defined, it means that the target platform does\n    ** not support Writable Static Data (WSD) such as global and static variables.\n    ** All variables must either be on the stack or dynamically allocated from\n    ** the heap.  When WSD is unsupported, the variable declarations scattered\n    ** throughout the SQLite code must become constants instead.  The SQLITE_WSD\n    ** macro is used for this purpose.  And instead of referencing the variable\n    ** directly, we use its constant as a key to lookup the run-time allocated\n    ** buffer that holds real variable.  The constant is also the initializer\n    ** for the run-time allocated buffer.\n    **\n    ** In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL\n    ** macros become no-ops and have zero performance impact.\n    */\n#if SQLITE_OMIT_WSD\n//#define SQLITE_WSD const\n//#define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))\n//#define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)\nint sqlite3_wsd_init(int N, int J);\nvoid *sqlite3_wsd_find(void *K, int L);\n#else\n    //#define SQLITE_WSD\n    //#define GLOBAL(t,v) v\n    //#define sqlite3GlobalConfig sqlite3Config\n    static Sqlite3Config sqlite3GlobalConfig;\n#endif\n\n    /*\n** The following macros are used to suppress compiler warnings and to\n** make it clear to human readers when a function parameter is deliberately\n** left unused within the body of a function. This usually happens when\n** a function is called via a function pointer. For example the\n** implementation of an SQL aggregate step callback may not use the\n** parameter indicating the number of arguments passed to the aggregate,\n** if it knows that this is enforced elsewhere.\n**\n** When a function parameter is not used at all within the body of a function,\n** it is generally named "NotUsed" or "NotUsed2" to make things even clearer.\n** However, these macros may also be used to suppress warnings related to\n** parameters that may or may not be used depending on compilation options.\n** For example those parameters only used in assert() statements. In these\n** cases the parameters are named as per the usual conventions.\n*/\n    //#define UNUSED_PARAMETER(x) (void)(x)\n    static void UNUSED_PARAMETER<T>( T x ) { }\n\n    //#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)\n    static void UNUSED_PARAMETER2<T1, T2>( T1 x, T2 y ) { UNUSED_PARAMETER( x ); UNUSED_PARAMETER( y ); }\n\n    /*\n    ** Forward references to structures\n    */\n    //typedef struct AggInfo AggInfo;\n    //typedef struct AuthContext AuthContext;\n    //typedef struct AutoincInfo AutoincInfo;\n    //typedef struct Bitvec Bitvec;\n    //typedef struct RowSet RowSet;\n    //typedef struct CollSeq CollSeq;\n    //typedef struct Column Column;\n    //typedef struct Db Db;\n    //typedef struct Schema Schema;\n    //typedef struct Expr Expr;\n    //typedef struct ExprList ExprList;\n    //typedef struct ExprSpan ExprSpan;\n    //typedef struct FKey FKey;\n    //typedef struct FuncDef FuncDef;\n    //typedef struct IdList IdList;\n    //typedef struct Index Index;\n    //typedef struct KeyClass KeyClass;\n    //typedef struct KeyInfo KeyInfo;\n    //typedef struct Lookaside Lookaside;\n    //typedef struct LookasideSlot LookasideSlot;\n    //typedef struct Module Module;\n    //typedef struct NameContext NameContext;\n    //typedef struct Parse Parse;\n    //typedef struct Savepoint Savepoint;\n    //typedef struct Select Select;\n    //typedef struct SrcList SrcList;\n    //typedef struct StrAccum StrAccum;\n    //typedef struct Table Table;\n    //typedef struct TableLock TableLock;\n    //typedef struct Token Token;\n    //typedef struct TriggerStack TriggerStack;\n    //typedef struct TriggerStep TriggerStep;\n    //typedef struct Trigger Trigger;\n    //typedef struct UnpackedRecord UnpackedRecord;\n    //typedef struct VTable VTable;\n    //typedef struct Walker Walker;\n    //typedef struct WherePlan WherePlan;\n    //typedef struct WhereInfo WhereInfo;\n    //typedef struct WhereLevel WhereLevel;\n\n    /*\n    ** Defer sourcing vdbe.h and btree.h until after the "u8" and\n    ** "BusyHandler" typedefs. vdbe.h also requires a few of the opaque\n    ** pointer types (i.e. FuncDef) defined above.\n    */\n    //#include "btree.h"\n    //#include "vdbe.h"\n    //#include "pager.h"\n    //#include "pcache_g.h"\n\n    //#include "os.h"\n    //#include "mutex.h"\n\n    /*\n    ** Each database file to be accessed by the system is an instance\n    ** of the following structure.  There are normally two of these structures\n    ** in the sqlite.aDb[] array.  aDb[0] is the main database file and\n    ** aDb[1] is the database file used to hold temporary tables.  Additional\n    ** databases may be attached.\n    */\n    public class Db\n    {\n      public string zName;                  /*  Name of this database  */\n      public Btree pBt;                     /*  The B Tree structure for this database file  */\n      public u8 inTrans;                    /*  0: not writable.  1: Transaction.  2: Checkpoint  */\n      public u8 safety_level;               /*  How aggressive at syncing data to disk  */\n      public Schema pSchema;                /* Pointer to database schema (possibly shared)  */\n    };\n\n    /*\n    ** An instance of the following structure stores a database schema.\n    **\n    ** If there are no virtual tables configured in this schema, the\n    ** Schema.db variable is set to NULL. After the first virtual table\n    ** has been added, it is set to point to the database connection\n    ** used to create the connection. Once a virtual table has been\n    ** added to the Schema structure and the Schema.db variable populated,\n    ** only that database connection may use the Schema to prepare\n    ** statements.\n    */\n    public class Schema\n    {\n      public int schema_cookie;         /* Database schema version number for this file */\n      public Hash tblHash = new Hash(); /* All tables indexed by name */\n      public Hash idxHash = new Hash(); /* All (named) indices indexed by name */\n      public Hash trigHash = new Hash();/* All triggers indexed by name */\n      public Table pSeqTab;             /* The sqlite_sequence table used by AUTOINCREMENT */\n      public u8 file_format;           /* Schema format version for this file */\n      public u8 enc;                   /* Text encoding used by this database */\n      public u16 flags;                 /* Flags associated with this schema */\n      public int cache_size;            /* Number of pages to use in the cache */\n#if !SQLITE_OMIT_VIRTUALTABLE\npublic   sqlite3 db;                    /* "Owner" connection. See comment above */\n#endif\n      public Schema Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Schema cp = (Schema)MemberwiseClone();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** These macros can be used to test, set, or clear bits in the\n    ** Db.flags field.\n    */\n    //#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->flags&(P))==(P))\n    static bool DbHasProperty( sqlite3 D, int I, ushort P ) { return ( D.aDb[I].pSchema.flags & P ) == P; }\n    //#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->flags&(P))!=0)\n    //#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->flags|=(P)\n    static void DbSetProperty( sqlite3 D, int I, ushort P ) { D.aDb[I].pSchema.flags = (u16)( D.aDb[I].pSchema.flags | P ); }\n    //#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->flags&=~(P)\n    static void DbClearProperty( sqlite3 D, int I, ushort P ) { D.aDb[I].pSchema.flags = (u16)( D.aDb[I].pSchema.flags & ~P ); }\n    /*\n    ** Allowed values for the DB.flags field.\n    **\n    ** The DB_SchemaLoaded flag is set after the database schema has been\n    ** read into internal hash tables.\n    **\n    ** DB_UnresetViews means that one or more views have column names that\n    ** have been filled out.  If the schema changes, these column names might\n    ** changes and so the view will need to be reset.\n    */\n    //#define DB_SchemaLoaded    0x0001  /* The schema has been loaded */\n    //#define DB_UnresetViews    0x0002  /* Some views have defined column names */\n    //#define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */\n    const u16 DB_SchemaLoaded = 0x0001;\n    const u16 DB_UnresetViews = 0x0002;\n    const u16 DB_Empty = 0x0004;\n\n    /*\n    ** The number of different kinds of things that can be limited\n    ** using the sqlite3_limit() interface.\n    */\n    //#define SQLITE_N_LIMIT (SQLITE_LIMIT_VARIABLE_NUMBER+1)\n    const int SQLITE_N_LIMIT = SQLITE_LIMIT_VARIABLE_NUMBER + 1;\n\n    /*\n    ** Lookaside malloc is a set of fixed-size buffers that can be used\n    ** to satisfy small transient memory allocation requests for objects\n    ** associated with a particular database connection.  The use of\n    ** lookaside malloc provides a significant performance enhancement\n    ** (approx 10%) by avoiding numerous malloc/free requests while parsing\n    ** SQL statements.\n    **\n    ** The Lookaside structure holds configuration information about the\n    ** lookaside malloc subsystem.  Each available memory allocation in\n    ** the lookaside subsystem is stored on a linked list of LookasideSlot\n    ** objects.\n    **\n    ** Lookaside allocations are only allowed for objects that are associated\n    ** with a particular database connection.  Hence, schema information cannot\n    ** be stored in lookaside because in shared cache mode the schema information\n    ** is shared by multiple database connections.  Therefore, while parsing\n    ** schema information, the Lookaside.bEnabled flag is cleared so that\n    ** lookaside allocations are not used to construct the schema objects.\n    */\n    public class Lookaside\n    {\n      public int sz;               /* Size of each buffer in bytes */\n      public u8 bEnabled;        /* False to disable new lookaside allocations */\n      public bool bMalloced;       /* True if pStart obtained from sqlite3_malloc() */\n      public int nOut;             /* Number of buffers currently checked out */\n      public int mxOut;            /* Highwater mark for nOut */\n      public LookasideSlot pFree;  /* List of available buffers */\n      public int pStart;           /* First byte of available memory space */\n      public int pEnd;             /* First byte past end of available space */\n    };\n    public class LookasideSlot\n    {\n      public LookasideSlot pNext;    /* Next buffer in the list of free buffers */\n    };\n\n    /*\n    ** A hash table for function definitions.\n    **\n    ** Hash each FuncDef structure into one of the FuncDefHash.a[] slots.\n    ** Collisions are on the FuncDef.pHash chain.\n    */\n    public class FuncDefHash\n    {\n      public FuncDef[] a = new FuncDef[23];       /* Hash table for functions */\n    };\n\n    /*\n    ** Each database is an instance of the following structure.\n    **\n    ** The sqlite.lastRowid records the last insert rowid generated by an\n    ** insert statement.  Inserts on views do not affect its value.  Each\n    ** trigger has its own context, so that lastRowid can be updated inside\n    ** triggers as usual.  The previous value will be restored once the trigger\n    ** exits.  Upon entering a before or instead of trigger, lastRowid is no\n    ** longer (since after version 2.8.12) reset to -1.\n    **\n    ** The sqlite.nChange does not count changes within triggers and keeps no\n    ** context.  It is reset at start of sqlite3_exec.\n    ** The sqlite.lsChange represents the number of changes made by the last\n    ** insert, update, or delete statement.  It remains constant throughout the\n    ** length of a statement and is then updated by OP_SetCounts.  It keeps a\n    ** context stack just like lastRowid so that the count of changes\n    ** within a trigger is not seen outside the trigger.  Changes to views do not\n    ** affect the value of lsChange.\n    ** The sqlite.csChange keeps track of the number of current changes (since\n    ** the last statement) and is used to update sqlite_lsChange.\n    **\n    ** The member variables sqlite.errCode, sqlite.zErrMsg and sqlite.zErrMsg16\n    ** store the most recent error code and, if applicable, string. The\n    ** internal function sqlite3Error() is used to set these variables\n    ** consistently.\n    */\n    public class sqlite3\n    {\n      public sqlite3_vfs pVfs;             /* OS Interface */\n      public int nDb;                      /* Number of backends currently in use */\n      public Db[] aDb = new Db[SQLITE_MAX_ATTACHED];         /* All backends */\n      public int flags;                    /* Miscellaneous flags. See below */\n      public int openFlags;                /* Flags passed to sqlite3_vfs.xOpen() */\n      public int errCode;                  /* Most recent error code (SQLITE_*) */\n      public int errMask;                  /* & result codes with this before returning */\n      public u8 autoCommit;                /* The auto-commit flag. */\n      public u8 temp_store;                /* 1: file 2: memory 0: default */\n      // Cannot happen under C#\n      //      public u8 mallocFailed;              /* True if we have seen a malloc failure */\n      public u8 dfltLockMode;              /* Default locking-mode for attached dbs */\n      public u8 dfltJournalMode;           /* Default journal mode for attached dbs */\n      public int nextAutovac;              /* Autovac setting after VACUUM if >=0 */\n      public int nextPagesize;             /* Pagesize after VACUUM if >0 */\n      public int nTable;                   /* Number of tables in the database */\n      public CollSeq pDfltColl;            /* The default collating sequence (BINARY) */\n      public i64 lastRowid;                /* ROWID of most recent insert (see above) */\n      public u32 magic;                    /* Magic number for detect library misuse */\n      public int nChange;                  /* Value returned by sqlite3_changes() */\n      public int nTotalChange;             /* Value returned by sqlite3_total_changes() */\n      public sqlite3_mutex mutex;          /* Connection mutex */\n      public int[] aLimit = new int[SQLITE_N_LIMIT];   /* Limits */\n      public class sqlite3InitInfo\n      {      /* Information used during initialization */\n        public int iDb;                    /* When back is being initialized */\n        public int newTnum;                /* Rootpage of table being initialized */\n        public u8 busy;                    /* TRUE if currently initializing */\n        public u8 orphanTrigger;           /* Last statement is orphaned TEMP trigger */\n      };\n      public sqlite3InitInfo init = new sqlite3InitInfo();\n      public int nExtension;               /* Number of loaded extensions */\n      public object[] aExtension;          /* Array of shared library handles */\n      public Vdbe pVdbe;                   /* List of active virtual machines */\n      public int activeVdbeCnt;            /* Number of VDBEs currently executing */\n      public int writeVdbeCnt;             /* Number of active VDBEs that are writing */\n      public dxTrace xTrace;//)(void*,const char*);        /* Trace function */\n      public object pTraceArg;                          /* Argument to the trace function */\n      public dxProfile xProfile;//)(void*,const char*,u64);  /* Profiling function */\n      public object pProfileArg;                        /* Argument to profile function */\n      public object pCommitArg;                 /* Argument to xCommitCallback() */\n      public dxCommitCallback xCommitCallback;//)(void*);    /* Invoked at every commit. */\n      public object pRollbackArg;               /* Argument to xRollbackCallback() */\n      public dxRollbackCallback xRollbackCallback;//)(void*); /* Invoked at every commit. */\n      public object pUpdateArg;\n      public dxUpdateCallback xUpdateCallback;//)(void*,int, const char*,const char*,sqlite_int64);\n      public dxCollNeeded xCollNeeded;//)(void*,sqlite3*,int eTextRep,const char*);\n      public dxCollNeeded xCollNeeded16;//)(void*,sqlite3*,int eTextRep,const void*);\n      public object pCollNeededArg;\n      public sqlite3_value pErr;            /* Most recent error message */\n      public string zErrMsg;                /* Most recent error message (UTF-8 encoded) */\n      public string zErrMsg16;              /* Most recent error message (UTF-16 encoded) */\n      public struct _u1\n      {\n        public bool isInterrupted;          /* True if sqlite3_interrupt has been called */\n        public double notUsed1;            /* Spacer */\n      }\n      public _u1 u1;\n      public Lookaside lookaside = new Lookaside();          /* Lookaside malloc configuration */\n#if !SQLITE_OMIT_AUTHORIZATION\npublic dxAuth xAuth;//)(void*,int,const char*,const char*,const char*,const char*);\n/* Access authorization function */\npublic object pAuthArg;               /* 1st argument to the access auth function */\n#endif\n#if !SQLITE_OMIT_PROGRESS_CALLBACK\n      public dxProgress xProgress;//)(void *);  /* The progress callback */\n      public object pProgressArg;               /* Argument to the progress callback */\n      public int nProgressOps;                  /* Number of opcodes for progress callback */\n#endif\n#if !SQLITE_OMIT_VIRTUALTABLE\n      public Hash aModule;                  /* populated by sqlite3_create_module() */\n      public Table pVTab;                   /* vtab with active Connect/Create method */\n      public VTable aVTrans;                /* Virtual tables with open transactions */\n      public int nVTrans;                   /* Allocated size of aVTrans */\n      public VTable pDisconnect;            /* Disconnect these in next sqlite3_prepare() */\n#endif\n      public FuncDefHash aFunc = new FuncDefHash();       /* Hash table of connection functions */\n      public Hash aCollSeq = new Hash();                  /* All collating sequences */\n      public BusyHandler busyHandler = new BusyHandler(); /* Busy callback */\n      public int busyTimeout;                             /* Busy handler timeout, in msec */\n      public Db[] aDbStatic = new Db[] { new Db(), new Db() };              /* Static space for the 2 default backends */\n      public Savepoint pSavepoint;         /* List of active savepoints */\n      public int nSavepoint;               /* Number of non-transaction savepoints */\n      public int nStatement;               /* Number of nested statement-transactions  */\n      public u8 isTransactionSavepoint;    /* True if the outermost savepoint is a TS */\n#if SQLITE_ENABLE_UNLOCK_NOTIFY\n/* The following variables are all protected by the STATIC_MASTER\n** mutex, not by sqlite3.mutex. They are used by code in notify.c.\n**\n** When X.pUnlockConnection==Y, that means that X is waiting for Y to\n** unlock so that it can proceed.\n**\n** When X.pBlockingConnection==Y, that means that something that X tried\n** tried to do recently failed with an SQLITE_LOCKED error due to locks\n** held by Y.\n*/\nsqlite3 *pBlockingConnection; /* Connection that caused SQLITE_LOCKED */\nsqlite3 *pUnlockConnection;           /* Connection to watch for unlock */\nvoid *pUnlockArg;                     /* Argument to xUnlockNotify */\nvoid (*xUnlockNotify)(void **, int);  /* Unlock notify callback */\nsqlite3 *pNextBlocked;        /* Next in list of all blocked connections */\n#endif\n    };\n\n    /*\n    ** A macro to discover the encoding of a database.\n    */\n    //#define ENC(db) ((db)->aDb[0].pSchema->enc)\n    static u8 ENC( sqlite3 db ) { return db.aDb[0].pSchema.enc; }\n\n    /*\n    ** Possible values for the sqlite.flags and or Db.flags fields.\n    **\n    ** On sqlite.flags, the SQLITE_InTrans value means that we have\n    ** executed a BEGIN.  On Db.flags, SQLITE_InTrans means a statement\n    ** transaction is active on that particular database file.\n    */\n    const int SQLITE_VdbeTrace = 0x00000001;//#define SQLITE_VdbeTrace      0x00000001  /* True to trace VDBE execution */\n    const int SQLITE_InTrans = 0x00000008;//#define SQLITE_InTrans        0x00000008  /* True if in a transaction */\n    const int SQLITE_InternChanges = 0x00000010;//#define SQLITE_InternChanges  0x00000010  /* Uncommitted Hash table changes */\n    const int SQLITE_FullColNames = 0x00000020;//#define SQLITE_FullColNames   0x00000020  /* Show full column names on SELECT */\n    const int SQLITE_ShortColNames = 0x00000040;//#define SQLITE_ShortColNames  0x00000040  /* Show short columns names */\n    const int SQLITE_CountRows = 0x00000080;//#define SQLITE_CountRows      0x00000080  /* Count rows changed by INSERT, */\n    //                                          /*   DELETE, or UPDATE and return */\n    //                                          /*   the count using a callback. */\n    const int SQLITE_NullCallback = 0x00000100;  //#define SQLITE_NullCallback   0x00000100  /* Invoke the callback once if the */\n    //                                          /*   result set is empty */\n    const int SQLITE_SqlTrace = 0x00000200;      //#define SQLITE_SqlTrace       0x00000200  /* Debug print SQL as it executes */\n    const int SQLITE_VdbeListing = 0x00000400;   //#define SQLITE_VdbeListing    0x00000400  /* Debug listings of VDBE programs */\n    const int SQLITE_WriteSchema = 0x00000800;   //#define SQLITE_WriteSchema    0x00000800  /* OK to update SQLITE_MASTER */\n    const int SQLITE_NoReadlock = 0x00001000;    //#define SQLITE_NoReadlock     0x00001000  /* Readlocks are omitted when\n    //                                          ** accessing read-only databases */\n    const int SQLITE_IgnoreChecks = 0x00002000;  //#define SQLITE_IgnoreChecks   0x00002000  /* Do not enforce check constraints */\n    const int SQLITE_ReadUncommitted = 0x00004000;//#define SQLITE_ReadUncommitted 0x00004000 /* For shared-cache mode */\n    const int SQLITE_LegacyFileFmt = 0x00008000; //#define SQLITE_LegacyFileFmt  0x00008000  /* Create new databases in format 1 */\n    const int SQLITE_FullFSync = 0x00010000;     //#define SQLITE_FullFSync      0x00010000  /* Use full fsync on the backend */\n    const int SQLITE_LoadExtension = 0x00020000; //#define SQLITE_LoadExtension  0x00020000  /* Enable load_extension */\n\n    const int SQLITE_RecoveryMode = 0x00040000;  //#define SQLITE_RecoveryMode   0x00040000  /* Ignore schema errors */\n    const int SQLITE_ReverseOrder = 0x00100000;  //#define SQLITE_ReverseOrder   0x00100000  /* Reverse unordered SELECTs */\n\n    /*\n    ** Possible values for the sqlite.magic field.\n    ** The numbers are obtained at random and have no special meaning, other\n    ** than being distinct from one another.\n    */\n    const int SQLITE_MAGIC_OPEN = 0x1029a697;   //#define SQLITE_MAGIC_OPEN     0xa029a697  /* Database is open */\n    const int SQLITE_MAGIC_CLOSED = 0x2f3c2d33; //#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /* Database is closed */\n    const int SQLITE_MAGIC_SICK = 0x3b771290;   //#define SQLITE_MAGIC_SICK     0x4b771290  /* Error and awaiting close */\n    const int SQLITE_MAGIC_BUSY = 0x403b7906;   //#define SQLITE_MAGIC_BUSY     0xf03b7906  /* Database currently in use */\n    const int SQLITE_MAGIC_ERROR = 0x55357930;  //#define SQLITE_MAGIC_ERROR    0xb5357930  /* An SQLITE_MISUSE error occurred */\n\n    /*\n    ** Each SQL function is defined by an instance of the following\n    ** structure.  A pointer to this structure is stored in the sqlite.aFunc\n    ** hash table.  When multiple functions have the same name, the hash table\n    ** points to a linked list of these structures.\n    */\n    public class FuncDef\n    {\n      public i16 nArg;           /* Number of arguments.  -1 means unlimited */\n      public u8 iPrefEnc;        /* Preferred text encoding (SQLITE_UTF8, 16LE, 16BE) */\n      public u8 flags;           /* Some combination of SQLITE_FUNC_* */\n      public object pUserData;   /* User data parameter */\n      public FuncDef pNext;      /* Next function with same name */\n      public dxFunc xFunc;//)(sqlite3_context*,int,sqlite3_value**); /* Regular function */\n      public dxStep xStep;//)(sqlite3_context*,int,sqlite3_value**); /* Aggregate step */\n      public dxFinal xFinalize;//)(sqlite3_context*);                /* Aggregate finalizer */\n      public string zName;       /* SQL name of the function. */\n      public FuncDef pHash;      /* Next with a different name but the same hash */\n\n\n      public FuncDef()\n      { }\n\n      public FuncDef( i16 nArg, u8 iPrefEnc, u8 iflags, object pUserData, FuncDef pNext, dxFunc xFunc, dxStep xStep, dxFinal xFinalize, string zName, FuncDef pHash )\n      {\n        this.nArg = nArg;\n        this.iPrefEnc = iPrefEnc;\n        this.flags = iflags;\n        this.pUserData = pUserData;\n        this.pNext = pNext;\n        this.xFunc = xFunc;\n        this.xStep = xStep;\n        this.xFinalize = xFinalize;\n        this.zName = zName;\n        this.pHash = pHash;\n      }\n      public FuncDef( string zName, u8 iPrefEnc, i16 nArg, int iArg, u8 iflags, dxFunc xFunc )\n      {\n        this.nArg = nArg;\n        this.iPrefEnc = iPrefEnc;\n        this.flags = iflags;\n        this.pUserData = iArg;\n        this.pNext = null;\n        this.xFunc = xFunc;\n        this.xStep = null;\n        this.xFinalize = null;\n        this.zName = zName;\n      }\n\n      public FuncDef( string zName, u8 iPrefEnc, i16 nArg, int iArg, u8 iflags, dxStep xStep, dxFinal xFinal )\n      {\n        this.nArg = nArg;\n        this.iPrefEnc = iPrefEnc;\n        this.flags = iflags;\n        this.pUserData = iArg;\n        this.pNext = null;\n        this.xFunc = null;\n        this.xStep = xStep;\n        this.xFinalize = xFinal;\n        this.zName = zName;\n      }\n\n      public FuncDef( string zName, u8 iPrefEnc, i16 nArg, object arg, dxFunc xFunc, u8 flags )\n      {\n        this.nArg = nArg;\n        this.iPrefEnc = iPrefEnc;\n        this.flags = flags;\n        this.pUserData = arg;\n        this.pNext = null;\n        this.xFunc = xFunc;\n        this.xStep = null;\n        this.xFinalize = null;\n        this.zName = zName;\n      }\n\n    };\n\n    /*\n    ** Possible values for FuncDef.flags\n    */\n    //#define SQLITE_FUNC_LIKE     0x01  /* Candidate for the LIKE optimization */\n    //#define SQLITE_FUNC_CASE     0x02  /* Case-sensitive LIKE-type function */\n    //#define SQLITE_FUNC_EPHEM    0x04  /* Ephemeral.  Delete with VDBE */\n    //#define SQLITE_FUNC_NEEDCOLL 0x08 /* sqlite3GetFuncCollSeq() might be called */\n    //#define SQLITE_FUNC_PRIVATE  0x10 /* Allowed for internal use only */\n    //#define SQLITE_FUNC_COUNT    0x20 /* Built-in count(*) aggregate */\n    const int SQLITE_FUNC_LIKE = 0x01;    /* Candidate for the LIKE optimization */\n    const int SQLITE_FUNC_CASE = 0x02;    /* Case-sensitive LIKE-type function */\n    const int SQLITE_FUNC_EPHEM = 0x04;   /* Ephermeral.  Delete with VDBE */\n    const int SQLITE_FUNC_NEEDCOLL = 0x08;/* sqlite3GetFuncCollSeq() might be called */\n    const int SQLITE_FUNC_PRIVATE = 0x10; /* Allowed for internal use only */\n    const int SQLITE_FUNC_COUNT = 0x20;   /* Built-in count(*) aggregate */\n\n\n    /*\n    ** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are\n    ** used to create the initializers for the FuncDef structures.\n    **\n    **   FUNCTION(zName, nArg, iArg, bNC, xFunc)\n    **     Used to create a scalar function definition of a function zName\n    **     implemented by C function xFunc that accepts nArg arguments. The\n    **     value passed as iArg is cast to a (void*) and made available\n    **     as the user-data (sqlite3_user_data()) for the function. If\n    **     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set.\n    **\n    **   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)\n    **     Used to create an aggregate function definition implemented by\n    **     the C functions xStep and xFinal. The first four parameters\n    **     are interpreted in the same way as the first 4 parameters to\n    **     FUNCTION().\n    **\n    **   LIKEFUNC(zName, nArg, pArg, flags)\n    **     Used to create a scalar function definition of a function zName\n    **     that accepts nArg arguments and is implemented by a call to C\n    **     function likeFunc. Argument pArg is cast to a (void *) and made\n    **     available as the function user-data (sqlite3_user_data()). The\n    **     FuncDef.flags variable is set to the value passed as the flags\n    **     parameter.\n    */\n    //#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n    //  {nArg, SQLITE_UTF8, bNC*SQLITE_FUNC_NEEDCOLL, \\\n    //SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, #zName, 0}\n\n    static FuncDef FUNCTION( string zName, i16 nArg, int iArg, u8 bNC, dxFunc xFunc )\n    { return new FuncDef( zName, SQLITE_UTF8, nArg, iArg, (u8)( bNC * SQLITE_FUNC_NEEDCOLL ), xFunc ); }\n\n    //#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \\\n    //  {nArg, SQLITE_UTF8, bNC*SQLITE_FUNC_NEEDCOLL, \\\n    //pArg, 0, xFunc, 0, 0, #zName, 0}\n\n    //#define LIKEFUNC(zName, nArg, arg, flags) \\\n    //  {nArg, SQLITE_UTF8, flags, (void *)arg, 0, likeFunc, 0, 0, #zName, 0}\n    static FuncDef LIKEFUNC( string zName, i16 nArg, object arg, u8 flags )\n    { return new FuncDef( zName, SQLITE_UTF8, nArg, arg, likeFunc, flags ); }\n\n    //#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) \\\n    //  {nArg, SQLITE_UTF8, nc*SQLITE_FUNC_NEEDCOLL, \\\n    //SQLITE_INT_TO_PTR(arg), 0, 0, xStep,xFinal,#zName,0}\n\n    static FuncDef AGGREGATE( string zName, i16 nArg, int arg, u8 nc, dxStep xStep, dxFinal xFinal )\n    { return new FuncDef( zName, SQLITE_UTF8, nArg, arg, (u8)( nc * SQLITE_FUNC_NEEDCOLL ), xStep, xFinal ); }\n\n    /*\n    ** All current savepoints are stored in a linked list starting at\n    ** sqlite3.pSavepoint. The first element in the list is the most recently\n    ** opened savepoint. Savepoints are added to the list by the vdbe\n    ** OP_Savepoint instruction.\n    */\n    //struct Savepoint {\n    //  char *zName;                        /* Savepoint name (nul-terminated) */\n    //  Savepoint *pNext;                   /* Parent savepoint (if any) */\n    //};\n    public class Savepoint\n    {\n      public string zName;              /* Savepoint name (nul-terminated) */\n      public Savepoint pNext;           /* Parent savepoint (if any) */\n    };\n    /*\n    ** The following are used as the second parameter to sqlite3Savepoint(),\n    ** and as the P1 argument to the OP_Savepoint instruction.\n    */\n    const int SAVEPOINT_BEGIN = 0;   //#define SAVEPOINT_BEGIN      0\n    const int SAVEPOINT_RELEASE = 1;   //#define SAVEPOINT_RELEASE    1\n    const int SAVEPOINT_ROLLBACK = 2;    //#define SAVEPOINT_ROLLBACK   2\n\n    /*\n    ** Each SQLite module (virtual table definition) is defined by an\n    ** instance of the following structure, stored in the sqlite3.aModule\n    ** hash table.\n    */\n    public class Module\n    {\n      public sqlite3_module pModule;          /* Callback pointers */\n      public string zName;                    /* Name passed to create_module() */\n      public object pAux;                     /* pAux passed to create_module() */\n      public dxDestroy xDestroy;//)(void *);  /* Module destructor function */\n    };\n\n    /*\n** information about each column of an SQL table is held in an instance\n** of this structure.\n*/\n    public class Column\n    {\n      public string zName;      /* Name of this column */\n      public Expr pDflt;        /* Default value of this column */\n      public string zDflt;      /* Original text of the default value */\n      public string zType;      /* Data type for this column */\n      public string zColl;      /* Collating sequence.  If NULL, use the default */\n      public u8 notNull;        /* True if there is a NOT NULL constraint */\n      public u8 isPrimKey;      /* True if this column is part of the PRIMARY KEY */\n      public char affinity;     /* One of the SQLITE_AFF_... values */\n#if !SQLITE_OMIT_VIRTUALTABLE\npublic   u8 isHidden;     /* True if this column is \'hidden\' */\n#endif\n      public Column Copy()\n      {\n        Column cp = (Column)MemberwiseClone();\n        if ( cp.pDflt != null ) cp.pDflt = pDflt.Copy();\n        return cp;\n      }\n    };\n\n    /*\n    ** A "Collating Sequence" is defined by an instance of the following\n    ** structure. Conceptually, a collating sequence consists of a name and\n    ** a comparison routine that defines the order of that sequence.\n    **\n    ** There may two separate implementations of the collation function, one\n    ** that processes text in UTF-8 encoding (CollSeq.xCmp) and another that\n    ** processes text encoded in UTF-16 (CollSeq.xCmp16), using the machine\n    ** native byte order. When a collation sequence is invoked, SQLite selects\n    ** the version that will require the least expensive encoding\n    ** translations, if any.\n    **\n    ** The CollSeq.pUser member variable is an extra parameter that passed in\n    ** as the first argument to the UTF-8 comparison function, xCmp.\n    ** CollSeq.pUser16 is the equivalent for the UTF-16 comparison function,\n    ** xCmp16.\n    **\n    ** If both CollSeq.xCmp and CollSeq.xCmp16 are NULL, it means that the\n    ** collating sequence is undefined.  Indices built on an undefined\n    ** collating sequence may not be read or written.\n    */\n    public class CollSeq\n    {\n      public string zName;          /* Name of the collating sequence, UTF-8 encoded */\n      public u8 enc;                /* Text encoding handled by xCmp() */\n      public u8 type;               /* One of the SQLITE_COLL_... values below */\n      public object pUser;          /* First argument to xCmp() */\n      public dxCompare xCmp;//)(void*,int, const void*, int, const void*);\n      public dxDelCollSeq xDel;//)(void*);  /* Destructor for pUser */\n\n      public CollSeq Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          CollSeq cp = (CollSeq)MemberwiseClone();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** Allowed values of CollSeq.type:\n    */\n    const int SQLITE_COLL_BINARY = 1;//#define SQLITE_COLL_BINARY  1  /* The default memcmp() collating sequence */\n    const int SQLITE_COLL_NOCASE = 2;//#define SQLITE_COLL_NOCASE  2  /* The built-in NOCASE collating sequence */\n    const int SQLITE_COLL_REVERSE = 3;//#define SQLITE_COLL_REVERSE 3  /* The built-in REVERSE collating sequence */\n    const int SQLITE_COLL_USER = 0;//#define SQLITE_COLL_USER    0  /* Any other user-defined collating sequence */\n\n    /*\n    ** A sort order can be either ASC or DESC.\n    */\n    const int SQLITE_SO_ASC = 0;//#define SQLITE_SO_ASC       0  /* Sort in ascending order */\n    const int SQLITE_SO_DESC = 1;//#define SQLITE_SO_DESC     1  /* Sort in ascending order */\n\n    /*\n    ** Column affinity types.\n    **\n    ** These used to have mnemonic name like \'i\' for SQLITE_AFF_INTEGER and\n    ** \'t\' for SQLITE_AFF_TEXT.  But we can save a little space and improve\n    ** the speed a little by numbering the values consecutively.\n    **\n    ** But rather than start with 0 or 1, we begin with \'a\'.  That way,\n    ** when multiple affinity types are concatenated into a string and\n    ** used as the P4 operand, they will be more readable.\n    **\n    ** Note also that the numeric types are grouped together so that testing\n    ** for a numeric type is a single comparison.\n    */\n    const char SQLITE_AFF_TEXT = \'a\';//#define SQLITE_AFF_TEXT     \'a\'\n    const char SQLITE_AFF_NONE = \'b\';//#define SQLITE_AFF_NONE     \'b\'\n    const char SQLITE_AFF_NUMERIC = \'c\';//#define SQLITE_AFF_NUMERIC  \'c\'\n    const char SQLITE_AFF_INTEGER = \'d\';//#define SQLITE_AFF_INTEGER  \'d\'\n    const char SQLITE_AFF_REAL = \'e\';//#define SQLITE_AFF_REAL     \'e\'\n\n    //#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)\n\n    /*\n    ** The SQLITE_AFF_MASK values masks off the significant bits of an\n    ** affinity value.\n    */\n    const int SQLITE_AFF_MASK = 0x67;//#define SQLITE_AFF_MASK     0x67\n\n    /*\n    ** Additional bit values that can be ORed with an affinity without\n    ** changing the affinity.\n    */\n    const int SQLITE_JUMPIFNULL = 0x08;//#define SQLITE_JUMPIFNULL   0x08  /* jumps if either operand is NULL */\n    const int SQLITE_STOREP2 = 0x10;   //#define SQLITE_STOREP2      0x10  /* Store result in reg[P2] rather than jump */\n\n    /*\n    ** An object of this type is created for each virtual table present in\n    ** the database schema. \n    **\n    ** If the database schema is shared, then there is one instance of this\n    ** structure for each database connection (sqlite3*) that uses the shared\n    ** schema. This is because each database connection requires its own unique\n    ** instance of the sqlite3_vtab* handle used to access the virtual table \n    ** implementation. sqlite3_vtab* handles can not be shared between \n    ** database connections, even when the rest of the in-memory database \n    ** schema is shared, as the implementation often stores the database\n    ** connection handle passed to it via the xConnect() or xCreate() method\n    ** during initialization internally. This database connection handle may\n    ** then used by the virtual table implementation to access real tables \n    ** within the database. So that they appear as part of the callers \n    ** transaction, these accesses need to be made via the same database \n    ** connection as that used to execute SQL operations on the virtual table.\n    **\n    ** All VTable objects that correspond to a single table in a shared\n    ** database schema are initially stored in a linked-list pointed to by\n    ** the Table.pVTable member variable of the corresponding Table object.\n    ** When an sqlite3_prepare() operation is required to access the virtual\n    ** table, it searches the list for the VTable that corresponds to the\n    ** database connection doing the preparing so as to use the correct\n    ** sqlite3_vtab* handle in the compiled query.\n    **\n    ** When an in-memory Table object is deleted (for example when the\n    ** schema is being reloaded for some reason), the VTable objects are not \n    ** deleted and the sqlite3_vtab* handles are not xDisconnect()ed \n    ** immediately. Instead, they are moved from the Table.pVTable list to\n    ** another linked list headed by the sqlite3.pDisconnect member of the\n    ** corresponding sqlite3 structure. They are then deleted/xDisconnected \n    ** next time a statement is prepared using said sqlite3*. This is done\n    ** to avoid deadlock issues involving multiple sqlite3.mutex mutexes.\n    ** Refer to comments above function sqlite3VtabUnlockList() for an\n    ** explanation as to why it is safe to add an entry to an sqlite3.pDisconnect\n    ** list without holding the corresponding sqlite3.mutex mutex.\n    **\n    ** The memory for objects of this type is always allocated by \n    ** sqlite3DbMalloc(), using the connection handle stored in VTable.db as \n    ** the first argument.\n    */\n    public class VTable\n    {\n      public sqlite3 db;              /* Database connection associated with this table */\n      public Module pMod;             /* Pointer to module implementation */\n      public sqlite3_vtab pVtab;      /* Pointer to vtab instance */\n      public int nRef;                /* Number of pointers to this structure */\n      public VTable pNext;            /* Next in linked list (see above) */\n    };\n\n    /*\n    ** Each SQL table is represented in memory by an instance of the\n    ** following structure.\n    **\n    ** Table.zName is the name of the table.  The case of the original\n    ** CREATE TABLE statement is stored, but case is not significant for\n    ** comparisons.\n    **\n    ** Table.nCol is the number of columns in this table.  Table.aCol is a\n    ** pointer to an array of Column structures, one for each column.\n    **\n    ** If the table has an INTEGER PRIMARY KEY, then Table.iPKey is the index of\n    ** the column that is that key.   Otherwise Table.iPKey is negative.  Note\n    ** that the datatype of the PRIMARY KEY must be INTEGER for this field to\n    ** be set.  An INTEGER PRIMARY KEY is used as the rowid for each row of\n    ** the table.  If a table has no INTEGER PRIMARY KEY, then a random rowid\n    ** is generated for each row of the table.  TF_HasPrimaryKey is set if\n    ** the table has any PRIMARY KEY, INTEGER or otherwise.\n    **\n    ** Table.tnum is the page number for the root BTree page of the table in the\n    ** database file.  If Table.iDb is the index of the database table backend\n    ** in sqlite.aDb[].  0 is for the main database and 1 is for the file that\n    ** holds temporary tables and indices.  If TF_Ephemeral is set\n    ** then the table is stored in a file that is automatically deleted\n    ** when the VDBE cursor to the table is closed.  In this case Table.tnum\n    ** refers VDBE cursor number that holds the table open, not to the root\n    ** page number.  Transient tables are used to hold the results of a\n    ** sub-query that appears instead of a real table name in the FROM clause\n    ** of a SELECT statement.\n    */\n    public class Table\n    {\n      public sqlite3 dbMem;     /* DB connection used for lookaside allocations. */\n      public string zName;      /* Name of the table or view */\n      public int iPKey;         /* If not negative, use aCol[iPKey] as the primary key */\n      public int nCol;          /* Number of columns in this table */\n      public Column[] aCol;     /* Information about each column */\n      public Index pIndex;      /* List of SQL indexes on this table. */\n      public int tnum;          /* Root BTree node for this table (see note above) */\n      public Select pSelect;    /* NULL for tables.  Points to definition if a view. */\n      public u16 nRef;          /* Number of pointers to this Table */\n      public u8 tabFlags;       /* Mask of TF_* values */\n      public u8 keyConf;        /* What to do in case of uniqueness conflict on iPKey */\n      public FKey pFKey;        /* Linked list of all foreign keys in this table */\n      public string zColAff;    /* String defining the affinity of each column */\n#if !SQLITE_OMIT_CHECK\n      public Expr pCheck;       /* The AND of all CHECK constraints */\n#endif\n#if !SQLITE_OMIT_ALTERTABLE\n      public int addColOffset;  /* Offset in CREATE TABLE stmt to add a new column */\n#endif\n#if !SQLITE_OMIT_VIRTUALTABLE\n      public VTable pVTable;      /* List of VTable objects. */\n      public int nModuleArg;      /* Number of arguments to the module */\n      public string[] azModuleArg;/* Text of all module args. [0] is module name */\n#endif\n      public Trigger pTrigger;  /* List of SQL triggers on this table */\n      public Schema pSchema;    /* Schema that contains this table */\n      public Table pNextZombie;  /* Next on the Parse.pZombieTab list */\n\n      public Table Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Table cp = (Table)MemberwiseClone();\n          if ( pIndex != null ) cp.pIndex = pIndex.Copy();\n          if ( pSelect != null ) cp.pSelect = pSelect.Copy();\n          if ( pTrigger != null ) cp.pTrigger = pTrigger.Copy();\n          if ( pFKey != null ) cp.pFKey = pFKey.Copy();\n#if !SQLITE_OMIT_CHECK\n          // Don\'t Clone Checks, only copy reference via Memberwise Clone above --\n          //if ( pCheck != null ) cp.pCheck = pCheck.Copy();\n#endif\n#if !SQLITE_OMIT_VIRTUALTABLE\nif ( pMod != null ) cp.pMod =pMod.Copy();\nif ( pVtab != null ) cp.pVtab =pVtab.Copy();\n#endif\n          // Don\'t Clone Schema, only copy reference via Memberwise Clone above --\n          // if ( pSchema != null ) cp.pSchema=pSchema.Copy();\n          // Don\'t Clone pNextZombie, only copy reference via Memberwise Clone above --\n          // if ( pNextZombie != null ) cp.pNextZombie=pNextZombie.Copy();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** Allowed values for Tabe.tabFlags.\n    */\n    //#define TF_Readonly        0x01    /* Read-only system table */\n    //#define TF_Ephemeral       0x02    /* An ephemeral table */\n    //#define TF_HasPrimaryKey   0x04    /* Table has a primary key */\n    //#define TF_Autoincrement   0x08    /* Integer primary key is autoincrement */\n    //#define TF_Virtual         0x10    /* Is a virtual table */\n    //#define TF_NeedMetadata    0x20    /* aCol[].zType and aCol[].pColl missing */\n    /*\n    ** Allowed values for Tabe.tabFlags.\n    */\n    const int TF_Readonly = 0x01;   /* Read-only system table */\n    const int TF_Ephemeral = 0x02;   /* An ephemeral table */\n    const int TF_HasPrimaryKey = 0x04;   /* Table has a primary key */\n    const int TF_Autoincrement = 0x08;   /* Integer primary key is autoincrement */\n    const int TF_Virtual = 0x10;   /* Is a virtual table */\n    const int TF_NeedMetadata = 0x20;   /* aCol[].zType and aCol[].pColl missing */\n\n    /*\n    ** Test to see whether or not a table is a virtual table.  This is\n    ** done as a macro so that it will be optimized out when virtual\n    ** table support is omitted from the build.\n    */\n#if !SQLITE_OMIT_VIRTUALTABLE\n//#  define IsVirtual(X)      (((X)->tabFlags & TF_Virtual)!=0)\nstatic bool IsVirtual( Table X) { return (X.tabFlags & TF_Virtual)!=0;}\n//#  define IsHiddenColumn(X) ((X)->isHidden)\nstatic bool IsVirtual( Column X) { return X.isHidden!=0;}\n#else\n    //#  define IsVirtual(X)      0\n    static bool IsVirtual( Table T ) { return false; }\n    //#  define IsHiddenColumn(X) 0\n    static bool IsHiddenColumn( Column C ) { return false; }\n#endif\n\n    /*\n** Each foreign key constraint is an instance of the following structure.\n**\n** A foreign key is associated with two tables.  The "from" table is\n** the table that contains the REFERENCES clause that creates the foreign\n** key.  The "to" table is the table that is named in the REFERENCES clause.\n** Consider this example:\n**\n**     CREATE TABLE ex1(\n**       a INTEGER PRIMARY KEY,\n**       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)\n**     );\n**\n** For foreign key "fk1", the from-table is "ex1" and the to-table is "ex2".\n**\n** Each REFERENCES clause generates an instance of the following structure\n** which is attached to the from-table.  The to-table need not exist when\n** the from-table is created.  The existence of the to-table is not checked.\n*/\n    public class FKey\n    {\n      public Table pFrom;         /* The table that contains the REFERENCES clause */\n      public FKey pNextFrom;      /* Next foreign key in pFrom */\n      public string zTo;          /* Name of table that the key points to */\n      public int nCol;            /* Number of columns in this key */\n      public u8 isDeferred;       /* True if constraint checking is deferred till COMMIT */\n      public u8 updateConf;       /* How to resolve conflicts that occur on UPDATE */\n      public u8 deleteConf;       /* How to resolve conflicts that occur on DELETE */\n      public u8 insertConf;       /* How to resolve conflicts that occur on INSERT */\n      public class sColMap\n      {  /* Mapping of columns in pFrom to columns in zTo */\n        public int iFrom;         /* Index of column in pFrom */\n        public string zCol;       /* Name of column in zTo.  If 0 use PRIMARY KEY */\n      };\n      public sColMap[] aCol;      /* One entry for each of nCol column s */\n\n      public FKey Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          FKey cp = (FKey)MemberwiseClone();\n          if ( pFrom != null ) cp.pFrom = pFrom.Copy();\n          if ( pNextFrom != null ) cp.pNextFrom = pNextFrom.Copy();\n          Debugger.Break(); // Check on the sCollMap\n          return cp;\n        }\n      }\n\n    };\n\n    /*\n    ** SQLite supports many different ways to resolve a constraint\n    ** error.  ROLLBACK processing means that a constraint violation\n    ** causes the operation in process to fail and for the current transaction\n    ** to be rolled back.  ABORT processing means the operation in process\n    ** fails and any prior changes from that one operation are backed out,\n    ** but the transaction is not rolled back.  FAIL processing means that\n    ** the operation in progress stops and returns an error code.  But prior\n    ** changes due to the same operation are not backed out and no rollback\n    ** occurs.  IGNORE means that the particular row that caused the constraint\n    ** error is not inserted or updated.  Processing continues and no error\n    ** is returned.  REPLACE means that preexisting database rows that caused\n    ** a UNIQUE constraint violation are removed so that the new insert or\n    ** update can proceed.  Processing continues and no error is reported.\n    **\n    ** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.\n    ** RESTRICT is the same as ABORT for IMMEDIATE foreign keys and the\n    ** same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreign\n    ** key is set to NULL.  CASCADE means that a DELETE or UPDATE of the\n    ** referenced table row is propagated into the row that holds the\n    ** foreign key.\n    **\n    ** The following symbolic values are used to record which type\n    ** of action to take.\n    */\n    const int OE_None = 0;//#define OE_None     0   /* There is no constraint to check */\n    const int OE_Rollback = 1;//#define OE_Rollback 1   /* Fail the operation and rollback the transaction */\n    const int OE_Abort = 2;//#define OE_Abort    2   /* Back out changes but do no rollback transaction */\n    const int OE_Fail = 3;//#define OE_Fail     3   /* Stop the operation but leave all prior changes */\n    const int OE_Ignore = 4;//#define OE_Ignore   4   /* Ignore the error. Do not do the INSERT or UPDATE */\n    const int OE_Replace = 5;//#define OE_Replace  5   /* Delete existing record, then do INSERT or UPDATE */\n\n    const int OE_Restrict = 6;//#define OE_Restrict 6   /* OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED */\n    const int OE_SetNull = 7;//#define OE_SetNull  7   /* Set the foreign key value to NULL */\n    const int OE_SetDflt = 8;//#define OE_SetDflt  8   /* Set the foreign key value to its default */\n    const int OE_Cascade = 9;//#define OE_Cascade  9   /* Cascade the changes */\n\n    const int OE_Default = 99;//#define OE_Default  99  /* Do whatever the default action is */\n\n\n    /*\n    ** An instance of the following structure is passed as the first\n    ** argument to sqlite3VdbeKeyCompare and is used to control the\n    ** comparison of the two index keys.\n    */\n    public class KeyInfo\n    {\n      public sqlite3 db;          /* The database connection */\n      public u8 enc;             /* Text encoding - one of the TEXT_Utf* values */\n      public u16 nField;          /* Number of entries in aColl[] */\n      public u8[] aSortOrder;   /* If defined an aSortOrder[i] is true, sort DESC */\n      public CollSeq[] aColl = new CollSeq[1];  /* Collating sequence for each term of the key */\n      public KeyInfo Copy()\n      {\n        return (KeyInfo)MemberwiseClone();\n      }\n    };\n\n    /*\n    ** An instance of the following structure holds information about a\n    ** single index record that has already been parsed out into individual\n    ** values.\n    **\n    ** A record is an object that contains one or more fields of data.\n    ** Records are used to store the content of a table row and to store\n    ** the key of an index.  A blob encoding of a record is created by\n    ** the OP_MakeRecord opcode of the VDBE and is disassembled by the\n    ** OP_Column opcode.\n    **\n    ** This structure holds a record that has already been disassembled\n    ** into its constituent fields.\n    */\n    public class UnpackedRecord\n    {\n      public KeyInfo pKeyInfo;   /* Collation and sort-order information */\n      public u16 nField;         /* Number of entries in apMem[] */\n      public u16 flags;          /* Boolean settings.  UNPACKED_... below */\n      public i64 rowid;          /* Used by UNPACKED_PREFIX_SEARCH */\n      public Mem[] aMem;         /* Values */\n    };\n\n    /*\n    ** Allowed values of UnpackedRecord.flags\n    */\n    //#define UNPACKED_NEED_FREE     0x0001  /* Memory is from sqlite3Malloc() */\n    //#define UNPACKED_NEED_DESTROY  0x0002  /* apMem[]s should all be destroyed */\n    //#define UNPACKED_IGNORE_ROWID  0x0004  /* Ignore trailing rowid on key1 */\n    //#define UNPACKED_INCRKEY       0x0008  /* Make this key an epsilon larger */\n    //#define UNPACKED_PREFIX_MATCH  0x0010  /* A prefix match is considered OK */\n    //#define UNPACKED_PREFIX_SEARCH 0x0020  /* A prefix match is considered OK */\n    const int UNPACKED_NEED_FREE = 0x0001;  /* Memory is from sqlite3Malloc() */\n    const int UNPACKED_NEED_DESTROY = 0x0002;  /* apMem[]s should all be destroyed */\n    const int UNPACKED_IGNORE_ROWID = 0x0004;  /* Ignore trailing rowid on key1 */\n    const int UNPACKED_INCRKEY = 0x0008;  /* Make this key an epsilon larger */\n    const int UNPACKED_PREFIX_MATCH = 0x0010;  /* A prefix match is considered OK */\n    const int UNPACKED_PREFIX_SEARCH = 0x0020; /* A prefix match is considered OK */\n\n    /*\n    ** Each SQL index is represented in memory by an\n    ** instance of the following structure.\n    **\n    ** The columns of the table that are to be indexed are described\n    ** by the aiColumn[] field of this structure.  For example, suppose\n    ** we have the following table and index:\n    **\n    **     CREATE TABLE Ex1(c1 int, c2 int, c3 text);\n    **     CREATE INDEX Ex2 ON Ex1(c3,c1);\n    **\n    ** In the Table structure describing Ex1, nCol==3 because there are\n    ** three columns in the table.  In the Index structure describing\n    ** Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed.\n    ** The value of aiColumn is {2, 0}.  aiColumn[0]==2 because the\n    ** first column to be indexed (c3) has an index of 2 in Ex1.aCol[].\n    ** The second column to be indexed (c1) has an index of 0 in\n    ** Ex1.aCol[], hence Ex2.aiColumn[1]==0.\n    **\n    ** The Index.onError field determines whether or not the indexed columns\n    ** must be unique and what to do if they are not.  When Index.onError=OE_None,\n    ** it means this is not a unique index.  Otherwise it is a unique index\n    ** and the value of Index.onError indicate the which conflict resolution\n    ** algorithm to employ whenever an attempt is made to insert a non-unique\n    ** element.\n    */\n    public class Index\n    {\n      public string zName;      /* Name of this index */\n      public int nColumn;       /* Number of columns in the table used by this index */\n      public int[] aiColumn;    /* Which columns are used by this index.  1st is 0 */\n      public int[] aiRowEst;    /* Result of ANALYZE: Est. rows selected by each column */\n      public Table pTable;      /* The SQL table being indexed */\n      public int tnum;          /* Page containing root of this index in database file */\n      public u8 onError;        /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n      public u8 autoIndex;      /* True if is automatically created (ex: by UNIQUE) */\n      public string zColAff;    /* String defining the affinity of each column */\n      public Index pNext;       /* The next index associated with the same table */\n      public Schema pSchema;    /* Schema containing this index */\n      public u8[] aSortOrder;   /* Array of size Index.nColumn. True==DESC, False==ASC */\n      public string[] azColl;   /* Array of collation sequence names for index */\n\n      public Index Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Index cp = (Index)MemberwiseClone();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** Each token coming out of the lexer is an instance of\n    ** this structure.  Tokens are also used as part of an expression.\n    **\n    ** Note if Token.z==0 then Token.dyn and Token.n are undefined and\n    ** may contain random values.  Do not make any assumptions about Token.dyn\n    ** and Token.n when Token.z==0.\n    */\n    public class Token\n    {\n#if DEBUG_CLASS_TOKEN || DEBUG_CLASS_ALL\npublic string _z; /* Text of the token.  Not NULL-terminated! */\npublic bool dyn;//  : 1;      /* True for malloced memory, false for static */\npublic Int32 _n;//  : 31;     /* Number of characters in this token */\n\npublic string z\n{\nget { return _z; }\nset { _z = value; }\n}\n\npublic Int32 n\n{\nget { return _n; }\nset { _n = value; }\n}\n#else\n      public string z; /* Text of the token.  Not NULL-terminated! */\n      public Int32 n;  /* Number of characters in this token */\n#endif\n      public Token()\n      {\n        this.z = null;\n        this.n = 0;\n      }\n      public Token( string z, Int32 n )\n      {\n        this.z = z;\n        this.n = n;\n      }\n      public Token Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Token cp = (Token)MemberwiseClone();\n          if ( z == null || z.Length == 0 )\n            cp.n = 0;\n          else\n            if ( n > z.Length ) cp.n = z.Length;\n          return cp;\n        }\n      }\n    }\n\n    /*\n    ** An instance of this structure contains information needed to generate\n    ** code for a SELECT that contains aggregate functions.\n    **\n    ** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a\n    ** pointer to this structure.  The Expr.iColumn field is the index in\n    ** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate\n    ** code for that node.\n    **\n    ** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the\n    ** original Select structure that describes the SELECT statement.  These\n    ** fields do not need to be freed when deallocating the AggInfo structure.\n    */\n    public class AggInfo_col\n    {    /* For each column used in source tables */\n      public Table pTab;             /* Source table */\n      public int iTable;              /* VdbeCursor number of the source table */\n      public int iColumn;             /* Column number within the source table */\n      public int iSorterColumn;       /* Column number in the sorting index */\n      public int iMem;                /* Memory location that acts as accumulator */\n      public Expr pExpr;             /* The original expression */\n    };\n    public class AggInfo_func\n    {   /* For each aggregate function */\n      public Expr pExpr;             /* Expression encoding the function */\n      public FuncDef pFunc;          /* The aggregate function implementation */\n      public int iMem;                /* Memory location that acts as accumulator */\n      public int iDistinct;           /* Ephemeral table used to enforce DISTINCT */\n    }\n    public class AggInfo\n    {\n      public u8 directMode;          /* Direct rendering mode means take data directly\n** from source tables rather than from accumulators */\n      public u8 useSortingIdx;       /* In direct mode, reference the sorting index rather\n** than the source table */\n      public int sortingIdx;         /* VdbeCursor number of the sorting index */\n      public ExprList pGroupBy;     /* The group by clause */\n      public int nSortingColumn;     /* Number of columns in the sorting index */\n      public AggInfo_col[] aCol;\n      public int nColumn;            /* Number of used entries in aCol[] */\n      public int nColumnAlloc;       /* Number of slots allocated for aCol[] */\n      public int nAccumulator;       /* Number of columns that show through to the output.\n** Additional columns are used only as parameters to\n** aggregate functions */\n      public AggInfo_func[] aFunc;\n      public int nFunc;              /* Number of entries in aFunc[] */\n      public int nFuncAlloc;         /* Number of slots allocated for aFunc[] */\n\n      public AggInfo Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          AggInfo cp = (AggInfo)MemberwiseClone();\n          if ( pGroupBy != null ) cp.pGroupBy = pGroupBy.Copy();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** Each node of an expression in the parse tree is an instance\n    ** of this structure.\n    **\n    ** Expr.op is the opcode.  The integer parser token codes are reused\n    ** as opcodes here.  For example, the parser defines TK_GE to be an integer\n    ** code representing the ">=" operator.  This same integer code is reused\n    ** to represent the greater-than-or-equal-to operator in the expression\n    ** tree.\n    **\n    ** If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB,\n    ** or TK_STRING), then Expr.token contains the text of the SQL literal. If\n    ** the expression is a variable (TK_VARIABLE), then Expr.token contains the\n    ** variable name. Finally, if the expression is an SQL function (TK_FUNCTION),\n    ** then Expr.token contains the name of the function.\n    **\n    ** Expr.pRight and Expr.pLeft are the left and right subexpressions of a\n    ** binary operator. Either or both may be NULL.\n    **\n    ** Expr.x.pList is a list of arguments if the expression is an SQL function,\n    ** a CASE expression or an IN expression of the form "<lhs> IN (<y>, <z>...)".\n    ** Expr.x.pSelect is used if the expression is a sub-select or an expression of\n    ** the form "<lhs> IN (SELECT ...)". If the EP_xIsSelect bit is set in the\n    ** Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is\n    ** valid.\n    **\n    ** An expression of the form ID or ID.ID refers to a column in a table.\n    ** For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable is\n    ** the integer cursor number of a VDBE cursor pointing to that table and\n    ** Expr.iColumn is the column number for the specific column.  If the\n    ** expression is used as a result in an aggregate SELECT, then the\n    ** value is also stored in the Expr.iAgg column in the aggregate so that\n    ** it can be accessed after all aggregates are computed.\n    **\n    ** If the expression is an unbound variable marker (a question mark\n    ** character \'?\' in the original SQL) then the Expr.iTable holds the index\n    ** number for that variable.\n    **\n    ** If the expression is a subquery then Expr.iColumn holds an integer\n    ** register number containing the result of the subquery.  If the\n    ** subquery gives a constant result, then iTable is -1.  If the subquery\n    ** gives a different answer at different times during statement processing\n    ** then iTable is the address of a subroutine that computes the subquery.\n    **\n    ** If the Expr is of type OP_Column, and the table it is selecting from\n    ** is a disk table or the "old.*" pseudo-table, then pTab points to the\n    ** corresponding table definition.\n    **\n    ** ALLOCATION NOTES:\n    **\n    ** Expr objects can use a lot of memory space in database schema.  To\n    ** help reduce memory requirements, sometimes an Expr object will be\n    ** truncated.  And to reduce the number of memory allocations, sometimes\n    ** two or more Expr objects will be stored in a single memory allocation,\n    ** together with Expr.zToken strings.\n    **\n    ** If the EP_Reduced and EP_TokenOnly flags are set when\n    ** an Expr object is truncated.  When EP_Reduced is set, then all\n    ** the child Expr objects in the Expr.pLeft and Expr.pRight subtrees\n    ** are contained within the same memory allocation.  Note, however, that\n    ** the subtrees in Expr.x.pList or Expr.x.pSelect are always separately\n    ** allocated, regardless of whether or not EP_Reduced is set.\n    */\n    public class Expr\n    {\n#if DEBUG_CLASS_EXPR || DEBUG_CLASS_ALL\npublic u8 _op;                      /* Operation performed by this node */\npublic u8 op\n{\nget { return _op; }\nset { _op = value; }\n}\n#else\n      public u8 op;                 /* Operation performed by this node */\n#endif\n      public char affinity;         /* The affinity of the column or 0 if not a column */\n#if DEBUG_CLASS_EXPR || DEBUG_CLASS_ALL\npublic u16 _flags;                            /* Various flags.  EP_* See below */\npublic u16 flags\n{\nget { return _flags; }\nset { _flags = value; }\n}\npublic struct _u\n{\npublic string _zToken;         /* Token value. Zero terminated and dequoted */\npublic string zToken\n{\nget { return _zToken; }\nset { _zToken = value; }\n}\npublic int iValue;            /* Integer value if EP_IntValue */\n}\n\n#else\n      public struct _u\n      {\n        public string zToken;         /* Token value. Zero terminated and dequoted */\n        public int iValue;            /* Integer value if EP_IntValue */\n      }\n      public u16 flags;             /* Various flags.  EP_* See below */\n#endif\n      public _u u;\n\n      /* If the EP_TokenOnly flag is set in the Expr.flags mask, then no\n      ** space is allocated for the fields below this point. An attempt to\n      ** access them will result in a segfault or malfunction.\n      *********************************************************************/\n\n      public Expr pLeft;                           /* Left subnode */\n      public Expr pRight;                          /* Right subnode */\n      public struct _x\n      {\n        public ExprList pList;                       /* Function arguments or in "<expr> IN (<expr-list)" */\n        public Select pSelect;                       /* Used for sub-selects and "<expr> IN (<select>)" */\n      }\n      public _x x;\n      public CollSeq pColl;                        /* The collation type of the column or 0 */\n\n      /* If the EP_Reduced flag is set in the Expr.flags mask, then no\n      ** space is allocated for the fields below this point. An attempt to\n      ** access them will result in a segfault or malfunction.\n      *********************************************************************/\n\n      public int iTable;            /* TK_COLUMN: cursor number of table holding column\n   ** TK_REGISTER: register number */\n      public i16 iColumn;           /* TK_COLUMN: column index.  -1 for rowid */\n      public i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */\n      public i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */\n      public u16 flags2;            /* Second set of flags.  EP2_... */\n      public AggInfo pAggInfo;      /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */\n      public Table pTab;            /* Table for TK_COLUMN expressions. */\n#if SQLITE_MAX_EXPR_DEPTH //>0\n      public int nHeight;           /* Height of the tree headed by this node */\n      public Table pZombieTab;      /* List of Table objects to delete after code gen */\n#endif\n\n#if DEBUG_CLASS\npublic int op\n{\nget { return _op; }\nset { _op = value; }\n}\n#endif\n      public void CopyFrom( Expr cf )\n      {\n        op = cf.op;\n        affinity = cf.affinity;\n        flags = cf.flags;\n        u = cf.u;\n        pColl = cf.pColl == null ? null : cf.pColl.Copy();\n        iTable = cf.iTable;\n        iColumn = cf.iColumn;\n        pAggInfo = cf.pAggInfo == null ? null : cf.pAggInfo.Copy();\n        iAgg = cf.iAgg;\n        iRightJoinTable = cf.iRightJoinTable;\n        flags2 = cf.flags2;\n        pTab = cf.pTab == null ? null : cf.pTab.Copy();\n#if SQLITE_TEST || SQLITE_MAX_EXPR_DEPTH //SQLITE_MAX_EXPR_DEPTH>0\n        nHeight = cf.nHeight;\n        pZombieTab = cf.pZombieTab;\n#endif\n        pLeft = cf.pLeft == null ? null : cf.pLeft.Copy();\n        pRight = cf.pRight == null ? null : cf.pRight.Copy();\n        x.pList = cf.x.pList == null ? null : cf.x.pList.Copy();\n        x.pSelect = cf.x.pSelect == null ? null : cf.x.pSelect.Copy();\n      }\n\n      public Expr Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Expr cp = Copy_Minimal();\n          if ( pLeft != null ) cp.pLeft = pLeft.Copy();\n          if ( pRight != null ) cp.pRight = pRight.Copy();\n          return cp;\n        }\n      }\n      public Expr Copy_Minimal()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Expr cp = new Expr();\n          cp.op = op;\n          cp.affinity = affinity;\n          cp.flags = flags;\n          cp.u = u;\n          if ( x.pList != null ) cp.x.pList = x.pList.Copy();\n          if ( x.pSelect != null ) cp.x.pSelect = x.pSelect.Copy();\n          if ( pColl != null ) cp.pColl = pColl.Copy();\n          cp.iTable = iTable;\n          cp.iColumn = iColumn;\n          if ( pAggInfo != null ) cp.pAggInfo = pAggInfo.Copy();\n          cp.iAgg = iAgg;\n          cp.iRightJoinTable = iRightJoinTable;\n          cp.flags2 = flags2;\n          if ( pTab != null ) cp.pTab = pTab.Copy();\n#if SQLITE_TEST || SQLITE_MAX_EXPR_DEPTH //SQLITE_MAX_EXPR_DEPTH>0\n          cp.nHeight = nHeight;\n          cp.pZombieTab = pZombieTab;\n#endif\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** The following are the meanings of bits in the Expr.flags field.\n    */\n    //#define EP_FromJoin   0x0001  /* Originated in ON or USING clause of a join */\n    //#define EP_Agg        0x0002  /* Contains one or more aggregate functions */\n    //#define EP_Resolved   0x0004  /* IDs have been resolved to COLUMNs */\n    //#define EP_Error      0x0008  /* Expression contains one or more errors */\n    //#define EP_Distinct   0x0010  /* Aggregate function with DISTINCT keyword */\n    //#define EP_VarSelect  0x0020  /* pSelect is correlated, not constant */\n    //#define EP_DblQuoted  0x0040  /* token.z was originally in "..." */\n    //#define EP_InfixFunc  0x0080  /* True for an infix function: LIKE, GLOB, etc */\n    //#define EP_ExpCollate 0x0100  /* Collating sequence specified explicitly */\n    //#define EP_AnyAff     0x0200  /* Can take a cached column of any affinity */\n    //#define EP_FixedDest  0x0400  /* Result needed in a specific register */\n    //#define EP_IntValue   0x0800  /* Integer value contained in u.iTable */\n    //#define EP_xIsSelect  0x1000  /* x.pSelect is valid (otherwise x.pList is) */\n\n    //#define EP_Reduced    0x2000  /* Expr struct is EXPR_REDUCEDSIZE bytes only */\n    //#define EP_TokenOnly  0x4000  /* Expr struct is EXPR_TOKENONLYSIZE bytes only */\n    //#define EP_Static     0x8000  /* Held in memory not obtained from malloc() */\n\n    const ushort EP_FromJoin = 0x0001;\n    const ushort EP_Agg = 0x0002;\n    const ushort EP_Resolved = 0x0004;\n    const ushort EP_Error = 0x0008;\n    const ushort EP_Distinct = 0x0010;\n    const ushort EP_VarSelect = 0x0020;\n    const ushort EP_DblQuoted = 0x0040;\n    const ushort EP_InfixFunc = 0x0080;\n    const ushort EP_ExpCollate = 0x0100;\n    const ushort EP_AnyAff = 0x0200;\n    const ushort EP_FixedDest = 0x0400;\n    const ushort EP_IntValue = 0x0800;\n    const ushort EP_xIsSelect = 0x1000;\n\n    const ushort EP_Reduced = 0x2000;\n    const ushort EP_TokenOnly = 0x4000;\n    const ushort EP_Static = 0x8000;\n\n    /*\n    ** The following are the meanings of bits in the Expr.flags2 field.\n    */\n    //#define EP2_MallocedToken  0x0001  /* Need to //sqlite3DbFree() Expr.zToken */\n    //#define EP2_Irreducible    0x0002  /* Cannot EXPRDUP_REDUCE this Expr */\n    const ushort EP2_MallocedToken = 0x0001;\n    const ushort EP2_Irreducible = 0x0002;\n\n    /*\n    ** The pseudo-routine sqlite3ExprSetIrreducible sets the EP2_Irreducible\n    ** flag on an expression structure.  This flag is used for VV&A only.  The\n    ** routine is implemented as a macro that only works when in debugging mode,\n    ** so as not to burden production code.\n    */\n#if SQLITE_DEBUG\n    //# define ExprSetIrreducible(X)  (X)->flags2 |= EP2_Irreducible\n    static void ExprSetIrreducible( Expr X ) { X.flags2 |= EP2_Irreducible; }\n#else\n//# define ExprSetIrreducible(X)\nstatic void ExprSetIrreducible( Expr X ) { }\n#endif\n\n    /*\n** These macros can be used to test, set, or clear bits in the\n** Expr.flags field.\n*/\n    //#define ExprHasProperty(E,P)     (((E)->flags&(P))==(P))\n    static bool ExprHasProperty( Expr E, int P ) { return ( E.flags & P ) == P; }\n    //#define ExprHasAnyProperty(E,P)  (((E)->flags&(P))!=0)\n    static bool ExprHasAnyProperty( Expr E, int P ) { return ( E.flags & P ) != 0; }\n    //#define ExprSetProperty(E,P)     (E)->flags|=(P)\n    static void ExprSetProperty( Expr E, int P ) { E.flags = (ushort)( E.flags | P ); }\n    //#define ExprClearProperty(E,P)   (E)->flags&=~(P)\n    static void ExprClearProperty( Expr E, int P ) { E.flags = (ushort)( E.flags & ~P ); }\n\n    /*\n    ** Macros to determine the number of bytes required by a normal Expr\n    ** struct, an Expr struct with the EP_Reduced flag set in Expr.flags\n    ** and an Expr struct with the EP_TokenOnly flag set.\n    */\n    //#define EXPR_FULLSIZE           sizeof(Expr)           /* Full size */\n    //#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /* Common features */\n    //#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /* Fewer features */\n\n    // We don\'t use these in C#, but define them anyway,\n    const int EXPR_FULLSIZE = 48;\n    const int EXPR_REDUCEDSIZE = 8216;\n    const int EXPR_TOKENONLYSIZE = 16392;\n\n    /*\n    ** Flags passed to the sqlite3ExprDup() function. See the header comment\n    ** above sqlite3ExprDup() for details.\n    */\n    //#define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */\n    const int EXPRDUP_REDUCE = 0x0001;\n\n    /*\n    ** A list of expressions.  Each expression may optionally have a\n    ** name.  An expr/name combination can be used in several ways, such\n    ** as the list of "expr AS ID" fields following a "SELECT" or in the\n    ** list of "ID = expr" items in an UPDATE.  A list of expressions can\n    ** also be used as the argument to a function, in which case the a.zName\n    ** field is not used.\n    */\n    public class ExprList_item\n    {\n      public Expr pExpr;          /* The list of expressions */\n      public string zName;        /* Token associated with this expression */\n      public string zSpan;        /*  Original text of the expression */\n      public u8 sortOrder;        /* 1 for DESC or 0 for ASC */\n      public u8 done;             /* A flag to indicate when processing is finished */\n      public u16 iCol;            /* For ORDER BY, column number in result set */\n      public u16 iAlias;          /* Index into Parse.aAlias[] for zName */\n    }\n    public class ExprList\n    {\n      public int nExpr;             /* Number of expressions on the list */\n      public int nAlloc;            /* Number of entries allocated below */\n      public int iECursor;          /* VDBE VdbeCursor associated with this ExprList */\n      public ExprList_item[] a;     /* One entry for each expression */\n\n      public ExprList Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          ExprList cp = (ExprList)MemberwiseClone();\n          a.CopyTo( cp.a, 0 );\n          return cp;\n        }\n      }\n\n    };\n\n    /*\n    ** An instance of this structure is used by the parser to record both\n    ** the parse tree for an expression and the span of input text for an\n    ** expression.\n    */\n    public class ExprSpan\n    {\n      public Expr pExpr;            /* The expression parse tree */\n      public string zStart;  /* First character of input text */\n      public string zEnd;    /* One character past the end of input text */\n    };\n\n    /*\n    ** An instance of this structure can hold a simple list of identifiers,\n    ** such as the list "a,b,c" in the following statements:\n    **\n    **      INSERT INTO t(a,b,c) VALUES ...;\n    **      CREATE INDEX idx ON t(a,b,c);\n    **      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;\n    **\n    ** The IdList.a.idx field is used when the IdList represents the list of\n    ** column names after a table name in an INSERT statement.  In the statement\n    **\n    **     INSERT INTO t(a,b,c) ...\n    **\n    ** If "a" is the k-th column of table "t", then IdList.a[0].idx==k.\n    */\n    public class IdList_item\n    {\n      public string zName;      /* Name of the identifier */\n      public int idx;          /* Index in some Table.aCol[] of a column named zName */\n    }\n    public class IdList\n    {\n      public IdList_item[] a;\n      public int nId;         /* Number of identifiers on the list */\n      public int nAlloc;      /* Number of entries allocated for a[] below */\n\n      public IdList Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          IdList cp = (IdList)MemberwiseClone();\n          a.CopyTo( cp.a, 0 );\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** The bitmask datatype defined below is used for various optimizations.\n    **\n    ** Changing this from a 64-bit to a 32-bit type limits the number of\n    ** tables in a join to 32 instead of 64.  But it also reduces the size\n    ** of the library by 738 bytes on ix86.\n    */\n    //typedef u64 Bitmask;\n\n    /*\n    ** The number of bits in a Bitmask.  "BMS" means "BitMask Size".\n    */\n    //#define BMS  ((int)(sizeof(Bitmask)*8))\n    const int BMS = ( (int)( sizeof( Bitmask ) * 8 ) );\n\n\n    /*\n    ** The following structure describes the FROM clause of a SELECT statement.\n    ** Each table or subquery in the FROM clause is a separate element of\n    ** the SrcList.a[] array.\n    **\n    ** With the addition of multiple database support, the following structure\n    ** can also be used to describe a particular table such as the table that\n    ** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,\n    ** such a table must be a simple name: ID.  But in SQLite, the table can\n    ** now be identified by a database name, a dot, then the table name: ID.ID.\n    **\n    ** The jointype starts out showing the join type between the current table\n    ** and the next table on the list.  The parser builds the list this way.\n    ** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each\n    ** jointype expresses the join between the table and the previous table.\n    */\n    public class SrcList_item\n    {\n      public string zDatabase; /* Name of database holding this table */\n      public string zName;     /* Name of the table */\n      public string zAlias;    /* The "B" part of a "A AS B" phrase.  zName is the "A" */\n      public Table pTab;       /* An SQL table corresponding to zName */\n      public Select pSelect;   /* A SELECT statement used in place of a table name */\n      public u8 isPopulated;   /* Temporary table associated with SELECT is populated */\n      public u8 jointype;      /* Type of join between this able and the previous */\n      public u8 notIndexed;    /* True if there is a NOT INDEXED clause */\n      public int iCursor;      /* The VDBE cursor number used to access this table */\n      public Expr pOn;         /* The ON clause of a join */\n      public IdList pUsing;    /* The USING clause of a join */\n      public Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */\n      public string zIndex;    /* Identifier from "INDEXED BY <zIndex>" clause */\n      public Index pIndex;     /* Index structure corresponding to zIndex, if any */\n    }\n    public class SrcList\n    {\n      public i16 nSrc;        /* Number of tables or subqueries in the FROM clause */\n      public i16 nAlloc;      /* Number of entries allocated in a[] below */\n      public SrcList_item[] a;/* One entry for each identifier on the list */\n      public SrcList Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          SrcList cp = (SrcList)MemberwiseClone();\n          if ( a != null ) a.CopyTo( cp.a, 0 );\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** Permitted values of the SrcList.a.jointype field\n    */\n    const int JT_INNER = 0x0001;   //#define JT_INNER     0x0001    /* Any kind of inner or cross join */\n    const int JT_CROSS = 0x0002;   //#define JT_CROSS     0x0002    /* Explicit use of the CROSS keyword */\n    const int JT_NATURAL = 0x0004; //#define JT_NATURAL   0x0004    /* True for a "natural" join */\n    const int JT_LEFT = 0x0008;    //#define JT_LEFT      0x0008    /* Left outer join */\n    const int JT_RIGHT = 0x0010;   //#define JT_RIGHT     0x0010    /* Right outer join */\n    const int JT_OUTER = 0x0020;   //#define JT_OUTER     0x0020    /* The "OUTER" keyword is present */\n    const int JT_ERROR = 0x0040;   //#define JT_ERROR     0x0040    /* unknown or unsupported join type */\n\n\n    /*\n    ** A WherePlan object holds information that describes a lookup\n    ** strategy.\n    **\n    ** This object is intended to be opaque outside of the where.c module.\n    ** It is included here only so that that compiler will know how big it\n    ** is.  None of the fields in this object should be used outside of\n    ** the where.c module.\n    **\n    ** Within the union, pIdx is only used when wsFlags&WHERE_INDEXED is true.\n    ** pTerm is only used when wsFlags&WHERE_MULTI_OR is true.  And pVtabIdx\n    ** is only used when wsFlags&WHERE_VIRTUALTABLE is true.  It is never the\n    ** case that more than one of these conditions is true.\n    */\n    public class WherePlan\n    {\n      public u32 wsFlags;                   /* WHERE_* flags that describe the strategy */\n      public u32 nEq;                       /* Number of == constraints */\n      public class _u\n      {\n        public Index pIdx;                  /* Index when WHERE_INDEXED is true */\n        public WhereTerm pTerm;             /* WHERE clause term for OR-search */\n        public sqlite3_index_info pVtabIdx; /* Virtual table index to use */\n      }\n      public _u u = new _u();\n    };\n\n    /*\n    ** For each nested loop in a WHERE clause implementation, the WhereInfo\n    ** structure contains a single instance of this structure.  This structure\n    ** is intended to be private the the where.c module and should not be\n    ** access or modified by other modules.\n    **\n    ** The pIdxInfo field is used to help pick the best index on a\n    ** virtual table.  The pIdxInfo pointer contains indexing\n    ** information for the i-th table in the FROM clause before reordering.\n    ** All the pIdxInfo pointers are freed by whereInfoFree() in where.c.\n    ** All other information in the i-th WhereLevel object for the i-th table\n    ** after FROM clause ordering.\n    */\n    public class InLoop\n    {\n      public int iCur;              /* The VDBE cursor used by this IN operator */\n      public int addrInTop;         /* Top of the IN loop */\n    }\n    public class WhereLevel\n    {\n      public WherePlan plan;       /* query plan for this element of the FROM clause */\n      public int iLeftJoin;        /* Memory cell used to implement LEFT OUTER JOIN */\n      public int iTabCur;          /* The VDBE cursor used to access the table */\n      public int iIdxCur;          /* The VDBE cursor used to access pIdx */\n      public int addrBrk;          /* Jump here to break out of the loop */\n      public int addrNxt;          /* Jump here to start the next IN combination */\n      public int addrCont;         /* Jump here to continue with the next loop cycle */\n      public int addrFirst;        /* First instruction of interior of the loop */\n      public u8 iFrom;             /* Which entry in the FROM clause */\n      public u8 op, p5;            /* Opcode and P5 of the opcode that ends the loop */\n      public int p1, p2;           /* Operands of the opcode used to ends the loop */\n      public class _u\n      {\n        public class __in               /* Information that depends on plan.wsFlags */\n        {\n          public int nIn;              /* Number of entries in aInLoop[] */\n          public InLoop[] aInLoop;           /* Information about each nested IN operator */\n        }\n        public __in _in = new __in();                 /* Used when plan.wsFlags&WHERE_IN_ABLE */\n      }\n      public _u u = new _u();\n\n\n      /* The following field is really not part of the current level.  But\n      ** we need a place to cache virtual table index information for each\n      ** virtual table in the FROM clause and the WhereLevel structure is\n      ** a convenient place since there is one WhereLevel for each FROM clause\n      ** element.\n      */\n      public sqlite3_index_info pIdxInfo;  /* Index info for n-th source table */\n    };\n\n    /*\n    ** Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()\n    ** and the WhereInfo.wctrlFlags member.\n    */\n    //#define WHERE_ORDERBY_NORMAL   0x0000 /* No-op */\n    //#define WHERE_ORDERBY_MIN      0x0001 /* ORDER BY processing for min() func */\n    //#define WHERE_ORDERBY_MAX      0x0002 /* ORDER BY processing for max() func */\n    //#define WHERE_ONEPASS_DESIRED  0x0004 /* Want to do one-pass UPDATE/DELETE */\n    //#define WHERE_DUPLICATES_OK    0x0008 /* Ok to return a row more than once */\n    //#define WHERE_OMIT_OPEN        0x0010  /* Table cursor are already open */\n    //#define WHERE_OMIT_CLOSE       0x0020  /* Omit close of table & index cursors */\n    //#define WHERE_FORCE_TABLE      0x0040 /* Do not use an index-only search */\n    const int WHERE_ORDERBY_NORMAL = 0x0000;\n    const int WHERE_ORDERBY_MIN = 0x0001;\n    const int WHERE_ORDERBY_MAX = 0x0002;\n    const int WHERE_ONEPASS_DESIRED = 0x0004;\n    const int WHERE_DUPLICATES_OK = 0x0008;\n    const int WHERE_OMIT_OPEN = 0x0010;\n    const int WHERE_OMIT_CLOSE = 0x0020;\n    const int WHERE_FORCE_TABLE = 0x0040;\n\n    /*\n    ** The WHERE clause processing routine has two halves.  The\n    ** first part does the start of the WHERE loop and the second\n    ** half does the tail of the WHERE loop.  An instance of\n    ** this structure is returned by the first half and passed\n    ** into the second half to give some continuity.\n    */\n    public class WhereInfo\n    {\n      public Parse pParse;          /* Parsing and code generating context */\n      public u16 wctrlFlags;        /* Flags originally passed to sqlite3WhereBegin() */\n      public u8 okOnePass;          /* Ok to use one-pass algorithm for UPDATE or DELETE */\n      public SrcList pTabList;      /* List of tables in the join */\n      public int iTop;              /* The very beginning of the WHERE loop */\n      public int iContinue;         /* Jump here to continue with next record */\n      public int iBreak;            /* Jump here to break out of the loop */\n      public int nLevel;            /* Number of nested loop */\n      public WhereClause pWC;       /* Decomposition of the WHERE clause */\n      public WhereLevel[] a = new WhereLevel[] { new WhereLevel() };     /* Information about each nest loop in the WHERE */\n    };\n\n    /*\n    ** A NameContext defines a context in which to resolve table and column\n    ** names.  The context consists of a list of tables (the pSrcList) field and\n    ** a list of named expression (pEList).  The named expression list may\n    ** be NULL.  The pSrc corresponds to the FROM clause of a SELECT or\n    ** to the table being operated on by INSERT, UPDATE, or DELETE.  The\n    ** pEList corresponds to the result set of a SELECT and is NULL for\n    ** other statements.\n    **\n    ** NameContexts can be nested.  When resolving names, the inner-most\n    ** context is searched first.  If no match is found, the next outer\n    ** context is checked.  If there is still no match, the next context\n    ** is checked.  This process continues until either a match is found\n    ** or all contexts are check.  When a match is found, the nRef member of\n    ** the context containing the match is incremented.\n    **\n    ** Each subquery gets a new NameContext.  The pNext field points to the\n    ** NameContext in the parent query.  Thus the process of scanning the\n    ** NameContext list corresponds to searching through successively outer\n    ** subqueries looking for a match.\n    */\n    public class NameContext\n    {\n      public Parse pParse;       /* The parser */\n      public SrcList pSrcList;   /* One or more tables used to resolve names */\n      public ExprList pEList;    /* Optional list of named expressions */\n      public int nRef;           /* Number of names resolved by this context */\n      public int nErr;           /* Number of errors encountered while resolving names */\n      public u8 allowAgg;        /* Aggregate functions allowed here */\n      public u8 hasAgg;          /* True if aggregates are seen */\n      public u8 isCheck;         /* True if resolving names in a CHECK constraint */\n      public int nDepth;         /* Depth of subquery recursion. 1 for no recursion */\n      public AggInfo pAggInfo;   /* Information about aggregates at this level */\n      public NameContext pNext;  /* Next outer name context.  NULL for outermost */\n    };\n\n    /*\n    ** An instance of the following structure contains all information\n    ** needed to generate code for a single SELECT statement.\n    **\n    ** nLimit is set to -1 if there is no LIMIT clause.  nOffset is set to 0.\n    ** If there is a LIMIT clause, the parser sets nLimit to the value of the\n    ** limit and nOffset to the value of the offset (or 0 if there is not\n    ** offset).  But later on, nLimit and nOffset become the memory locations\n    ** in the VDBE that record the limit and offset counters.\n    **\n    ** addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.\n    ** These addresses must be stored so that we can go back and fill in\n    ** the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo nor\n    ** the number of columns in P2 can be computed at the same time\n    ** as the OP_OpenEphm instruction is coded because not\n    ** enough information about the compound query is known at that point.\n    ** The KeyInfo for addrOpenTran[0] and [1] contains collating sequences\n    ** for the result set.  The KeyInfo for addrOpenTran[2] contains collating\n    ** sequences for the ORDER BY clause.\n    */\n    public class Select\n    {\n      public ExprList pEList;      /* The fields of the result */\n      public u8 op;                /* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT */\n      public char affinity;        /* MakeRecord with this affinity for SRT_Set */\n      public u16 selFlags;         /* Various SF_* values */\n      public SrcList pSrc;         /* The FROM clause */\n      public Expr pWhere;          /* The WHERE clause */\n      public ExprList pGroupBy;    /* The GROUP BY clause */\n      public Expr pHaving;         /* The HAVING clause */\n      public ExprList pOrderBy;    /* The ORDER BY clause */\n      public Select pPrior;        /* Prior select in a compound select statement */\n      public Select pNext;         /* Next select to the left in a compound */\n      public Select pRightmost;    /* Right-most select in a compound select statement */\n      public Expr pLimit;          /* LIMIT expression. NULL means not used. */\n      public Expr pOffset;         /* OFFSET expression. NULL means not used. */\n      public int iLimit;\n      public int iOffset;          /* Memory registers holding LIMIT & OFFSET counters */\n      public int[] addrOpenEphm = new int[3];   /* OP_OpenEphem opcodes related to this select */\n\n      public Select Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Select cp = (Select)MemberwiseClone();\n          if ( pEList != null ) cp.pEList = pEList.Copy();\n          if ( pSrc != null ) cp.pSrc = pSrc.Copy();\n          if ( pWhere != null ) cp.pWhere = pWhere.Copy();\n          if ( pGroupBy != null ) cp.pGroupBy = pGroupBy.Copy();\n          if ( pHaving != null ) cp.pHaving = pHaving.Copy();\n          if ( pOrderBy != null ) cp.pOrderBy = pOrderBy.Copy();\n          if ( pPrior != null ) cp.pPrior = pPrior.Copy();\n          if ( pNext != null ) cp.pNext = pNext.Copy();\n          if ( pRightmost != null ) cp.pRightmost = pRightmost.Copy();\n          if ( pLimit != null ) cp.pLimit = pLimit.Copy();\n          if ( pOffset != null ) cp.pOffset = pOffset.Copy();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** Allowed values for Select.selFlags.  The "SF" prefix stands for\n    ** "Select Flag".\n    */\n    //#define SF_Distinct        0x0001  /* Output should be DISTINCT */\n    //#define SF_Resolved        0x0002  /* Identifiers have been resolved */\n    //#define SF_Aggregate       0x0004  /* Contains aggregate functions */\n    //#define SF_UsesEphemeral   0x0008  /* Uses the OpenEphemeral opcode */\n    //#define SF_Expanded        0x0010  /* sqlite3SelectExpand() called on this */\n    //#define SF_HasTypeInfo     0x0020  /* FROM subqueries have Table metadata */\n    const int SF_Distinct = 0x0001;  /* Output should be DISTINCT */\n    const int SF_Resolved = 0x0002;  /* Identifiers have been resolved */\n    const int SF_Aggregate = 0x0004;  /* Contains aggregate functions */\n    const int SF_UsesEphemeral = 0x0008;  /* Uses the OpenEphemeral opcode */\n    const int SF_Expanded = 0x0010;  /* sqlite3SelectExpand() called on this */\n    const int SF_HasTypeInfo = 0x0020;  /* FROM subqueries have Table metadata */\n\n\n    /*\n    ** The results of a select can be distributed in several ways.  The\n    ** "SRT" prefix means "SELECT Result Type".\n    */\n    const int SRT_Union = 1;//#define SRT_Union        1  /* Store result as keys in an index */\n    const int SRT_Except = 2;//#define SRT_Except      2  /* Remove result from a UNION index */\n    const int SRT_Exists = 3;//#define SRT_Exists      3  /* Store 1 if the result is not empty */\n    const int SRT_Discard = 4;//#define SRT_Discard    4  /* Do not save the results anywhere */\n\n    /* The ORDER BY clause is ignored for all of the above */\n    //#define IgnorableOrderby(X) ((X->eDest)<=SRT_Discard)\n\n    const int SRT_Output = 5;//#define SRT_Output      5  /* Output each row of result */\n    const int SRT_Mem = 6;//#define SRT_Mem            6  /* Store result in a memory cell */\n    const int SRT_Set = 7;//#define SRT_Set            7  /* Store results as keys in an index */\n    const int SRT_Table = 8;//#define SRT_Table        8  /* Store result as data with an automatic rowid */\n    const int SRT_EphemTab = 9;//#define SRT_EphemTab  9  /* Create transient tab and store like SRT_Table /\n    const int SRT_Coroutine = 10;//#define SRT_Coroutine   10  /* Generate a single row of result */\n\n    /*\n    ** A structure used to customize the behavior of sqlite3Select(). See\n    ** comments above sqlite3Select() for details.\n    */\n    //typedef struct SelectDest SelectDest;\n    public class SelectDest\n    {\n      public u8 eDest;        /* How to dispose of the results */\n      public char affinity;    /* Affinity used when eDest==SRT_Set */\n      public int iParm;        /* A parameter used by the eDest disposal method */\n      public int iMem;         /* Base register where results are written */\n      public int nMem;         /* Number of registers allocated */\n      public SelectDest()\n      {\n        this.eDest = 0;\n        this.affinity = \'\\0\';\n        this.iParm = 0;\n        this.iMem = 0;\n        this.nMem = 0;\n      }\n      public SelectDest( u8 eDest, char affinity, int iParm )\n      {\n        this.eDest = eDest;\n        this.affinity = affinity;\n        this.iParm = iParm;\n        this.iMem = 0;\n        this.nMem = 0;\n      }\n      public SelectDest( u8 eDest, char affinity, int iParm, int iMem, int nMem )\n      {\n        this.eDest = eDest;\n        this.affinity = affinity;\n        this.iParm = iParm;\n        this.iMem = iMem;\n        this.nMem = nMem;\n      }\n    };\n\n    /*\n    ** During code generation of statements that do inserts into AUTOINCREMENT\n    ** tables, the following information is attached to the Table.u.autoInc.p\n    ** pointer of each autoincrement table to record some side information that\n    ** the code generator needs.  We have to keep per-table autoincrement\n    ** information in case inserts are down within triggers.  Triggers do not\n    ** normally coordinate their activities, but we do need to coordinate the\n    ** loading and saving of autoincrement information.\n    */\n    public class AutoincInfo\n    {\n      public AutoincInfo pNext;    /* Next info block in a list of them all */\n      public Table pTab;           /* Table this info block refers to */\n      public int iDb;              /* Index in sqlite3.aDb[] of database holding pTab */\n      public int regCtr;           /* Memory register holding the rowid counter */\n    };\n\n    /*\n    ** Size of the column cache\n    */\n#if !SQLITE_N_COLCACHE\n    //# define SQLITE_N_COLCACHE 10\n    const int SQLITE_N_COLCACHE = 10;\n#endif\n\n    /*\n** An SQL parser context.  A copy of this structure is passed through\n** the parser and down into all the parser action routine in order to\n** carry around information that is global to the entire parse.\n**\n** The structure is divided into two parts.  When the parser and code\n** generate call themselves recursively, the first part of the structure\n** is constant but the second part is reset at the beginning and end of\n** each recursion.\n**\n** The nTableLock and aTableLock variables are only used if the shared-cache\n** feature is enabled (if sqlite3Tsd()->useSharedData is true). They are\n** used to store the set of table-locks required by the statement being\n** compiled. Function sqlite3TableLock() is used to add entries to the\n** list.\n*/\n    public class yColCache\n    {\n      public int iTable;           /* Table cursor number */\n      public int iColumn;          /* Table column number */\n      public bool affChange;       /* True if this register has had an affinity change */\n      public u8 tempReg;           /* iReg is a temp register that needs to be freed */\n      public int iLevel;           /* Nesting level */\n      public int iReg;             /* Reg with value of this column. 0 means none. */\n      public int lru;              /* Least recently used entry has the smallest value */\n    }\n    public class Parse\n    {\n      public sqlite3 db;          /* The main database structure */\n      public int rc;              /* Return code from execution */\n      public string zErrMsg;      /* An error message */\n      public Vdbe pVdbe;          /* An engine for executing database bytecode */\n      public u8 colNamesSet;      /* TRUE after OP_ColumnName has been issued to pVdbe */\n      public u8 nameClash;        /* A permanent table name clashes with temp table name */\n      public u8 checkSchema;      /* Causes schema cookie check after an error */\n      public u8 nested;           /* Number of nested calls to the parser/code generator */\n      public u8 parseError;       /* True after a parsing error.  Ticket #1794 */\n      public u8 nTempReg;         /* Number of temporary registers in aTempReg[] */\n      public u8 nTempInUse;       /* Number of aTempReg[] currently checked out */\n      public int[] aTempReg = new int[8];     /* Holding area for temporary registers */\n      public int nRangeReg;       /* Size of the temporary register block */\n      public int iRangeReg;       /* First register in temporary register block */\n      public int nErr;            /* Number of errors seen */\n      public int nTab;            /* Number of previously allocated VDBE cursors */\n      public int nMem;            /* Number of memory cells used so far */\n      public int nSet;            /* Number of sets used so far */\n      public int ckBase;          /* Base register of data during check constraints */\n      public int iCacheLevel;     /* ColCache valid when aColCache[].iLevel<=iCacheLevel */\n      public int iCacheCnt;       /* Counter used to generate aColCache[].lru values */\n      public u8 nColCache;        /* Number of entries in the column cache */\n      public u8 iColCache;        /* Next entry of the cache to replace */\n      public yColCache[] aColCache = new yColCache[SQLITE_N_COLCACHE];     /* One for each valid column cache entry */\n      public u32 writeMask;       /* Start a write transaction on these databases */\n      public u32 cookieMask;      /* Bitmask of schema verified databases */\n      public int cookieGoto;      /* Address of OP_Goto to cookie verifier subroutine */\n      public int[] cookieValue = new int[SQLITE_MAX_ATTACHED + 2];  /* Values of cookies to verify */\n#if !SQLITE_OMIT_SHARED_CACHE\npublic int nTableLock;         /* Number of locks in aTableLock */\npublic TableLock[] aTableLock; /* Required table locks for shared-cache mode */\n#endif\n      public int regRowid;           /* Register holding rowid of CREATE TABLE entry */\n      public int regRoot;            /* Register holding root page number for new objects */\n      public AutoincInfo pAinc;      /* Information about AUTOINCREMENT counters */\n\n      /* Above is constant between recursions.  Below is reset before and after\n      ** each recursion */\n\n      public int nVar;                       /* Number of \'?\' variables seen in the SQL so far */\n      public int nVarExpr;                   /* Number of used slots in apVarExpr[] */\n      public int nVarExprAlloc;              /* Number of allocated slots in apVarExpr[] */\n      public Expr[] apVarExpr;               /* Pointers to :aaa and $aaaa wildcard expressions */\n      public int nAlias;                     /* Number of aliased result set columns */\n      public int nAliasAlloc;                /* Number of allocated slots for aAlias[] */\n      public int[] aAlias;                   /* Register used to hold aliased result */\n      public u8 explain;                     /* True if the EXPLAIN flag is found on the query */\n      public Token sNameToken;               /* Token with unqualified schema object name */\n      public Token sLastToken = new Token(); /* The last token parsed */\n      public StringBuilder zTail;            /* All SQL text past the last semicolon parsed */\n      public Table pNewTable;                /* A table being constructed by CREATE TABLE */\n      public Trigger pNewTrigger;            /* Trigger under construct by a CREATE TRIGGER */\n      public TriggerStack trigStack;         /* Trigger actions being coded */\n      public string zAuthContext;            /* The 6th parameter to db.xAuth callbacks */\n#if !SQLITE_OMIT_VIRTUALTABLE\npublic Token sArg;                /* Complete text of a module argument */\npublic u8 declareVtab;            /* True if inside sqlite3_declare_vtab() */\npublic int nVtabLock;             /* Number of virtual tables to lock */\npublic Table[] apVtabLock;        /* Pointer to virtual tables needing locking */\n#endif\n      public int nHeight;             /* Expression tree height of current sub-select */\n      public Table pZombieTab;        /* List of Table objects to delete after code gen */\n\n      // We need to create instances of the col cache\n      public Parse()\n      {\n        for ( int i = 0 ; i < this.aColCache.Length ; i++ ) { this.aColCache[i] = new yColCache(); }\n      }\n\n      public void ResetMembers() // Need to clear all the following variables during each recursion\n      {\n        nVar = 0;\n        nVarExpr = 0;\n        nVarExprAlloc = 0;\n        apVarExpr = null;\n        nAlias = 0;\n        nAliasAlloc = 0;\n        aAlias = null;\n        explain = 0;\n        sNameToken = new Token();\n        sLastToken = new Token();\n        zTail.Length = 0;\n        pNewTable = null;\n        pNewTrigger = null;\n        trigStack = null;\n        zAuthContext = null;\n#if !SQLITE_OMIT_VIRTUALTABLE\nsArg = new Token();\ndeclareVtab = 0;\nnVtabLock = 0;\napVtabLoc = null;\n#endif\n        nHeight = 0;\n        pZombieTab = null;\n      }\n      Parse[] SaveBuf = new Parse[10];  //For Recursion Storage\n      public void RestoreMembers()  // Need to clear all the following variables during each recursion\n      {\n        if ( SaveBuf[nested] != null )\n          nVar = SaveBuf[nested].nVar;\n        nVarExpr = SaveBuf[nested].nVarExpr;\n        nVarExprAlloc = SaveBuf[nested].nVarExprAlloc;\n        apVarExpr = SaveBuf[nested].apVarExpr;\n        nAlias = SaveBuf[nested].nAlias;\n        nAliasAlloc = SaveBuf[nested].nAliasAlloc;\n        aAlias = SaveBuf[nested].aAlias;\n        explain = SaveBuf[nested].explain;\n        sNameToken = SaveBuf[nested].sNameToken;\n        sLastToken = SaveBuf[nested].sLastToken;\n        zTail = SaveBuf[nested].zTail;\n        pNewTable = SaveBuf[nested].pNewTable;\n        pNewTrigger = SaveBuf[nested].pNewTrigger;\n        trigStack = SaveBuf[nested].trigStack;\n        zAuthContext = SaveBuf[nested].zAuthContext;\n#if !SQLITE_OMIT_VIRTUALTABLE\nsArg = SaveBuf[nested].sArg              ;\ndeclareVtab = SaveBuf[nested].declareVtab;\nnVtabLock = SaveBuf[nested].nVtabLock;\napVtabLock = SaveBuf[nested].apVtabLock;\n#endif\n        nHeight = SaveBuf[nested].nHeight;\n        pZombieTab = SaveBuf[nested].pZombieTab;\n        SaveBuf[nested] = null;\n      }\n      public void SaveMembers() // Need to clear all the following variables during each recursion\n      {\n        SaveBuf[nested] = new Parse();\n        SaveBuf[nested].nVar = nVar;\n        SaveBuf[nested].nVarExpr = nVarExpr;\n        SaveBuf[nested].nVarExprAlloc = nVarExprAlloc;\n        SaveBuf[nested].apVarExpr = apVarExpr;\n        SaveBuf[nested].nAlias = nAlias;\n        SaveBuf[nested].nAliasAlloc = nAliasAlloc;\n        SaveBuf[nested].aAlias = aAlias;\n        SaveBuf[nested].explain = explain;\n        SaveBuf[nested].sNameToken = sNameToken;\n        SaveBuf[nested].sLastToken = sLastToken;\n        SaveBuf[nested].zTail = zTail;\n        SaveBuf[nested].pNewTable = pNewTable;\n        SaveBuf[nested].pNewTrigger = pNewTrigger;\n        SaveBuf[nested].trigStack = trigStack;\n        SaveBuf[nested].zAuthContext = zAuthContext;\n#if !SQLITE_OMIT_VIRTUALTABLE\nSaveBuf[nested].sArg = sArg             ;\nSaveBuf[nested].declareVtab = declareVtab;\nSaveBuf[nested].nVtabLock = nVtabLock   ;\nSaveBuf[nested].apVtabLock = apVtabLock ;\n#endif\n        SaveBuf[nested].nHeight = nHeight;\n        SaveBuf[nested].pZombieTab = pZombieTab;\n      }\n    };\n\n#if SQLITE_OMIT_VIRTUALTABLE\n    static bool IN_DECLARE_VTAB = false;//#define IN_DECLARE_VTAB 0\n#else\n//  int ;//#define IN_DECLARE_VTAB (pParse.declareVtab)\n#endif\n\n    /*\n** An instance of the following structure can be declared on a stack and used\n** to save the Parse.zAuthContext value so that it can be restored later.\n*/\n    public class AuthContext\n    {\n      public string zAuthContext;   /* Put saved Parse.zAuthContext here */\n      public Parse pParse;              /* The Parse structure */\n    };\n\n    /*\n    ** Bitfield flags for P5 value in OP_Insert and OP_Delete\n    */\n    //#define OPFLAG_NCHANGE   1    /* Set to update db->nChange */\n    //#define OPFLAG_LASTROWID 2    /* Set to update db->lastRowid */\n    //#define OPFLAG_ISUPDATE  4    /* This OP_Insert is an sql UPDATE */\n    //#define OPFLAG_APPEND    8    /* This is likely to be an append */\n    //#define OPFLAG_USESEEKRESULT 16    /* Try to avoid a seek in BtreeInsert() */\n    const byte OPFLAG_NCHANGE = 1;\n    const byte OPFLAG_LASTROWID = 2;\n    const byte OPFLAG_ISUPDATE = 4;\n    const byte OPFLAG_APPEND = 8;\n    const byte OPFLAG_USESEEKRESULT = 16;\n\n    /*\n    * Each trigger present in the database schema is stored as an instance of\n    * struct Trigger.\n    *\n    * Pointers to instances of struct Trigger are stored in two ways.\n    * 1. In the "trigHash" hash table (part of the sqlite3* that represents the\n    *    database). This allows Trigger structures to be retrieved by name.\n    * 2. All triggers associated with a single table form a linked list, using the\n    *    pNext member of struct Trigger. A pointer to the first element of the\n    *    linked list is stored as the "pTrigger" member of the associated\n    *    struct Table.\n    *\n    * The "step_list" member points to the first element of a linked list\n    * containing the SQL statements specified as the trigger program.\n    */\n    public class Trigger\n    {\n      public string name;             /* The name of the trigger                        */\n      public string table;            /* The table or view to which the trigger applies */\n      public u8 op;                   /* One of TK_DELETE, TK_UPDATE, TK_INSERT         */\n      public u8 tr_tm;                /* One of TRIGGER_BEFORE, TRIGGER_AFTER */\n      public Expr pWhen;              /* The WHEN clause of the expression (may be NULL) */\n      public IdList pColumns;         /* If this is an UPDATE OF <column-list> trigger,\nthe <column-list> is stored here */\n      public Schema pSchema;          /* Schema containing the trigger */\n      public Schema pTabSchema;       /* Schema containing the table */\n      public TriggerStep step_list;   /* Link list of trigger program steps             */\n      public Trigger pNext;           /* Next trigger associated with the table */\n\n      public Trigger Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Trigger cp = (Trigger)MemberwiseClone();\n          if ( pWhen != null ) cp.pWhen = pWhen.Copy();\n          if ( pColumns != null ) cp.pColumns = pColumns.Copy();\n          if ( pSchema != null ) cp.pSchema = pSchema.Copy();\n          if ( pTabSchema != null ) cp.pTabSchema = pTabSchema.Copy();\n          if ( step_list != null ) cp.step_list = step_list.Copy();\n          if ( pNext != null ) cp.pNext = pNext.Copy();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    ** A trigger is either a BEFORE or an AFTER trigger.  The following constants\n    ** determine which.\n    **\n    ** If there are multiple triggers, you might of some BEFORE and some AFTER.\n    ** In that cases, the constants below can be ORed together.\n    */\n    const u8 TRIGGER_BEFORE = 1;//#define TRIGGER_BEFORE  1\n    const u8 TRIGGER_AFTER = 2;//#define TRIGGER_AFTER   2\n\n    /*\n    * An instance of struct TriggerStep is used to store a single SQL statement\n    * that is a part of a trigger-program.\n    *\n    * Instances of struct TriggerStep are stored in a singly linked list (linked\n    * using the "pNext" member) referenced by the "step_list" member of the\n    * associated struct Trigger instance. The first element of the linked list is\n    * the first step of the trigger-program.\n    *\n    * The "op" member indicates whether this is a "DELETE", "INSERT", "UPDATE" or\n    * "SELECT" statement. The meanings of the other members is determined by the\n    * value of "op" as follows:\n    *\n    * (op == TK_INSERT)\n    * orconf    -> stores the ON CONFLICT algorithm\n    * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, then\n    *              this stores a pointer to the SELECT statement. Otherwise NULL.\n    * target    -> A token holding the quoted name of the table to insert into.\n    * pExprList -> If this is an INSERT INTO ... VALUES ... statement, then\n    *              this stores values to be inserted. Otherwise NULL.\n    * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ...\n    *              statement, then this stores the column-names to be\n    *              inserted into.\n    *\n    * (op == TK_DELETE)\n    * target    -> A token holding the quoted name of the table to delete from.\n    * pWhere    -> The WHERE clause of the DELETE statement if one is specified.\n    *              Otherwise NULL.\n    *\n    * (op == TK_UPDATE)\n    * target    -> A token holding the quoted name of the table to update rows of.\n    * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.\n    *              Otherwise NULL.\n    * pExprList -> A list of the columns to update and the expressions to update\n    *              them to. See sqlite3Update() documentation of "pChanges"\n    *              argument.\n    *\n    */\n    public class TriggerStep\n    {\n      public u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */\n      public u8 orconf;           /* OE_Rollback etc. */\n      public Trigger pTrig;       /* The trigger that this step is a part of */\n      public Select pSelect;      /* SELECT statment or RHS of INSERT INTO .. SELECT ... */\n      public Token target;        /* Target table for DELETE, UPDATE, INSERT */\n      public Expr pWhere;         /* The WHERE clause for DELETE or UPDATE steps */\n      public ExprList pExprList;  /* SET clause for UPDATE.  VALUES clause for INSERT */\n      public IdList pIdList;      /* Column names for INSERT */\n      public TriggerStep pNext;   /* Next in the link-list */\n      public TriggerStep pLast;   /* Last element in link-list. Valid for 1st elem only */\n\n      public TriggerStep()\n      {\n        target = new Token();\n      }\n      public TriggerStep Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          TriggerStep cp = (TriggerStep)MemberwiseClone();\n          return cp;\n        }\n      }\n    };\n\n    /*\n    * An instance of struct TriggerStack stores information required during code\n    * generation of a single trigger program. While the trigger program is being\n    * coded, its associated TriggerStack instance is pointed to by the\n    * "pTriggerStack" member of the Parse structure.\n    *\n    * The pTab member points to the table that triggers are being coded on. The\n    * newIdx member contains the index of the vdbe cursor that points at the temp\n    * table that stores the new.* references. If new.* references are not valid\n    * for the trigger being coded (for example an ON DELETE trigger), then newIdx\n    * is set to -1. The oldIdx member is analogous to newIdx, for old.* references.\n    *\n    * The ON CONFLICT policy to be used for the trigger program steps is stored\n    * as the orconf member. If this is OE_Default, then the ON CONFLICT clause\n    * specified for individual triggers steps is used.\n    *\n    * struct TriggerStack has a "pNext" member, to allow linked lists to be\n    * constructed. When coding nested triggers (triggers fired by other triggers)\n    * each nested trigger stores its parent trigger\'s TriggerStack as the "pNext"\n    * pointer. Once the nested trigger has been coded, the pNext value is restored\n    * to the pTriggerStack member of the Parse stucture and coding of the parent\n    * trigger continues.\n    *\n    * Before a nested trigger is coded, the linked list pointed to by the\n    * pTriggerStack is scanned to ensure that the trigger is not about to be coded\n    * recursively. If this condition is detected, the nested trigger is not coded.\n    */\n    public class TriggerStack\n    {\n      public Table pTab;         /* Table that triggers are currently being coded on */\n      public int newIdx;          /* Index of vdbe cursor to "new" temp table */\n      public int oldIdx;          /* Index of vdbe cursor to "old" temp table */\n      public u32 newColMask;\n      public u32 oldColMask;\n      public int orconf;          /* Current orconf policy */\n      public int ignoreJump;      /* where to jump to for a RAISE(IGNORE) */\n      public Trigger pTrigger;   /* The trigger currently being coded */\n      public TriggerStack pNext; /* Next trigger down on the trigger stack */\n    };\n\n    /*\n    ** The following structure contains information used by the sqliteFix...\n    ** routines as they walk the parse tree to make database references\n    ** explicit.\n    */\n    //typedef struct DbFixer DbFixer;\n    public class DbFixer\n    {\n      public Parse pParse;       /* The parsing context.  Error messages written here */\n      public string zDb;         /* Make sure all objects are contained in this database */\n      public string zType;       /* Type of the container - used for error messages */\n      public Token pName;        /* Name of the container - used for error messages */\n    };\n\n    /*\n    ** An objected used to accumulate the text of a string where we\n    ** do not necessarily know how big the string will be in the end.\n    */\n    public class StrAccum\n    {\n      public sqlite3 db;          /* Optional database for lookaside.  Can be NULL */\n      public StringBuilder zBase = new StringBuilder();     /* A base allocation.  Not from malloc. */\n      public StringBuilder zText = new StringBuilder();     /* The string collected so far */\n      public int nChar;                                     /* Length of the string so far */\n      public int nAlloc;                                    /* Amount of space allocated in zText */\n      public int mxAlloc;         /* Maximum allowed string length */\n      // Cannot happen under C#\n      //public u8 mallocFailed;     /* Becomes true if any memory allocation fails */\n      public u8 useMalloc;        /* True if zText is enlargeable using realloc */\n      public u8 tooBig;           /* Becomes true if string size exceeds limits */\n      public Mem Context;\n    };\n\n    /*\n    ** A pointer to this structure is used to communicate information\n    ** from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.\n    */\n    public class InitData\n    {\n      public sqlite3 db;        /* The database being initialized */\n      public int iDb;            /* 0 for main database.  1 for TEMP, 2.. for ATTACHed */\n      public string pzErrMsg;    /* Error message stored here */\n      public int rc;             /* Result code stored here */\n    }\n\n    /*\n    ** Structure containing global configuration data for the SQLite library.\n    **\n    ** This structure also contains some state information.\n    */\n    public class Sqlite3Config\n    {\n      public bool bMemstat;                    /* True to enable memory status */\n      public bool bCoreMutex;                  /* True to enable core mutexing */\n      public bool bFullMutex;                   /* True to enable full mutexing */\n      public int mxStrlen;                     /* Maximum string length */\n      public int szLookaside;                  /* Default lookaside buffer size */\n      public int nLookaside;                   /* Default lookaside buffer count */\n      public sqlite3_mem_methods m;            /* Low-level memory allocation interface */\n      public sqlite3_mutex_methods mutex;      /* Low-level mutex interface */\n      public sqlite3_pcache_methods pcache;    /* Low-level page-cache interface */\n      public byte[] pHeap;                     /* Heap storage space */\n      public int nHeap;                        /* Size of pHeap[] */\n      public int mnReq, mxReq;                 /* Min and max heap requests sizes */\n      public byte[] pScratch;                  /* Scratch memory */\n      public int szScratch;                    /* Size of each scratch buffer */\n      public int nScratch;                     /* Number of scratch buffers */\n      public MemPage pPage;                    /* Page cache memory */\n      public int szPage;                       /* Size of each page in pPage[] */\n      public int nPage;                        /* Number of pages in pPage[] */\n      public int mxParserStack;                /* maximum depth of the parser stack */\n      public bool sharedCacheEnabled;           /* true if shared-cache mode enabled */\n      /* The above might be initialized to non-zero.  The following need to always\n      ** initially be zero, however. */\n      public int isInit;                       /* True after initialization has finished */\n      public int inProgress;                   /* True while initialization in progress */\n      public int isMallocInit;                 /* True after malloc is initialized */\n      public sqlite3_mutex pInitMutex;         /* Mutex used by sqlite3_initialize() */\n      public int nRefInitMutex;                /* Number of users of pInitMutex */\n\n      public Sqlite3Config( int bMemstat, int bCoreMutex, bool bFullMutex, int mxStrlen, int szLookaside, int nLookaside\n      , sqlite3_mem_methods m\n      , sqlite3_mutex_methods mutex\n      , sqlite3_pcache_methods pcache\n      , byte[] pHeap\n      , int nHeap,\n      int mnReq, int mxReq\n      , byte[] pScratch\n      , int szScratch\n      , int nScratch\n      , MemPage pPage\n      , int szPage\n      , int nPage\n      , int mxParserStack\n      , bool sharedCacheEnabled\n      , int isInit\n      , int inProgress\n      , int isMallocInit\n      , sqlite3_mutex pInitMutex\n      , int nRefInitMutex\n      )\n      {\n        this.bMemstat = bMemstat != 0;\n        this.bCoreMutex = bCoreMutex != 0;\n        this.bFullMutex = bFullMutex;\n        this.mxStrlen = mxStrlen;\n        this.szLookaside = szLookaside;\n        this.nLookaside = nLookaside;\n        this.m = m;\n        this.mutex = mutex;\n        this.pcache = pcache;\n        this.pHeap = pHeap;\n        this.nHeap = nHeap;\n        this.mnReq = mnReq;\n        this.mxReq = mxReq;\n        this.pScratch = pScratch;\n        this.szScratch = szScratch;\n        this.nScratch = nScratch;\n        this.pPage = pPage;\n        this.szPage = szPage;\n        this.nPage = nPage;\n        this.mxParserStack = mxParserStack;\n        this.sharedCacheEnabled = sharedCacheEnabled;\n        this.isInit = isInit;\n        this.inProgress = inProgress;\n        this.isMallocInit = isMallocInit;\n        this.pInitMutex = pInitMutex;\n        this.nRefInitMutex = nRefInitMutex;\n      }\n    };\n\n    /*\n    ** Context pointer passed down through the tree-walk.\n    */\n    public class Walker\n    {\n      public dxExprCallback xExprCallback; //)(Walker*, Expr*);     /* Callback for expressions */\n      public dxSelectCallback xSelectCallback; //)(Walker*,Select*);  /* Callback for SELECTs */\n      public Parse pParse;                            /* Parser context.  */\n      public struct uw\n      {                              /* Extra data for callback */\n        public NameContext pNC;                       /* Naming context */\n        public int i;                                 /* Integer value */\n      }\n      public uw u;\n    };\n\n    /* Forward declarations */\n    //int sqlite3WalkExpr(Walker*, Expr*);\n    //int sqlite3WalkExprList(Walker*, ExprList*);\n    //int sqlite3WalkSelect(Walker*, Select*);\n    //int sqlite3WalkSelectExpr(Walker*, Select*);\n    //int sqlite3WalkSelectFrom(Walker*, Select*);\n\n    /*\n    ** Return code from the parse-tree walking primitives and their\n    ** callbacks.\n    */\n    //#define WRC_Continue    0   /* Continue down into children */\n    //#define WRC_Prune       1   /* Omit children but continue walking siblings */\n    //#define WRC_Abort       2   /* Abandon the tree walk */\n    const int WRC_Continue = 0;\n    const int WRC_Prune = 1;\n    const int WRC_Abort = 2;\n\n\n    /*\n    ** Assuming zIn points to the first byte of a UTF-8 character,\n    ** advance zIn to point to the first byte of the next UTF-8 character.\n    */\n    //#define SQLITE_SKIP_UTF8(zIn) {                        \\\n    //  if( (*(zIn++))>=0xc0 ){                              \\\n    //    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \\\n    //  }                                                    \\\n    //}\n    static void SQLITE_SKIP_UTF8( string zIn, ref int iz )\n    {\n      iz++;\n      if ( iz < zIn.Length && zIn[iz - 1] >= 0xC0 )\n      {\n        while ( iz < zIn.Length && ( zIn[iz] & 0xC0 ) == 0x80 ) { iz++; }\n      }\n    }\n    static void SQLITE_SKIP_UTF8(\n    byte[] zIn, ref int iz )\n    {\n      iz++;\n      if ( iz < zIn.Length && zIn[iz - 1] >= 0xC0 )\n      {\n        while ( iz < zIn.Length && ( zIn[iz] & 0xC0 ) == 0x80 ) { iz++; }\n      }\n    }\n\n    /*\n    ** The SQLITE_CORRUPT_BKPT macro can be either a constant (for production\n    ** builds) or a function call (for debugging).  If it is a function call,\n    ** it allows the operator to set a breakpoint at the spot where database\n    ** corruption is first detected.\n    */\n#if SQLITE_DEBUG || DEBUG\n    static int SQLITE_CORRUPT_BKPT()\n    {\n       return sqlite3Corrupt();\n    }\n#else\n//#define SQLITE_CORRUPT_BKPT SQLITE_CORRUPT\nconst int SQLITE_CORRUPT_BKPT = SQLITE_CORRUPT;\n#endif\n\n    /*\n** The ctype.h header is needed for non-ASCII systems.  It is also\n** needed by FTS3 when FTS3 is included in the amalgamation.\n*/\n    //#if !defined(SQLITE_ASCII) || \\\n    //    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))\n    //# include <ctype.h>\n    //#endif\n\n\n    /*\n    ** The following macros mimic the standard library functions toupper(),\n    ** isspace(), isalnum(), isdigit() and isxdigit(), respectively. The\n    ** sqlite versions only work for ASCII characters, regardless of locale.\n    */\n#if SQLITE_ASCII\n    //# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))\n\n    //# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)\n    static bool sqlite3Isspace( byte x ) { return ( sqlite3CtypeMap[(byte)( x )] & 0x01 ) != 0; }\n    static bool sqlite3Isspace( char x ) { return x < 256 && ( sqlite3CtypeMap[(byte)( x )] & 0x01 ) != 0; }\n\n    //# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)\n    static bool sqlite3Isalnum( byte x ) { return ( sqlite3CtypeMap[(byte)( x )] & 0x06 ) != 0; }\n    static bool sqlite3Isalnum( char x ) { return x < 256 && ( sqlite3CtypeMap[(byte)( x )] & 0x06 ) != 0; }\n\n    //# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)\n\n    //# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)\n    static bool sqlite3Isdigit( byte x ) { return ( sqlite3CtypeMap[( (byte)x )] & 0x04 ) != 0; }\n    static bool sqlite3Isdigit( char x ) { return x < 256 && ( sqlite3CtypeMap[( (byte)x )] & 0x04 ) != 0; }\n\n    //# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)\n    static bool sqlite3Isxdigit( byte x ) { return ( sqlite3CtypeMap[( (byte)x )] & 0x08 ) != 0; }\n    static bool sqlite3Isxdigit( char x ) { return x < 256 && ( sqlite3CtypeMap[( (byte)x )] & 0x08 ) != 0; }\n\n    //# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])\n#else\n//# define sqlite3Toupper(x)   toupper((unsigned char)(x))\n//# define sqlite3Isspace(x)   isspace((unsigned char)(x))\n//# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))\n//# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))\n//# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))\n//# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))\n//# define sqlite3Tolower(x)   tolower((unsigned char)(x))\n#endif\n\n    /*\n** Internal function prototypes\n*/\n    //int sqlite3StrICmp(const char *, const char *);\n    //int sqlite3IsNumber(const char*, int*, u8);\n    //int sqlite3Strlen30(const char*);\n    //#define sqlite3StrNICmp sqlite3_strnicmp\n\n    //int sqlite3MallocInit(void);\n    //void sqlite3MallocEnd(void);\n    //void *sqlite3Malloc(int);\n    //void *sqlite3MallocZero(int);\n    //void *sqlite3DbMallocZero(sqlite3*, int);\n    //void *sqlite3DbMallocRaw(sqlite3*, int);\n    //char *sqlite3DbStrDup(sqlite3*,const char*);\n    //char *sqlite3DbStrNDup(sqlite3*,const char*, int);\n    //void *sqlite3Realloc(void*, int);\n    //void *sqlite3DbReallocOrFree(sqlite3 *, void *, int);\n    //void *sqlite3DbRealloc(sqlite3 *, void *, int);\n    //void //sqlite3DbFree(sqlite3*, void*);\n    //int sqlite3MallocSize(void*);\n    //int sqlite3DbMallocSize(sqlite3*, void*);\n    //void *sqlite3ScratchMalloc(int);\n    //void //sqlite3ScratchFree(void*);\n    //void *sqlite3PageMalloc(int);\n    //void sqlite3PageFree(void*);\n    //void sqlite3MemSetDefault(void);\n    //void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));\n    //int sqlite3MemoryAlarm(void (*)(void*, sqlite3_int64, int), void*, sqlite3_int64);\n\n    /*\n    ** On systems with ample stack space and that support alloca(), make\n    ** use of alloca() to obtain space for large automatic objects.  By default,\n    ** obtain space from malloc().\n    **\n    ** The alloca() routine never returns NULL.  This will cause code paths\n    ** that deal with sqlite3StackAlloc() failures to be unreachable.\n    */\n#if SQLITE_USE_ALLOCA\n//# define sqlite3StackAllocRaw(D,N)   alloca(N)\n//# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)\n//# define //sqlite3StackFree(D,P)\n#else\n#if FALSE\n    //# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)\n    static void sqlite3StackAllocRaw( sqlite3 D, int N ) { sqlite3DbMallocRaw( D, N ); }\n    //# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)\n    static void sqlite3StackAllocZero( sqlite3 D, int N ) { sqlite3DbMallocZero( D, N ); }\n    //# define //sqlite3StackFree(D,P)       //sqlite3DbFree(D,P)\n    static void //sqlite3StackFree( sqlite3 D, object P ) {sqlite3DbFree( D, P ); }\n#endif\n#endif\n\n#if SQLITE_ENABLE_MEMSYS3\nconst sqlite3_mem_methods *sqlite3MemGetMemsys3(void);\n#endif\n#if SQLITE_ENABLE_MEMSYS5\nconst sqlite3_mem_methods *sqlite3MemGetMemsys5(void);\n#endif\n\n#if !SQLITE_MUTEX_OMIT\n//  sqlite3_mutex_methods *sqlite3DefaultMutex(void);\n//  sqlite3_mutex *sqlite3MutexAlloc(int);\n//  int sqlite3MutexInit(void);\n//  int sqlite3MutexEnd(void);\n#endif\n\n    //int sqlite3StatusValue(int);\n    //void sqlite3StatusAdd(int, int);\n    //void sqlite3StatusSet(int, int);\n\n    //int sqlite3IsNaN(double);\n\n    //void sqlite3VXPrintf(StrAccum*, int, const char*, va_list);\n    //char *sqlite3MPrintf(sqlite3*,const char*, ...);\n    //char *sqlite3VMPrintf(sqlite3*,const char*, va_list);\n    //char *sqlite3MAppendf(sqlite3*,char*,const char*,...);\n#if SQLITE_TEST || SQLITE_DEBUG\n    //  void sqlite3DebugPrintf(const char*, ...);\n#endif\n#if SQLITE_TEST\n    //  void *sqlite3TestTextToPtr(const char*);\n#endif\n    //void sqlite3SetString(char **, sqlite3*, const char*, ...);\n    //void sqlite3ErrorMsg(Parse*, const char*, ...);\n    //void sqlite3ErrorClear(Parse*);\n    //int sqlite3Dequote(char*);\n    //int sqlite3KeywordCode(const unsigned char*, int);\n    //int sqlite3RunParser(Parse*, const char*, char **);\n    //void sqlite3FinishCoding(Parse*);\n    //int sqlite3GetTempReg(Parse*);\n    //void sqlite3ReleaseTempReg(Parse*,int);\n    //int sqlite3GetTempRange(Parse*,int);\n    //void sqlite3ReleaseTempRange(Parse*,int,int);\n    //Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);\n    //Expr *sqlite3Expr(sqlite3*,int,const char*);\n    //void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);\n    //Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*, const Token*);\n    //Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*);\n    //Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*);\n    //void sqlite3ExprAssignVarNumber(Parse*, Expr*);\n    //void sqlite3ExprClear(sqlite3*, Expr*);\n    //void sqlite3ExprDelete(sqlite3*, Expr*);\n    //ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);\n    //void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);\n    //void sqlite3ExprListSetSpan(Parse*,ExprList*,ExprSpan*);\n    //void sqlite3ExprListDelete(sqlite3*, ExprList*);\n    //int sqlite3Init(sqlite3*, char**);\n    //int sqlite3InitCallback(void*, int, char**, char**);\n    //void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);\n    //void sqlite3ResetInternalSchema(sqlite3*, int);\n    //void sqlite3BeginParse(Parse*,int);\n    //void sqlite3CommitInternalChanges(sqlite3*);\n    //Table *sqlite3ResultSetOfSelect(Parse*,Select*);\n    //void sqlite3OpenMasterTable(Parse *, int);\n    //void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);\n    //void sqlite3AddColumn(Parse*,Token*);\n    //void sqlite3AddNotNull(Parse*, int);\n    //void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);\n    //void sqlite3AddCheckConstraint(Parse*, Expr*);\n    //void sqlite3AddColumnType(Parse*,Token*);\n    //void sqlite3AddDefaultValue(Parse*,ExprSpan*);\n    //void sqlite3AddCollateType(Parse*, Token*);\n    //void sqlite3EndTable(Parse*,Token*,Token*,Select*);\n\n    //Bitvec *sqlite3BitvecCreate(u32);\n    //int sqlite3BitvecTest(Bitvec*, u32);\n    //int sqlite3BitvecSet(Bitvec*, u32);\n    //void sqlite3BitvecClear(Bitvec*, u32, void*);\n    //void sqlite3BitvecDestroy(Bitvec*);\n    //u32 sqlite3BitvecSize(Bitvec*);\n    //int sqlite3BitvecBuiltinTest(int,int*);\n\n    //RowSet *sqlite3RowSetInit(sqlite3*, void*, unsigned int);\n    //void sqlite3RowSetClear(RowSet*);\n    //void sqlite3RowSetInsert(RowSet*, i64);\n    //int sqlite3RowSetTest(RowSet*, u8 iBatch, i64);\n    //int sqlite3RowSetNext(RowSet*, i64*);\n\n    //void sqlite3CreateView(Parse*,Token*,Token*,Token*,Select*,int,int);\n\n    //#if !(SQLITE_OMIT_VIEW) || !SQLITE_OMIT_VIRTUALTABLE)\n    //  int sqlite3ViewGetColumnNames(Parse*,Table*);\n    //#else\n    //# define sqlite3ViewGetColumnNames(A,B) 0\n    //#endif\n\n    //void sqlite3DropTable(Parse*, SrcList*, int, int);\n    //void sqlite3DeleteTable(Table*);\n    //#if ! SQLITE_OMIT_AUTOINCREMENT\n    //  void sqlite3AutoincrementBegin(Parse *pParse);\n    //  void sqlite3AutoincrementEnd(Parse *pParse);\n    //#else\n    //# define sqlite3AutoincrementBegin(X)\n    //# define sqlite3AutoincrementEnd(X)\n    //#endif\n    //void sqlite3Insert(Parse*, SrcList*, ExprList*, Select*, IdList*, int);\n    //void *sqlite3ArrayAllocate(sqlite3*,void*,int,int,int*,int*,int*);\n    //IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*);\n    //int sqlite3IdListIndex(IdList*,const char*);\n    //SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int);\n    //SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*);\n    //SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,\n    //                                      Token*, Select*, Expr*, IdList*);\n    //void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);\n    //int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);\n    //void sqlite3SrcListShiftJoinType(SrcList*);\n    //void sqlite3SrcListAssignCursors(Parse*, SrcList*);\n    //void sqlite3IdListDelete(sqlite3*, IdList*);\n    //void sqlite3SrcListDelete(sqlite3*, SrcList*);\n    //void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,\n    //                        Token*, int, int);\n    //void sqlite3DropIndex(Parse*, SrcList*, int);\n    //int sqlite3Select(Parse*, Select*, SelectDest*);\n    //Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,\n    //                         Expr*,ExprList*,int,Expr*,Expr*);\n    //void sqlite3SelectDelete(sqlite3*, Select*);\n    //Table *sqlite3SrcListLookup(Parse*, SrcList*);\n    //int sqlite3IsReadOnly(Parse*, Table*, int);\n    //void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);\n#if (SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !(SQLITE_OMIT_SUBQUERY)\n//Expr *sqlite3LimitWhere(Parse *, SrcList *, Expr *, ExprList *, Expr *, Expr *, char *);\n#endif\n    //void sqlite3DeleteFrom(Parse*, SrcList*, Expr*);\n    //void sqlite3Update(Parse*, SrcList*, ExprList*, Expr*, int);\n    //WhereInfo *sqlite3WhereBegin(Parse*, SrcList*, Expr*, ExprList**, u16);\n    //void sqlite3WhereEnd(WhereInfo*);\n    //int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, int);\n    //void sqlite3ExprCodeMove(Parse*, int, int, int);\n    //void sqlite3ExprCodeCopy(Parse*, int, int, int);\n    //void sqlite3ExprCacheStore(Parse*, int, int, int);\n    //void sqlite3ExprCachePush(Parse*);\n    //void sqlite3ExprCachePop(Parse*, int);\n    //void sqlite3ExprCacheRemove(Parse*, int);\n    //void sqlite3ExprCacheClear(Parse*);\n    //void sqlite3ExprCacheAffinityChange(Parse*, int, int);\n    //void sqlite3ExprHardCopy(Parse*,int,int);\n    //int sqlite3ExprCode(Parse*, Expr*, int);\n    //int sqlite3ExprCodeTemp(Parse*, Expr*, int*);\n    //int sqlite3ExprCodeTarget(Parse*, Expr*, int);\n    //int sqlite3ExprCodeAndCache(Parse*, Expr*, int);\n    //void sqlite3ExprCodeConstants(Parse*, Expr*);\n    //int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int);\n    //void sqlite3ExprIfTrue(Parse*, Expr*, int, int);\n    //void sqlite3ExprIfFalse(Parse*, Expr*, int, int);\n    //Table *sqlite3FindTable(sqlite3*,const char*, const char*);\n    //Table *sqlite3LocateTable(Parse*,int isView,const char*, const char*);\n    //Index *sqlite3FindIndex(sqlite3*,const char*, const char*);\n    //void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);\n    //void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);\n    //void sqlite3Vacuum(Parse*);\n    //int sqlite3RunVacuum(char**, sqlite3*);\n    //char *sqlite3NameFromToken(sqlite3*, Token*);\n    //int sqlite3ExprCompare(Expr*, Expr*);\n    //void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);\n    //void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);\n    //Vdbe *sqlite3GetVdbe(Parse*);\n    //Expr *sqlite3CreateIdExpr(Parse *, const char*);\n    //void sqlite3PrngSaveState(void);\n    //void sqlite3PrngRestoreState(void);\n    //void sqlite3PrngResetState(void);\n    //void sqlite3RollbackAll(sqlite3*);\n    //void sqlite3CodeVerifySchema(Parse*, int);\n    //void sqlite3BeginTransaction(Parse*, int);\n    //void sqlite3CommitTransaction(Parse*);\n    //void sqlite3RollbackTransaction(Parse*);\n    //void sqlite3Savepoint(Parse*, int, Token*);\n    //void sqlite3CloseSavepoints(sqlite3 *);\n    //int sqlite3ExprIsConstant(Expr*);\n    //int sqlite3ExprIsConstantNotJoin(Expr*);\n    //int sqlite3ExprIsConstantOrFunction(Expr*);\n    //int sqlite3ExprIsInteger(Expr*, int*);\n    //int sqlite3IsRowid(const char*);\n    //void sqlite3GenerateRowDelete(Parse*, Table*, int, int, int);\n    //void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int*);\n    //int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int);\n    //void sqlite3GenerateConstraintChecks(Parse*,Table*,int,int,\n    //                                     int*,int,int,int,int,int*);\n    //void sqlite3CompleteInsertion(Parse*, Table*, int, int, int*, int, int,int,int);\n    //int sqlite3OpenTableAndIndices(Parse*, Table*, int, int);\n    //void sqlite3BeginWriteOperation(Parse*, int, int);\n    //Expr *sqlite3ExprDup(sqlite3*,Expr*,int);\n    //ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);\n    //SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);\n    //IdList *sqlite3IdListDup(sqlite3*,IdList*);\n    //Select *sqlite3SelectDup(sqlite3*,Select*,int);\n    //void sqlite3FuncDefInsert(FuncDefHash*, FuncDef*);\n    //FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,int,u8,int);\n    //void sqlite3RegisterBuiltinFunctions(sqlite3*);\n    //void sqlite3RegisterDateTimeFunctions(void);\n    //void sqlite3RegisterGlobalFunctions(void);\n    //#if SQLITE_DEBUG\n    //  int sqlite3SafetyOn(sqlite3*);\n    //  int sqlite3SafetyOff(sqlite3*);\n    //#else\n    //# define sqlite3SafetyOn(A) 0\n    //# define sqlite3SafetyOff(A) 0\n    //#endif\n    //int sqlite3SafetyCheckOk(sqlite3*);\n    //int sqlite3SafetyCheckSickOrOk(sqlite3*);\n    //void sqlite3ChangeCookie(Parse*, int);\n#if !(SQLITE_OMIT_VIEW) && !(SQLITE_OMIT_TRIGGER)\n    //void sqlite3MaterializeView(Parse*, Table*, Expr*, int);\n#endif\n\n#if !SQLITE_OMIT_TRIGGER\n    //void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,\n    //                         Expr*,int, int);\n    //void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);\n    //void sqlite3DropTrigger(Parse*, SrcList*, int);\n    //Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);\n    //Trigger *sqlite3TriggerList(Parse *, Table *);\n    //int sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,\n    //                          int, int, int, int, u32*, u32*);\n    //void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);\n    //void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);\n    //TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*);\n    //TriggerStep *sqlite3TriggerInsertStep(sqlite3*,Token*, IdList*,\n    //                                      ExprList*,Select*,u8);\n    //TriggerStep *sqlite3TriggerUpdateStep(sqlite3*,Token*,ExprList*, Expr*, u8);\n    //TriggerStep *sqlite3TriggerDeleteStep(sqlite3*,Token*, Expr*);\n    //void sqlite3DeleteTrigger(sqlite3*, Trigger*);\n    //void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);\n#else\n//# define sqlite3TriggersExist(B,C,D,E,F) 0\n//# define sqlite3DeleteTrigger(A,B)\n//# define sqlite3DropTriggerPtr(A,B)\n//# define sqlite3UnlinkAndDeleteTrigger(A,B,C)\n//# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I,J,K,L) 0\n//# define sqlite3TriggerList(X, Y) 0\n#endif\n\n    //int sqlite3JoinType(Parse*, Token*, Token*, Token*);\n    //void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);\n    //void sqlite3DeferForeignKey(Parse*, int);\n#if !SQLITE_OMIT_AUTHORIZATION\nvoid sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);\nint sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);\nvoid sqlite3AuthContextPush(Parse*, AuthContext*, const char*);\nvoid sqlite3AuthContextPop(AuthContext*);\n#else\n    //# define sqlite3AuthRead(a,b,c,d)\n    static void sqlite3AuthRead( Parse a, Expr b, Schema c, SrcList d ) { }\n    static int sqlite3AuthCheck( Parse a, int b, string c, byte[] d, byte[] e ) { return SQLITE_OK; }//# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK\n    //# define sqlite3AuthContextPush(a,b,c)\n    //# define sqlite3AuthContextPop(a)  ((void)(a))\n#endif\n    //void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);\n    //void sqlite3Detach(Parse*, Expr*);\n    //int sqlite3BtreeFactory(const sqlite3 db, const char *zFilename,\n    //                       int omitJournal, int nCache, int flags, Btree **ppBtree);\n    //int sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);\n    //int sqlite3FixSrcList(DbFixer*, SrcList*);\n    //int sqlite3FixSelect(DbFixer*, Select*);\n    //int sqlite3FixExpr(DbFixer*, Expr*);\n    //int sqlite3FixExprList(DbFixer*, ExprList*);\n    //int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);\n    //int sqlite3AtoF(const char *z, double*);\n    //int sqlite3GetInt32(const char *, int*);\n    //int sqlite3FitsIn64Bits(const char *, int);\n    //int sqlite3Utf16ByteLen(const void pData, int nChar);\n    //int sqlite3Utf8CharLen(const char pData, int nByte);\n    //int sqlite3Utf8Read(const u8*, const u8**);\n\n    /*\n    ** Routines to read and write variable-length integers.  These used to\n    ** be defined locally, but now we use the varint routines in the util.c\n    ** file.  Code should use the MACRO forms below, as the Varint32 versions\n    ** are coded to assume the single byte case is already handled (which\n    ** the MACRO form does).\n    */\n    //int sqlite3PutVarint(unsigned char*, u64);\n    //int putVarint32(unsigned char*, u32);\n    //u8 sqlite3GetVarint(const unsigned char *, u64 *);\n    //u8 sqlite3GetVarint32(const unsigned char *, u32 *);\n    //int sqlite3VarintLen(u64 v);\n\n    /*\n    ** The header of a record consists of a sequence variable-length integers.\n    ** These integers are almost always small and are encoded as a single byte.\n    ** The following macros take advantage this fact to provide a fast encode\n    ** and decode of the integers in a record header.  It is faster for the common\n    ** case where the integer is a single byte.  It is a little slower when the\n    ** integer is two or more bytes.  But overall it is faster.\n    **\n    ** The following expressions are equivalent:\n    **\n    **     x = sqlite3GetVarint32( A, B );\n    **     x = putVarint32( A, B );\n    **\n    **     x = getVarint32( A, B );\n    **     x = putVarint32( A, B );\n    **\n    */\n    //#define getVarint32(A,B)  (u8)((*(A)<(u8)0x80) ? ((B) = (u32)*(A)),1 : sqlite3GetVarint32((A), (u32 *)&(B)))\n    //#define putVarint32(A,B)  (u8)(((u32)(B)<(u32)0x80) ? (*(A) = (unsigned char)(B)),1 : sqlite3PutVarint32((A), (B)))\n    //#define getVarint    sqlite3GetVarint\n    //#define putVarint    sqlite3PutVarint\n\n\n    //void sqlite3IndexAffinityStr(Vdbe *, Index *);\n    //void sqlite3TableAffinityStr(Vdbe *, Table *);\n    //char sqlite3CompareAffinity(Expr pExpr, char aff2);\n    //int sqlite3IndexAffinityOk(Expr pExpr, char idx_affinity);\n    //char sqlite3ExprAffinity(Expr pExpr);\n    //int sqlite3Atoi64(const char*, i64*);\n    //void sqlite3Error(sqlite3*, int, const char*,...);\n    //void *sqlite3HexToBlob(sqlite3*, const char *z, int n);\n    //int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);\n    //const char *sqlite3ErrStr(int);\n    //int sqlite3ReadSchema(Parse pParse);\n    //CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);\n    //CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);\n    //CollSeq *sqlite3ExprCollSeq(Parse pParse, Expr pExpr);\n    //Expr *sqlite3ExprSetColl(Parse pParse, Expr *, Token *);\n    //int sqlite3CheckCollSeq(Parse *, CollSeq *);\n    //int sqlite3CheckObjectName(Parse *, const char *);\n    //void sqlite3VdbeSetChanges(sqlite3 *, int);\n\n    //const void *sqlite3ValueText(sqlite3_value*, u8);\n    //int sqlite3ValueBytes(sqlite3_value*, u8);\n    //void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,\n    //                      //  void(*)(void*));\n    //void sqlite3ValueFree(sqlite3_value*);\n    //sqlite3_value *sqlite3ValueNew(sqlite3 *);\n    //char *sqlite3Utf16to8(sqlite3 *, const void*, int);\n    //int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);\n    //void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);\n    //#if !SQLITE_AMALGAMATION\n    //extern const unsigned char sqlite3UpperToLower[];\n    //extern const unsigned char sqlite3CtypeMap[];\n    //extern struct Sqlite3Config sqlite3Config;\n    //extern FuncDefHash sqlite3GlobalFunctions;\n    //extern int sqlite3PendingByte;\n    //#endif\n    //void sqlite3RootPageMoved(Db*, int, int);\n    //void sqlite3Reindex(Parse*, Token*, Token*);\n    //void sqlite3AlterFunctions(sqlite3*);\n    //void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);\n    //int sqlite3GetToken(const unsigned char *, int *);\n    //void sqlite3NestedParse(Parse*, const char*, ...);\n    //void sqlite3ExpirePreparedStatements(sqlite3*);\n    //void sqlite3CodeSubselect(Parse *, Expr *, int, int);\n    //void sqlite3SelectPrep(Parse*, Select*, NameContext*);\n    //int sqlite3ResolveExprNames(NameContext*, Expr*);\n    //void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);\n    //int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);\n    //void sqlite3ColumnDefault(Vdbe *, Table *, int, int);\n    //void sqlite3AlterFinishAddColumn(Parse *, Token *);\n    //void sqlite3AlterBeginAddColumn(Parse *, SrcList *);\n    //CollSeq *sqlite3GetCollSeq(sqlite3*, CollSeq *, const char*);\n    //char sqlite3AffinityType(const char*);\n    //void sqlite3Analyze(Parse*, Token*, Token*);\n    //int sqlite3InvokeBusyHandler(BusyHandler*);\n    //int sqlite3FindDb(sqlite3*, Token*);\n    //int sqlite3FindDbName(sqlite3 *, const char *);\n    //int sqlite3AnalysisLoad(sqlite3*,int iDB);\n    //void sqlite3DefaultRowEst(Index*);\n    //void sqlite3RegisterLikeFunctions(sqlite3*, int);\n    //int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);\n    //void sqlite3MinimumFileFormat(Parse*, int, int);\n    //void sqlite3SchemaFree(void *);\n    //Schema *sqlite3SchemaGet(sqlite3 *, Btree *);\n    //int sqlite3SchemaToIndex(sqlite3 db, Schema *);\n    //KeyInfo *sqlite3IndexKeyinfo(Parse *, Index *);\n    //int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,\n    //  void (*)(sqlite3_context*,int,sqlite3_value **),\n    //  void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*));\n    //int sqlite3ApiExit(sqlite3 db, int);\n    //int sqlite3OpenTempDatabase(Parse *);\n\n    //void sqlite3StrAccumAppend(StrAccum*,const char*,int);\n    //char *sqlite3StrAccumFinish(StrAccum*);\n    //void sqlite3StrAccumReset(StrAccum*);\n    //void sqlite3SelectDestInit(SelectDest*,int,int);\n\n    //void sqlite3BackupRestart(sqlite3_backup *);\n    //void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);\n\n    /*\n    ** The interface to the LEMON-generated parser\n    */\n    //void *sqlite3ParserAlloc(void*(*)(size_t));\n    //void sqlite3ParserFree(void*, void(*)(void*));\n    //void sqlite3Parser(void*, int, Token, Parse*);\n#if YYTRACKMAXSTACKDEPTH\nint sqlite3ParserStackPeak(void*);\n#endif\n\n    //void sqlite3AutoLoadExtensions(sqlite3*);\n#if !SQLITE_OMIT_LOAD_EXTENSION\n    //void sqlite3CloseExtensions(sqlite3*);\n#else\n//# define sqlite3CloseExtensions(X)\n#endif\n\n#if !SQLITE_OMIT_SHARED_CACHE\n//void sqlite3TableLock(Parse *, int, int, u8, const char *);\n#else\n    //#define sqlite3TableLock(v,w,x,y,z)\n    static void sqlite3TableLock( Parse p, int p1, int p2, u8 p3, byte[] p4 ) { }\n    static void sqlite3TableLock( Parse p, int p1, int p2, u8 p3, string p4 ) { }\n#endif\n\n#if SQLITE_TEST\n    ///int sqlite3Utf8To8(unsigned char*);\n#endif\n\n#if SQLITE_OMIT_VIRTUALTABLE\n    //#  define sqlite3VtabClear(Y)\n    static void sqlite3VtabClear( Table Y ) { }\n\n    //#  define sqlite3VtabSync(X,Y) SQLITE_OK\n    static int sqlite3VtabSync( sqlite3 X, string Y ) { return SQLITE_OK; }\n\n    //#  define sqlite3VtabRollback(X)\n    static void sqlite3VtabRollback( sqlite3 X ) { }\n\n    //#  define sqlite3VtabCommit(X)\n    static void sqlite3VtabCommit( sqlite3 X ) { }\n\n    //#  define sqlite3VtabInSync(db) 0\n    //#  define sqlite3VtabLock(X) \n    static void sqlite3VtabLock( VTable X ) { }\n\n    //#  define sqlite3VtabUnlock(X)\n    static void sqlite3VtabUnlock( VTable X ) { }\n\n    //#  define sqlite3VtabUnlockList(X)\n    static void sqlite3VtabUnlockList( sqlite3 X ) { }\n\n    static void sqlite3VtabArgExtend( Parse p, Token t ) { }//#  define sqlite3VtabArgExtend(P, T)\n    static void sqlite3VtabArgInit( Parse p ) { }//#  define sqlite3VtabArgInit(P)\n    static void sqlite3VtabBeginParse( Parse p, Token t1, Token t2, Token t3 ) { }//#  define sqlite3VtabBeginParse(P, T, T1, T2)\n    static void sqlite3VtabFinishParse<T>( Parse P, T t ) { }//#  define sqlite3VtabFinishParse(P, T)\n    static bool sqlite3VtabInSync( sqlite3 db ) { return false; }\n\n    static VTable sqlite3GetVTable(sqlite3 db , Table T) {return null;}\n#else\n//void sqlite3VtabClear(Table*);\n//int sqlite3VtabSync(sqlite3 db, int rc);\n//int sqlite3VtabRollback(sqlite3 db);\n//int sqlite3VtabCommit(sqlite3 db);\n//void sqlite3VtabLock(VTable *);\n//void sqlite3VtabUnlock(VTable *);\n//void sqlite3VtabUnlockList(sqlite3*);\n//#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)\nstatic bool sqlite3VtabInSync( sqlite3 db ) { return ( db.nVTrans > 0 && db.aVTrans == 0 ); }\n#endif\n    //void sqlite3VtabMakeWritable(Parse*,Table*);\n    //void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*);\n    //void sqlite3VtabFinishParse(Parse*, Token*);\n    //void sqlite3VtabArgInit(Parse*);\n    //void sqlite3VtabArgExtend(Parse*, Token*);\n    //int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);\n    //int sqlite3VtabCallConnect(Parse*, Table*);\n    //int sqlite3VtabCallDestroy(sqlite3*, int, const char *);\n    //int sqlite3VtabBegin(sqlite3 *, VTable *);\n    //FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);\n    //void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**);\n    //int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);\n    //int sqlite3Reprepare(Vdbe*);\n    //void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);\n    //CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);\n    //int sqlite3TempInMemory(const sqlite3*);\n    //VTable *sqlite3GetVTable(sqlite3*, Table*);\n\n\n    /*\n    ** Available fault injectors.  Should be numbered beginning with 0.\n    */\n    const int SQLITE_FAULTINJECTOR_MALLOC = 0;//#define SQLITE_FAULTINJECTOR_MALLOC     0\n    const int SQLITE_FAULTINJECTOR_COUNT = 1;//#define SQLITE_FAULTINJECTOR_COUNT      1\n\n    /*\n    ** The interface to the code in fault.c used for identifying "benign"\n    ** malloc failures. This is only present if SQLITE_OMIT_BUILTIN_TEST\n    ** is not defined.\n    */\n#if !SQLITE_OMIT_BUILTIN_TEST\n    //void sqlite3BeginBenignMalloc(void);\n    //void sqlite3EndBenignMalloc(void);\n#else\n//#define sqlite3BeginBenignMalloc()\n//#define sqlite3EndBenignMalloc()\n#endif\n\n    const int IN_INDEX_ROWID = 1;//#define IN_INDEX_ROWID           1\n    const int IN_INDEX_EPH = 2;//#define IN_INDEX_EPH             2\n    const int IN_INDEX_INDEX = 3;//#define IN_INDEX_INDEX           3\n    //int sqlite3FindInIndex(Parse *, Expr *, int*);\n\n#if SQLITE_ENABLE_ATOMIC_WRITE\n//  int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);\n//  int sqlite3JournalSize(sqlite3_vfs *);\n//  int sqlite3JournalCreate(sqlite3_file *);\n#else\n    //#define sqlite3JournalSize(pVfs) ((pVfs)->szOsFile)\n    static int sqlite3JournalSize( sqlite3_vfs pVfs ) { return pVfs.szOsFile; }\n#endif\n\n    //void sqlite3MemJournalOpen(sqlite3_file *);\n    //int sqlite3MemJournalSize(void);\n    //int sqlite3IsMemJournal(sqlite3_file *);\n\n#if SQLITE_MAX_EXPR_DEPTH//>0\n    //  void sqlite3ExprSetHeight(Parse pParse, Expr p);\n    //  int sqlite3SelectExprHeight(Select *);\n    //int sqlite3ExprCheckHeight(Parse*, int);\n#else\n//#define sqlite3ExprSetHeight(x,y)\n//#define sqlite3SelectExprHeight(x) 0\n//#define sqlite3ExprCheckHeight(x,y)\n#endif\n\n    //u32 sqlite3Get4byte(const u8*);\n    //void sqlite3sqlite3Put4byte(u8*, u32);\n\n#if SQLITE_ENABLE_UNLOCK_NOTIFY\nvoid sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);\nvoid sqlite3ConnectionUnlocked(sqlite3 *db);\nvoid sqlite3ConnectionClosed(sqlite3 *db);\n#else\n    static void sqlite3ConnectionBlocked( sqlite3 x, sqlite3 y ) { } //#define sqlite3ConnectionBlocked(x,y)\n    static void sqlite3ConnectionUnlocked( sqlite3 x ) { }                   //#define sqlite3ConnectionUnlocked(x)\n    static void sqlite3ConnectionClosed( sqlite3 x ) { }                     //#define sqlite3ConnectionClosed(x)\n#endif\n\n#if SQLITE_DEBUG\n    //  void sqlite3ParserTrace(FILE*, char *);\n#endif\n\n    /*\n** If the SQLITE_ENABLE IOTRACE exists then the global variable\n** sqlite3IoTrace is a pointer to a printf-like routine used to\n** print I/O tracing messages.\n*/\n#if SQLITE_ENABLE_IOTRACE\nstatic bool SQLite3IoTrace = false;\n//#define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }\nstatic void IOTRACE( string X, params object[] ap ) { if ( SQLite3IoTrace ) { printf( X, ap ); } }\n\n//  void sqlite3VdbeIOTraceSql(Vdbe);\n//SQLITE_EXTERN void (*sqlite3IoTrace)(const char*,...);\n#else\n    //#define IOTRACE(A)\n    static void IOTRACE( string F, params object[] ap ) { }\n    //#define sqlite3VdbeIOTraceSql(X)\n    static void sqlite3VdbeIOTraceSql( Vdbe X ) { }\n#endif\n\n    //#endif\n  }\n}\n'