b'#\' dedupeMatches\n#\'\n#\' Dedupe matched dataframes.\n#\'\n#\' @usage dedupeMatches(matchesA, matchesB, EM,\n#\' matchesLink, patterns, linprog)\n#\' @param matchesA A dataframe of the matched observations in\n#\' dataset A, with all variables used to inform the match.\n#\' @param matchesB A dataframe of the matched observations in\n#\' dataset B, with all variables used to inform the match.\n#\' @param EM The EM object from \\code{emlinkMARmov()}\n#\' @param matchesLink The output from \\code{matchesLink()}\n#\' @param patterns The output from \\code{getPatterns()}.\n#\' @param linprog Whether to implement Winkler\'s linear programming solution to the deduplication\n#\' problem. Default is false.\n#\'\n#\' @return \\code{dedupeMatches()} returns a list containing the following elements:\n#\' \\item{matchesA}{A deduped version of matchesA}\n#\' \\item{matchesB}{A deduped version of matchesB}\n#\' \\item{EM}{A deduped version of the EM object}\n#\' \n#\' @author Ted Enamorado <ted.enamorado@gmail.com> and Ben Fifield <benfifield@gmail.com>\n#\' @export\n#\' @importFrom adagio assignment\n#\' @importFrom dplyr group_by summarise n "%>%"\n#\' @importFrom stringdist stringdist\n#\' @importFrom stats runif\ndedupeMatches <- function(matchesA, matchesB, EM, matchesLink,\n                          patterns, linprog = FALSE){\n\n    ## --------------\n    ## Start function\n    ## --------------\n    ## Convert to dataframe\n    if(any(class(matchesA) %in% c("tbl_df", "data.table"))){\n        matchesA <- as.data.frame(matchesA)\n    }\n    if(any(class(matchesB) %in% c("tbl_df", "data.table"))){\n        matchesB <- as.data.frame(matchesB)\n    }\n\n    ## Get original column names\n    colnames.df.a <- colnames(matchesA)\n    colnames.df.b <- colnames(matchesB)\n\n    ## Gammalist\n    gammalist <- patterns\n\n    ## -------------------------------\n    ## Convert EM object to data frame\n    ## -------------------------------\n    emdf <- as.data.frame(EM$patterns.w)\n    emdf$zeta.j <- c(EM$zeta.j)\n\n    ## ---------------------\n    ## Merge EM to gammalist\n    ## ---------------------\n    namevec <- names(patterns)\n    matchesA <- cbind(matchesA, gammalist)\n    matchesB <- cbind(matchesB, gammalist)\n    matchesA$roworder <- 1:nrow(matchesA)\n    matchesB$roworder <- 1:nrow(matchesB)\n    matchesA <- merge(matchesA, emdf, by = namevec, all.x = TRUE)\n    matchesB <- merge(matchesB, emdf, by = namevec, all.x = TRUE)\n    matchesA <- matchesA[order(matchesA$roworder),]\n    matchesB <- matchesB[order(matchesB$roworder),]\n\n    ## ------------\n    ## Start dedupe\n    ## ------------\n    ## Ids \n    matchesA$idA <- matchesLink$inds.a\n    matchesB$idB <- matchesLink$inds.b\n    matchesB$idA <- matchesA$idA\n    matchesA$idB <- matchesB$idB\n\n    ## Remove observations with NA for zeta.j\n    matchesA <- matchesA[!is.na(matchesA$zeta.j),]\n    matchesB <- matchesB[!is.na(matchesB$zeta.j),]\n\n    if(!linprog){\n\n        ## Step 1: Find max zeta for each observation in dataset A:\n        ## Merge in maximum zeta for each observation in dataset A\n        temp <- as.matrix(tapply(matchesA$zeta.j, matchesA$idA, max, na.rm = T))\t\t\t\n        temp <- data.frame(cbind(as.numeric(rownames(temp)), as.numeric(temp)))\n        names(temp) <- c("idA", "zeta.max")\n        matchesA <- merge(matchesA, temp, by = "idA")\n\n        ## Calculate difference\n        matchesA <- matchesA[order(matchesA$roworder), ]\t\t\t\n        matchesB <- matchesB[order(matchesB$roworder), ]\t\t\t\n        matchesA$rm <- abs(matchesA$zeta.j - matchesA$zeta.max)\n        rm <- which(matchesA$rm == 0)\n\n        ## Subset down to max zetas\n        matchesA <- matchesA[rm, ]\n        matchesB <- matchesB[rm, ]\n\n        ## Step 2: Find max zeta for each observation in dataset B, if in first subset:\n        ## Merge in maximum zeta for each observation in dataset B\n        temp <- as.matrix(tapply(matchesB$zeta.j, matchesB$idB, max, na.rm = T))\t\t\t\n        temp <- data.frame(cbind(as.numeric(rownames(temp)), as.numeric(temp)))\n        names(temp) <- c("idB", "zeta.max")\n        matchesB <- merge(matchesB, temp, by = "idB")\n\n        ## Calculate difference\n        matchesA <- matchesA[order(matchesA$roworder), ]\t\t\t\n        matchesB <- matchesB[order(matchesB$roworder), ]\t\t\t\n        matchesB$rm <- abs(matchesB$zeta.j - matchesB$zeta.max)\n        rm <- which(matchesB$rm == 0)\n\n        ## Subset down to max zetas\n        matchesA <- matchesA[rm, ]\n        matchesB <- matchesB[rm, ]\n\n        ## Step 3: Break remaining ties\n        ## Find remaining duplicates in A\n        d1 <- duplicated(matchesA$idA)\n        d2 <- duplicated(matchesA$idA, fromLast = T)\n        matchesA$dA <- ifelse((d1 + d2) > 0, 1, 0)\n        matchesB$dA <- ifelse((d1 + d2) > 0, 1, 0)\n\n        ## Draw uniform to break tie, and merge in \n        matchesA$uni <- runif(nrow(matchesA))\t\t\t\n        temp <- as.matrix(tapply(matchesA$uni, matchesA$idA, max, na.rm = T))\t\t\t\n        temp <- data.frame(cbind(as.numeric(rownames(temp)), as.numeric(temp)))\n        names(temp) <- c("idA", "uni.max")\n        matchesA <- merge(matchesA, temp, by = "idA")\n        matchesA <- matchesA[order(matchesA$roworder), ]\t\t\t\n        matchesB <- matchesB[order(matchesB$roworder), ]\t\t\t\n        matchesA$rm <- abs(matchesA$uni - matchesA$uni.max)\n        rm <- which(matchesA$rm == 0)\n\n        ## Subset down to broken tie\n        matchesA <- matchesA[rm, ]\n        matchesB <- matchesB[rm, ]\n        \n    }else{\n\n        ## Find duplicates\n        dupA <- duplicated(matchesA$idA)\n        dupB <- duplicated(matchesA$idA, fromLast = T)\n        matchesA$dupA <- ifelse(dupA == 1 | dupB == 1, 1, 0)\n\n        dupA <- duplicated(matchesB$idB)\n        dupB <- duplicated(matchesB$idB, fromLast = T)\n        matchesA$dupB <- ifelse(dupA == 1 | dupB == 1, 1, 0)\n\n        ## Split into dupes, not dups\n        dups <- subset(matchesA, dupA == 1 | dupB == 1)\n        nodups <- subset(matchesA, dupA == 0 & dupB == 0)\n\n        dups$idA.t <- as.numeric(as.factor(dups$idA))\n        dups$idB.t <- as.numeric(as.factor(dups$idB))\n\n        nr <- max(dups$idA.t)\n        nc <- max(dups$idB.t)\n        dim <- max(nr, nc)\n\n        ## Create adjacency matrix to id duplicates\n        mat.adj <- sparseMatrix(i = dups$idA.t, j = dups$idB.t, x = dups$zeta.j,\n                                dims = c(dim, dim))\n        mat.adj <- as.matrix(mat.adj)\n\n        ## Solve linear sum assignment problem\n        T1 <- suppressWarnings(assignment(-mat.adj))\n        temp.0 <- cbind(1:dim, T1$perm)\n        n1 <- which(rowSums(mat.adj) == 0)\n        n2 <- which(colSums(mat.adj) == 0)\n\n        if(length(n1) > 0) {\n            temp.0 <- temp.0[-n1, ]\n        }\n\n        if(length(n2) > 0) {\n            temp.0 <- temp.0[, -n2]\n        }\n\n        temp.0 <- data.frame(temp.0)\n        names(temp.0) <- c("idA.t", "idB.t")\n\n        ## Merge in dedupe information\n        dedup <- merge(temp.0, dups, by = c("idA.t", "idB.t"))\n        dedup$idA.t <- dedup$idB.t <- NULL\n\n        ## Combine dupes, dedupes\n        matchesA <- rbind(dedup, nodups)\n        matchesA$dupA <- matchesA$dupB <- NULL\t\n        listA <- paste(matchesA$idA, matchesA$idB, sep = "-")\n        listB <- paste(matchesB$idA, matchesB$idB, sep = "-")\n        keep <- which(listB %in% listA)\n        matchesB <- matchesB[keep, ]\n\n        ## Subset down and order\n        matchesA <- matchesA[order(matchesA$idA, matchesA$idB), ]\n        matchesB <- matchesB[order(matchesB$idA, matchesB$idB), ]\n\n    }\n\n    ## -----------------\n    ## Correct EM object\n    ## -----------------\n    counts <- eval(parse(\n        text = paste0("data.frame(matchesA %>% group_by(",\n                      paste(namevec, collapse = ", "),\n                      ") %>% summarise(counts = n()))"))\n        )\n    patterns <- as.data.frame(EM$patterns.w)\n    patterns$rownum <- 1:nrow(patterns)\n    patterns <- merge(patterns, counts, by = namevec, all.x = TRUE)\n    patterns$counts.x <- ifelse(!is.na(patterns$counts.y), patterns$counts.y,\n                                patterns$counts.x)\n    patterns <- patterns[order(patterns$rownum),]\n    patterns$counts.y <- NULL; patterns$rownum <- NULL\n    names(patterns) <- c(namevec, "counts", "weights", "p.gamma.j.m", "p.gamma.j.u")\n    EM$patterns.w <- as.matrix(patterns)\n\n    ## --------------------------\n    ## Correct matchesLink object\n    ## --------------------------\n    matchesLink <- data.frame(inds.a = matchesA$idA, inds.b = matchesB$idB)\n\n    ## -------------------\n    ## Get the zeta values\n    ## -------------------\n    max.zeta <- matchesA$zeta.j\n\n    ## --------------------------\n    ## Correct dataframes objects\n    ## --------------------------\n    matchesA <- subset(matchesA, select = colnames.df.a)\n    matchesB <- subset(matchesB, select = colnames.df.b)\n\n    ## Return deduped object\n    out <- list(matchesA = matchesA, matchesB = matchesB,\n                EM = EM, matchesLink = matchesLink,\n                max.zeta = max.zeta)\n    return(out)\n\n}\n\n'