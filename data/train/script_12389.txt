b'{-# OPTIONS_GHC -fno-warn-orphans #-}\nmodule Database.Beam.Migrate.Tool.Registry where\n\nimport           Database.Beam.Migrate\nimport           Database.Beam.Migrate.Backend\nimport           Database.Beam.Migrate.Serialization\nimport           Database.Beam.Migrate.Tool.CmdLine\n\nimport           Control.Applicative\nimport           Control.Exception\n\nimport qualified Crypto.Hash as Crypto\n\nimport           Data.Aeson\nimport           Data.Aeson.Types (Parser)\nimport qualified Data.ByteString.Char8 as BS\nimport           Data.Graph.Inductive.Graph\nimport           Data.Graph.Inductive.PatriciaTree\nimport qualified Data.HashMap.Strict as HM\nimport qualified Data.HashSet as HS\nimport           Data.LargeWord (Word256)\nimport           Data.List (find, intercalate, sort)\nimport           Data.Maybe\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Monoid\n#endif\nimport           Data.String\nimport           Data.Text (Text, unpack)\nimport qualified Data.Text as T\nimport           Data.Time\nimport           Data.UUID (UUID)\nimport qualified Data.UUID.V4 as UUID (nextRandom)\nimport qualified Data.Yaml as Yaml\n\nimport           Network.HostName\n\nimport           Numeric (showHex, readHex)\n\nimport           System.Directory\n#if defined(mingw32_HOST_OS)\nimport           System.Environment\n#endif\nimport           System.FilePath\nimport           System.IO\n\n#if !defined(mingw32_HOST_OS)\nimport           System.Posix.User\n#endif\n\nimport           Text.Read hiding (String)\n\ndata InvalidCommitId = InvalidCommitId T.Text\n  deriving Show\ninstance Exception InvalidCommitId\n\nnewtype MigrateUUID = MigrateUUID { unMigrateUUID :: UUID }\n\ndata BeamMigrateMode\n  = BeamMigrateReady\n  | BeamMigrateCreatingSchema !FilePath !(Maybe UUID) !Word256 -- ^ currently editing a schema, with SHA256 hash of file\n  | BeamMigrateEditingMigration !FilePath !UUID !UUID !Word256 -- ^ currently editing a migration, with SHA256 hash of file\n  deriving Show\n\ndata PredicateFetchSource\n  = PredicateFetchSourceCommit     !(Maybe ModuleName) !UUID\n  | PredicateFetchSourceDbHead     !MigrationDatabase !(Maybe Int)\n  | PredicateFetchSourceEmpty\n  deriving Show\n\ndata RegisteredSchemaInfo\n  = RegisteredSchemaInfo\n  { registeredSchemaInfoHash    :: UUID\n  , registeredSchemaInfoCommitter :: UserInfo\n  , registeredSchemaInfoMessage :: Text\n  , registeredSchemaInfoFormats :: [ MigrationFormat ]\n  } deriving Show\n\ndata RegisteredMigrationInfo\n  = RegisteredMigrationInfo\n  { registeredMigrationInfoResult :: UUID\n  , registeredMigrationInfoSource :: UUID\n  , registeredMigrationInfoFormats :: [ MigrationFormat ]\n  } deriving Show\n\ndata MigrationBranch\n  = MigrationBranch\n  { migrationBranchName   :: Text\n  , migrationBranchCommit :: UUID\n  } deriving Show\n\ndata UserInfo\n  = UserInfo\n  { userInfoFullName      :: Text\n  , userInfoEmail         :: Text\n  } deriving Show\n\ndata MigrationDatabase\n  = MigrationDatabase\n  { migrationDbBackend :: ModuleName\n  , migrationDbConnString :: String\n  } deriving Show\n\ndata MigrationHead\n  = MigrationHeadDetached UUID\n  | MigrationHeadBranch   Text\n  deriving (Show, Eq)\n\ndata MigrationRegistry\n  = MigrationRegistry\n  { migrationRegistryDatabases      :: HM.HashMap DatabaseName MigrationDatabase\n  , migrationRegistryHead           :: MigrationHead\n  , migrationRegistrySchemas        :: [ RegisteredSchemaInfo ]\n  , migrationRegistryMigrations     :: [ RegisteredMigrationInfo ]\n  , migrationRegistryBranches       :: [ MigrationBranch ]\n\n  , migrationRegistrySrcDir         :: FilePath\n  , migrationRegistrySchemaModule   :: ModuleName\n\n  , migrationRegistryUserInfo       :: Maybe UserInfo\n\n  , migrationRegistryMode           :: BeamMigrateMode\n  } deriving Show\n\ndata Schema\n  = Schema\n  { schemaPredicates :: [ (HS.HashSet PredicateSpecificity, SomeDatabasePredicate) ]\n  } deriving Show\n\ndata SchemaMetaData\n  = SchemaMetaData\n  { schemaMetaDataCommit    :: UUID\n  , schemaMetaDataFormats   :: [ MigrationFormat ]\n  , schemaMetaDataCreatedOn :: UTCTime\n  , schemaMetaDataSchema    :: Schema\n  } deriving Show\n\ninstance ToJSON SchemaMetaData where\n  toJSON (SchemaMetaData commit formats timestamp\' schema) =\n    object [ "commit"    .= commit\n           , "formats"   .= formats\n           , "createdOn" .= timestamp\'\n           , "schema"    .= schema ]\n-- instance FromJSON SchemaMetaData where\n--   parseJSON = withObject "SchemaMetaData" $ \\o ->\n--               SchemaMetaData <$> o .: "commit" <*> o .: "formats" <*> o .: "createdOn"\n--                              <*> o .: "schema"\n\ninstance ToJSON Schema where\n  toJSON (Schema predicates) =\n    let grouped = HM.fromListWith mappend (map (fmap pure) predicates)\n    in toJSON (map (\\(specificity, predicates\') ->\n                       object [ "specificity" .= specificity\n                              , "predicates" .= map (\\(SomeDatabasePredicate predicate) -> serializePredicate predicate) predicates\' ])\n                   (HM.toList grouped))\n-- instance FromJSON Schema where\n--   parseJSON = withArray "Schema" $ \\a ->\n--               foldlM (\\done -> withObject "Schema[]" $ \\o ->\n--                                do specificity <- o .: "specificity"\n--                                   predicates <- o .: "predicates"\n--                                   pure (map (specifity,) predicates ++ done))\n--                      [] a\n\ninstance ToJSON MigrationDatabase where\n  toJSON (MigrationDatabase backend connString) =\n    object [ "backend" .= backend, "uri" .= connString ]\ninstance FromJSON MigrationDatabase where\n  parseJSON = withObject "MigrationDatabase" $ \\o ->\n              MigrationDatabase <$> o .: "backend" <*> o .: "uri"\n\ninstance ToJSON MigrateUUID where\n  toJSON = toJSON . show . unMigrateUUID\ninstance FromJSON MigrateUUID where\n  parseJSON v = fmap readMaybe (parseJSON v) >>=\n                \\case\n                  Nothing -> fail "Could not read UUID"\n                  Just uuid -> pure (MigrateUUID uuid)\n\ninstance ToJSON MigrationHead where\n  toJSON (MigrationHeadDetached headId) = toJSON (MigrateUUID headId)\n  toJSON (MigrationHeadBranch branch) = toJSON ("ref/branch/" <> branch)\ninstance FromJSON MigrationHead where\n  parseJSON x = (MigrationHeadDetached . unMigrateUUID <$> parseJSON x) <|>\n                readRef x\n    where\n      readRef = withText "MigrationHead" $ \\ref ->\n                if "ref/branch/" `T.isPrefixOf` ref\n                  then pure (MigrationHeadBranch (T.drop (T.length "ref/branch/") ref))\n                  else fail "Cannot read head"\n\ninstance ToJSON BeamMigrateMode where\n  toJSON BeamMigrateReady = "ready"\n  toJSON (BeamMigrateCreatingSchema schemaFl src hash) =\n    object [ "tmpFile" .= schemaFl\n           , "src" .= src\n           , "hash" .= showHex hash "" ]\n  toJSON (BeamMigrateEditingMigration migrationFl from to hash) =\n    object [ "tmpFile" .= migrationFl\n           , "from" .= from, "to" .= to\n           , "hash" .= showHex hash "" ]\ninstance FromJSON BeamMigrateMode where\n  parseJSON "ready" = pure BeamMigrateReady\n  parseJSON o = withObject "BeamMigrateMode"\n                (\\v -> BeamMigrateCreatingSchema <$> v .: "tmpFile"\n                                                 <*> v .: "src"\n                                                 <*> (rdHash =<< v .: "hash") <|>\n                       BeamMigrateEditingMigration <$> v .: "tmpFile"\n                                                   <*> v .: "from" <*> v .: "to"\n                                                   <*> (rdHash =<< v .: "hash")) o\n    where\n      rdHash h = case filter (null . snd) (readHex h) of\n                   [(x, _)] -> pure x\n                   _ -> fail "Invalid hash"\n\ninstance ToJSON MigrationRegistry where\n  toJSON MigrationRegistry {..} =\n    object ( (case migrationRegistryMode of\n                BeamMigrateReady -> []\n                mode -> [ "mode" .= mode ]) ++\n             [ "databases"  .= migrationRegistryDatabases\n             , "head"       .= migrationRegistryHead\n             , "schemas"    .= migrationRegistrySchemas\n             , "migrations" .= migrationRegistryMigrations\n             , "branches"   .= migrationRegistryBranches\n             , "module"     .= object [ "src" .= migrationRegistrySrcDir, "name" .= migrationRegistrySchemaModule ] ] ++\n             case migrationRegistryUserInfo of\n               Nothing -> []\n               Just ui -> [ "user" .= ui ] )\n\ninstance FromJSON MigrationRegistry where\n  parseJSON = withObject "MigrationRegistry" $ \\o -> do\n    (srcDir, name) <- (o .: "module") >>= withObject "MigrationRegistry.module" (\\o\' -> (,) <$> o\' .: "src" <*> o\' .: "name")\n    MigrationRegistry <$> o .: "databases"\n                      <*> o .: "head"\n                      <*> fmap (fromMaybe []) (o .:? "schemas")\n                      <*> fmap (fromMaybe []) (o .:? "migrations")\n                      <*> o .: "branches"\n                      <*> pure srcDir <*> pure name\n                      <*> o .:? "user"\n                      <*> (fromMaybe BeamMigrateReady <$> o .:? "mode")\n\ninstance ToJSON UserInfo where\n  toJSON UserInfo {..} =\n    object [ "full-name" .= userInfoFullName\n           , "email"     .= userInfoEmail ]\ninstance FromJSON UserInfo where\n  parseJSON = withObject "UserInfo" $ \\o ->\n              UserInfo <$> o .: "full-name" <*> o .: "email"\n\ninstance ToJSON MigrationBranch where\n  toJSON MigrationBranch {..} =\n    object [ "name"   .= migrationBranchName\n           , "commit" .= MigrateUUID migrationBranchCommit ]\ninstance FromJSON MigrationBranch where\n  parseJSON = withObject "MigrationBranch" $ \\o ->\n              MigrationBranch <$> o .: "name" <*> (unMigrateUUID <$> o .: "commit")\n\ninstance ToJSON RegisteredSchemaInfo where\n  toJSON RegisteredSchemaInfo {..} =\n    object [ "hash"    .= MigrateUUID registeredSchemaInfoHash\n           , "message" .= registeredSchemaInfoMessage\n           , "formats" .= registeredSchemaInfoFormats\n           , "committer" .= registeredSchemaInfoCommitter ]\ninstance FromJSON RegisteredSchemaInfo where\n  parseJSON = withObject "RegisteredSchemaInfo" $ \\o ->\n              RegisteredSchemaInfo <$> (unMigrateUUID <$> o .: "hash")\n                                   <*> o .: "committer"\n                                   <*> o .: "message"\n                                   <*> o .: "formats"\n\ninstance ToJSON RegisteredMigrationInfo where\n  toJSON RegisteredMigrationInfo {..} =\n    object [ "result" .= registeredMigrationInfoResult\n           , "source" .= registeredMigrationInfoSource\n           , "formats" .= registeredMigrationInfoFormats ]\ninstance FromJSON RegisteredMigrationInfo where\n  parseJSON = withObject "RegisteredMigrationInfo" $ \\o ->\n              RegisteredMigrationInfo <$> o .: "result"\n                                      <*> o .: "source"\n                                      <*> o .: "formats"\n\ninstance ToJSON MigrationFormat where\n  toJSON MigrationFormatHaskell = "haskell"\n  toJSON (MigrationFormatBackend be) = fromString be\ninstance FromJSON MigrationFormat where\n  parseJSON "haskell" = pure MigrationFormatHaskell\n  parseJSON (String be) = pure (MigrationFormatBackend (unpack be))\n  parseJSON _ = fail "Cannot parse MigrationFormat"\n\nreportDdlErrors :: IO (Either DdlError a) -> IO a\nreportDdlErrors go = do\n  res <- go\n  case res of\n    Left err -> fail ("DDL error: " ++ show err)\n    Right  x -> pure x\n\nregisteredSchemaInfoShortMessage :: RegisteredSchemaInfo -> Text\nregisteredSchemaInfoShortMessage sch =\n  let fullMsg = registeredSchemaInfoMessage sch\n  in case T.lines fullMsg of\n       [] -> "(No message)"\n       x:_ -> x\n\n-- | Attempt to read a registry from the common lookup paths\n--\n--     1. If a registry is given on the command line, don\'t attempt lookup\n--     2. Otherwise, look for a @.beam-migrate@ file in this directory and each parent directory\nlookupRegistry\' :: MigrateCmdLine -> IO (FilePath, MigrationRegistry)\nlookupRegistry\' MigrateCmdLine { migrateRegistryPath = Just path } =\n  Yaml.decodeFileEither path >>= either (\\e -> fail ("Could not read migration registry: " ++ show e)) (pure . (path,))\nlookupRegistry\' cmdLine = getCurrentDirectory >>= lookupRegistry\'\'\n  where\n    lookupRegistry\'\' dir =\n      do let potentialRegistry = dir </> ".beam-migrate"\n         registryExists <- doesPathExist potentialRegistry\n\n         if registryExists\n           then lookupRegistry\' cmdLine { migrateRegistryPath = Just potentialRegistry }\n           else if isDrive dir\n                then fail "Could not find migration registry"\n                else lookupRegistry\'\' (takeDirectory dir)\n\nlookupRegistry :: MigrateCmdLine -> IO MigrationRegistry\nlookupRegistry = fmap snd . lookupRegistry\'\n\nlookupUserInfo :: MigrationRegistry -> IO UserInfo\nlookupUserInfo MigrationRegistry { migrationRegistryUserInfo = Just ui } = pure ui\nlookupUserInfo _ = do\n#if defined(mingw32_HOST_OS)\n  username <- getEnv "USERNAME"\n  let fullName = username\n#else\n  userId <- getEffectiveUserID\n  UserEntry { userName = username, userGecos = fullName } <- getUserEntryForID userId\n#endif\n  hostname <- getHostName\n\n  let email = username ++ "@" ++ hostname\n      userInfo = UserInfo { userInfoFullName = fromString fullName, userInfoEmail = fromString email }\n\n  hPutStrLn stderr ("WARNING: defaulting user info to " ++ show userInfo)\n  pure userInfo\n\nshowMigrationFormats :: [ MigrationFormat ] -> String\nshowMigrationFormats = intercalate ", ". map showFormat . sort\n  where\n    showFormat MigrationFormatHaskell = "Haskell"\n    showFormat (MigrationFormatBackend be) = be\n\nuserInfoCommitter :: UserInfo -> Text\nuserInfoCommitter ui = "\\"" <> userInfoEmail ui <> "\\"<" <> userInfoEmail ui <> ">"\n\nassertRegistryReady :: MigrationRegistry -> IO ()\nassertRegistryReady MigrationRegistry { migrationRegistryMode = BeamMigrateReady } = pure ()\nassertRegistryReady _ = fail "There is an edit in progress. Use \'beam-migrate abort\' to cancel"\n\nupdatingRegistry :: MigrateCmdLine -> (MigrationRegistry -> IO (a, MigrationRegistry)) -> IO a\nupdatingRegistry cmdLine action =\n  do (registryPath, registry) <- lookupRegistry\' cmdLine\n     (x, registry\') <- action registry\n     Yaml.encodeFile registryPath registry\'\n     pure x\n\nlookupDb :: MigrationRegistry -> MigrateCmdLine -> IO MigrationDatabase\nlookupDb MigrationRegistry { migrationRegistryDatabases = dbs } MigrateCmdLine { migrateDatabase = Nothing }\n  | HM.null dbs = fail "No databases in registry"\n  | [(dbName, db)] <- HM.toList dbs =\n    do hPutStrLn stderr ("WARNING: No database specified, defaulting to \'" ++ unDatabaseName dbName ++ "\'")\n       pure db\n  | otherwise = fail ("Please specify database with the --database option")\nlookupDb reg MigrateCmdLine { migrateDatabase = Just db } =\n  case HM.lookup db (migrationRegistryDatabases reg) of\n    Nothing -> fail ("No such database: " ++ unDatabaseName db)\n    Just db\' -> pure db\'\n\nlookupBranch :: MigrationRegistry -> Text -> Maybe MigrationBranch\nlookupBranch reg branchNm =\n  find ((==branchNm) . migrationBranchName) (migrationRegistryBranches reg)\n\nlookupSchema :: UUID -> [MigrationFormat] -> MigrationRegistry -> Maybe RegisteredSchemaInfo\nlookupSchema commitId fmts reg =\n  find (\\sch -> registeredSchemaInfoHash sch == commitId &&\n                all (`elem` registeredSchemaInfoFormats sch) fmts)\n       (migrationRegistrySchemas reg)\n\nlookupMigration :: UUID -> UUID -> [MigrationFormat] -> MigrationRegistry -> Maybe RegisteredMigrationInfo\nlookupMigration from dest fmts reg =\n  find (\\mig -> registeredMigrationInfoSource mig == from &&\n                registeredMigrationInfoResult mig == dest &&\n                all (`elem` registeredMigrationInfoFormats mig) fmts)\n       (migrationRegistryMigrations reg)\n\nnewBaseBranch :: Text -> UUID -> MigrationRegistry -> IO MigrationRegistry\nnewBaseBranch branchName commit reg =\n  case find ((==branchName) . migrationBranchName) (migrationRegistryBranches reg) of\n    Just {} -> fail "Branch already exists"\n    Nothing -> do\n      putStrLn ("Created new branch " ++ unpack branchName)\n      let branch = MigrationBranch branchName commit\n\n      pure reg { migrationRegistryBranches = branch:migrationRegistryBranches reg }\n\nupdateBranch :: Text -> MigrationBranch -> MigrationRegistry -> IO MigrationRegistry\nupdateBranch branchNm newBranch reg =\n  case lookupBranch reg branchNm of\n    Nothing -> fail ("Cannot update branch " ++ T.unpack branchNm)\n    Just {} ->\n      pure reg { migrationRegistryBranches =\n                   map (\\br -> if migrationBranchName br == branchNm\n                               then newBranch else br)\n                       (migrationRegistryBranches reg) }\n\nnewSchema :: UUID -> [MigrationFormat] -> Text -> MigrationRegistry -> IO MigrationRegistry\nnewSchema commitId fmts msg reg =\n  case lookupSchema commitId [] reg of\n    Just {} -> fail "Schema already exists"\n    Nothing -> do\n      userInfo <- lookupUserInfo reg\n      let schema = RegisteredSchemaInfo commitId userInfo msg fmts\n      pure reg { migrationRegistrySchemas = schema:migrationRegistrySchemas reg }\n\nnewMigration :: UUID -> UUID -> [MigrationFormat] -> MigrationRegistry -> IO MigrationRegistry\nnewMigration from dest fmts reg =\n  case lookupMigration from dest [] reg of\n    Just {} -> fail "Migration alread exists"\n    Nothing ->\n      let mig = RegisteredMigrationInfo from dest fmts\n      in pure reg { migrationRegistryMigrations = mig:migrationRegistryMigrations reg}\n\nuuidToFileName :: UUID -> String\nuuidToFileName = map (\\c -> if c == \'-\' then \'_\' else c) . show\n\nschemaScriptName, schemaModuleName :: UUID -> String\nschemaScriptName commitId =\n  "schema_" <> uuidToFileName commitId\nschemaModuleName commitId =\n  "Schema_" <> uuidToFileName commitId\n\nmigrationScriptName, migrationModuleName :: UUID -> UUID -> String\nmigrationScriptName fromId toId =\n  "migration_" <> uuidToFileName fromId <> "_to_" <> uuidToFileName toId\nmigrationModuleName fromId toId =\n  "Migration_" <> uuidToFileName fromId <> "_To_" <> uuidToFileName toId\n\nwriteSchemaFile :: MigrateCmdLine -> MigrationRegistry -> String -> String -> String -> IO FilePath\nwriteSchemaFile _ reg extension fileNm content = do\n  let path = migrationRegistrySrcDir reg </> (fileNm <.> extension)\n\n  putStrLn ("Writing schema to " ++ path ++ "...")\n  createDirectoryIfMissing True (migrationRegistrySrcDir reg)\n  writeFile path content\n\n  pure path\n\nschemaFilePath :: MigrationRegistry -> UUID -> FilePath\nschemaFilePath reg commitId =\n  migrationRegistrySrcDir reg </> schemaModuleName commitId <.> "hs"\n\nschemaFilePathForBackend :: Maybe SomeBeamMigrationBackend -> MigrationRegistry -> UUID -> FilePath\nschemaFilePathForBackend Nothing reg commit = schemaFilePath reg commit\nschemaFilePathForBackend (Just (SomeBeamMigrationBackend be)) reg commit =\n  migrationRegistrySrcDir reg </> schemaScriptName commit <.> backendFileExtension be\n\nregistryNewCommitId :: MigrationRegistry -> IO UUID\nregistryNewCommitId reg = do\n  newCommitId <- UUID.nextRandom\n  case lookupSchema newCommitId [] reg of\n    Just {} -> registryNewCommitId reg\n    Nothing -> pure newCommitId\n\nregistryHeadCommit :: MigrationRegistry -> UUID\nregistryHeadCommit reg =\n  case migrationRegistryHead reg of\n    MigrationHeadDetached commitId -> commitId\n    MigrationHeadBranch nm ->\n      case lookupBranch reg nm of\n        Nothing -> error "Cannot find branch"\n        Just branch -> migrationBranchCommit branch\n\n-- hashToUUID :: Hashable a => a -> UUID\n-- hashToUUID a =\n--   let intSize = finiteBitSize (undefined :: Int)\n--       wordsNeeded = (128 + intSize - 1) `div` intSize\n\n--       wordsData = take wordsNeeded (tail (iterate (\\seed -> hashWithSalt seed a) 0))\n\n--       uuidData :: Integer\n--       uuidData = foldr (\\w a\' -> a\' `shiftL` intSize .|. fromIntegral (fromIntegral w :: Word)) 0 wordsData\n\n--       uuidWord1 = fromIntegral $ (uuidData `shiftR` 96) .&. 0xFFFFFFFF\n--       uuidWord2 = fromIntegral $ (uuidData `shiftR` 64) .&. 0xFFFFFFFF\n--       uuidWord3 = fromIntegral $ (uuidData `shiftR` 32) .&. 0xFFFFFFFF\n--       uuidWord4 = fromIntegral $ uuidData .&. 0xFFFFFFFF\n\n--   in fromWords uuidWord1 uuidWord2 uuidWord3 uuidWord4\n\nmetadataComment :: String -> SchemaMetaData -> String\nmetadataComment commentMarker metadata =\n  let encoded = map BS.unpack (BS.lines (Yaml.encode metadata))\n  in unlines ( [commentMarker <> " + BEAM-MIGRATE"] <>\n               map ((commentMarker <> " + ") <>) encoded <>\n               [commentMarker <> " + END-BEAM-MIGRATE"])\n\nparseMetaData :: BeamDeserializers cmd -> Value -> Parser SchemaMetaData\nparseMetaData d =\n  withObject "SchemaMetaData" $ \\o ->\n  SchemaMetaData <$> o .: "commit" <*> o .: "formats" <*> o .: "createdOn"\n                 <*> (Schema <$> (parseSchema =<< o .: "schema"))\n  where\n    parseSchema =\n      fmap mconcat .\n      mapM (withObject "SchemaMetaData.schema" $ \\o ->\n            do specificity <- o .: "specificity"\n               predicates <- o .: "predicates"\n               -- TODO parse dummy if we can\'t parse\n               fmap (fmap (specificity,)) (mapM (beamDeserialize d) predicates))\n\npredsForBackend :: BeamMigrationBackend be m -> [ (HS.HashSet PredicateSpecificity, SomeDatabasePredicate) ]\n                -> [ SomeDatabasePredicate ]\npredsForBackend be = predsForBackendNamed (backendName be)\n\npredsForBackendNamed :: String -> [ (HS.HashSet PredicateSpecificity, SomeDatabasePredicate) ]\n                     -> [SomeDatabasePredicate]\npredsForBackendNamed be preds =\n  let ourSources = HS.fromList [ PredicateSpecificityAllBackends, PredicateSpecificityOnlyBackend be ]\n      applicablePreds = map snd (filter (not . HS.null . HS.intersection ourSources . fst) preds)\n  in applicablePreds\n\nwithMetadata, withoutMetadata :: (Eq a, IsString a) => [a] -> [a]\nwithMetadata =\n    takeWhile (/="-- + END-BEAM-MIGRATE") .\n    dropWhile (/="-- + BEAM-MIGRATE")\nwithoutMetadata =\n    takeWhile (/="-- + BEAM-MIGRATE")\n\nreadSchemaMetaData :: MigrationRegistry\n                   -> BeamMigrationBackend be m\n                   -> UUID\n                   -> IO SchemaMetaData\nreadSchemaMetaData reg BeamMigrationBackend { backendPredicateParsers = parsers } commitId = do\n  d <- withMetadata .\n       BS.lines <$>\n       BS.readFile (schemaFilePath reg commitId)\n  case d of\n    [] -> fail "Invalid data in schema"\n    _:d\' | Just realData <- BS.unlines <$> traverse (BS.stripPrefix "-- + ") d\'\n         , Right metadataV <- Yaml.decodeEither\' realData\n         -> case Yaml.parseEither (parseMetaData parsers) metadataV of\n             Left err -> fail ("Could not parse metadata: " ++ show err)\n             Right metadata -> pure metadata\n         | otherwise -> fail "Invalid data in schema"\n\npredicateFetchSourceBackend :: PredicateFetchSource -> Maybe ModuleName\npredicateFetchSourceBackend (PredicateFetchSourceCommit be _) = be\npredicateFetchSourceBackend (PredicateFetchSourceDbHead (MigrationDatabase be _) _) = Just be\npredicateFetchSourceBackend PredicateFetchSourceEmpty = Nothing\n\npredicateSourceWithBackend :: ModuleName -> PredicateFetchSource -> PredicateFetchSource\npredicateSourceWithBackend nm (PredicateFetchSourceCommit _ c) = PredicateFetchSourceCommit (Just nm) c\npredicateSourceWithBackend nm (PredicateFetchSourceDbHead (MigrationDatabase _ conn) ref) =\n  PredicateFetchSourceDbHead (MigrationDatabase nm conn) ref\npredicateSourceWithBackend _ PredicateFetchSourceEmpty = PredicateFetchSourceEmpty\n\nparsePredicateFetchSourceSpec :: MigrateCmdLine -> MigrationRegistry -> Text\n                              -> IO PredicateFetchSource\nparsePredicateFetchSourceSpec cmdLine reg t\n  | t == "0" = pure PredicateFetchSourceEmpty\n  | Just t\' <- T.stripPrefix "HEAD" t =\n      let mod\' = parsePredicateFetchSourceModulePart t\'\n      in pure (PredicateFetchSourceCommit mod\' (registryHeadCommit reg))\n  | Just t\' <- T.stripPrefix "DB" t = do\n      let (t\'\', db) = parsePredicateFetchSourceDbName t\'\n          ref = parsePredicateFetchSourceDbRef t\'\'\n      db\' <-\n        case db of\n          Nothing ->\n            case migrateDatabase cmdLine of\n              Nothing -> fail "Ambiguous database: DB given with no -d option or database specified"\n              Just cmdLineDb -> pure cmdLineDb\n          Just explicitDb -> pure explicitDb\n\n      dbInfo <- lookupDb reg cmdLine { migrateDatabase = Just db\' }\n\n      pure (PredicateFetchSourceDbHead dbInfo ref)\n  | Just branchNm <- T.stripPrefix "branch/" t = do\n      let (branchNm\', dbModNm) = T.breakOn "/" branchNm\n      case lookupBranch reg branchNm\' of\n        Nothing -> fail ("No such branch: " ++ T.unpack branchNm\')\n        Just branch -> do\n          let dbMod = if dbModNm == "" then Nothing else Just (ModuleName (T.unpack dbModNm))\n          pure (PredicateFetchSourceCommit dbMod (migrationBranchCommit branch))\n  | (commitIdTxt, dbModNm) <- T.breakOn "/" t\n  , Just commitId <- readMaybe (T.unpack commitIdTxt) = do\n      let dbMod = if T.null dbModNm then Nothing else Just (ModuleName (T.unpack (T.tail dbModNm)))\n      pure (PredicateFetchSourceCommit dbMod commitId)\n  | (t\', rest) <- T.break (\\c -> c == \'/\' || c == \'!\') t\n  , Just dbInfo <- HM.lookup (DatabaseName (T.unpack t\')) (migrationRegistryDatabases reg) =\n      pure (PredicateFetchSourceDbHead dbInfo (parsePredicateFetchSourceDbRef rest))\n  | otherwise = fail "Invalid predicate source spec"\n\n  where\n    parsePredicateFetchSourceModulePart t\'\n      | Just mod\' <- T.stripPrefix "/" t\' = Just (ModuleName (T.unpack mod\'))\n      | otherwise = Nothing\n    parsePredicateFetchSourceDbName t\'\n      | Just dbName <- T.stripPrefix "/" t\' =\n          let (dbName\', t\'\') = T.break (\\c -> c == \'/\' || c == \'!\') dbName\n          in (t\'\', Just (DatabaseName (T.unpack dbName\')))\n      | otherwise = (t\', Nothing)\n    parsePredicateFetchSourceDbRef "!" = Nothing\n    parsePredicateFetchSourceDbRef "" = Just 0\n    parsePredicateFetchSourceDbRef dbRef\n      | (dbRef\', "") <- T.span (==\'^\') dbRef =\n          Just (T.length dbRef\')\n      | otherwise = error "Invalid dbref"\n\nregistryMigrationGraph :: MigrationRegistry -> Gr RegisteredSchemaInfo RegisteredMigrationInfo\nregistryMigrationGraph reg =\n  let schemaIdxs = zip [0..] (migrationRegistrySchemas reg)\n      schemaIdToIdxMap = HM.fromList (map (\\(i, schema) -> (registeredSchemaInfoHash schema, i)) schemaIdxs)\n      schemaIdToIdx = flip HM.lookup schemaIdToIdxMap\n\n      migrations = mapMaybe (\\mig -> (,,mig) <$> schemaIdToIdx (registeredMigrationInfoSource mig)\n                                             <*> schemaIdToIdx (registeredMigrationInfoResult mig))\n                            (migrationRegistryMigrations reg)\n\n  in mkGraph schemaIdxs migrations\n\nsha256\' :: BS.ByteString -> Word256\nsha256\' d = let digest :: Crypto.Digest Crypto.SHA256\n                digest = Crypto.hash d\n            in case filter (null . snd) (readHex (show digest)) of\n                 [(x, _)] -> x\n                 _ -> error "Can\'t parse digest"\n\nsha256 :: String -> Word256\nsha256 = sha256\' . BS.pack\n\nabortEdits :: MigrateCmdLine -> Bool -> IO ()\nabortEdits cmdLine force =\n  updatingRegistry cmdLine (abortEdits\' force)\n\nabortEdits\' :: Bool -> MigrationRegistry -> IO ((), MigrationRegistry)\nabortEdits\' force reg =\n  let reg\' = reg { migrationRegistryMode = BeamMigrateReady }\n\n      tryAbort flNm flHash = do\n        flExists <- doesFileExist flNm\n        if flExists\n          then do\n            doDelete <- if force\n                        then pure True\n                        else do\n                          flContents <- BS.readFile flNm\n                          let actualHash = sha256\' flContents\n                          return (actualHash == flHash)\n\n            if doDelete\n              then do\n                removeFile flNm\n                pure ((), reg\')\n              else fail "WARNING: the editing files have been modified use \'--force\' to force abort"\n          else pure ((), reg\')\n  in case migrationRegistryMode reg of\n       BeamMigrateReady -> pure ((), reg)\n       BeamMigrateEditingMigration tmpFile _ _ hash -> tryAbort tmpFile hash\n       BeamMigrateCreatingSchema tmpFile _ hash -> tryAbort tmpFile hash\n'