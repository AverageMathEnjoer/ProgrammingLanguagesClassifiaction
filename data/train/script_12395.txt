b'\xef\xbb\xbf// Chapter 14 covers SVD (Singular Value Decomposition)\n\n#r @"..\\..\\MachineLearningInAction\\packages\\MathNet.Numerics.2.5.0\\lib\\net40\\MathNet.Numerics.dll"\n#r @"..\\..\\MachineLearningInAction\\packages\\MathNet.Numerics.FSharp.2.5.0\\lib\\net40\\MathNet.Numerics.FSharp.dll"\n\nopen MathNet.Numerics.LinearAlgebra\nopen MathNet.Numerics.LinearAlgebra.Double\nopen MathNet.Numerics.Statistics\n\ntype Rating = { UserId: int; DishId: int; Rating: int }\n\n// Our existing "ratings database"\nlet ratings = [\n    { UserId = 0; DishId = 0; Rating = 2 };\n    { UserId = 0; DishId = 3; Rating = 4 };\n    { UserId = 0; DishId = 4; Rating = 4 };\n    { UserId = 1; DishId = 10; Rating = 5 };\n    { UserId = 2; DishId = 7; Rating = 1 };\n    { UserId = 2; DishId = 0; Rating = 4 };\n    { UserId = 3; DishId = 0; Rating = 3 };\n    { UserId = 3; DishId = 1; Rating = 3 };\n    { UserId = 3; DishId = 2; Rating = 4 };\n    { UserId = 3; DishId = 4; Rating = 3 };\n    { UserId = 3; DishId = 7; Rating = 2 };\n    { UserId = 3; DishId = 8; Rating = 2 };\n    { UserId = 4; DishId = 0; Rating = 5 };\n    { UserId = 4; DishId = 1; Rating = 5 };\n    { UserId = 4; DishId = 2; Rating = 5 };\n    { UserId = 5; DishId = 6; Rating = 5 };\n    { UserId = 5; DishId = 9; Rating = 5 };\n    { UserId = 6; DishId = 0; Rating = 4 };\n    { UserId = 6; DishId = 2; Rating = 4 };\n    { UserId = 6; DishId = 10; Rating = 5 };\n    { UserId = 7; DishId = 5; Rating = 4 };\n    { UserId = 7; DishId = 10; Rating = 4 };\n    { UserId = 8; DishId = 6; Rating = 5 };\n    { UserId = 9; DishId = 3; Rating = 3 };\n    { UserId = 9; DishId = 8; Rating = 4 };\n    { UserId = 9; DishId = 9; Rating = 5 };\n    { UserId = 10; DishId = 0; Rating = 1 };\n    { UserId = 10; DishId = 1; Rating = 1 };\n    { UserId = 10; DishId = 2; Rating = 2 };\n    { UserId = 10; DishId = 3; Rating = 1 };\n    { UserId = 10; DishId = 4; Rating = 1 };\n    { UserId = 10; DishId = 5; Rating = 2 };\n    { UserId = 10; DishId = 6; Rating = 1 };\n    { UserId = 10; DishId = 8; Rating = 4 };\n    { UserId = 10; DishId = 9; Rating = 5 } ]\n\n// Let\'s populate a matrix with these ratings;\n// unrated items are denoted by a 0\n\nlet rows = 11\nlet cols = 11\nlet data = DenseMatrix(rows, cols)\nratings \n|> List.iter (fun rating -> \n       data.[rating.UserId, rating.DishId] <- (float)rating.Rating)\n\n// "Pretty" rendering of a matrix\n// something is not 100% right here, but it\'s good enough\nlet printNumber v = \n    if v < 0. \n    then printf "%.2f " v \n    else printf " %.2f " v\n// Display a Matrix in a "pretty" format\nlet pretty matrix = \n    Matrix.iteri (fun row col value ->\n        if col = 0 then printfn "" else ignore ()\n        printNumber value) matrix\n    printfn ""\n\nprintfn "Original data matrix"\npretty data\n\n// Now let\'s run a SVD on that matrix\nlet svd = data.Svd(true)\nlet U, sigmas, Vt = svd.U(), svd.S(), svd.VT()\n\n// recompose the S matrix from the singular values\nprintfn "S-matrix, with singular values in diagonal"\nlet S = DiagonalMatrix(rows, cols, sigmas.ToArray())\npretty S\n\n// The SVD decomposition verifies\n// data = U x S x Vt\n\nprintfn "Reconstructed matrix from SVD decomposition"\nlet reconstructed = U * S * Vt\npretty reconstructed\n\n// Can we interpret the SVD decomposition? Let\'s see.\n\n// Each row maps to a User, \n// each column to an extracted Category\nlet userToCategory = U * S |> pretty\n\n// Each row maps to an extracted Category, \n// each column to a Dish\nlet categoryToDish = S * Vt |> pretty\n\n// We can use SVD as a data compression mechanism\n// by retaining only the n first singular values\n\n// Total energy is the sum of the squares \n// of the singular values\nlet totalEnergy = sigmas.DotProduct(sigmas)\n// Let\'s compute how much energy is contributed\n// by each singular value\nprintfn "Energy contribution by Singular Value"\nsigmas.ToArray() \n|> Array.fold (fun acc x ->\n       let energy = x * x\n       let percent = (acc + energy)/totalEnergy\n       printfn "Energy: %.1f, Percent of total: %.3f" energy percent\n       acc + energy) 0. \n|> ignore\n\n// We\'ll retain only the first 5 singular values,\n// which cover 90% of the total energy\nlet subset = 5\nlet U\' = U.SubMatrix(0, U.RowCount, 0, subset)\nlet S\' = S.SubMatrix(0, subset, 0, subset)\nlet Vt\' = Vt.SubMatrix(0, subset, 0, Vt.ColumnCount)\n\n// Using U\', S\', Vt\' instead of U, S, Vt\n// should produce a "decent" approximation\n// of the original matrix\n\nprintfn "Approximation of the original matrix"\nU\' * S\' * Vt\' |> pretty'