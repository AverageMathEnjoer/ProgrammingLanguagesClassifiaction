b'{-# LANGUAGE\n    CPP\n  , DeriveDataTypeable\n  , FlexibleInstances\n  , ScopedTypeVariables\n  #-}\n\n#include "overlapping-compat.h"\n\nmodule Rest.StringMap.Map.Lazy\n  ( StringMap\n  , fromMap\n  , toMap\n  , toList\n  , fromList\n  ) where\n\nimport Data.Aeson\nimport Data.JSON.Schema\nimport Data.Map (Map)\nimport Data.String\nimport Data.String.ToString\nimport Data.Typeable\nimport Text.XML.HXT.Arrow.Pickle\nimport qualified Data.Map as M\n\nimport Rest.StringMap.Util\n\nnewtype StringMap a b = StringMap { unM :: Map a b }\n  deriving (Eq, Show, Typeable)\n\nfromMap :: Map a b -> StringMap a b\nfromMap = StringMap\n\ntoMap :: StringMap a b -> Map a b\ntoMap = unM\n\nfromList :: Ord a => [(a,b)] -> StringMap a b\nfromList = StringMap . M.fromList\n\ntoList :: StringMap a b -> [(a, b)]\ntoList = M.toList . unM\n\nmapKeys :: Ord l => (k -> l) -> StringMap k v -> StringMap l v\nmapKeys f = StringMap . M.mapKeys f . unM\n\ninstance XmlPickler b => XmlPickler (StringMap String b) where\n  xpickle = pickleStringMap fromList toList\n\ninstance OVERLAPPABLE_ (Ord a, IsString a, ToString a, XmlPickler b) => XmlPickler (StringMap a b) where\n  xpickle = pickleMap mapKeys mapKeys\n\ninstance (ToString a, ToJSON b) => ToJSON (StringMap a b) where\n  toJSON = toJSON . M.mapKeys toString . toMap\n\ninstance (Ord a, IsString a, FromJSON b) => FromJSON (StringMap a b) where\n  parseJSON = fmap (StringMap . M.mapKeys fromString) . parseJSON\n\ninstance JSONSchema b => JSONSchema (StringMap a b) where\n  schema _ = mapSchema (Proxy :: Proxy b)\n'