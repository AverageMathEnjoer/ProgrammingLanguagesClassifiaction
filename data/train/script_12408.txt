b'\n-- | Font info contains information, extracted from font,\n-- that may be needed when processing content stream\n\nmodule Pdf.Content.FontInfo\n(\n  FontInfo(..),\n  FISimple(..),\n  FontBaseEncoding(..),\n  SimpleFontEncoding(..),\n  FIComposite(..),\n  CIDFontWidths(..),\n  makeCIDFontWidths,\n  cidFontGetWidth,\n  fontInfoDecodeGlyphs\n)\nwhere\n\nimport Pdf.Core\nimport Pdf.Core.Util\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Types\n\nimport Pdf.Content.UnicodeCMap\nimport Pdf.Content.Transform\nimport Pdf.Content.Processor (Glyph(..))\nimport Pdf.Content.GlyphList\nimport Pdf.Content.TexGlyphList\nimport Pdf.Content.FontDescriptor\nimport qualified Pdf.Content.Encoding.WinAnsi as WinAnsi\nimport qualified Pdf.Content.Encoding.MacRoman as MacRoman\n\nimport Data.List\nimport Data.Maybe\nimport Data.Word\nimport Data.Map (Map)\nimport qualified Data.Map as Map\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport Data.Text (Text)\nimport qualified Data.Text as Text\nimport qualified Data.Text.Encoding as Text\nimport qualified Data.Vector as Vector\nimport Control.Monad\n\n-- | Font info\ndata FontInfo\n  = FontInfoSimple FISimple\n  | FontInfoComposite FIComposite\n  deriving (Show)\n\n-- | Font info for simple fonts\ndata FISimple = FISimple {\n  fiSimpleUnicodeCMap :: Maybe UnicodeCMap,\n  fiSimpleEncoding :: Maybe SimpleFontEncoding,\n  fiSimpleWidths :: Maybe (Int, Int, [Double]),\n  -- ^ FirstChar, LastChar, list of widths\n  fiSimpleFontMatrix :: Transform Double,\n  -- FIXME: no Maybe as soon as this library provides metrics for the\n  -- 14 standard fonts\n  fiSimpleFontDescriptor :: Maybe FontDescriptor\n  }\n  deriving (Show)\n\n-- | Standard encoding, other encodings are based on them\ndata FontBaseEncoding\n  = FontBaseEncodingWinAnsi\n  | FontBaseEncodingMacRoman\n  deriving (Show)\n\n-- | Encoding fo simple font\ndata SimpleFontEncoding = SimpleFontEncoding {\n  simpleFontBaseEncoding :: FontBaseEncoding,\n  -- | Mapping from glyph code to glyph name for cases when it is different\n  -- from base encoding\n  simpleFontDifferences :: [(Word8, ByteString)]\n  }\n  deriving (Show)\n\n-- | Font info for Type0 font\ndata FIComposite = FIComposite {\n  fiCompositeUnicodeCMap :: Maybe UnicodeCMap,\n  fiCompositeWidths :: CIDFontWidths,\n  fiCompositeDefaultWidth :: Double,\n  -- FontDescriptor is present in CIDFonts, but according to specs\n  -- shall not be used with Type0 fonts\n  fiCompositeFontDescriptor :: Maybe FontDescriptor\n  }\n  deriving (Show)\n\n-- | Glyph widths for CID fonts\ndata CIDFontWidths = CIDFontWidths {\n  cidFontWidthsChars :: Map Int Double,\n  cidFontWidthsRanges :: [(Int, Int, Double)]\n  }\n  deriving (Show)\n\ninstance Monoid CIDFontWidths where\n  mempty = CIDFontWidths {\n    cidFontWidthsChars = mempty,\n    cidFontWidthsRanges = mempty\n    }\n  mappend = (<>)\n\ninstance Semigroup CIDFontWidths where\n  w1 <> w2 = CIDFontWidths {\n    cidFontWidthsChars = cidFontWidthsChars w1\n        <> cidFontWidthsChars w2,\n    cidFontWidthsRanges = cidFontWidthsRanges w1\n        <> cidFontWidthsRanges w2\n    }\n\n-- | Returns the Y coordinates for a bbox of a glyph of a font, in\n-- text space units. Defaults to (0,1) if no FontDescriptor is\n-- present.\n--\n-- Maybe for vertical scripts, there are individual heights for the\n-- glyphs, so this takes a glyph code as second argument.\ngetGlyphYCoordinates :: FontInfo -> Int -> (Double, Double)\ngetGlyphYCoordinates (FontInfoComposite fi) =\n  const $ fromMaybe (0,1) $ join $ fmap (fdYCoordinates 1000) $ fiCompositeFontDescriptor fi\ngetGlyphYCoordinates (FontInfoSimple fi) =\n  const $ fromMaybe (0,1) $ join $ fmap (fdYCoordinates 1000) $ fiSimpleFontDescriptor fi\n\nfdYCoordinates :: Double -> FontDescriptor -> Maybe (Double, Double)\nfdYCoordinates scaling fd =\n  maybe cap Just $          -- third: try CapHeight\n  maybe descAsc Just $      -- second: try Descent and Ascent\n  fmap bbox $ fdFontBBox fd -- first: try FontBBox\n  where\n    bbox (Rectangle _ b _ t) = (b / scaling, t / scaling)\n    descAsc = (,) <$> (fmap (/scaling) $ fdDescent fd) <*> (fmap (/scaling) $ fdAscent fd)\n    cap = (,) <$> (Just 0.0) <*> (fmap (/scaling) $ fdCapHeight fd)\n\nsimpleFontEncodingDecode :: SimpleFontEncoding -> Word8 -> Maybe Text\nsimpleFontEncodingDecode enc code =\n  case lookup code (simpleFontDifferences enc) of\n    Nothing ->\n      case simpleFontBaseEncoding enc of\n        FontBaseEncodingWinAnsi -> Map.lookup code WinAnsi.encoding\n        FontBaseEncodingMacRoman -> Map.lookup code MacRoman.encoding\n    Just glyphName ->\n      case Map.lookup glyphName adobeGlyphList of\n        Just c -> Just $ Text.pack [c]\n        Nothing ->\n          case Map.lookup glyphName texGlyphList of\n            Nothing-> Nothing\n            Just c -> Just $ Text.pack [c]\n\n-- | Make `CIDFontWidths` from value of \\"W\\" key in descendant font\nmakeCIDFontWidths :: Array -> Either String CIDFontWidths\nmakeCIDFontWidths vals = go mempty (Vector.toList vals)\n  `notice` ("Can\'t parse CIDFont width " ++ show vals)\n  where\n  go res [] = return res\n  go res (x1@Number{} : x2@Number{} : x3@Number{} : xs) = do\n    n1 <- intValue x1\n    n2 <- intValue x2\n    n3 <- realValue x3\n    go res {cidFontWidthsRanges = (n1, n2, n3) : cidFontWidthsRanges res} xs\n  go res (x : Array arr : xs) = do\n    n <- intValue x\n    ws <- forM (Vector.toList arr) realValue\n    go res {cidFontWidthsChars = Map.fromList (zip [n ..] ws)\n        `mappend` cidFontWidthsChars res} xs\n  go _ _ = Nothing\n\n-- | Get glyph width by glyph code\ncidFontGetWidth :: CIDFontWidths -> Int -> Maybe Double\ncidFontGetWidth w code =\n  case Map.lookup code (cidFontWidthsChars w) of\n    Just width -> Just width\n    Nothing -> case find (\\(start, end, _) -> code >= start && code <= end)\n                         (cidFontWidthsRanges w) of\n                 Just (_, _, width) -> Just width\n                 _ -> Nothing\n\n-- | Decode string into list of glyphs and their widths\nfontInfoDecodeGlyphs :: FontInfo -> ByteString -> [(Glyph, Double)]\nfontInfoDecodeGlyphs fInfo@(FontInfoSimple fi) = \\bs ->\n  flip map (BS.unpack bs) $ \\c ->\n    let code = fromIntegral c\n        txt =\n          case fiSimpleUnicodeCMap fi of\n            Nothing ->\n              case fiSimpleEncoding fi of\n                Nothing ->\n                  case Text.decodeUtf8\' (BS.pack [c]) of\n                    Right t -> Just t\n                    _ -> Nothing\n                Just enc ->\n                  case simpleFontEncodingDecode enc c of\n                    Just t -> Just t\n                    Nothing ->\n                      case Text.decodeUtf8\' (BS.pack [c]) of\n                        Right t -> Just t\n                        _ -> Nothing\n            Just toUnicode ->\n              case unicodeCMapDecodeGlyph toUnicode code of\n                Just t -> Just t\n                Nothing ->\n                  case fiSimpleEncoding fi of\n                    Nothing -> Nothing\n                    Just enc ->\n                      case simpleFontEncodingDecode enc c of\n                        Just t -> Just t\n                        Nothing ->\n                          case Text.decodeUtf8\' (BS.pack [c]) of\n                            Right t -> Just t\n                            _ -> Nothing\n        width =\n          case fiSimpleWidths fi of\n            Nothing -> 0\n            Just (firstChar, lastChar, widths) ->\n              if code >= firstChar && code <= lastChar\n                  && (code - firstChar) < length widths\n                 then let Vector w _ = transform (fiSimpleFontMatrix fi) $\n                            Vector (widths !! (code - firstChar)) 0\n                      in w\n                 else 0\n        (yBottom, yTop) = getGlyphYCoordinates fInfo code\n    in (Glyph {\n      glyphCode = code,\n      glyphTopLeft = Vector 0 yBottom,\n      glyphBottomRight = Vector width yTop,\n      glyphText = txt\n      }, width)\nfontInfoDecodeGlyphs fInfo@(FontInfoComposite fi) = \\bs ->\n  case fiCompositeUnicodeCMap fi of\n    Nothing ->  -- XXX: use encoding here\n      tryDecode2byte $ BS.unpack bs\n    Just toUnicode ->\n      let getWidth = fromMaybe (fiCompositeDefaultWidth fi)\n                   . cidFontGetWidth (fiCompositeWidths fi)\n      in cmapDecodeString getWidth toUnicode fInfo bs\n  where\n  -- Most of the time composite fonts have 2-byte encoding,\n  -- so lets try that for now.\n  tryDecode2byte (b1:b2:rest) =\n    let code = fromIntegral b1 * 255 + fromIntegral b2\n        width = (/ 1000) $ fromMaybe (fiCompositeDefaultWidth fi)\n                         $ cidFontGetWidth (fiCompositeWidths fi) code\n        txt =\n          case Text.decodeUtf8\' (BS.pack [b1, b2]) of\n            Right t -> Just t\n            _ -> Nothing\n        (yBottom, yTop) = getGlyphYCoordinates fInfo code\n        g = Glyph {\n          glyphCode = code,\n          glyphTopLeft = Vector 0 yBottom,\n          glyphBottomRight = Vector width yTop,\n          glyphText = txt\n          }\n    in (g, width) : tryDecode2byte rest\n  tryDecode2byte _ = []\n\ncmapDecodeString\n  :: (Int -> Double)\n  -> UnicodeCMap\n  -> FontInfo\n  -> ByteString\n  -> [(Glyph, Double)]\ncmapDecodeString getWidth cmap fInfo str = go str\n  where\n  go s =\n    case unicodeCMapNextGlyph cmap s of\n      Nothing -> []\n      Just (g, rest) ->\n        let width = getWidth g / 1000\n            (yBottom, yTop) = getGlyphYCoordinates fInfo g\n            glyph = Glyph {\n          glyphCode = g,\n          glyphTopLeft = Vector 0 yBottom,\n          glyphBottomRight = Vector width yTop,\n          glyphText = unicodeCMapDecodeGlyph cmap g\n          }\n        in (glyph, width) : go rest\n'