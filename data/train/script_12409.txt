b'#include <riru.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <logging.h>\n#include <config.h>\n#include <socket.h>\n#include <unistd.h>\n#include <malloc.h>\n#include <vector>\n#include <string>\n#include <dirent.h>\n#include "rirud.h"\n#include "module.h"\n#include "finally.h"\n\nbool RirudSocket::Write(std::string_view str) const {\n    auto count = str.size();\n    const auto *buf = str.data();\n    return Write<uint32_t>(str.size()) && Write(buf, count);\n}\n\nbool RirudSocket::Read(std::string &str) const {\n    uint32_t size;\n    if (!Read(size) || size < 0) return false;\n    str.resize(size);\n    return Read(str.data(), size);\n}\n\n\nRirudSocket::RirudSocket(unsigned retries) {\n    if ((fd_ = socket(PF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) < 0) {\n        return;\n    }\n\n    struct sockaddr_un addr{\n            .sun_family = AF_UNIX,\n            .sun_path={0}\n    };\n    strncpy(addr.sun_path + 1, RIRUD.data(), RIRUD.size());\n    socklen_t socklen = sizeof(sa_family_t) + strlen(addr.sun_path + 1) + 1;\n\n    while (retries-- > 0) {\n        if (connect(fd_, reinterpret_cast<struct sockaddr *>(&addr), socklen) != -1) return;\n        LOGW("retrying to connect rirud in 1s");\n        sleep(1);\n    }\n    close(fd_);\n    fd_ = -1;\n}\n\nRirudSocket::~RirudSocket() {\n    if (fd_ != -1) {\n        close(fd_);\n    }\n}\n\nvoid RirudSocket::DirIter::ContinueRead() {\n    int32_t reply;\n    unsigned char type;\n    if (!socket_.Write(continue_read) || !socket_.Read(reply) || reply != 0 ||\n        !socket_.Read(type) || !socket_.Read(path.data(), MAX_PATH_SIZE)) {\n        path[0] = \'\\0\';\n    }\n}\n\nstd::string RirudSocket::ReadMagiskTmpfsPath() const {\n    std::string result;\n    if (Write(Action::READ_MAGISK_TMPFS_PATH)) {\n        Read(result);\n    }\n    return result;\n}\n\nstd::string RirudSocket::ReadNativeBridge() const {\n    std::string result;\n    if (Write(Action::READ_NATIVE_BRIDGE)) {\n        Read(result);\n    }\n    return result;\n}\n\nstd::string RirudSocket::ReadFile(std::string_view path) {\n    Write(Action::READ_FILE);\n    Write(path);\n    int32_t rirud_errno;\n    Read(rirud_errno);\n    if (rirud_errno != 0) {\n        return {};\n    }\n    std::string content;\n    Read(content);\n    return content;\n}\n\nbool RirudSocket::Write(const void *buf, size_t len) const {\n    auto count = len;\n    while (count > 0) {\n        ssize_t size = write(fd_, buf, count < SSIZE_MAX ? count : SSIZE_MAX);\n        if (size == -1) {\n            if (errno == EINTR) continue;\n            else return false;\n        }\n        buf = static_cast<const char *>(buf) + size;\n        count -= size;\n    }\n    return true;\n}\n\nbool RirudSocket::Read(void *out, size_t len) const {\n    while (len > 0) {\n        ssize_t ret = read(fd_, out, len);\n        if (ret <= 0) {\n            if (errno == EINTR) continue;\n            else return false;\n        }\n        out = static_cast<char *>(out) + ret;\n        len -= ret;\n    }\n    return true;\n}\n'