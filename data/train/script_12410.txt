b'// UVa11212 Editing a Book\n// Rujia Liu\n// This implementation is not very fast, but easy to understand\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 9;\nint n, a[maxn];\n\nbool is_sorted() {\n  for(int i = 0; i < n-1; i++)\n    if(a[i] >= a[i+1]) return false;\n  return true;\n}\n\n// the number of integers with incorrect successor\nint h() {\n  int cnt = 0;\n  for(int i = 0; i < n-1; i++)\n    if(a[i]+1 != a[i+1]) cnt++;\n  if(a[n-1] != n) cnt++;\n  return cnt;\n}\n\nbool dfs(int d, int maxd) {\n  if(d*3 + h() > maxd*3) return false;\n  if(is_sorted()) return true;\n\n  int b[maxn], olda[maxn];\n  memcpy(olda, a, sizeof(a));\n  for(int i = 0; i < n; i++)\n   for(int j = i; j < n; j++) {\n     // cut\n     int cnt = 0;\n     for(int k = 0; k < n; k++)\n       if(k < i || k > j) b[cnt++] = a[k];\n\n     // insert before position k\n     for(int k = 0; k <= cnt; k++) {\n       int cnt2 = 0;\n       for(int p = 0; p < k; p++) a[cnt2++] = b[p];\n       for(int p = i; p <= j; p++) a[cnt2++] = olda[p];\n       for(int p = k; p < cnt; p++) a[cnt2++] = b[p];\n\n       if(dfs(d+1, maxd)) return true;\n       memcpy(a, olda, sizeof(a));\n     }\n   }\n  return false;\n}\n\nint solve() {\n  if(is_sorted()) return 0;\n  int max_ans = 5; // after experiments, we found ans <= 5 for n <= 9\n  for(int maxd = 1; maxd < max_ans; maxd++)\n    if(dfs(0, maxd)) return maxd;\n  return max_ans;\n}\n\nint main() {\n  int kase = 0;\n  while(scanf("%d", &n) == 1 && n) {\n    for(int i = 0; i < n; i++) scanf("%d", &a[i]);\n    printf("Case %d: %d\\n", ++kase, solve());\n  }\n  return 0;\n}\n'