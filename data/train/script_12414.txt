b'/*\n * This file is part of LSPosed.\n *\n * LSPosed is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * LSPosed is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with LSPosed.  If not, see <https://www.gnu.org/licenses/>.\n *\n * Copyright (C) 2019 Swift Gan\n * Copyright (C) 2021 LSPosed Contributors\n */\n#include <malloc.h>\n#include <cstring>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <cassert>\n#include <sys/stat.h>\n#include "logging.h"\n#include "elf_util.h"\n\nusing namespace SandHook;\n\ntemplate<typename T>\ninline constexpr auto offsetOf(ElfW(Ehdr) *head, ElfW(Off) off) {\n    return reinterpret_cast<std::conditional_t<std::is_pointer_v<T>, T, T *>>(\n            reinterpret_cast<uintptr_t>(head) + off);\n}\n\nElfImg::ElfImg(std::string_view base_name) : elf(base_name) {\n    if (!findModuleBase()) {\n        base = nullptr;\n        return;\n    }\n\n    //load elf\n    int fd = open(elf.data(), O_RDONLY);\n    if (fd < 0) {\n        LOGE("failed to open %s", elf.data());\n        return;\n    }\n\n    size = lseek(fd, 0, SEEK_END);\n    if (size <= 0) {\n        LOGE("lseek() failed for %s", elf.data());\n    }\n\n    header = reinterpret_cast<decltype(header)>(mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0));\n\n    close(fd);\n\n    section_header = offsetOf<decltype(section_header)>(header, header->e_shoff);\n\n    auto shoff = reinterpret_cast<uintptr_t>(section_header);\n    char *section_str = offsetOf<char *>(header, section_header[header->e_shstrndx].sh_offset);\n\n    for (int i = 0; i < header->e_shnum; i++, shoff += header->e_shentsize) {\n        auto *section_h = (ElfW(Shdr) *) shoff;\n        char *sname = section_h->sh_name + section_str;\n        auto entsize = section_h->sh_entsize;\n        switch (section_h->sh_type) {\n            case SHT_DYNSYM: {\n                if (bias == -4396) {\n                    dynsym = section_h;\n                    dynsym_offset = section_h->sh_offset;\n                    dynsym_start = offsetOf<decltype(dynsym_start)>(header, dynsym_offset);\n                }\n                break;\n            }\n            case SHT_SYMTAB: {\n                if (strcmp(sname, ".symtab") == 0) {\n                    symtab = section_h;\n                    symtab_offset = section_h->sh_offset;\n                    symtab_size = section_h->sh_size;\n                    symtab_count = symtab_size / entsize;\n                    symtab_start = offsetOf<decltype(symtab_start)>(header, symtab_offset);\n                }\n                break;\n            }\n            case SHT_STRTAB: {\n                if (bias == -4396) {\n                    strtab = section_h;\n                    symstr_offset = section_h->sh_offset;\n                    strtab_start = offsetOf<decltype(strtab_start)>(header, symstr_offset);\n                }\n                if (strcmp(sname, ".strtab") == 0) {\n                    symstr_offset_for_symtab = section_h->sh_offset;\n                }\n                break;\n            }\n            case SHT_PROGBITS: {\n                if (strtab == nullptr || dynsym == nullptr) break;\n                if (bias == -4396) {\n                    bias = (off_t) section_h->sh_addr - (off_t) section_h->sh_offset;\n                }\n                break;\n            }\n            case SHT_HASH: {\n                auto *d_un = offsetOf<ElfW(Word)>(header, section_h->sh_offset);\n                nbucket_ = d_un[0];\n                bucket_ = d_un + 2;\n                chain_ = bucket_ + nbucket_;\n                break;\n            }\n            case SHT_GNU_HASH: {\n                auto *d_buf = reinterpret_cast<ElfW(Word) *>(((size_t) header) +\n                                                             section_h->sh_offset);\n                gnu_nbucket_ = d_buf[0];\n                gnu_symndx_ = d_buf[1];\n                gnu_bloom_size_ = d_buf[2];\n                gnu_shift2_ = d_buf[3];\n                gnu_bloom_filter_ = reinterpret_cast<decltype(gnu_bloom_filter_)>(d_buf + 4);\n                gnu_bucket_ = reinterpret_cast<decltype(gnu_bucket_)>(gnu_bloom_filter_ +\n                                                                      gnu_bloom_size_);\n                gnu_chain_ = gnu_bucket_ + gnu_nbucket_ - gnu_symndx_;\n                break;\n            }\n        }\n    }\n}\n\nElfW(Addr) ElfImg::ElfLookup(std::string_view name, uint32_t hash) const {\n    if (nbucket_ == 0) return 0;\n\n    char *strings = (char *) strtab_start;\n\n    for (auto n = bucket_[hash % nbucket_]; n != 0; n = chain_[n]) {\n        auto *sym = dynsym_start + n;\n        if (name == strings + sym->st_name) {\n            return sym->st_value;\n        }\n    }\n    return 0;\n}\n\nElfW(Addr) ElfImg::GnuLookup(std::string_view name, uint32_t hash) const {\n    static constexpr auto bloom_mask_bits = sizeof(ElfW(Addr)) * 8;\n\n    if (gnu_nbucket_ == 0 || gnu_bloom_size_ == 0) return 0;\n\n    auto bloom_word = gnu_bloom_filter_[(hash / bloom_mask_bits) % gnu_bloom_size_];\n    uintptr_t mask = 0\n                     | (uintptr_t) 1 << (hash % bloom_mask_bits)\n                     | (uintptr_t) 1 << ((hash >> gnu_shift2_) % bloom_mask_bits);\n    if ((mask & bloom_word) == mask) {\n        auto sym_index = gnu_bucket_[hash % gnu_nbucket_];\n        if (sym_index >= gnu_symndx_) {\n            char *strings = (char *) strtab_start;\n            do {\n                auto *sym = dynsym_start + sym_index;\n                if (((gnu_chain_[sym_index] ^ hash) >> 1) == 0\n                    && name == strings + sym->st_name) {\n                    return sym->st_value;\n                }\n            } while ((gnu_chain_[sym_index++] & 1) == 0);\n        }\n    }\n    return 0;\n}\n\nElfW(Addr) ElfImg::LinearLookup(std::string_view name) const {\n    if (symtabs_.empty()) {\n        symtabs_.reserve(symtab_count);\n        if (symtab_start != nullptr && symstr_offset_for_symtab != 0) {\n            for (ElfW(Off) i = 0; i < symtab_count; i++) {\n                unsigned int st_type = ELF_ST_TYPE(symtab_start[i].st_info);\n                const char *st_name = offsetOf<const char *>(header, symstr_offset_for_symtab +\n                                                                     symtab_start[i].st_name);\n                if ((st_type == STT_FUNC || st_type == STT_OBJECT) && symtab_start[i].st_size) {\n                    symtabs_.emplace(st_name, &symtab_start[i]);\n                }\n            }\n        }\n    }\n    if (auto i = symtabs_.find(name); i != symtabs_.end()) {\n        return i->second->st_value;\n    } else {\n        return 0;\n    }\n}\n\n\nElfImg::~ElfImg() {\n    //open elf file local\n    if (buffer) {\n        free(buffer);\n        buffer = nullptr;\n    }\n    //use mmap\n    if (header) {\n        munmap(header, size);\n    }\n}\n\nElfW(Addr)\nElfImg::getSymbOffset(std::string_view name, uint32_t gnu_hash, uint32_t elf_hash) const {\n    if (auto offset = GnuLookup(name, gnu_hash); offset > 0) {\n        LOGD("found %s %p in %s in dynsym by gnuhash", name.data(),\n             reinterpret_cast<void *>(offset), elf.data());\n        return offset;\n    } else if (offset = ElfLookup(name, elf_hash); offset > 0) {\n        LOGD("found %s %p in %s in dynsym by elfhash", name.data(),\n             reinterpret_cast<void *>(offset), elf.data());\n        return offset;\n    } else if (offset = LinearLookup(name); offset > 0) {\n        LOGD("found %s %p in %s in symtab by linear lookup", name.data(),\n             reinterpret_cast<void *>(offset), elf.data());\n        return offset;\n    } else {\n        return 0;\n    }\n\n}\n\nbool ElfImg::findModuleBase() {\n    char buff[256];\n    off_t load_addr;\n    bool found = false;\n    FILE *maps = fopen("/proc/self/maps", "r");\n\n\n    while (fgets(buff, sizeof(buff), maps)) {\n        if ((strstr(buff, "r-xp") || strstr(buff, "r--p")) && strstr(buff, elf.data())) {\n            LOGD("found: %s", buff);\n            std::string_view b = buff;\n            if (auto begin = b.find_last_of(\' \'); begin != std::string_view::npos && b[++begin] == \'/\') {\n                found = true;\n                elf = b.substr(begin);\n                if (elf.back() == \'\\n\') elf.pop_back();\n                LOGD("update path: %s", elf.data());\n                break;\n            }\n        }\n    }\n\n    if (!found) {\n        LOGE("failed to read load address for %s", elf.data());\n        fclose(maps);\n        return false;\n    }\n\n    if (char *next = buff; load_addr = strtoul(buff, &next, 16), next == buff) {\n        LOGE("failed to read load address for %s", elf.data());\n    }\n\n    fclose(maps);\n\n    LOGD("get module base %s: %lx", elf.data(), load_addr);\n\n    base = reinterpret_cast<void *>(load_addr);\n    return true;\n}\n'