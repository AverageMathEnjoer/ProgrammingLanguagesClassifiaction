b"{-\n - Modified from code released with:\n - Intel Concurrent Collections for Haskell\n - Copyright (c) 2010, Intel Corporation.\n -}\n{-# LANGUAGE ExistentialQuantification\n   , ScopedTypeVariables\n   , BangPatterns\n   , NamedFieldPuns\n   , RecordWildCards\n   , FlexibleInstances\n   , DeriveDataTypeable\n   , MagicHash\n   , UnboxedTuples\n   , CPP #-}\n-- This is INCOMPATIBLE with CncPure..\n\n-- Author: Chih-Ping Chen\n-- Ported to Monad-par by Ryan Newton.\n\n-- This program uses CnC to calculate the accelerations of the bodies in a 3D system.\n\nimport Control.Monad\nimport Data.Int\nimport qualified Data.List as List\nimport qualified Data.Array as A\nimport GHC.Exts\nimport System.Environment\n#ifdef PARSCHED\nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\ntype Float3D = (Float, Float, Float)\ntype UFloat3D = (# Float#, Float#, Float# #)\n\n\n-- This step generates the bodies in the system.\ngenVector tag = (tag' * 1.0, tag' * 0.2, tag' * 30.0)\n   where tag' = fromIntegral tag\n\n-- We are keeping the idiomatic Haskell version around as well for comparison:\n-- #define IDIOMATIC_VER\n\n-- Only doing the O(N^2) part in parallel:\n-- This step computes the accelerations of the bodies.\n         \n-- compute :: A.Array Int Float3D -> A.Array Int (IVar Float3D) -> Int -> Par ()\ncompute vecList accels tag =\n    do\n       let myvector = vecList A.! (tag-1)\n       put (accels A.! tag) (accel myvector vecList)\n       where\n             g = 9.8\n\n             multTriple :: Float -> Float3D -> Float3D\n             multTriple c ( x,y,z ) = ( c*x,c*y,c*z )\n\n\t     pairWiseAccel :: Float3D -> Float3D -> Float3D\n             pairWiseAccel (x,y,z) (x',y',z') = let dx = x'-x\n                                                    dy = y'-y\n                                                    dz = z'-z\n                                                    eps = 0.005\n\t\t\t\t\t\t    -- Performance degredation here:\n\t\t\t\t\t\t    distanceSq = dx*dx + dy*dy + dz*dz + eps\n\t\t\t\t\t\t    factor = 1/sqrt(distanceSq * distanceSq * distanceSq)\n\n--                                                in multTriple factor (dx,dy,dz)\n                                                in multTriple factor (dx,dy,dz)\n#ifdef IDIOMATIC_VER\n             sumTriples = foldr (\\(x,y,z) (x',y',z') -> (x+x',y+y',z+z')) (0,0,0)\n\t     accel vector vecList = multTriple g $ sumTriples $ List.map (pairWiseAccel vector) vecList\n#else\n-- Making this much less idiomatic to avoid allocation:\n             (strt,end) = A.bounds vecList\n\n             accel :: Float3D -> (A.Array Int Float3D) -> Float3D\n\t     accel vector vecList =\n\n             -- Manually inlining to see if the tuples unbox:\n\t        let (# sx,sy,sz #) = loop strt 0 0 0\n\t\t    loop !i !ax !ay !az\n                      | i == end = (# ax,ay,az #)\n\t\t      | otherwise =\n                       let ( x,y,z )    = vector\n\t\t\t   ( x',y',z' ) = vecList A.! i\n\n                           (# dx,dy,dz #) = (# x'-x, y'-y, z'-z #)\n\t\t\t   eps = 0.005\n\t\t\t   distanceSq = dx*dx + dy*dy + dz*dz + eps\n\t\t\t   factor = 1/sqrt(distanceSq * distanceSq * distanceSq)\n\n\t\t\t   (# px,py,pz #) = (# factor * dx, factor * dy, factor *dz #)\n\n\t\t       in loop (i+1) (ax+px) (ay+py) (az+pz)\n\t\tin ( g*sx, g*sy, g*sz )\n#endif\n\n\nrun :: Int -> [Float3D]\nrun n = runPar $\n        do\n\t   vars <- sequence$ take n $ repeat new\n--           accels  <- A.array (0,n-1) [ (i,) | i <- [0..n-1]]\n\t   -- Is there a better way to make an array of pvars?\n           let accels = A.array (1,n) (zip [1..n] vars)\n\n#ifdef IDIOMATIC_VER\n           let initVecs = List.map genVector [1..n]\n#else\n           let initVecs = A.array (0,n-1) [ (i, genVector i) | i <- [0..n-1] ]\n#endif\n\n\t   forM_ [1..n] $ \\ t -> fork (compute initVecs accels t)\n\n           sequence (List.map (\\i -> get (accels A.! i)) [1..n])\n\n\nmain =\n    do args <- getArgs\n       let accList = case args of\n                      []  -> run (3::Int)\n\t\t      [s] -> run (read s)\n       putStrLn $ show (foldl (\\sum (x,y,z) -> if x>0 then sum+1 else sum) 0 accList)\n\n\n"