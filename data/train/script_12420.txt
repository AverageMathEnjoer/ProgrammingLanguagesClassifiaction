b'\n{-|\n\n  The @monad-par@ package provides a family of @Par@ monads, for\n  speeding up pure computations using parallel processors.  (for a similar\n  programming model for use with @IO@, see "Control.Monad.Par.IO".)\n\n  The result of a given @Par@ computation is always the same - i.e. it\n  is deterministic, but the computation may be performed more quickly\n  if there are processors available to share the work.\n\n  For example, the following program fragment computes the values of\n  @(f x)@ and @(g x)@ in parallel, and returns a pair of their results:\n\n  >  runPar $ do\n  >      fx <- spawnP (f x)  -- start evaluating (f x)\n  >      gx <- spawnP (g x)  -- start evaluating (g x)\n  >      a  <- get fx        -- wait for fx\n  >      b  <- get gx        -- wait for gx\n  >      return (a,b)        -- return results\n\n  @Par@ can be used for specifying pure parallel computations in\n  which the order of the computation is not known beforehand.\n  The programmer specifies how information flows from one\n  part of the computation to another, but not the order in which\n  computations will be evaluated at runtime.  Information flow is\n  described using "variables" called @IVar@s, which support \'put\' and\n  \'get\' operations.  For example, suppose you have a problem that\n  can be expressed as a network with four nodes, where @b@ and @c@\n  require the value of @a@, and @d@ requires the value of @b@ and @c@:\n\n  >                       a\n  >                      / \\               \n  >                     b   c             \n  >                      \\ /  \n  >                       d\n\n  Then you could express this in the @Par@ monad like this:\n\n  >   runPar $ do\n  >       [a,b,c,d] <- sequence [new,new,new,new]\n  >       fork $ do x <- get a; put b (x+1)\n  >       fork $ do x <- get a; put c (x+2)\n  >       fork $ do x <- get b; y <- get c; put d (x+y)\n  >       fork $ do put a (3 :: Int)\n  >       get d\n\n  The result of the above computation is always 9.  The \'get\' operation\n  waits until its input is available; multiple \'put\'s to the same\n  @IVar@ are not allowed, and result in a runtime error.  Values\n  stored in @IVar@s are usually fully evaluated (although there are\n  ways provided to pass lazy values if necessary).\n\n  In the above example, @b@ and @c@ will be evaluated in parallel.\n  In practice the work involved at each node is too small here to see\n  the benefits of parallelism though: typically each node should\n  involve much more work.  The granularity is completely under your\n  control - too small and the overhead of the @Par@ monad will\n  outweigh any parallelism benefits, whereas if the nodes are too\n  large then there might not be enough parallelism to use all the\n  available processors.\n\n  Unlike @Control.Parallel@, in @Control.Monad.Par@ parallelism is\n  not combined with laziness, so sharing and granularity are\n  completely under the control of the programmer.  New units of\n  parallel work are only created by @fork@ and a few other\n  combinators.\n\n  The default implementation is based on a work-stealing scheduler\n  that divides the work as evenly as possible between the available\n  processors at runtime.  Other schedulers are available that are\n  based on different policies and have different performance\n  characteristics.  To use one of these other schedulers, just import\n  its module instead of "Control.Monad.Par":\n\n  * "Control.Monad.Par.Scheds.Trace"\n\n  * "Control.Monad.Par.Scheds.Sparks"\n\n  For more information on the programming model, please see these sources:\n\n      * The wiki\\/tutorial (<http://www.haskell.org/haskellwiki/Par_Monad:_A_Parallelism_Tutorial>)\n\n      * The original paper (<http://www.cs.indiana.edu/~rrnewton/papers/haskell2011_monad-par.pdf>)\n\n      * Tutorial slides (<http://community.haskell.org/~simonmar/slides/CUFP.pdf>)\n\n      * Other slides: (<http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/28/slides/simon.pdf>,\n                      <http://www.cs.indiana.edu/~rrnewton/talks/2011_HaskellSymposium_ParMonad.pdf>)\n\n -}\n\nmodule Control.Monad.Par \n (\n  -- * The Par Monad\n  Par, \n  runPar, runParIO,\n\n  fork,\n  -- | Forks a computation to happen in parallel.  The forked\n  -- computation may exchange values with other computations using\n  -- @IVar@s.\n\n  -- * Communication: IVars\n  IVar,\n\n  new, \n  -- creates a new @IVar@\n\n  newFull, \n  -- creates a new @IVar@ that contains a value\n\n  newFull_, \n  -- creates a new @IVar@ that contains a value (head-strict only)\n\n  get, \n  -- read the value in an @IVar@.  \'get\' can only return when the\n  -- value has been written by a prior or parallel @put@ to the same\n  -- @IVar@.\n\n  put, \n  -- put a value into an @IVar@.  Multiple \'put\'s to the same @IVar@\n  -- are not allowed, and result in a runtime error.\n  --\n  -- \'put\' fully evaluates its argument, which therefore must be an\n  -- instance of \'NFData\'.  The idea is that this forces the work to\n  -- happen when we expect it, rather than being passed to the consumer\n  -- of the @IVar@ and performed later, which often results in less\n  -- parallelism than expected.\n  --\n  -- Sometimes partial strictness is more appropriate: see \'put_\'.\n  --\n\n  put_,\n  -- like \'put\', but only head-strict rather than fully-strict.\n\n  -- * Operations\n  spawn,\n  -- | Like \'fork\', but returns an @IVar@ that can be used to query the\n  -- result of the forked computataion.  Therefore @spawn@ provides /futures/ or /promises/.\n  --\n  -- >  spawn p = do\n  -- >    r <- new\n  -- >    fork (p >>= put r)\n  -- >    return r\n  --\n\n  spawn_,\n  -- | Like \'spawn\', but the result is only head-strict, not fully-strict.\n\n  spawnP,\n  -- | Spawn a pure (rather than monadic) computation.  Fully-strict.\n  -- \n  -- >  spawnP = spawn . return\n\n  module Control.Monad.Par.Combinator,\n  -- | This module also reexports the Combinator library for backwards\n  --   compatibility with version 0.1.\n\n  NFData()\n  -- | /(0.3)/ Reexport \'NFData\' for fully-strict operators.\n\n )\nwhere \n\nimport Control.Monad.Par.Class hiding ( spawn, spawn_, spawnP, put, put_\n                                      , get, newFull, new, fork, newFull_ )\nimport Control.Monad.Par.Scheds.Trace\nimport Control.Monad.Par.Combinator\n'