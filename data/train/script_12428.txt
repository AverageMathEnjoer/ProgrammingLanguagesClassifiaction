b'{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE InstanceSigs #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule Network.OAuth2.Experiment.Types where\n\nimport Control.Monad.IO.Class (MonadIO (..))\nimport Control.Monad.Trans.Except (ExceptT (..), throwE)\nimport Data.Aeson (FromJSON)\nimport Data.Bifunctor\nimport Data.ByteString qualified as BS\nimport Data.ByteString.Lazy.Char8 qualified as BSL\nimport Data.Default (Default (def))\nimport Data.Kind\nimport Data.Map.Strict (Map)\nimport Data.Map.Strict qualified as Map\nimport Data.Set (Set)\nimport Data.Set qualified as Set\nimport Data.String\nimport Data.Text.Encoding qualified as T\nimport Data.Text.Lazy (Text)\nimport Data.Text.Lazy qualified as TL\nimport Network.HTTP.Conduit\nimport Network.OAuth.OAuth2 hiding (RefreshToken)\nimport Network.OAuth.OAuth2 qualified as OAuth2\nimport Network.OAuth2.Experiment.Pkce\nimport Network.OAuth2.Experiment.Utils\nimport URI.ByteString hiding (UserInfo)\n\n{- NOTE\n  1. shall I lift the constrain of all \'a :: GrantTypeFlow\' so that user has max customization/flexibility?\n-}\n\n-------------------------------------------------------------------------------\n\n-- * Grant Type\n\n-------------------------------------------------------------------------------\n\ndata GrantTypeFlow\n  = -- | https://www.rfc-editor.org/rfc/rfc6749#section-4.1\n    AuthorizationCode\n  | -- | https://www.rfc-editor.org/rfc/rfc6749#section-4.3\n    ResourceOwnerPassword\n  | -- | https://www.rfc-editor.org/rfc/rfc6749#section-4.4\n    ClientCredentials\n  | -- | https://www.rfc-editor.org/rfc/rfc7523.html#section-2.1\n    JwtBearer\n\n-------------------------------------------------------------------------------\n\n-- * Response Type value\n\n-------------------------------------------------------------------------------\n\nclass ToResponseTypeValue (a :: GrantTypeFlow) where\n  toResponseTypeValue :: IsString b => b\n\ninstance ToResponseTypeValue \'AuthorizationCode where\n  -- https://www.rfc-editor.org/rfc/rfc6749#section-3.1.1\n  -- Only support "authorization code" flow\n  toResponseTypeValue :: IsString b => b\n  toResponseTypeValue = "code"\n\ntoResponseTypeParam :: forall a b req. (ToResponseTypeValue a, IsString b) => req a -> Map b b\ntoResponseTypeParam _ = Map.singleton "response_type" (toResponseTypeValue @a)\n\n-------------------------------------------------------------------------------\n\n-- * Grant Type value\n\n-------------------------------------------------------------------------------\n\nnewtype UrnOAuthParam a = UrnOAuthParam a\n\n-- | Grant type query parameter has association with \'GrantTypeFlow\' but not completely strict.\n--\n-- e.g. Both \'AuthorizationCode\' and \'ResourceOwnerPassword\' flow could support refresh token flow.\ndata GrantTypeValue\n  = GTAuthorizationCode\n  | GTPassword\n  | GTClientCredentials\n  | GTRefreshToken\n  | GTJwtBearer\n  deriving (Eq, Show)\n\n-------------------------------------------------------------------------------\n\n-- * Scope\n\n-------------------------------------------------------------------------------\n\n-- TODO: following data type is not ideal as Idp would have lots of \'Custom Text\'\n--\n-- @\n-- data Scope = OPENID | PROFILE | EMAIL | OFFLINE_ACCESS | Custom Text\n-- @\n--\n-- Would be nice to define Enum for standard Scope, plus allow user to define their own define (per Idp) and plugin somehow.\nnewtype Scope = Scope {unScope :: Text}\n  deriving (Show, Eq, Ord)\n\ninstance IsString Scope where\n  fromString :: String -> Scope\n  fromString = Scope . TL.pack\n\n-------------------------------------------------------------------------------\n\n-- * Credentials\n\n-------------------------------------------------------------------------------\nnewtype ClientId = ClientId {unClientId :: Text}\n  deriving (Show, Eq, IsString)\n\n-- | Can be either "Client Secret" or JWT base on client authentication method\nnewtype ClientSecret = ClientSecret {unClientSecret :: Text}\n  deriving (Eq, IsString)\n\n-- | In order to reuse some methods from legacy "Network.OAuth.OAuth2".\n-- Will be removed when Experiment module becomes default.\ntoOAuth2Key :: ClientId -> ClientSecret -> OAuth2\ntoOAuth2Key cid csecret =\n  def\n    { oauth2ClientId = TL.toStrict $ unClientId cid\n    , oauth2ClientSecret = TL.toStrict $ unClientSecret csecret\n    }\n\nnewtype RedirectUri = RedirectUri {unRedirectUri :: URI}\n  deriving (Eq)\n\nnewtype AuthorizeState = AuthorizeState {unAuthorizeState :: Text}\n  deriving (Eq)\n\ninstance IsString AuthorizeState where\n  fromString :: String -> AuthorizeState\n  fromString = AuthorizeState . TL.pack\n\nnewtype Username = Username {unUsername :: Text}\n  deriving (Eq)\n\ninstance IsString Username where\n  fromString :: String -> Username\n  fromString = Username . TL.pack\n\nnewtype Password = Password {unPassword :: Text}\n  deriving (Eq)\n\ninstance IsString Password where\n  fromString :: String -> Password\n  fromString = Password . TL.pack\n\n-------------------------------------------------------------------------------\n\n-- * Query parameters\n\n-------------------------------------------------------------------------------\nclass ToQueryParam a where\n  toQueryParam :: a -> Map Text Text\n\ninstance ToQueryParam a => ToQueryParam (Maybe a) where\n  toQueryParam :: ToQueryParam a => Maybe a -> Map Text Text\n  toQueryParam Nothing = Map.empty\n  toQueryParam (Just a) = toQueryParam a\n\ninstance ToQueryParam GrantTypeValue where\n  toQueryParam :: GrantTypeValue -> Map Text Text\n  toQueryParam x = Map.singleton "grant_type" (val x)\n    where\n      val :: GrantTypeValue -> Text\n      val GTAuthorizationCode = "authorization_code"\n      val GTPassword = "password"\n      val GTClientCredentials = "client_credentials"\n      val GTRefreshToken = "refresh_token"\n      val GTJwtBearer = "urn:ietf:params:oauth:grant-type:jwt-bearer"\n\ninstance ToQueryParam ClientId where\n  toQueryParam :: ClientId -> Map Text Text\n  toQueryParam (ClientId i) = Map.singleton "client_id" i\n\ninstance ToQueryParam ClientSecret where\n  toQueryParam :: ClientSecret -> Map Text Text\n  toQueryParam (ClientSecret x) = Map.singleton "client_secret" x\n\ninstance ToQueryParam Username where\n  toQueryParam :: Username -> Map Text Text\n  toQueryParam (Username x) = Map.singleton "username" x\n\ninstance ToQueryParam Password where\n  toQueryParam :: Password -> Map Text Text\n  toQueryParam (Password x) = Map.singleton "password" x\n\ninstance ToQueryParam AuthorizeState where\n  toQueryParam :: AuthorizeState -> Map Text Text\n  toQueryParam (AuthorizeState x) = Map.singleton "state" x\n\ninstance ToQueryParam RedirectUri where\n  toQueryParam (RedirectUri uri) = Map.singleton "redirect_uri" (bs8ToLazyText $ serializeURIRef\' uri)\n\ninstance ToQueryParam (Set Scope) where\n  toQueryParam :: Set Scope -> Map Text Text\n  toQueryParam = toScopeParam . Set.map unScope\n    where\n      toScopeParam :: (IsString a) => Set Text -> Map a Text\n      toScopeParam scope = Map.singleton "scope" (TL.intercalate " " $ Set.toList scope)\n\ninstance ToQueryParam CodeVerifier where\n  toQueryParam :: CodeVerifier -> Map Text Text\n  toQueryParam (CodeVerifier x) = Map.singleton "code_verifier" (TL.fromStrict x)\n\ninstance ToQueryParam CodeChallenge where\n  toQueryParam :: CodeChallenge -> Map Text Text\n  toQueryParam (CodeChallenge x) = Map.singleton "code_challenge" (TL.fromStrict x)\n\ninstance ToQueryParam CodeChallengeMethod where\n  toQueryParam :: CodeChallengeMethod -> Map Text Text\n  toQueryParam x = Map.singleton "code_challenge_method" (TL.pack $ show x)\n\ninstance ToQueryParam ExchangeToken where\n  toQueryParam :: ExchangeToken -> Map Text Text\n  toQueryParam (ExchangeToken x) = Map.singleton "code" (TL.fromStrict x)\n\ninstance ToQueryParam OAuth2.RefreshToken where\n  toQueryParam :: OAuth2.RefreshToken -> Map Text Text\n  toQueryParam (OAuth2.RefreshToken x) = Map.singleton "refresh_token" (TL.fromStrict x)\n\n-------------------------------------------------------------------------------\n\n-- * Authorization and Token Requests types\n\n-------------------------------------------------------------------------------\n\nclass HasAuthorizeRequest (a :: GrantTypeFlow) where\n  data AuthorizationRequest a\n  type MkAuthorizationRequestResponse a\n  mkAuthorizeRequestParameter :: IdpApplication a i -> AuthorizationRequest a\n  mkAuthorizeRequest :: IdpApplication a i -> MkAuthorizationRequestResponse a\n\nclass HasTokenRequest (a :: GrantTypeFlow) where\n  -- | Each GrantTypeFlow has slightly different request parameter to /token endpoint.\n  data TokenRequest a\n\n  -- | Only \'AuthorizationCode flow (but not resource owner password nor client credentials) will use \'ExchangeToken\' in the token request\n  -- create type family to be explicit on it.\n  -- with \'type instance WithExchangeToken a b = b\' implies no exchange token\n  -- v.s. \'type instance WithExchangeToken a b = ExchangeToken -> b\' implies needing an exchange token\n  type WithExchangeToken a b\n\n  mkTokenRequest ::\n    IdpApplication a i ->\n    WithExchangeToken a (TokenRequest a)\n\n  conduitTokenRequest ::\n    (MonadIO m) =>\n    IdpApplication a i ->\n    Manager ->\n    WithExchangeToken a (ExceptT TokenRequestError m OAuth2Token)\n\nclass HasPkceAuthorizeRequest (a :: GrantTypeFlow) where\n  mkPkceAuthorizeRequest :: MonadIO m => IdpApplication a i -> m (TL.Text, CodeVerifier)\n\nclass HasPkceTokenRequest (b :: GrantTypeFlow) where\n  conduitPkceTokenRequest ::\n    (MonadIO m) =>\n    IdpApplication b i ->\n    Manager ->\n    (ExchangeToken, CodeVerifier) ->\n    ExceptT TokenRequestError m OAuth2Token\n\nclass HasRefreshTokenRequest (a :: GrantTypeFlow) where\n  -- | https://www.rfc-editor.org/rfc/rfc6749#page-47\n  data RefreshTokenRequest a\n\n  mkRefreshTokenRequest :: IdpApplication a i -> OAuth2.RefreshToken -> RefreshTokenRequest a\n  conduitRefreshTokenRequest ::\n    (MonadIO m) =>\n    IdpApplication a i ->\n    Manager ->\n    OAuth2.RefreshToken ->\n    ExceptT TokenRequestError m OAuth2Token\n\n-------------------------------------------------------------------------------\n\n-- * User Info types\n\n-------------------------------------------------------------------------------\n\ntype family IdpUserInfo a\n\nclass HasUserInfoRequest (a :: GrantTypeFlow) where\n  conduitUserInfoRequest ::\n    FromJSON (IdpUserInfo i) =>\n    IdpApplication a i ->\n    Manager ->\n    AccessToken ->\n    ExceptT BSL.ByteString IO (IdpUserInfo i)\n\n-------------------------------------------------------------------------------\n\n-- * Idp App\n\n-------------------------------------------------------------------------------\n\n-- | Shall IdpApplication has a field of \'Idp a\'??\ndata Idp a = Idp\n  { idpUserInfoEndpoint :: URI\n  , -- NOTE: maybe worth data type to distinguish authorize and token endpoint\n    -- as I made mistake at passing to Authorize and Token Request\n    idpAuthorizeEndpoint :: URI\n  , idpTokenEndpoint :: URI\n  , idpFetchUserInfo ::\n      forall m.\n      (FromJSON (IdpUserInfo a), MonadIO m) =>\n      Manager ->\n      AccessToken ->\n      URI ->\n      ExceptT BSL.ByteString m (IdpUserInfo a)\n  }\n\n-------------------------------------------------------------------------------\n\n-- * Idp App Config\n\n-------------------------------------------------------------------------------\n\ndata family IdpApplication (a :: GrantTypeFlow) (i :: Type)\n\n-------------------------------------------------------------------------------\n\n-- * Authorization Code flow\n\n-------------------------------------------------------------------------------\n\n-- | An Application that supports "Authorization code" flow\ndata instance IdpApplication \'AuthorizationCode i = AuthorizationCodeIdpApplication\n  { idpAppName :: Text\n  , idpAppClientId :: ClientId\n  , idpAppClientSecret :: ClientSecret\n  , idpAppScope :: Set Scope\n  , idpAppRedirectUri :: URI\n  , idpAppAuthorizeState :: AuthorizeState\n  , idpAppAuthorizeExtraParams :: Map Text Text\n  -- ^ Though technically one key can have multiple value in query, but who actually does it?!\n  , idpAppTokenRequestAuthenticationMethod :: ClientAuthenticationMethod\n  , idp :: Idp i\n  }\n\n-- NOTE: maybe add function for parase authorization response\n-- though seems overkill. https://github.com/freizl/hoauth2/issues/149\n-- parseAuthorizationResponse :: String -> AuthorizationResponse\n-- parseAuthorizationResponse :: ( String, String ) -> AuthorizationResponse\n\ninstance HasAuthorizeRequest \'AuthorizationCode where\n  -- \\| https://www.rfc-editor.org/rfc/rfc6749#section-4.1.1\n  data AuthorizationRequest \'AuthorizationCode = AuthorizationCodeAuthorizationRequest\n    { scope :: Set Scope\n    , state :: AuthorizeState\n    , clientId :: ClientId\n    , redirectUri :: Maybe RedirectUri\n    }\n  type MkAuthorizationRequestResponse \'AuthorizationCode = Text\n\n  mkAuthorizeRequestParameter :: IdpApplication \'AuthorizationCode i -> AuthorizationRequest \'AuthorizationCode\n  mkAuthorizeRequestParameter AuthorizationCodeIdpApplication {..} =\n    AuthorizationCodeAuthorizationRequest\n      { scope = if null idpAppScope then Set.empty else idpAppScope\n      , state = idpAppAuthorizeState\n      , clientId = idpAppClientId\n      , redirectUri = Just (RedirectUri idpAppRedirectUri)\n      }\n\n  mkAuthorizeRequest :: IdpApplication \'AuthorizationCode i -> Text\n  mkAuthorizeRequest idpAppConfig@AuthorizationCodeIdpApplication {..} =\n    let req = mkAuthorizeRequestParameter idpAppConfig\n        allParams =\n          map (bimap tlToBS tlToBS) $\n            Map.toList $\n              Map.unions [idpAppAuthorizeExtraParams, toQueryParam req]\n     in TL.fromStrict $\n          T.decodeUtf8 $\n            serializeURIRef\' $\n              appendQueryParams allParams $\n                idpAuthorizeEndpoint idp\n\ninstance HasTokenRequest \'AuthorizationCode where\n  -- \\| https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n  data TokenRequest \'AuthorizationCode = AuthorizationCodeTokenRequest\n    { code :: ExchangeToken\n    , clientId :: ClientId\n    , grantType :: GrantTypeValue\n    , redirectUri :: RedirectUri\n    }\n  type WithExchangeToken \'AuthorizationCode a = ExchangeToken -> a\n\n  mkTokenRequest ::\n    IdpApplication \'AuthorizationCode i ->\n    ExchangeToken ->\n    TokenRequest \'AuthorizationCode\n  mkTokenRequest AuthorizationCodeIdpApplication {..} authCode =\n    AuthorizationCodeTokenRequest\n      { code = authCode\n      , clientId = idpAppClientId\n      , grantType = GTAuthorizationCode\n      , redirectUri = RedirectUri idpAppRedirectUri\n      }\n  conduitTokenRequest ::\n    forall m i.\n    (MonadIO m) =>\n    IdpApplication \'AuthorizationCode i ->\n    Manager ->\n    ExchangeToken ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitTokenRequest idpAppConfig@AuthorizationCodeIdpApplication {..} mgr exchangeToken =\n    let req = mkTokenRequest idpAppConfig exchangeToken\n        key = toOAuth2Key idpAppClientId idpAppClientSecret\n        body =\n          mapsToParams\n            [ toQueryParam req\n            , toQueryParam\n                ( if idpAppTokenRequestAuthenticationMethod == ClientSecretPost\n                    then Just idpAppClientSecret\n                    else Nothing\n                )\n            ]\n     in doJSONPostRequest mgr key (idpTokenEndpoint idp) body\n\ninstance HasPkceAuthorizeRequest \'AuthorizationCode where\n  mkPkceAuthorizeRequest :: MonadIO m => IdpApplication \'AuthorizationCode i -> m (Text, CodeVerifier)\n  mkPkceAuthorizeRequest idpAppConfig@AuthorizationCodeIdpApplication {..} = do\n    PkceRequestParam {..} <- mkPkceParam\n    let req = mkAuthorizeRequestParameter idpAppConfig\n    let allParams =\n          mapsToParams\n            [ idpAppAuthorizeExtraParams\n            , toQueryParam req\n            , toQueryParam codeChallenge\n            , toQueryParam codeChallengeMethod\n            ]\n\n    let url =\n          TL.fromStrict $\n            T.decodeUtf8 $\n              serializeURIRef\' $\n                appendQueryParams allParams $\n                  idpAuthorizeEndpoint idp\n    pure (url, codeVerifier)\n\ninstance HasPkceTokenRequest \'AuthorizationCode where\n  conduitPkceTokenRequest ::\n    MonadIO m =>\n    IdpApplication \'AuthorizationCode i ->\n    Manager ->\n    (ExchangeToken, CodeVerifier) ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitPkceTokenRequest idpAppConfig@AuthorizationCodeIdpApplication {..} mgr (exchangeToken, codeVerifier) =\n    let req = mkTokenRequest idpAppConfig exchangeToken\n        key = toOAuth2Key idpAppClientId idpAppClientSecret\n        body =\n          mapsToParams\n            [ toQueryParam req\n            , toQueryParam codeVerifier\n            , toQueryParam (if idpAppTokenRequestAuthenticationMethod == ClientSecretPost then Just idpAppClientSecret else Nothing)\n            ]\n     in doJSONPostRequest mgr key (idpTokenEndpoint idp) body\n\ninstance HasRefreshTokenRequest \'AuthorizationCode where\n  data RefreshTokenRequest \'AuthorizationCode = AuthorizationCodeTokenRefreshRequest\n    { refreshToken :: OAuth2.RefreshToken\n    , grantType :: GrantTypeValue\n    , scope :: Set Scope\n    }\n\n  mkRefreshTokenRequest :: IdpApplication \'AuthorizationCode i -> OAuth2.RefreshToken -> RefreshTokenRequest \'AuthorizationCode\n  mkRefreshTokenRequest AuthorizationCodeIdpApplication {..} rt =\n    AuthorizationCodeTokenRefreshRequest\n      { scope = idpAppScope\n      , grantType = GTRefreshToken\n      , refreshToken = rt\n      }\n  conduitRefreshTokenRequest ::\n    (MonadIO m) =>\n    IdpApplication \'AuthorizationCode i ->\n    Manager ->\n    OAuth2.RefreshToken ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitRefreshTokenRequest idpAppConfig@AuthorizationCodeIdpApplication {..} mgr rt =\n    let req = mkRefreshTokenRequest idpAppConfig rt\n        key = toOAuth2Key idpAppClientId idpAppClientSecret\n        body =\n          mapsToParams\n            [ toQueryParam req\n            , toQueryParam (if idpAppTokenRequestAuthenticationMethod == ClientSecretPost then Just idpAppClientSecret else Nothing)\n            ]\n     in doJSONPostRequest mgr key (idpTokenEndpoint idp) body\n\ninstance HasUserInfoRequest \'AuthorizationCode where\n  conduitUserInfoRequest ::\n    FromJSON (IdpUserInfo i) =>\n    IdpApplication \'AuthorizationCode i ->\n    Manager ->\n    AccessToken ->\n    ExceptT BSL.ByteString IO (IdpUserInfo i)\n  conduitUserInfoRequest AuthorizationCodeIdpApplication {..} mgr at = do\n    idpFetchUserInfo idp mgr at (idpUserInfoEndpoint idp)\n\ninstance ToQueryParam (AuthorizationRequest \'AuthorizationCode) where\n  toQueryParam :: AuthorizationRequest \'AuthorizationCode -> Map Text Text\n  toQueryParam req@AuthorizationCodeAuthorizationRequest {..} =\n    Map.unions\n      [ toResponseTypeParam req\n      , toQueryParam scope\n      , toQueryParam clientId\n      , toQueryParam state\n      , toQueryParam redirectUri\n      ]\n\ninstance ToQueryParam (TokenRequest \'AuthorizationCode) where\n  toQueryParam :: TokenRequest \'AuthorizationCode -> Map Text Text\n  toQueryParam AuthorizationCodeTokenRequest {..} =\n    Map.unions\n      [ toQueryParam grantType\n      , toQueryParam code\n      , toQueryParam redirectUri\n      ]\n\ninstance ToQueryParam (RefreshTokenRequest \'AuthorizationCode) where\n  toQueryParam :: RefreshTokenRequest \'AuthorizationCode -> Map Text Text\n  toQueryParam AuthorizationCodeTokenRefreshRequest {..} =\n    Map.unions\n      [ toQueryParam grantType\n      , toQueryParam scope\n      , toQueryParam refreshToken\n      ]\n\n-------------------------------------------------------------------------------\n\n-- * JWTBearer\n\n-------------------------------------------------------------------------------\n\n-- | An Application that supports "Authorization code" flow\ndata instance IdpApplication \'JwtBearer i = JwtBearerIdpApplication\n  { idpAppName :: Text\n  , idpAppJwt :: BS.ByteString\n  , idp :: Idp i\n  }\n\ninstance HasTokenRequest \'JwtBearer where\n  data TokenRequest \'JwtBearer = JwtBearerTokenRequest\n    { grantType :: GrantTypeValue -- \\| \'GTJwtBearer\'\n    , assertion :: BS.ByteString -- \\| The the signed JWT token\n    }\n  type WithExchangeToken \'JwtBearer a = a\n\n  mkTokenRequest ::\n    IdpApplication \'JwtBearer i ->\n    TokenRequest \'JwtBearer\n  mkTokenRequest JwtBearerIdpApplication {..} =\n    JwtBearerTokenRequest\n      { grantType = GTJwtBearer\n      , assertion = idpAppJwt\n      }\n\n  conduitTokenRequest ::\n    forall m i.\n    (MonadIO m) =>\n    IdpApplication \'JwtBearer i ->\n    Manager ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitTokenRequest idpAppConfig@JwtBearerIdpApplication {..} mgr = do\n    resp <- ExceptT . liftIO $ do\n      let tokenReq = mkTokenRequest idpAppConfig\n      let body = mapsToParams [toQueryParam tokenReq]\n      req <- uriToRequest (idpTokenEndpoint idp)\n      handleOAuth2TokenResponse <$> httpLbs (urlEncodedBody body (addDefaultRequestHeaders req)) mgr\n    case parseResponseFlexible resp of\n      Right obj -> return obj\n      Left e -> throwE e\n\ninstance ToQueryParam (TokenRequest \'JwtBearer) where\n  toQueryParam :: TokenRequest \'JwtBearer -> Map Text Text\n  toQueryParam JwtBearerTokenRequest {..} =\n    Map.unions\n      [ toQueryParam grantType\n      , Map.fromList [("assertion", bs8ToLazyText assertion)]\n      ]\n\ninstance HasUserInfoRequest \'JwtBearer where\n  conduitUserInfoRequest JwtBearerIdpApplication {..} mgr at = do\n    idpFetchUserInfo idp mgr at (idpUserInfoEndpoint idp)\n\n-------------------------------------------------------------------------------\n\n-- * Password flow\n\n-------------------------------------------------------------------------------\n\n-- https://www.rfc-editor.org/rfc/rfc6749#section-4.3.1\n-- 4.3.1.  Authorization Request and Response (Password grant type)\n-- The method through which the client obtains the resource owner\n-- credentials is beyond the scope of this specification.  The client\n-- MUST discard the credentials once an access token has been obtained.\n--\n-- Hence no AuhorizationRequest instance\n\ndata instance IdpApplication \'ResourceOwnerPassword i = ResourceOwnerPasswordIDPApplication\n  { idpAppClientId :: ClientId\n  , idpAppClientSecret :: ClientSecret\n  , idpAppName :: Text\n  , idpAppScope :: Set Scope\n  , idpAppUserName :: Username\n  , idpAppPassword :: Password\n  , idpAppTokenRequestExtraParams :: Map Text Text\n  -- ^ Any parameter that required by your Idp and not mentioned in the OAuth2 spec\n  , idp :: Idp i\n  }\n\ninstance HasUserInfoRequest \'ResourceOwnerPassword where\n  conduitUserInfoRequest ResourceOwnerPasswordIDPApplication {..} mgr at = do\n    idpFetchUserInfo idp mgr at (idpUserInfoEndpoint idp)\n\ninstance HasTokenRequest \'ResourceOwnerPassword where\n  -- \\| https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n  data TokenRequest \'ResourceOwnerPassword = PasswordTokenRequest\n    { scope :: Set Scope\n    , username :: Username\n    , password :: Password\n    , grantType :: GrantTypeValue\n    }\n  type WithExchangeToken \'ResourceOwnerPassword a = a\n\n  mkTokenRequest :: IdpApplication \'ResourceOwnerPassword i -> TokenRequest \'ResourceOwnerPassword\n  mkTokenRequest ResourceOwnerPasswordIDPApplication {..} =\n    PasswordTokenRequest\n      { username = idpAppUserName\n      , password = idpAppPassword\n      , grantType = GTPassword\n      , scope = idpAppScope\n      }\n\n  conduitTokenRequest ::\n    (MonadIO m) =>\n    IdpApplication \'ResourceOwnerPassword i ->\n    Manager ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitTokenRequest idpAppConfig@ResourceOwnerPasswordIDPApplication {..} mgr =\n    let req = mkTokenRequest idpAppConfig\n        key = toOAuth2Key idpAppClientId idpAppClientSecret\n        body = mapsToParams [idpAppTokenRequestExtraParams, toQueryParam req]\n     in doJSONPostRequest mgr key (idpTokenEndpoint idp) body\n\n-- | TODO: TBD\ninstance HasRefreshTokenRequest \'ResourceOwnerPassword where\n  data RefreshTokenRequest \'ResourceOwnerPassword = PasswordRefreshTokenRequest\n\n  mkRefreshTokenRequest ::\n    IdpApplication \'ResourceOwnerPassword i ->\n    OAuth2.RefreshToken ->\n    RefreshTokenRequest \'ResourceOwnerPassword\n  mkRefreshTokenRequest = undefined\n\n  conduitRefreshTokenRequest ::\n    MonadIO m =>\n    IdpApplication \'ResourceOwnerPassword i ->\n    Manager ->\n    OAuth2.RefreshToken ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitRefreshTokenRequest = undefined\n\ninstance ToQueryParam (TokenRequest \'ResourceOwnerPassword) where\n  toQueryParam :: TokenRequest \'ResourceOwnerPassword -> Map Text Text\n  toQueryParam PasswordTokenRequest {..} =\n    Map.unions\n      [ toQueryParam grantType\n      , toQueryParam scope\n      , toQueryParam username\n      , toQueryParam password\n      ]\n\n-------------------------------------------------------------------------------\n\n-- * Client Credentials flow\n\n-------------------------------------------------------------------------------\n\n-- https://www.rfc-editor.org/rfc/rfc6749#section-4.4.1\n-- 4.4.1.  Authorization Request and Response (Client Credentials grant type)\n-- Since the client authentication is used as the authorization grant,\n-- no additional authorization request is needed.\n--\n-- Hence no AuhorizationRequest instance\n\ndata instance IdpApplication \'ClientCredentials i = ClientCredentialsIDPApplication\n  { idpAppClientId :: ClientId\n  , idpAppClientSecret :: ClientSecret\n  , idpAppTokenRequestAuthenticationMethod :: ClientAuthenticationMethod\n  -- ^ FIXME: rename to ClientCredential\n  , idpAppName :: Text\n  , idpAppScope :: Set Scope\n  , idpAppTokenRequestExtraParams :: Map Text Text\n  -- ^ Any parameter that required by your Idp and not mentioned in the OAuth2 spec\n  , idp :: Idp i\n  }\n\ninstance HasTokenRequest \'ClientCredentials where\n  -- \\| https://www.rfc-editor.org/rfc/rfc6749#section-4.4.2\n  data TokenRequest \'ClientCredentials = ClientCredentialsTokenRequest\n    { scope :: Set Scope\n    , grantType :: GrantTypeValue\n    , clientAssertionType :: Text\n    , clientAssertion :: BS.ByteString\n    , clientAuthenticationMethod :: ClientAuthenticationMethod\n    }\n\n  type WithExchangeToken \'ClientCredentials a = a\n\n  mkTokenRequest :: IdpApplication \'ClientCredentials i -> TokenRequest \'ClientCredentials\n  mkTokenRequest ClientCredentialsIDPApplication {..} =\n    ClientCredentialsTokenRequest\n      { scope = idpAppScope\n      , grantType = GTClientCredentials\n      , clientAssertionType = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"\n      , clientAssertion = tlToBS $ unClientSecret idpAppClientSecret\n      , clientAuthenticationMethod = idpAppTokenRequestAuthenticationMethod\n      }\n\n  conduitTokenRequest ::\n    (MonadIO m) =>\n    IdpApplication \'ClientCredentials i ->\n    Manager ->\n    ExceptT TokenRequestError m OAuth2Token\n  conduitTokenRequest idpAppConfig@ClientCredentialsIDPApplication {..} mgr = do\n    let tokenReq = mkTokenRequest idpAppConfig\n        key =\n          toOAuth2Key\n            idpAppClientId\n            idpAppClientSecret\n        body =\n          mapsToParams\n            [ idpAppTokenRequestExtraParams\n            , toQueryParam tokenReq\n            ]\n    if clientAuthenticationMethod tokenReq == ClientAssertionJwt\n      then do\n        resp <- ExceptT . liftIO $ do\n          req <- uriToRequest (idpTokenEndpoint idp)\n          let req\' = urlEncodedBody body (addDefaultRequestHeaders req)\n          handleOAuth2TokenResponse <$> httpLbs req\' mgr\n        case parseResponseFlexible resp of\n          Right obj -> return obj\n          Left e -> throwE e\n      else doJSONPostRequest mgr key (idpTokenEndpoint idp) body\n\ninstance ToQueryParam (TokenRequest \'ClientCredentials) where\n  toQueryParam :: TokenRequest \'ClientCredentials -> Map Text Text\n  toQueryParam ClientCredentialsTokenRequest {..} =\n    Map.unions $\n      [ toQueryParam grantType\n      , toQueryParam scope\n      ]\n        ++ [ Map.fromList\n              ( if clientAuthenticationMethod == ClientAssertionJwt\n                  then\n                    [ ("client_assertion_type", clientAssertionType)\n                    , ("client_assertion", bs8ToLazyText clientAssertion)\n                    ]\n                  else []\n              )\n           ]\n'