b'{-# LANGUAGE LambdaCase #-}\n-- | @since 1.4.2\n\nmodule Test.Tasty.Patterns.Printer\n  ( printAwkExpr\n  )\n  where\n\nimport Prelude hiding (LT, GT, EQ)\nimport Test.Tasty.Patterns.Types\n\n-- | @since 1.4.2\nprintAwkExpr :: Expr -> String\nprintAwkExpr e = go 0 e ""\n\ngo :: Int -> Expr -> ShowS\ngo p = \\case\n  NF -> showString "NF"\n  IntLit n -> showsPrec p n\n  StringLit xs -> showChar \'"\' . showString (escapeString xs) . showChar \'"\'\n  ERE xs -> showChar \'/\' . showString (escapeERE xs) . showChar \'/\'\n\n  Field x -> showParen (p >= 9) $ showChar \'$\' . go 9 x\n\n  -- Cf. comment for Test.Tasty.Patterns.Parser.expr2 to understand\n  -- why we put showParens when precedence is 6 not 8.\n  Neg x -> showParen (p >= 6) $ showChar \'-\' . go 8 x\n  Not x -> showParen (p >= 8) $ showChar \'!\' . go 8 x\n\n  Add x y -> showParen (p >= 7) $ go 7 x . showChar \'+\' . go 7 y\n  Sub x y -> showParen (p >= 7) $ go 7 x . showChar \'-\' . go 7 y\n\n  Concat x y -> showParen (p >= 6) $ go 6 x . showChar \' \' . go 6 y\n\n  LT x y -> showParen (p >= 5) $ go 5 x . showChar \'<\'    . go 5 y\n  LE x y -> showParen (p >= 5) $ go 5 x . showString "<=" . go 5 y\n  GT x y -> showParen (p >= 5) $ go 5 x . showChar \'>\'    . go 5 y\n  GE x y -> showParen (p >= 5) $ go 5 x . showString ">=" . go 5 y\n  EQ x y -> showParen (p >= 5) $ go 5 x . showString "==" . go 5 y\n  NE x y -> showParen (p >= 5) $ go 5 x . showString "!=" . go 5 y\n\n  Match x y   -> showParen (p >= 4) $ go 4 x . showChar \'~\'    . go 4 (ERE y)\n  NoMatch x y -> showParen (p >= 4) $ go 4 x . showString "!~" . go 4 (ERE y)\n\n  And x y -> showParen (p >= 2) $ go 2 x . showString "&&" . go 2 y\n\n  Or x y -> showParen (p >= 1) $ go 1 x . showString "||" . go 1 y\n\n  If c t f -> showParen (p >= 0) $ go 0 c . showChar \'?\' . go 0 t . showChar \':\' . go 0 f\n\n  ToUpperFn x -> showString "toupper(" . go 0 x . showChar \')\'\n  ToLowerFn x -> showString "tolower(" . go 0 x . showChar \')\'\n\n  LengthFn Nothing  -> showString "length()"\n  LengthFn (Just x) -> showString "length(" . go 0 x . showChar \')\'\n\n  SubstrFn x y Nothing  -> showString "substr(" . go 0 x . showChar \',\' . go 0 y . showChar \')\'\n  SubstrFn x y (Just z) -> showString "substr(" . go 0 x . showChar \',\' . go 0 y . showChar \',\' . go 0 z . showChar \')\'\n\n  MatchFn x y -> showString "match(" . go 0 x . showChar \',\' . go 0 (ERE y) . showChar \')\'\n\nescapeString :: String -> String\nescapeString = concatMap $ \\c -> (if c `elem` "\\\\\\"" then (\'\\\\\' :) else id) [c]\n\nescapeERE :: String -> String\nescapeERE = concatMap $ \\c -> (if c `elem` "\\\\/" then (\'\\\\\' :) else id) [c]\n'