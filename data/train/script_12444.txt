b'/*\n* Copyright (C) 2014 The CyanogenMod Project\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage com.naman14.timber.provider;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\n\nimport java.util.ArrayList;\n\npublic class SearchHistory {\n\n    private static final int MAX_ITEMS_IN_DB = 25;\n\n    private static SearchHistory sInstance = null;\n\n    private MusicDB mMusicDatabase = null;\n\n    public SearchHistory(final Context context) {\n        mMusicDatabase = MusicDB.getInstance(context);\n    }\n\n    public static final synchronized SearchHistory getInstance(final Context context) {\n        if (sInstance == null) {\n            sInstance = new SearchHistory(context.getApplicationContext());\n        }\n        return sInstance;\n    }\n\n    public void onCreate(final SQLiteDatabase db) {\n        db.execSQL("CREATE TABLE IF NOT EXISTS " + SearchHistoryColumns.NAME + " ("\n                + SearchHistoryColumns.SEARCHSTRING + " STRING NOT NULL,"\n                + SearchHistoryColumns.TIMESEARCHED + " LONG NOT NULL);");\n    }\n\n    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {\n    }\n\n    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        db.execSQL("DROP TABLE IF EXISTS " + SearchHistoryColumns.NAME);\n        onCreate(db);\n    }\n\n    public void addSearchString(final String searchString) {\n        if (searchString == null) {\n            return;\n        }\n\n        String trimmedString = searchString.trim();\n\n        if (trimmedString.isEmpty()) {\n            return;\n        }\n\n        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();\n        database.beginTransaction();\n\n        try {\n\n            database.delete(SearchHistoryColumns.NAME,\n                    SearchHistoryColumns.SEARCHSTRING + " = ? COLLATE NOCASE",\n                    new String[]{trimmedString});\n\n            final ContentValues values = new ContentValues(2);\n            values.put(SearchHistoryColumns.SEARCHSTRING, trimmedString);\n            values.put(SearchHistoryColumns.TIMESEARCHED, System.currentTimeMillis());\n            database.insert(SearchHistoryColumns.NAME, null, values);\n\n            Cursor oldest = null;\n            try {\n                database.query(SearchHistoryColumns.NAME,\n                        new String[]{SearchHistoryColumns.TIMESEARCHED}, null, null, null, null,\n                        SearchHistoryColumns.TIMESEARCHED + " ASC");\n\n                if (oldest != null && oldest.getCount() > MAX_ITEMS_IN_DB) {\n                    oldest.moveToPosition(oldest.getCount() - MAX_ITEMS_IN_DB);\n                    long timeOfRecordToKeep = oldest.getLong(0);\n\n                    database.delete(SearchHistoryColumns.NAME,\n                            SearchHistoryColumns.TIMESEARCHED + " < ?",\n                            new String[]{String.valueOf(timeOfRecordToKeep)});\n\n                }\n            } finally {\n                if (oldest != null) {\n                    oldest.close();\n                    oldest = null;\n                }\n            }\n        } finally {\n            database.setTransactionSuccessful();\n            database.endTransaction();\n        }\n    }\n\n\n    public Cursor queryRecentSearches(final String limit) {\n        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();\n        return database.query(SearchHistoryColumns.NAME,\n                new String[]{SearchHistoryColumns.SEARCHSTRING}, null, null, null, null,\n                SearchHistoryColumns.TIMESEARCHED + " DESC", limit);\n    }\n\n    public ArrayList<String> getRecentSearches() {\n        Cursor searches = queryRecentSearches(String.valueOf(MAX_ITEMS_IN_DB));\n\n        ArrayList<String> results = new ArrayList<String>(MAX_ITEMS_IN_DB);\n\n        try {\n            if (searches != null && searches.moveToFirst()) {\n                int colIdx = searches.getColumnIndex(SearchHistoryColumns.SEARCHSTRING);\n\n                do {\n                    results.add(searches.getString(colIdx));\n                } while (searches.moveToNext());\n            }\n        } finally {\n            if (searches != null) {\n                searches.close();\n                searches = null;\n            }\n        }\n\n        return results;\n    }\n\n    public interface SearchHistoryColumns {\n        /* Table name */\n        String NAME = "searchhistory";\n\n        /* What was searched */\n        String SEARCHSTRING = "searchstring";\n\n        /* Time of search */\n        String TIMESEARCHED = "timesearched";\n    }\n}\n'