b"{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Data.Xournal.BBox where\n\nimport Control.Monad (guard, liftM2)\nimport qualified Data.Foldable as F\nimport Data.Kind (Type)\nimport Data.Serialize (Serialize, get, put)\nimport Data.Strict.Tuple (Pair, fst, snd)\nimport Data.Xournal.Generic\n  ( GLayer,\n    GPage,\n    GStrokeable,\n    GXournal,\n    gFromStroke,\n    gToStroke,\n  )\nimport Data.Xournal.Simple\n  ( Background (..),\n    Dimension (..),\n    Stroke (..),\n  )\nimport Data.Xournal.Util (fst3, snd3, trd3)\nimport Prelude hiding (fst, snd)\nimport qualified Prelude as Prelude (fst, snd)\n\n-- | bounding box type\ndata BBox = BBox\n  { bbox_upperleft :: (Double, Double),\n    bbox_lowerright :: (Double, Double)\n  }\n  deriving (Show, Eq, Ord)\n\n-- |\ninstance Serialize BBox where\n  put BBox {..} = put bbox_upperleft >> put bbox_lowerright\n  get = liftM2 BBox get get\n\n-- |\ndata StrokeBBox = StrokeBBox\n  { strokebbox_stroke :: Stroke,\n    strokebbox_bbox :: BBox\n  }\n  deriving (Show, Eq, Ord)\n\n-- |\ninstance Serialize StrokeBBox where\n  put StrokeBBox {..} = put strokebbox_stroke >> put strokebbox_bbox\n  get = liftM2 StrokeBBox get get\n\ntype TLayerBBox = GLayer [] StrokeBBox\n\ntype TPageBBox = GPage Background [] TLayerBBox\n\ntype TXournalBBox = GXournal [] TPageBBox\n\ninstance GStrokeable StrokeBBox where\n  gFromStroke = mkStrokeBBoxFromStroke\n  gToStroke = strokeFromStrokeBBox\n\n-- |\nmkbbox :: [Pair Double Double] -> BBox\nmkbbox lst =\n  let xs = map fst lst\n      ys = map snd lst\n   in BBox\n        { bbox_upperleft = (minimum xs, minimum ys),\n          bbox_lowerright = (maximum xs, maximum ys)\n        }\n\n-- |\nmkbboxF :: (F.Foldable m, Functor m) => m (Double, Double) -> BBox\nmkbboxF lst =\n  let xs = fmap Prelude.fst lst\n      ys = fmap Prelude.snd lst\n   in BBox\n        { bbox_upperleft = (F.minimum xs, F.minimum ys),\n          bbox_lowerright = (F.maximum xs, F.maximum ys)\n        }\n\n-- |\nbboxFromStroke :: Stroke -> BBox\nbboxFromStroke (Stroke _ _ w dat) = inflate (mkbbox dat) w\nbboxFromStroke (VWStroke _ _ dat) =\n  let dat' = map ((,) <$> fst3 <*> snd3) dat\n      widthmax = F.maximum (map trd3 dat)\n   in inflate (mkbboxF dat') widthmax\n\n-- |\ndimToBBox :: Dimension -> BBox\ndimToBBox (Dim w h) = BBox (0, 0) (w, h)\n\n-- | transform BBox\nxformBBox :: ((Double, Double) -> (Double, Double)) -> BBox -> BBox\nxformBBox f (BBox c1 c2) = BBox (f c1) (f c2)\n\n-- |\ninflate :: BBox -> Double -> BBox\ninflate (BBox (x1, y1) (x2, y2)) r = BBox (x1 - r, y1 - r) (x2 + r, y2 + r)\n\n-- |\nmoveBBoxToOrigin :: BBox -> BBox\nmoveBBoxToOrigin (BBox (x0, y0) (x1, y1)) = BBox (0, 0) (x1 - x0, y1 - y0)\n\n-- |\nmoveBBoxByOffset :: (Double, Double) -> BBox -> BBox\nmoveBBoxByOffset (xoff, yoff) (BBox (x0, y0) (x1, y1)) = BBox (x0 + xoff, y0 + yoff) (x1 + xoff, y1 + yoff)\n\n-- |\nmoveBBoxULCornerTo :: (Double, Double) -> BBox -> BBox\nmoveBBoxULCornerTo (x, y) b@(BBox (x0, y0) _) = moveBBoxByOffset (x - x0, y - y0) b\n\n-- |\nintersectBBox :: BBox -> BBox -> Maybe BBox\nintersectBBox (BBox (x1, y1) (x2, y2)) (BBox (x3, y3) (x4, y4)) = do\n  guard $ (x1 <= x3 && x3 <= x2) || (x3 <= x1 && x1 <= x4)\n  guard $ (y1 <= y3 && y3 <= y2) || (y3 <= y1 && y1 <= y4)\n  let x5 = if x1 <= x3 then x3 else x1\n      y5 = if y1 <= y3 then y3 else y1\n      x6 = min x2 x4\n      y6 = min y2 y4\n  return (BBox (x5, y5) (x6, y6))\n\n-- |\nunionBBox :: BBox -> BBox -> BBox\nunionBBox (BBox (x1, y1) (x2, y2)) (BBox (x3, y3) (x4, y4)) =\n  let x5 = if x1 < x3 then x1 else x3\n      y5 = if y1 < y3 then y1 else y3\n      x6 = if x2 < x4 then x4 else x2\n      y6 = if y2 < y4 then y4 else y2\n   in BBox (x5, y5) (x6, y6)\n\n-- |\ndata ULMaybe a = Bottom | Middle a | Top\n\nderiving instance Show a => Show (ULMaybe a)\n\nderiving instance Eq a => Eq (ULMaybe a)\n\n-- |\nnewtype IntersectBBox = Intersect {unIntersect :: ULMaybe BBox}\n  deriving (Show, Eq)\n\n-- |\nnewtype UnionBBox = Union {unUnion :: ULMaybe BBox}\n  deriving (Show, Eq)\n\ninstance Semigroup IntersectBBox where\n  (Intersect Bottom) <> _ = Intersect Bottom\n  _ <> (Intersect Bottom) = Intersect Bottom\n  (Intersect Top) <> x = x\n  x <> (Intersect Top) = x\n  (Intersect (Middle x)) <> (Intersect (Middle y)) =\n    maybe (Intersect Bottom) (Intersect . Middle) (x `intersectBBox` y)\n\ninstance Monoid IntersectBBox where\n  mempty = Intersect Top\n\ninstance Semigroup UnionBBox where\n  (Union Bottom) <> x = x\n  x <> (Union Bottom) = x\n  (Union Top) <> _ = Union Top\n  _ <> (Union Top) = Union Top\n  (Union (Middle x)) <> (Union (Middle y)) = Union (Middle (x `unionBBox` y))\n\ninstance Monoid UnionBBox where\n  mempty = Union Bottom\n\n-- |\nclass Maybeable a where\n  type ElemType a :: Type\n  toMaybe :: a -> Maybe (ElemType a)\n  fromMaybe :: Maybe (ElemType a) -> a\n\ninstance Maybeable IntersectBBox where\n  type ElemType IntersectBBox = BBox\n  toMaybe (Intersect Bottom) = Nothing\n  toMaybe (Intersect Top) = Nothing\n  toMaybe (Intersect (Middle x)) = Just x\n  fromMaybe Nothing = Intersect Top\n  fromMaybe (Just x) = Intersect (Middle x)\n\ninstance Maybeable UnionBBox where\n  type ElemType UnionBBox = BBox\n  toMaybe (Union Bottom) = Nothing\n  toMaybe (Union Top) = Nothing\n  toMaybe (Union (Middle x)) = Just x\n  fromMaybe Nothing = Union Top\n  fromMaybe (Just x) = Union (Middle x)\n\n-- |\nmkStrokeBBoxFromStroke :: Stroke -> StrokeBBox\nmkStrokeBBoxFromStroke str =\n  StrokeBBox\n    { strokebbox_stroke = str,\n      strokebbox_bbox = bboxFromStroke str\n    }\n\n-- |\nstrokeFromStrokeBBox :: StrokeBBox -> Stroke\nstrokeFromStrokeBBox = strokebbox_stroke\n"