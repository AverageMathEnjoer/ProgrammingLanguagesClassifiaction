b'// UVa1228 Integer Transmission\n// Rujia Liu\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 64;\n\nint n, d, K[maxn];\nunsigned long long f[maxn+1][maxn+1];\n\nint zcnt = 0, ocnt = 0;\nint Z[maxn], O[maxn]; // z[i] is the i-th zero from left (0-based)\n\n// now we received i zeros and j ones. Can we receive another zero at the next time?\nbool can_receive_zero(int i, int j) {\n  return i+1 <= zcnt && (j == ocnt || O[j]+d >= Z[i]);\n}\n\nbool can_receive_one(int i, int j) {\n  return j+1 <= ocnt && (i == zcnt || Z[i]+d >= O[j]);\n}\n\nunsigned long long minv, maxv;\n\nvoid greedy() {\n  minv = maxv = 0;\n  int i = 0, j = 0;\n  while(i < zcnt || j < ocnt) {\n    if(can_receive_zero(i, j)) { i++; minv = minv * 2; }\n    else { j++; minv = minv * 2 + 1; }\n  }\n  i = j = 0;\n  while(i < zcnt || j < ocnt) {\n    if(can_receive_one(i, j)) { j++; maxv = maxv * 2 + 1; }\n    else { i++; maxv = maxv * 2; }\n  }\n}\n\nvoid solve() {\n  // compute Z and O\n  ocnt = zcnt = 0;\n  for(int i = 0; i < n; i++)\n    if(K[i] == 1) O[ocnt++] = i;\n    else Z[zcnt++] = i;\n\n  // greedy to get minv, maxv\n  greedy();\n  \n  // dp\n  memset(f, 0, sizeof(f));\n  f[0][0] = 1;\n  for(int i = 0; i <= zcnt; i++)\n    for(int j = 0; j <= ocnt; j++) {\n      if(can_receive_zero(i, j)) f[i+1][j] += f[i][j];\n      if(can_receive_one(i, j)) f[i][j+1] += f[i][j];\n    }\n  cout << f[zcnt][ocnt] << " " << minv << " " << maxv << "\\n";\n}\n\nint main() {\n  int kase = 0;\n  unsigned long long k;\n  while(cin >> n >> d >> k) {\n    for(int i = 0; i < n; i++) {\n      K[n-i-1] = k % 2; k /= 2;\n    }\n    cout << "Case " << ++kase << ": ";\n    solve();\n  }\n  return 0;\n}\n'