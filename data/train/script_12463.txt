b'// I2Cdev library collection - BMA150 I2C device class header file\n// Based on BMA150 datasheet, 29/05/2008\n// 01/18/2012 by Brian McCain <bpmccain@gmail.com>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     2012-01-18 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2011 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include "BMA150.h"\n\n/** Default constructor, uses default I2C address.\n * @see BMA150_DEFAULT_ADDRESS\n */\nBMA150::BMA150() {\n    devAddr = BMA150_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see BMA150_DEFAULT_ADDRESS\n * @see BMA150_ADDRESS_00\n */\nBMA150::BMA150(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage. This sets the full scale range of \n * the sensor, as well as the bandwidth\n */\nvoid BMA150::initialize() {\n\tsetRange(BMA150_RANGE_2G);\n\tsetBandwidth(BMA150_BW_25HZ);\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool BMA150::testConnection() {\n    return getDeviceID() == 0b010;\n}\n\n// CHIP_ID register\n/** Get Device ID.\n * This register is used to verify the identity of the device (0b010).\n * @return Device ID (should be 2 dec)\n * @see BMA150_RA_CHIP_ID\n */\nuint8_t BMA150::getDeviceID() {\n    I2Cdev::readByte(devAddr, BMA150_RA_CHIP_ID, buffer);\n    return buffer[0];\n}\n\n\n// VERSION register\n/** Get Chip Revision number\n * @return Chip Revision\n * @see BMA150_RA_VERSION\n */\n uint8_t BMA150::getChipRevision() {\n    I2Cdev::readByte(devAddr, BMA150_RA_VERSION, buffer);\n    return buffer[0];\n}\n\t\t\n// AXIS registers\n/** Get 3-axis accelerometer readings.\n * @param x 16-bit signed integer container for X-axis acceleration\n * @param y 16-bit signed integer container for Y-axis acceleration\n * @param z 16-bit signed integer container for Z-axis acceleration\n * @see BMA150_RA_Y_AXIS_LSB\n */\n\nvoid BMA150::getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, BMA150_RA_X_AXIS_LSB, 6, buffer);\n    *x = ((((int16_t)buffer[1]) << 8) | buffer[0]) >> 6;\n    *y = ((((int16_t)buffer[3]) << 8) | buffer[2]) >> 6;\n    *z = ((((int16_t)buffer[5]) << 8) | buffer[4]) >> 6;\n}\n\n/** Get X-axis accelerometer reading.\n * @return X-axis acceleration measurement in 16-bit 2\'s complement format\n * @see BMA150_RA_X_AXIS_LSB\n */\nint16_t BMA150::getAccelerationX() {\n    I2Cdev::readBytes(devAddr, BMA150_RA_X_AXIS_LSB, 2, buffer);\n    return ((((int16_t)buffer[1]) << 8) | buffer[0]) >> 6;\n}\n\n/** Get Y-axis accelerometer reading.\n * @return Y-axis acceleration measurement in 16-bit 2\'s complement format\n * @see BMA150_RA_Y_AXIS_LSB\n */\nint16_t BMA150::getAccelerationY() {\n    I2Cdev::readBytes(devAddr, BMA150_RA_Y_AXIS_LSB, 2, buffer);\n    return ((((int16_t)buffer[1]) << 8) | buffer[0]) >> 6;\n}\n\n/** Get Z-axis accelerometer reading.\n * @return Z-axis acceleration measurement in 16-bit 2\'s complement format\n * @see BMA150_RA_Z_AXIS_LSB\n */\nint16_t BMA150::getAccelerationZ() {\n    I2Cdev::readBytes(devAddr, BMA150_RA_Z_AXIS_LSB, 2, buffer);\n    return ((((int16_t)buffer[1]) << 8) | buffer[0]) >> 6;\n}\n\n/** Check for new X axis acceleration data.\n * @return New X-Axis Data Status\n * @see BMA150_RA_X_AXIS_LSB\n */\nbool BMA150::newDataX() {\n    I2Cdev::readBit(devAddr, BMA150_RA_X_AXIS_LSB, BMA150_X_NEW_DATA_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Check for new Y axis acceleration data.\n * @return New Y-Axis Data Status\n * @see BMA150_RA_Y_AXIS_LSB\n */\nbool BMA150::newDataY() {\n    I2Cdev::readBit(devAddr, BMA150_RA_Y_AXIS_LSB, BMA150_Y_NEW_DATA_BIT, buffer);\n\treturn buffer[0];\n}\n\n/** Check for new Z axis acceleration data.\n * @return New Z-Axis Data Status\n * @see BMA150_RA_Z_AXIS_LSB\n */\nbool BMA150::newDataZ() {\n    I2Cdev::readBit(devAddr, BMA150_RA_Z_AXIS_LSB, BMA150_Z_NEW_DATA_BIT, buffer);\n\treturn buffer[0];\n}\n\t\t\t\t\n// TEMP register\n/** Check for current temperature\n * @return Current Temperature in 0.5C increments from -30C at 00h\n * @see BMA150_RA_TEMP_RD\n */\nint8_t BMA150::getTemperature() {\n    I2Cdev::readByte(devAddr, BMA150_RA_TEMP_RD, buffer);\n    return buffer[0];\n}\n\t\t\n// SMB150 registers\nbool BMA150::getStatusHG() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_STATUS_HG_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setStatusHG(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_STATUS_HG_BIT, enabled);\n}\n\nbool BMA150::getStatusLG() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_STATUS_LG_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setStatusLG(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_STATUS_LG_BIT, enabled);\n}\n\nbool BMA150::getHGLatched() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_HG_LATCHED_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setHGLatched(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_HG_LATCHED_BIT, enabled);\n}\n\nbool BMA150::getLGLatched() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_LG_LATCHED_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setLGLatched(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_LG_LATCHED_BIT, enabled);\n}\n\nbool BMA150::getAlertPhase() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_ALERT_PHASE_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setAlertPhase(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_ALERT_PHASE_BIT, enabled);\n}\n\nbool BMA150::getSTResult() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_ST_RESULT_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setSTResult(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_STATUS, BMA150_ST_RESULT_BIT, enabled);\n}\n\n\n\n\n\n\nbool BMA150::getSleep() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_SLEEP_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setSleep(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_SLEEP_BIT, enabled);\n}\n\nbool BMA150::getSoftReset() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_SOFT_RESET_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setSoftReset(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_SOFT_RESET_BIT, enabled);\n}\n\nbool BMA150::getSelfTest0() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_ST0_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setSelfTest0(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_ST0_BIT, enabled);\n}\n\nbool BMA150::getSelfTest1() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_ST1_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setSelfTest1(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_ST1_BIT, enabled);\n}\n\nbool BMA150::getEEW() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_EEW_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setEEW(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_EEW_BIT, enabled);\n}\n\nbool BMA150::getUpdateImage() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_UPDATE_IMAGE_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setUpdateImage(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_UPDATE_IMAGE_BIT, enabled);\n}\n\nbool BMA150::getResetINT() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_RESET_INT_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setResetINT(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CTRL, BMA150_RESET_INT_BIT, enabled);\n}\n\n\n\n\nbool BMA150::getEnableLG() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ENABLE_LG_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setEnableLG(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ENABLE_LG_BIT, enabled);\n}\n\nbool BMA150::getEnableHG() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ENABLE_HG_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setEnableHG(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ENABLE_HG_BIT, enabled);\n}\n\nint8_t BMA150::getCounterLG() {\n    I2Cdev::readBits(devAddr, BMA150_RA_SMB150_CONF1, BMA150_COUNTER_LG_BIT, BMA150_COUNTER_LG_LENGTH, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setCounterLG(int8_t counter_lg) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_SMB150_CONF1, BMA150_COUNTER_LG_BIT, BMA150_COUNTER_LG_LENGTH, counter_lg);\n}\n\nint8_t BMA150::getCounterHG() {\n    I2Cdev::readBits(devAddr, BMA150_RA_SMB150_CONF1, BMA150_COUNTER_HG_BIT, BMA150_COUNTER_HG_LENGTH, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setCounterHG(int8_t counter_hg) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_SMB150_CONF1, BMA150_COUNTER_HG_BIT, BMA150_COUNTER_HG_LENGTH, counter_hg);\n}\n\nbool BMA150::getAnyMotion() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ANY_MOTION_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setAnyMotion(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ANY_MOTION_BIT, enabled);\n}\n\nbool BMA150::getAlert() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ALERT_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setAlert(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF1, BMA150_ALERT_BIT, enabled);\n}\n\n\n\n\n\n\nbool BMA150::getWakeUp() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_WAKE_UP_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setWakeUp(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_WAKE_UP_BIT, enabled);\n}\n\nint8_t BMA150::getWakeUpPause() {\n    I2Cdev::readBits(devAddr, BMA150_RA_SMB150_CONF1, BMA150_WAKE_UP_PAUSE_BIT, BMA150_WAKE_UP_PAUSE_LENGTH, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setWakeUpPause(int8_t wake_up_pause) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_SMB150_CONF1, BMA150_WAKE_UP_PAUSE_BIT, BMA150_WAKE_UP_PAUSE_LENGTH, wake_up_pause);\n}\n\nbool BMA150::getShadowDis() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_SHADOW_DIS_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setShadowDis(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_SHADOW_DIS_BIT, enabled);\n}\n\nbool BMA150::getLatchInt() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_LATCH_INT_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setLatchInt(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_LATCH_INT_BIT, enabled);\n}\n\nbool BMA150::getNewDataInt() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_NEW_DATA_INT_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setNewDataInt(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_NEW_DATA_INT_BIT, enabled);\n}\n\nbool BMA150::getEnableAdvInt() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_ENABLE_ADV_INT_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setEnableAdvInt(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_ENABLE_ADV_INT_BIT, enabled);\n}\n\nbool BMA150::getSPI4() {\n    I2Cdev::readBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_SPI4_BIT, buffer);\n\treturn buffer[0];\n}\nvoid BMA150::setSPI4(bool enabled) {\n    I2Cdev::writeBit(devAddr, BMA150_RA_SMB150_CONF2, BMA150_SPI4_BIT, enabled);\n}\n\n\t\t\n// LG / HG registers\nuint8_t BMA150::getLGThreshold() {\n    I2Cdev::readByte(devAddr, BMA150_RA_LG_THRESHOLD, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setLGThreshold(uint8_t lgthres) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_LG_THRESHOLD, lgthres);\n}\n\n\nuint8_t BMA150::getLGDuration() {\n    I2Cdev::readByte(devAddr, BMA150_RA_LG_DURATION, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setLGDuration(uint8_t lgdur) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_LG_DURATION, lgdur);\n}\n\n\nuint8_t BMA150::getHGThreshold() {\n    I2Cdev::readByte(devAddr, BMA150_RA_HG_THRESHOLD, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setHGThreshold(uint8_t hgthres) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_HG_THRESHOLD, hgthres);\n}\n\n\nuint8_t BMA150::getHGDuration() {\n    I2Cdev::readByte(devAddr, BMA150_RA_HG_DURATION, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setHGDuration(uint8_t hgdur) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_HG_DURATION, hgdur);\n}\n\n\n// MOTION_THRS register\nuint8_t BMA150::getMotionThreshold() {\n    I2Cdev::readByte(devAddr, BMA150_RA_MOTION_THRS, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setMotionThreshold(uint8_t mot_thres) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_MOTION_THRS, mot_thres);\n}\n\n// HYSTERESIS register\nuint8_t BMA150::getLGHysteresis() {\n    I2Cdev::readBits(devAddr, BMA150_RA_HYSTERESIS, BMA150_LG_HYST_BIT, BMA150_LG_HYST_LENGTH, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setLGHysteresis(uint8_t lg_hyst) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_HYSTERESIS, BMA150_LG_HYST_BIT, BMA150_LG_HYST_LENGTH,lg_hyst);\n}\n\nuint8_t BMA150::getHGHysteresis() {\n    I2Cdev::readBits(devAddr, BMA150_RA_HYSTERESIS, BMA150_HG_HYST_BIT, BMA150_HG_HYST_LENGTH, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setHGHysteresis(uint8_t hg_hyst) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_HYSTERESIS, BMA150_HG_HYST_BIT, BMA150_HG_HYST_LENGTH,hg_hyst);\n}\n\nuint8_t BMA150::getMotionDuration() {\n    I2Cdev::readBits(devAddr, BMA150_RA_HYSTERESIS, BMA150_ANY_MOTION_DUR_BIT, BMA150_ANY_MOTION_DUR_LENGTH, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setMotionDuration(uint8_t mot_dur) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_HYSTERESIS, BMA150_ANY_MOTION_DUR_BIT, BMA150_ANY_MOTION_DUR_LENGTH, mot_dur);\n}\n\n\t\n// CUSTOMER registers\nuint8_t BMA150::getCustom1() {\n    I2Cdev::readByte(devAddr, BMA150_RA_CUSTOMER1, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setCustom1(uint8_t custom1) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_CUSTOMER1, custom1);\n}\n\nuint8_t BMA150::getCustom2() {\n    I2Cdev::readByte(devAddr, BMA150_RA_CUSTOMER2, buffer);\n    return buffer[0];\n}\n\nvoid BMA150::setCustom2(uint8_t custom2) {\n    I2Cdev::writeByte(devAddr, BMA150_RA_CUSTOMER2, custom2);\n}\n\t\n// RANGE / BANDWIDTH registers\n\n/** Get Sensor Full Range\n * @return Current Sensor Full Scale Range\n * 0 = +/- 2G\n * 1 = +/- 4G\n * 2 = +/- 8G\n * @see BMA150_RA_RANGE_BWIDTH\n * @see BMA150_RANGE_BIT\n * @see BMA150_RANGE_LENGTH\n */\nuint8_t BMA150::getRange() {\n    I2Cdev::readBits(devAddr, BMA150_RA_RANGE_BWIDTH, BMA150_RANGE_BIT, BMA150_RANGE_LENGTH, buffer);\n    return buffer[0];\n}\n\n/** Set Sensor Full Range\n * @param range New full-scale range value\n * @see getRange()\n * @see BMA150_RA_RANGE_BWIDTH\n * @see BMA150_RANGE_BIT\n * @see BMA150_RANGE_LENGTH\n */\nvoid BMA150::setRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_RANGE_BWIDTH, BMA150_RANGE_BIT, BMA150_RANGE_LENGTH, range);\n}\n\n\n/** Get digital filter bandwidth.\n * The bandwidth parameter is used to setup the digital filtering of ADC output data to obtain\n * the desired bandwidth.\n * @return Current Sensor Bandwidth\n * 0 = 25Hz\n * 1 = 50Hz\n * 2 = 100Hz\n * 3 = 190Hz\n * 4 = 375Hz\n * 5 = 750Hz\n * 6 = 1500Hz\n * @see BMA150_RA_RANGE_BWIDTH\n * @see BMA150_RANGE_BIT\n * @see BMA150_RANGE_LENGTH\n */\nuint8_t BMA150::getBandwidth() {\n    I2Cdev::readBits(devAddr, BMA150_RA_RANGE_BWIDTH, BMA150_RANGE_BIT, BMA150_RANGE_LENGTH, buffer);\n    return buffer[0];\n}\n\n/** Set Sensor Full Range\n * @param bandwidth New bandwidth value\n * @see getBandwidth()\n * @see BMA150_RA_RANGE_BWIDTH\n * @see BMA150_RANGE_BIT\n * @see BMA150_RANGE_LENGTH\n */\nvoid BMA150::setBandwidth(uint8_t bandwidth) {\n    I2Cdev::writeBits(devAddr, BMA150_RA_RANGE_BWIDTH, BMA150_BANDWIDTH_BIT, BMA150_BANDWIDTH_LENGTH, bandwidth);\n}'