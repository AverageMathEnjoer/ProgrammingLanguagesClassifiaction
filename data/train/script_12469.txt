b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_callback = CSSQLite.dxCallback;\n  using sqlite3_stmt = CSSQLite.Vdbe;\n\n  public partial class CSSQLite\n  {\n\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** Main file for the SQLite library.  The routines in this file\n    ** implement the programmer interface to the library.  Routines in\n    ** other files are for internal use by SQLite and should not be\n    ** accessed by users of the library.\n    **\n    ** $Id: legacy.c,v 1.35 2009/08/07 16:56:00 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n    //#include "sqliteInt.h"\n\n    /*\n    ** Execute SQL code.  Return one of the SQLITE_ success/failure\n    ** codes.  Also write an error message into memory obtained from\n    ** malloc() and make pzErrMsg point to that message.\n    **\n    ** If the SQL is a query, then for each row in the query result\n    ** the xCallback() function is called.  pArg becomes the first\n    ** argument to xCallback().  If xCallback=NULL then no callback\n    ** is invoked, even for queries.\n    */\n    //OVERLOADS\n\n    public static int sqlite3_exec(\n    sqlite3 db,             /* The database on which the SQL executes */\n    string zSql,            /* The SQL to be executed */\n    int NoCallback, int NoArgs, int NoErrors\n    )\n    {\n      string Errors = "";\n      return sqlite3_exec( db, zSql, null, null, ref Errors );\n    }\n\n    public static int sqlite3_exec(\n    sqlite3 db,             /* The database on which the SQL executes */\n    string zSql,                /* The SQL to be executed */\n    sqlite3_callback xCallback, /* Invoke this callback routine */\n    object pArg,                /* First argument to xCallback() */\n    int NoErrors\n    )\n    {\n      string Errors = "";\n      return sqlite3_exec( db, zSql, xCallback, pArg, ref Errors );\n    }\n    public static int sqlite3_exec(\n    sqlite3 db,             /* The database on which the SQL executes */\n    string zSql,                /* The SQL to be executed */\n    sqlite3_callback xCallback, /* Invoke this callback routine */\n    object pArg,                /* First argument to xCallback() */\n    ref string pzErrMsg         /* Write error messages here */\n    )\n    {\n\n      int rc = SQLITE_OK;         /* Return code */\n      string zLeftover = "";      /* Tail of unprocessed SQL */\n      sqlite3_stmt pStmt = null;  /* The current SQL statement */\n      string[] azCols = null;     /* Names of result columns */\n      int nRetry = 0;             /* Number of retry attempts */\n      int callbackIsInit;         /* True if callback data is initialized */\n\n      if ( zSql == null ) zSql = "";\n\n      sqlite3_mutex_enter( db.mutex );\n      sqlite3Error( db, SQLITE_OK, 0 );\n      while ( ( rc == SQLITE_OK || ( rc == SQLITE_SCHEMA && ( ++nRetry ) < 2 ) ) && zSql != "" )\n      {\n        int nCol;\n        string[] azVals = null;\n\n        pStmt = null;\n        rc = sqlite3_prepare( db, zSql, -1, ref pStmt, ref zLeftover );\n        Debug.Assert( rc == SQLITE_OK || pStmt == null );\n        if ( rc != SQLITE_OK )\n        {\n          continue;\n        }\n        if ( pStmt == null )\n        {\n          /* this happens for a comment or white-space */\n          zSql = zLeftover;\n          continue;\n        }\n\n        callbackIsInit = 0;\n        nCol = sqlite3_column_count( pStmt );\n\n        while ( true )\n        {\n          int i;\n          rc = sqlite3_step( pStmt );\n\n          /* Invoke the callback function if required */\n          if ( xCallback != null && ( SQLITE_ROW == rc ||\n          ( SQLITE_DONE == rc && callbackIsInit == 0\n          && ( db.flags & SQLITE_NullCallback ) != 0 ) ) )\n          {\n            if ( 0 == callbackIsInit )\n            {\n              azCols = new string[nCol];//sqlite3DbMallocZero(db, 2*nCol*sizeof(const char*) + 1);\n              if ( azCols == null )\n              {\n                goto exec_out;\n              }\n              for ( i = 0 ; i < nCol ; i++ )\n              {\n                azCols[i] = sqlite3_column_name( pStmt, i );\n                /* sqlite3VdbeSetColName() installs column names as UTF8\n                ** strings so there is no way for sqlite3_column_name() to fail. */\n                Debug.Assert( azCols[i] != null );\n              }\n              callbackIsInit = 1;\n            }\n            if ( rc == SQLITE_ROW )\n            {\n              azVals = new string[nCol];// azCols[nCol];\n              for ( i = 0 ; i < nCol ; i++ )\n              {\n                azVals[i] = sqlite3_column_text( pStmt, i );\n                if ( azVals[i] == null && sqlite3_column_type( pStmt, i ) != SQLITE_NULL )\n                {\n          ////        db.mallocFailed = 1;\n                  goto exec_out;\n                }\n              }\n            }\n            if ( xCallback( pArg, nCol, azVals, azCols ) != 0 )\n            {\n              rc = SQLITE_ABORT;\n              sqlite3VdbeFinalize( pStmt );\n              pStmt = null;\n              sqlite3Error( db, SQLITE_ABORT, 0 );\n              goto exec_out;\n            }\n          }\n\n          if ( rc != SQLITE_ROW )\n          {\n            rc = sqlite3VdbeFinalize( pStmt );\n            pStmt = null;\n            if ( rc != SQLITE_SCHEMA )\n            {\n              nRetry = 0;\n              if ( ( zSql = zLeftover ) != "" )\n              {\n                int zindex = 0;\n                while ( zindex < zSql.Length && sqlite3Isspace( zSql[zindex] ) ) zindex++;\n                if ( zindex != 0 ) zSql = zindex < zSql.Length ? zSql.Substring( zindex ) : "";\n              }\n            }\n            break;\n          }\n        }\n\n        //sqlite3DbFree( db, ref  azCols );\n        azCols = null;\n      }\n\nexec_out:\n      if ( pStmt != null ) sqlite3VdbeFinalize( pStmt );\n      //sqlite3DbFree( db, ref  azCols );\n\n      rc = sqlite3ApiExit( db, rc );\n      if ( rc != SQLITE_OK && ALWAYS( rc == sqlite3_errcode( db ) ) && pzErrMsg != null )\n      {\n        //int nErrMsg = 1 + sqlite3Strlen30(sqlite3_errmsg(db));\n        //pzErrMsg = sqlite3Malloc(nErrMsg);\n        //if (pzErrMsg)\n        //{\n        //   memcpy(pzErrMsg, sqlite3_errmsg(db), nErrMsg);\n        //}else{\n        //rc = SQLITE_NOMEM;\n        //sqlite3Error(db, SQLITE_NOMEM, 0);\n        //}\n        pzErrMsg = sqlite3_errmsg( db );\n      }\n      else if ( pzErrMsg != "" )\n      {\n        pzErrMsg = "";\n      }\n\n      Debug.Assert( ( rc & db.errMask ) == rc );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n  }\n}\n'