b'using i64 = System.Int64;\nusing u8 = System.Byte;\nusing u64 = System.UInt64;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** Header file for the Virtual DataBase Engine (VDBE)\n    **\n    ** This header defines the interface to the virtual database engine\n    ** or VDBE.  The VDBE implements an abstract machine that runs a\n    ** simple program to access and modify the underlying database.\n    **\n    ** $Id: vdbe.h,v 1.142 2009/07/24 17:58:53 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#if !_SQLITE_VDBE_H_\n    //#define _SQLITE_VDBE_H_\n    //#include <stdio.h>\n\n    /*\n    ** A single VDBE is an opaque structure named "Vdbe".  Only routines\n    ** in the source file sqliteVdbe.c are allowed to see the insides\n    ** of this structure.\n    */\n    //typedef struct Vdbe Vdbe;\n\n    /*\n    ** The names of the following types declared in vdbeInt.h are required\n    ** for the VdbeOp definition.\n    */\n    //typedef struct VdbeFunc VdbeFunc;\n    //typedef struct Mem Mem;\n\n    /*\n    ** A single instruction of the virtual machine has an opcode\n    ** and as many as three operands.  The instruction is recorded\n    ** as an instance of the following structure:\n    */\n    public class union_p4\n    {             /* forth parameter */\n      public int i;                /* Integer value if p4type==P4_INT32 */\n      public object p;             /* Generic pointer */\n      //public string z;           /* Pointer to data for string (char array) types */\n      public string z;             // In C# string is unicode, so use byte[] instead\n      public i64 pI64;             /* Used when p4type is P4_INT64 */\n      public double pReal;         /* Used when p4type is P4_REAL */\n      public FuncDef pFunc;        /* Used when p4type is P4_FUNCDEF */\n      public VdbeFunc pVdbeFunc;   /* Used when p4type is P4_VDBEFUNC */\n      public CollSeq pColl;        /* Used when p4type is P4_COLLSEQ */\n      public Mem pMem;             /* Used when p4type is P4_MEM */\n      public VTable pVtab;         /* Used when p4type is P4_VTAB */\n      public KeyInfo pKeyInfo;     /* Used when p4type is P4_KEYINFO */\n      public int[] ai;             /* Used when p4type is P4_INTARRAY */\n      public dxDel pFuncDel;       /* Used when p4type is P4_FUNCDEL */\n    } ;\n    public class VdbeOp\n    {\n      public u8 opcode;           /* What operation to perform */\n      public int p4type;          /* One of the P4_xxx constants for p4 */\n      public u8 opflags;          /* Not currently used */\n      public u8 p5;               /* Fifth parameter is an unsigned character */\n#if DEBUG_CLASS_VDBEOP || DEBUG_CLASS_ALL\npublic int _p1;              /* First operand */\npublic int p1\n{\nget { return _p1; }\nset { _p1 = value; }\n}\n\npublic int _p2;              /* Second parameter (often the jump destination) */\npublic int p2\n{\nget { return _p2; }\nset { _p2 = value; }\n}\n\npublic int _p3;              /* The third parameter */\npublic int p3\n{\nget { return _p3; }\nset { _p3 = value; }\n}\n#else\n      public int p1;              /* First operand */\n      public int p2;              /* Second parameter (often the jump destination) */\n      public int p3;              /* The third parameter */\n#endif\n      public union_p4 p4 = new union_p4();\n#if SQLITE_DEBUG || DEBUG\n      public string zComment;     /* Comment to improve readability */\n#endif\n#if VDBE_PROFILE\npublic int cnt;             /* Number of times this instruction was executed */\npublic u64 cycles;         /* Total time spend executing this instruction */\n#endif\n    };\n    //typedef struct VdbeOp VdbeOp;\n\n    /*\n    ** A smaller version of VdbeOp used for the VdbeAddOpList() function because\n    ** it takes up less space.\n    */\n    public struct VdbeOpList\n    {\n      public u8 opcode;  /* What operation to perform */\n      public int p1;     /* First operand */\n      public int p2;     /* Second parameter (often the jump destination) */\n      public int p3;     /* Third parameter */\n      public VdbeOpList( u8 opcode, int p1, int p2, int p3 )\n      {\n        this.opcode = opcode;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n      }\n\n    };\n    //typedef struct VdbeOpList VdbeOpList;\n\n    /*\n    ** Allowed values of VdbeOp.p3type\n    */\n    const int P4_NOTUSED = 0;   /* The P4 parameter is not used */\n    const int P4_DYNAMIC = ( -1 );  /* Pointer to a string obtained from sqliteMalloc=(); */\n    const int P4_STATIC = ( -2 );  /* Pointer to a static string */\n    const int P4_COLLSEQ = ( -4 );  /* P4 is a pointer to a CollSeq structure */\n    const int P4_FUNCDEF = ( -5 );  /* P4 is a pointer to a FuncDef structure */\n    const int P4_KEYINFO = ( -6 );  /* P4 is a pointer to a KeyInfo structure */\n    const int P4_VDBEFUNC = ( -7 );  /* P4 is a pointer to a VdbeFunc structure */\n    const int P4_MEM = ( -8 );  /* P4 is a pointer to a Mem*    structure */\n    const int P4_TRANSIENT = ( -9 ); /* P4 is a pointer to a transient string */\n    const int P4_VTAB = ( -10 ); /* P4 is a pointer to an sqlite3_vtab structure */\n    const int P4_MPRINTF = ( -11 ); /* P4 is a string obtained from sqlite3_mprintf=(); */\n    const int P4_REAL = ( -12 ); /* P4 is a 64-bit floating point value */\n    const int P4_INT64 = ( -13 ); /* P4 is a 64-bit signed integer */\n    const int P4_INT32 = ( -14 ); /* P4 is a 32-bit signed integer */\n    const int P4_INTARRAY = ( -15 ); /* #define P4_INTARRAY (-15) /* P4 is a vector of 32-bit integers */\n\n    /* When adding a P4 argument using P4_KEYINFO, a copy of the KeyInfo structure\n    ** is made.  That copy is freed when the Vdbe is finalized.  But if the\n    ** argument is P4_KEYINFO_HANDOFF, the passed in pointer is used.  It still\n    ** gets freed when the Vdbe is finalized so it still should be obtained\n    ** from a single sqliteMalloc().  But no copy is made and the calling\n    ** function should *not* try to free the KeyInfo.\n    */\n    const int P4_KEYINFO_HANDOFF = ( -16 );  // #define P4_KEYINFO_HANDOFF (-16)\n    const int P4_KEYINFO_STATIC = ( -17 );   // #define P4_KEYINFO_STATIC  (-17)\n\n    /*\n    ** The Vdbe.aColName array contains 5n Mem structures, where n is the\n    ** number of columns of data returned by the statement.\n    */\n    //#define COLNAME_NAME     0\n    //#define COLNAME_DECLTYPE 1\n    //#define COLNAME_DATABASE 2\n    //#define COLNAME_TABLE    3\n    //#define COLNAME_COLUMN   4\n    //#if SQLITE_ENABLE_COLUMN_METADATA\n    //# define COLNAME_N        5      /* Number of COLNAME_xxx symbols */\n    //#else\n    //# ifdef SQLITE_OMIT_DECLTYPE\n    //#   define COLNAME_N      1      /* Store only the name */\n    //# else\n    //#   define COLNAME_N      2      /* Store the name and decltype */\n    //# endif\n    //#endif\n    const int COLNAME_NAME = 0;\n    const int COLNAME_DECLTYPE = 1;\n    const int COLNAME_DATABASE = 2;\n    const int COLNAME_TABLE = 3;\n    const int COLNAME_COLUMN = 4;\n#if SQLITE_ENABLE_COLUMN_METADATA\nconst int COLNAME_N = 5;     /* Number of COLNAME_xxx symbols */\n#else\n# if SQLITE_OMIT_DECLTYPE\nconst int COLNAME_N = 1;     /* Number of COLNAME_xxx symbols */\n# else\n    const int COLNAME_N = 2;\n# endif\n#endif\n\n    /*\n** The following macro converts a relative address in the p2 field\n** of a VdbeOp structure into a negative number so that\n** sqlite3VdbeAddOpList() knows that the address is relative.  Calling\n** the macro again restores the address.\n*/\n    //#define ADDR(X)  (-1-(X))\n    static int ADDR( int x ) { return -1 - x; }\n    /*\n    ** The makefile scans the vdbe.c source file and creates the "opcodes.h"\n    ** header file that defines a number for each opcode used by the VDBE.\n    */\n    //#include "opcodes.h"\n\n    /*\n    ** Prototypes for the VDBE interface.  See comments on the implementation\n    ** for a description of what each of these routines does.\n    */\n    /*\n    ** Prototypes for the VDBE interface.  See comments on the implementation\n    ** for a description of what each of these routines does.\n    */\n    //Vdbe *sqlite3VdbeCreate(sqlite3*);\n    //int sqlite3VdbeAddOp0(Vdbe*,int);\n    //int sqlite3VdbeAddOp1(Vdbe*,int,int);\n    //int sqlite3VdbeAddOp2(Vdbe*,int,int,int);\n    //int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);\n    //int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);\n    //int sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp);\n    //void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);\n    //void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);\n    //void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);\n    //void sqlite3VdbeChangeP5(Vdbe*, u8 P5);\n    //void sqlite3VdbeJumpHere(Vdbe*, int addr);\n    //void sqlite3VdbeChangeToNoop(Vdbe*, int addr, int N);\n    //void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);\n    //void sqlite3VdbeUsesBtree(Vdbe*, int);\n    //VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);\n    //int sqlite3VdbeMakeLabel(Vdbe*);\n    //void sqlite3VdbeDelete(Vdbe*);\n    //void sqlite3VdbeMakeReady(Vdbe*,int,int,int,int);\n    //int sqlite3VdbeFinalize(Vdbe*);\n    //void sqlite3VdbeResolveLabel(Vdbe*, int);\n    //int sqlite3VdbeCurrentAddr(Vdbe*);\n    //#if SQLITE_DEBUG\n    //  void sqlite3VdbeTrace(Vdbe*,FILE*);\n    //#endif\n    //void sqlite3VdbeResetStepResult(Vdbe*);\n    //int sqlite3VdbeReset(Vdbe*);\n    //void sqlite3VdbeSetNumCols(Vdbe*,int);\n    //int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));\n    //void sqlite3VdbeCountChanges(Vdbe*);\n    //sqlite3 *sqlite3VdbeDb(Vdbe*);\n    //void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, int);\n    //void sqlite3VdbeSwap(Vdbe*,Vdbe*);\n\n#if SQLITE_ENABLE_MEMORY_MANAGEMENT\n//int sqlite3VdbeReleaseMemory(int);\n#endif\n    //UnpackedRecord *sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,char*,int);\n    //void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord*);\n    //int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);\n\n\n#if !NDEBUG\n    //void sqlite3VdbeComment(Vdbe*, const char*, ...);\n    static void VdbeComment( Vdbe v, string zFormat, params object[] ap ) { sqlite3VdbeComment( v, zFormat, ap ); }//# define VdbeComment(X)  sqlite3VdbeComment X\n    //void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);\n    static void VdbeNoopComment( Vdbe v, string zFormat, params object[] ap ) { sqlite3VdbeNoopComment( v, zFormat, ap ); }//# define VdbeNoopComment(X)  sqlite3VdbeNoopComment X\n#else\n//# define VdbeComment(X)\nstatic void VdbeComment( Vdbe v, string zFormat, params object[] ap ) { }\n//# define VdbeNoopComment(X)\nstatic void VdbeNoopComment( Vdbe v, string zFormat, params object[] ap ) { }\n#endif\n  }\n}\n'