b'struct node{\n\tll ans;\n\tvoid leaf(int val){\n\t\tans = val;\n\t}\n\t\n\tvoid merge(node r, node l){\n\t\tans = r.ans + l.ans;\n\t}\t\n\t\n};\nclass st{\n\tint n;\n\tnode* T;\n\tint* a;\n\tpublic:\n\t#define l(x) 2*x\n\t#define r(x) 2*x+1\n\t#define lpart left, lo, mid\n\t#define rpart right, mid+1, hi\n\tst() {}\n\tst(int x){\n\t\ta = new int[x];\n\t\tclr(a);\n\t\tn = 1;\n\t\twhile(n <= x) n *= 2; n *= 2;\n\t\tT = new node[n];\n\t\tn = x;\n\t\tbuild(1, 0, n-1);\n\t}\n\tst(int *arr, int x){\n\t\ta = arr;\n\t\tn = 1;\n\t\twhile(n <= x) n *= 2; n *= 2;\n\t\tT = new node[n];\n\t\tn = x;\n\t\tbuild(1, 0, n-1);\n\t}\n\tvoid build(int id, int lo, int hi){\n\t\tif(lo == hi){\n\t\t\tT[id].leaf(a[lo]);\n\t\t\treturn;\n\t\t}\n\t\tint left = l(id), right = r(id), mid = (lo+hi)/2;\n\t\tbuild(lpart);\n\t\tbuild(rpart);\n\t\tT[id].merge(T[left], T[right]);\n\t}\n\tvoid update(int pos, int val){\n\t\tupdate(1, 0, n-1, pos, val);\n\t}\n\tvoid update(int id, int lo, int hi, int pos, int val){\n\t\tif(lo==hi and lo==pos){\n\t\t\ta[pos] = val;\n\t\t\tT[id].leaf(a[lo]);\n\t\t\treturn;\n\t\t}\n\t\tint left = l(id), right = r(id), mid = (lo+hi)/2;\n\t\tif(pos <= mid) update(lpart, pos, val);\n\t\telse update(rpart, pos, val);\n\t\tT[id].merge(T[left], T[right]);\n\t}\n\tll query(int x, int y){\n\t\treturn query(1, 0, n-1, x, y).ans;\n\t}\n\tnode query(int id, int lo, int hi, int x, int y){\n\t\tif(lo==x and hi==y){\n\t\t\treturn T[id];\n\t\t}\n\t\tint left = l(id), right = r(id), mid = (lo+hi)/2;\n\t\tif(y <= mid) return query(lpart, x, y);\n\t\telse if(x>mid) return query(rpart, x, y);\n\t\tnode L = query(lpart, x, mid);\n\t\tnode R = query(rpart, mid+1, y);\n\t\tnode res;\n\t\tres.merge(L, R);\n\t\treturn res;\n\t}\n};\n'