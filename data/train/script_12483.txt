b'namespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2007 August 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** @(#) $Id: journal.c,v 1.9 2009/01/20 17:06:27 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n#if SQLITE_ENABLE_ATOMIC_WRITE\n\n/*\n** This file implements a special kind of sqlite3_file object used\n** by SQLite to create journal files if the atomic-write optimization\n** is enabled.\n**\n** The distinctive characteristic of this sqlite3_file is that the\n** actual on disk file is created lazily. When the file is created,\n** the caller specifies a buffer size for an in-memory buffer to\n** be used to service read() and write() requests. The actual file\n** on disk is not created or populated until either:\n**\n**   1) The in-memory representation grows too large for the allocated\n**      buffer, or\n**   2) The sqlite3JournalCreate() function is called.\n*/\n\n//#include "sqliteInt.h"\n\n\n/*\n** A JournalFile object is a subclass of sqlite3_file used by\n** as an open file handle for journal files.\n*/\nstruct JournalFile {\nsqlite3_io_methods pMethod;    /* I/O methods on journal files */\nint nBuf;                       /* Size of zBuf[] in bytes */\nchar *zBuf;                     /* Space to buffer journal writes */\nint iSize;                      /* Amount of zBuf[] currently used */\nint flags;                      /* xOpen flags */\nsqlite3_vfs pVfs;              /* The "real" underlying VFS */\nsqlite3_file pReal;            /* The "real" underlying file descriptor */\nconst char *zJournal;           /* Name of the journal file */\n};\ntypedef struct JournalFile JournalFile;\n\n/*\n** If it does not already exists, create and populate the on-disk file\n** for JournalFile p.\n*/\nstatic int createFile(JournalFile p){\nint rc = SQLITE_OK;\nif( null==p.pReal ){\nsqlite3_file pReal = (sqlite3_file *)&p[1];\nrc = sqlite3OsOpen(p.pVfs, p.zJournal, pReal, p.flags, 0);\nif( rc==SQLITE_OK ){\np.pReal = pReal;\nif( p.iSize>0 ){\nDebug.Assert(p.iSize<=p.nBuf);\nrc = sqlite3OsWrite(p.pReal, p.zBuf, p.iSize, 0);\n}\n}\n}\nreturn rc;\n}\n\n/*\n** Close the file.\n*/\nstatic int jrnlClose(sqlite3_file pJfd){\nJournalFile p = (JournalFile *)pJfd;\nif( p.pReal ){\nsqlite3OsClose(p.pReal);\n}\n//sqlite3DbFree(db,p.zBuf);\nreturn SQLITE_OK;\n}\n\n/*\n** Read data from the file.\n*/\nstatic int jrnlRead(\nsqlite3_file *pJfd,    /* The journal file from which to read */\nvoid *zBuf,            /* Put the results here */\nint iAmt,              /* Number of bytes to read */\nsqlite_int64 iOfst     /* Begin reading at this offset */\n){\nint rc = SQLITE_OK;\nJournalFile *p = (JournalFile *)pJfd;\nif( p->pReal ){\nrc = sqlite3OsRead(p->pReal, zBuf, iAmt, iOfst);\n}else if( (iAmt+iOfst)>p->iSize ){\nrc = SQLITE_IOERR_SHORT_READ;\n}else{\nmemcpy(zBuf, &p->zBuf[iOfst], iAmt);\n}\nreturn rc;\n}\n\n/*\n** Write data to the file.\n*/\nstatic int jrnlWrite(\nsqlite3_file pJfd,    /* The journal file into which to write */\nconst void *zBuf,      /* Take data to be written from here */\nint iAmt,              /* Number of bytes to write */\nsqlite_int64 iOfst     /* Begin writing at this offset into the file */\n){\nint rc = SQLITE_OK;\nJournalFile p = (JournalFile *)pJfd;\nif( null==p.pReal && (iOfst+iAmt)>p.nBuf ){\nrc = createFile(p);\n}\nif( rc==SQLITE_OK ){\nif( p.pReal ){\nrc = sqlite3OsWrite(p.pReal, zBuf, iAmt, iOfst);\n}else{\nmemcpy(p.zBuf[iOfst], zBuf, iAmt);\nif( p.iSize<(iOfst+iAmt) ){\np.iSize = (iOfst+iAmt);\n}\n}\n}\nreturn rc;\n}\n\n/*\n** Truncate the file.\n*/\nstatic int jrnlTruncate(sqlite3_file pJfd, sqlite_int64 size){\nint rc = SQLITE_OK;\nJournalFile p = (JournalFile *)pJfd;\nif( p.pReal ){\nrc = sqlite3OsTruncate(p.pReal, size);\n}else if( size<p.iSize ){\np.iSize = size;\n}\nreturn rc;\n}\n\n/*\n** Sync the file.\n*/\nstatic int jrnlSync(sqlite3_file pJfd, int flags){\nint rc;\nJournalFile p = (JournalFile *)pJfd;\nif( p.pReal ){\nrc = sqlite3OsSync(p.pReal, flags);\n}else{\nrc = SQLITE_OK;\n}\nreturn rc;\n}\n\n/*\n** Query the size of the file in bytes.\n*/\nstatic int jrnlFileSize(sqlite3_file pJfd, sqlite_int64 pSize){\nint rc = SQLITE_OK;\nJournalFile p = (JournalFile *)pJfd;\nif( p.pReal ){\nrc = sqlite3OsFileSize(p.pReal, pSize);\n}else{\npSize = (sqlite_int64) p.iSize;\n}\nreturn rc;\n}\n\n/*\n** Table of methods for JournalFile sqlite3_file object.\n*/\nstatic struct sqlite3_io_methods JournalFileMethods = {\n1,             /* iVersion */\njrnlClose,     /* xClose */\njrnlRead,      /* xRead */\njrnlWrite,     /* xWrite */\njrnlTruncate,  /* xTruncate */\njrnlSync,      /* xSync */\njrnlFileSize,  /* xFileSize */\n0,             /* xLock */\n0,             /* xUnlock */\n0,             /* xCheckReservedLock */\n0,             /* xFileControl */\n0,             /* xSectorSize */\n0              /* xDeviceCharacteristics */\n};\n\n/*\n** Open a journal file.\n*/\nint sqlite3JournalOpen(\nsqlite3_vfs pVfs,         /* The VFS to use for actual file I/O */\nconst char *zName,         /* Name of the journal file */\nsqlite3_file pJfd,        /* Preallocated, blank file handle */\nint flags,                 /* Opening flags */\nint nBuf                   /* Bytes buffered before opening the file */\n){\nJournalFile p = (JournalFile *)pJfd;\nmemset(p, 0, sqlite3JournalSize(pVfs));\nif( nBuf>0 ){\np.zBuf = sqlite3MallocZero(nBuf);\nif( null==p.zBuf ){\nreturn SQLITE_NOMEM;\n}\n}else{\nreturn sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);\n}\np.pMethod = &JournalFileMethods;\np.nBuf = nBuf;\np.flags = flags;\np.zJournal = zName;\np.pVfs = pVfs;\nreturn SQLITE_OK;\n}\n\n/*\n** If the argument p points to a JournalFile structure, and the underlying\n** file has not yet been created, create it now.\n*/\nint sqlite3JournalCreate(sqlite3_file p){\nif( p.pMethods!=&JournalFileMethods ){\nreturn SQLITE_OK;\n}\nreturn createFile((JournalFile *)p);\n}\n\n/*\n** Return the number of bytes required to store a JournalFile that uses vfs\n** pVfs to create the underlying on-disk files.\n*/\nint sqlite3JournalSize(sqlite3_vfs pVfs){\nreturn (pVfs->szOsFile+sizeof(JournalFile));\n}\n#endif\n  }\n}\n'