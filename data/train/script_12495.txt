b"{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\nmodule Database.Beam.Migrate.Types\n  ( -- * Checked database entities\n    CheckedDatabaseSettings\n\n  , IsCheckedDatabaseEntity(..)\n  , CheckedDatabaseEntityDescriptor(..)\n  , CheckedDatabaseEntity(..)\n\n  , unCheckDatabase, collectChecks\n  , renameCheckedEntity\n\n    -- ** Modifyinging checked entities\n    --\n    --    The functions in this section can be used to modify 'CheckedDatabaseSettings' objects.\n  , CheckedFieldModification\n  , checkedFieldNamed\n\n  , modifyCheckedTable\n  , checkedTableModification\n\n    -- * Predicates\n  , DatabasePredicate(..)\n  , SomeDatabasePredicate(..)\n  , PredicateSpecificity(..)\n  , QualifiedName(..)\n\n  , p\n\n    -- * Entity checks\n  , TableCheck(..), DomainCheck(..)\n  , FieldCheck(..)\n\n    -- * Migrations\n  , MigrationStep(..), MigrationSteps(..)\n  , Migration, MigrationF(..)\n\n  , MigrationCommand(..), MigrationDataLoss(..)\n\n  , runMigrationSteps, runMigrationSilenced\n  , executeMigration, eraseMigrationType, migrationStep\n  , upDown, migrationDataLoss\n\n  , migrateScript, evaluateDatabase, stepNames ) where\n\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Migrate.Types.CheckedEntities\nimport Database.Beam.Migrate.Types.Predicates\nimport Control.Monad.Free.Church\nimport Control.Arrow\nimport Control.Category (Category)\n\n#if !MIN_VERSION_base(4, 11, 0)\nimport Data.Semigroup\n#endif\nimport Data.Text (Text)\n\n-- * Migration types\n\n-- | Represents a particular step in a migration\ndata MigrationStep be next where\n    MigrationStep :: Text -> Migration be a -> (a -> next) -> MigrationStep be next\nderiving instance Functor (MigrationStep be)\n\n-- | A series of 'MigrationStep's that take a database from the schema in @from@\n-- to the one in @to@. Use the 'migrationStep' function and the arrow interface\n-- to sequence 'MigrationSteps'.\nnewtype MigrationSteps be from to = MigrationSteps (Kleisli (F (MigrationStep be)) from to)\n  deriving (Category, Arrow)\n\n-- | Free monadic function for 'Migration's\ndata MigrationF be next where\n  MigrationRunCommand\n    :: { _migrationUpCommand   :: BeamSqlBackendSyntax be\n       -- ^ What to execute when applying the migration\n       , _migrationDownCommand :: Maybe (BeamSqlBackendSyntax be)\n       -- ^ What to execute when unapplying the migration\n       , _migrationNext :: next }\n    -> MigrationF be next\nderiving instance Functor (MigrationF be)\n\n-- | A sequence of potentially reversible schema update commands\ntype Migration be = F (MigrationF be)\n\n-- | Information on whether a 'MigrationCommand' loses data. You can\n-- monoidally combine these to get the potential data loss for a\n-- sequence of commands.\ndata MigrationDataLoss\n  = MigrationLosesData\n    -- ^ The command loses data\n  | MigrationKeepsData\n    -- ^ The command keeps all data\n  deriving Show\n\ninstance Semigroup MigrationDataLoss where\n    (<>) = mappend\n\ninstance Monoid MigrationDataLoss where\n    mempty = MigrationKeepsData\n    mappend MigrationLosesData _ = MigrationLosesData\n    mappend _ MigrationLosesData = MigrationLosesData\n    mappend MigrationKeepsData MigrationKeepsData = MigrationKeepsData\n\n-- | A migration command along with metadata on whether the command can lose data\ndata MigrationCommand be\n  = MigrationCommand\n  { migrationCommand :: BeamSqlBackendSyntax be\n    -- ^ The command to run\n  , migrationCommandDataLossPossible :: MigrationDataLoss\n    -- ^ Information on whether the migration loses data\n  }\nderiving instance Show (BeamSqlBackendSyntax be) => Show (MigrationCommand be)\n\n-- | Run the migration steps between the given indices, using a custom execution function.\nrunMigrationSteps :: Monad m\n                  => Int -- ^ Zero-based index of the first step to run\n                  -> Maybe Int -- ^ Index of the last step to run, or 'Nothing' to run every step\n                  -> MigrationSteps be () a -- ^ The set of steps to run\n                  -> (forall a'. Int -> Text -> Migration be a' -> m a')\n                  -- ^ Callback for each step. Called with the step index, the\n                  -- step description and the migration.\n                  -> m a\nrunMigrationSteps firstIdx lastIdx (MigrationSteps steps) runMigration =\n  runF (runKleisli steps ()) finish step 0\n  where finish x _ = pure x\n        step (MigrationStep nm doStep next) i =\n          if i >= firstIdx && maybe True (i <) lastIdx\n          then runMigration i nm doStep >>= \\x -> next x (i + 1)\n          else next (runMigrationSilenced doStep) (i + 1)\n\n-- | Get the result of a migration, without running any steps\nrunMigrationSilenced :: Migration be a -> a\nrunMigrationSilenced m = runF m id step\n  where\n    step (MigrationRunCommand _ _ next) = next\n\n-- | Remove the explicit source and destination schemas from a 'MigrationSteps' object\neraseMigrationType :: a -> MigrationSteps be a a' -> MigrationSteps be () ()\neraseMigrationType a (MigrationSteps steps) = MigrationSteps (arr (const a) >>> steps >>> arr (const ()))\n\n-- | Create a 'MigrationSteps' from the given description and migration function.\nmigrationStep :: Text -> (a -> Migration be a') -> MigrationSteps be a a'\nmigrationStep stepName migration =\n    MigrationSteps (Kleisli (\\a -> liftF (MigrationStep stepName (migration a) id)))\n\n-- | Given a command in the forward direction, and an optional one in the\n-- reverse direction, construct a 'Migration' that performs the given\n-- command. Multiple commands can be sequenced monadically.\nupDown :: BeamSqlBackendSyntax be -> Maybe (BeamSqlBackendSyntax be) -> Migration be ()\nupDown up down = liftF (MigrationRunCommand up down ())\n\n-- | Given functions to render a migration step description and the underlying\n-- syntax, create a script for the given 'MigrationSteps'.\nmigrateScript :: forall be m a. (Monoid m, Semigroup m, BeamSqlBackend be)\n              => (Text -> m)\n              -- ^ Called at the beginning of each 'MigrationStep' with the step description\n              -> (BeamSqlBackendSyntax be -> m)\n              -- ^ Called for each command in the migration step\n              -> MigrationSteps be () a\n              -- ^ The set of steps to run\n              -> m\nmigrateScript renderMigrationHeader renderMigrationSyntax (MigrationSteps steps) =\n  runF (runKleisli steps ()) (\\_ x -> x)\n    (\\(MigrationStep header migration next) x ->\n       let (res, script) = renderMigration migration mempty\n       in next res (x <> renderMigrationHeader header <> script)) mempty\n  where\n    renderMigration :: forall a'. Migration be a' -> m -> (a', m)\n    renderMigration migrationSteps =\n      runF migrationSteps (,)\n           (\\(MigrationRunCommand a _ next) x -> next (x <> renderMigrationSyntax a))\n\n-- | Execute a given migration, provided a command to execute arbitrary syntax.\n--   You usually use this with 'runNoReturn'.\nexecuteMigration :: Applicative m => (BeamSqlBackendSyntax be -> m ()) -> Migration be a -> m a\nexecuteMigration runSyntax go = runF go pure doStep\n  where\n    doStep (MigrationRunCommand cmd _ next) =\n      runSyntax cmd *> next\n\n-- | Given a migration, get the potential data loss, if it's run top-down\nmigrationDataLoss :: Migration be a -> MigrationDataLoss\nmigrationDataLoss go = runF go (\\_ -> MigrationKeepsData)\n                         (\\(MigrationRunCommand _ x next) ->\n                            case x of\n                              Nothing -> MigrationLosesData\n                              _ -> next)\n\n-- | Run a 'MigrationSteps' without executing any of the commands against a\n-- database.\nevaluateDatabase :: forall be a. MigrationSteps be () a -> a\nevaluateDatabase (MigrationSteps f) = runF (runKleisli f ()) id (\\(MigrationStep _ migration next) -> next (runMigration migration))\n  where\n    runMigration :: forall a'. Migration be a' -> a'\n    runMigration migration = runF migration id (\\(MigrationRunCommand _ _ next) -> next)\n\n-- | Collect the names of all steps in hte given 'MigrationSteps'\nstepNames :: forall be a. MigrationSteps be () a -> [Text]\nstepNames (MigrationSteps f) = runF (runKleisli f ()) (\\_ x -> x) (\\(MigrationStep nm migration next) x -> next (runMigration migration) (x ++ [nm])) []\n  where\n    runMigration :: forall a'. Migration be a' -> a'\n    runMigration migration = runF migration id (\\(MigrationRunCommand _ _ next) -> next)\n\n"