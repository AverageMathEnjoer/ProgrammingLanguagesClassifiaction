b'#\' Shrink log2 fold changes\n#\'\n#\' Adds shrunken log2 fold changes (LFC) and SE to a\n#\' results table from \\code{DESeq} run without LFC shrinkage.\n#\' For consistency with \\code{results}, the column name \\code{lfcSE}\n#\' is used here although what is returned is a posterior SD.\n#\' Three shrinkage estimators for LFC are available via \\code{type}\n#\' (see the vignette for more details on the estimators).\n#\' The apeglm publication demonstrates that \'apeglm\' and \'ashr\' outperform\n#\' the original \'normal\' shrinkage estimator.\n#\'\n#\' See vignette for a comparison of shrinkage estimators on an example dataset.\n#\' For all shrinkage methods, details on the prior is included in\n#\' \\code{priorInfo(res)}, including the \\code{fitted_g} mixture for ashr.\n#\'\n#\' \\strong{For type="apeglm":}\n#\' Specifying \\code{apeglm} passes along DESeq2 MLE log2\n#\' fold changes and standard errors to the \\code{apeglm} function\n#\' in the apeglm package, and re-estimates posterior LFCs for\n#\' the coefficient specified by \\code{coef}.\n#\'\n#\' \\strong{For type="ashr":}\n#\' Specifying \\code{ashr} passes along DESeq2 MLE log2\n#\' fold changes and standard errors to the \\code{ash} function\n#\' in the ashr package, \n#\' with arguments \\code{mixcompdist="normal"} and \\code{method="shrink"}.\n#\'\n#\' \\strong{For type="normal":}\n#\' For design as a formula, shrinkage cannot be applied\n#\' to coefficients in a model with interaction terms. \n#\' For user-supplied model matrices, shrinkage is only\n#\' supported via \\code{coef}. \\code{coef} will make use\n#\' of standard model matrices, while \\code{contrast}\n#\' will make use of expanded model matrices, and for the\n#\' latter, a results object should be provided to\n#\' \\code{res}. With numeric- or list-style contrasts,\n#\' it is possible to use \\code{lfcShrink}, but likely easier to use\n#\' \\code{DESeq} with \\code{betaPrior=TRUE} followed by \\code{results},\n#\' because the numeric or list should reference the coefficients\n#\' from the expanded model matrix. These coefficients will be printed\n#\' to console if \'contrast\' is used.\n#\' \n#\' @param dds a DESeqDataSet object, after running \\code{\\link{DESeq}}\n#\' @param coef the name or number of the coefficient (LFC) to shrink,\n#\' consult \\code{resultsNames(dds)} after running \\code{DESeq(dds)}.\n#\' note: only \\code{coef} or \\code{contrast} can be specified, not both.\n#\' \\code{apeglm} requires use of \\code{coef}.\n#\' For \\code{normal}, one of \\code{coef} or \\code{contrast} must be provided.\n#\' @param contrast see argument description in \\code{\\link{results}}.\n#\' only \\code{coef} or \\code{contrast} can be specified, not both.\n#\' @param res a DESeqResults object. Results table produced by the\n#\' default pipeline, i.e. \\code{DESeq} followed by \\code{results}.\n#\' If not provided, it will be generated internally using \\code{coef} or \\code{contrast}.\n#\' For \\code{ashr}, if \\code{res} is provided, then \\code{coef} and \\code{contrast} are ignored.\n#\' @param type \n#\' \\code{"apeglm"} is the adaptive Student\'s t prior shrinkage estimator from the \'apeglm\' package;\n#\' \\code{"ashr"} is the adaptive shrinkage estimator from the \'ashr\' package,\n#\' using a fitted mixture of normals prior\n#\' - see the Stephens (2016) reference below for citation;\n#\' \\code{"normal"} is the 2014 DESeq2 shrinkage estimator using a Normal prior;\n#\' @param lfcThreshold a non-negative value which specifies a log2 fold change\n#\' threshold (as in \\code{\\link{results}}). This can be used with any\n#\' shrinkage \\code{type}. It will produce new p-values or\n#\' s-values testing whether the LFC is greater in absolute value than the threshold.\n#\' The s-values returned in combination with \\code{apeglm} or \\code{ashr}\n#\' provide the probability of FSOS events, "false sign or small",\n#\' among the tests with equal or smaller s-value\n#\' than a given gene\'s s-value, where "small" is specified by \\code{lfcThreshold}.\n#\' @param svalue logical, should p-values and adjusted p-values be replaced\n#\' with s-values when using \\code{apeglm} or \\code{ashr}. s-values provide the probability\n#\' of false signs among the tests with equal or smaller s-value than a given given\'s s-value.\n#\' See Stephens (2016) reference on s-values.\n#\' @param returnList logical, should \\code{lfcShrink} return a list, where\n#\' the first element is the results table, and the second element is the\n#\' output of \\code{apeglm} or \\code{ashr}\n#\' @param format same as defined in \\code{\\link{results}},\n#\' either \\code{"DataFrame"}, \\code{"GRanges"}, or \\code{"GRangesList"}\n#\' @param saveCols same as defined in \\code{\\link{results}},\n#\' which metadata columns to pass into output\n#\' @param apeAdapt logical, should \\code{apeglm} use the MLE estimates of\n#\' LFC to adapt the prior, or use default or specified \\code{prior.control}\n#\' @param apeMethod what \\code{method} to run \\code{apeglm}, which can\n#\' differ in terms of speed\n#\' @param parallel if FALSE, no parallelization. if TRUE, parallel\n#\' execution using \\code{BiocParallel}, see same argument of \\code{\\link{DESeq}}\n#\' parallelization only used with \\code{normal} or \\code{apeglm}\n#\' @param BPPARAM see same argument of \\code{\\link{DESeq}}\n#\' @param quiet whether to print messages \n#\' @param ... arguments passed to \\code{apeglm} and \\code{ashr}\n#\'\n#\' @references\n#\'\n#\' Publications for the following shrinkage estimators:\n#\' \n#\' \\code{type="apeglm"}:\n#\'\n#\' Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n#\' sequence count data: removing the noise and preserving large differences.\n#\' Bioinformatics. \\url{https://doi.org/10.1093/bioinformatics/bty895}\n#\' \n#\' \\code{type="ashr"}:\n#\'\n#\' Stephens, M. (2016) False discovery rates: a new deal.\n#\' Biostatistics, 18:2. \\url{https://doi.org/10.1093/biostatistics/kxw041}\n#\'\n#\' \\code{type="normal"}:\n#\'\n#\' Love, M.I., Huber, W., Anders, S. (2014) Moderated estimation of fold change and\n#\' dispersion for RNA-seq data with DESeq2. Genome Biology, 15:550.\n#\' \\url{https://doi.org/10.1186/s13059-014-0550-8}\n#\'\n#\' Related work, the \\code{bayesglm} function in the \\code{arm} package:\n#\'\n#\' Gelman, A., Jakulin, A., Pittau, M.G. and Su, Y.-S. (2009).\n#\' A Weakly Informative Default Prior Distribution For Logistic And Other Regression Models.\n#\' The Annals of Applied Statistics 2:4.\n#\' \\url{http://www.stat.columbia.edu/~gelman/research/published/ priors11.pdf}\n#\'\n#\' @return a DESeqResults object with the \\code{log2FoldChange} and \\code{lfcSE}\n#\' columns replaced with shrunken LFC and SE.\n#\' For consistency with \\code{results} (and similar to the output of \\code{bayesglm})\n#\' the column name \\code{lfcSE} is used here, although what is returned is a posterior SD.\n#\' For \\code{normal} and for \\code{apeglm} the estimate is the posterior mode,\n#\' for \\code{ashr} it is the posterior mean.\n#\' \\code{priorInfo(res)} contains information about the shrinkage procedure,\n#\' relevant to the various methods specified by \\code{type}.\n#\'\n#\' @export\n#\' \n#\' @examples\n#\'\n#\' set.seed(1)\n#\' dds <- makeExampleDESeqDataSet(n=500,betaSD=1)\n#\' dds <- DESeq(dds)\n#\' res <- results(dds)\n#\'\n#\' # these are the coefficients from the model\n#\' # we can specify them using \'coef\' by name or number below\n#\' resultsNames(dds)\n#\' \n#\' res.ape <- lfcShrink(dds=dds, coef=2, type="apeglm")\n#\' res.ash <- lfcShrink(dds=dds, coef=2, type="ashr")\n#\' res.norm <- lfcShrink(dds=dds, coef=2, type="normal")\n#\' \nlfcShrink <- function(dds, coef, contrast, res,\n                      type=c("apeglm","ashr","normal"),\n                      lfcThreshold=0,\n                      svalue=FALSE,\n                      returnList=FALSE,\n                      format=c("DataFrame","GRanges","GRangesList"),\n                      saveCols=NULL,\n                      apeAdapt=TRUE, apeMethod="nbinomCR",\n                      parallel=FALSE, BPPARAM=bpparam(),\n                      quiet=FALSE, ...) {  \n\n  stopifnot(is(dds, "DESeqDataSet"))\n  if (!missing(res)) {\n    if (!is(res, "DESeqResults")) stop("res should be a DESeqResults object, for GRanges output use \'format\'")\n  }\n  type <- match.arg(type, choices=c("apeglm","ashr","normal"))\n  format <- match.arg(format, choices=c("DataFrame", "GRanges","GRangesList"))\n  if (length(resultsNames(dds)) == 0) {\n    if (type != "apeglm" | (type == "apeglm" & apeAdapt)) {\n      stop("first run DESeq() before running lfcShrink()")\n    }\n  }\n  if (returnList) {\n    stopifnot(type %in% c("apeglm","ashr"))\n  }\n  betaPrior <- attr(dds,"betaPrior")\n  if (!is.null(betaPrior) && betaPrior) {\n    stop("lfcShrink() should be used downstream of DESeq() with betaPrior=FALSE (the default)")\n  }\n  stopifnot(length(lfcThreshold) == 1 && lfcThreshold >= 0)\n  resultsNamesDDS <- resultsNames(dds)\n  # we can run apeglm without running nbinomWaldTest()\n  # but we need to go get the column names of the model matrix first...\n  if (type == "apeglm" & !apeAdapt & length(resultsNames(dds)) == 0) {\n    resultsNamesDDS <- colnames(model.matrix(design(dds), data=colData(dds)))\n  }\n  # checks on the coef numeric or character wrt resultsNames(dds)\n  if (!missing(coef)) {\n    if (is.numeric(coef)) {\n      stopifnot(coef <= length(resultsNamesDDS))\n      coefAlpha <- resultsNamesDDS[coef]\n      coefNum <- coef\n    } else if (is.character(coef)) {\n      stopifnot(coef %in% resultsNamesDDS)\n      coefNum <- which(resultsNamesDDS == coef)\n      coefAlpha <- coef\n    }\n  }\n  if (missing(res)) {\n    if (!missing(coef)) {\n      res <- results(dds, name=coefAlpha)\n    } else if (!missing(contrast)) {\n      if (type=="normal" & is.numeric(contrast)) {\n        stop("for type=\'normal\' and numeric contrast, user must provide \'res\' object")\n      }\n      res <- results(dds, contrast=contrast)\n    } else {\n      stop("one of coef or contrast required if \'res\' is missing")\n    }\n  }\n\n  # check for standard errors\n  if (all(is.na(res$lfcSE)))\n    stop("lfcShrink requires standard errors, use default fitType")\n  \n  if (type %in% c("normal","apeglm")) {\n    if (is.null(dispersions(dds))) {\n      stop("type=\'normal\' and \'apeglm\' require dispersion estimates, first call estimateDispersions()")\n    }\n    stopifnot(all(rownames(dds) == rownames(res)))\n    if (parallel) {\n      nworkers <- getNworkers(BPPARAM)\n      parallelIdx <- factor(sort(rep(seq_len(nworkers),length.out=nrow(dds))))\n    }\n  }\n  \n  if (type == "normal") {\n\n    if (missing(coef) & missing(contrast)) {\n      stop("type=\'normal\' requires either \'coef\' or \'contrast\' be specified.")\n    }\n    \n    ############\n    ## normal ##\n    ############\n\n    if (!quiet) message("using \'normal\' for LFC shrinkage, the Normal prior from Love et al (2014).\n\nNote that type=\'apeglm\' and type=\'ashr\' have shown to have less bias than type=\'normal\'.\nSee ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette.\nReference: https://doi.org/10.1093/bioinformatics/bty895")\n    \n    if (is(design(dds), "formula")) {\n      if (attr(dds, "modelMatrixType") == "user-supplied") {\n        # if \'full\' was used, the model matrix should be stored here\n        # TODO... better one day to harmonize these two locations:\n        # 1) provided by \'full\' and stashed in attr(dds, "modelMatrix")\n        # 2) design(dds)\n        if (!missing(contrast)) {\n          stop("user-supplied design matrix supports shrinkage only with \'coef\'")\n        }\n        modelMatrix <- attr(dds, "modelMatrix")\n      } else {\n        termsOrder <- attr(terms.formula(design(dds)),"order")\n        interactionPresent <- any(termsOrder > 1)\n        if (interactionPresent) {\n          stop("LFC shrinkage type=\'normal\' not implemented for designs with interactions")\n        }\n        modelMatrix <- NULL\n      }\n    } else if (is(design(dds), "matrix")) {\n      if (!missing(contrast)) {\n        stop("user-supplied design matrix supports shrinkage only with \'coef\'")\n      }\n      modelMatrix <- design(dds)\n    }\n    \n    stopifnot(missing(coef) | missing(contrast))\n    # find and rename the MLE columns for estimateBetaPriorVar\n    betaCols <- grep("log2 fold change \\\\(MLE\\\\)", mcols(mcols(dds))$description)\n    stopifnot(length(betaCols) > 0)\n    if (!any(grepl("MLE_",names(mcols(dds))[betaCols]))) {\n      names(mcols(dds))[betaCols] <- paste0("MLE_", names(mcols(dds))[betaCols])\n    }\n    if (missing(contrast)) {\n      modelMatrixType <- "standard"\n    } else {\n      # contrast, and so using expanded model matrix: run some checks\n      modelMatrixType <- "expanded"\n      expMM <- makeExpandedModelMatrix(dds)\n      resNames <- colnames(expMM)\n      # quick and dirty checks so as to avoid running DESeq() before hitting error\n      if (is(contrast, "character")) {\n        stopifnot(length(contrast) == 3)\n        stopifnot(contrast[1] %in% names(colData(dds)))\n        stopifnot(is(colData(dds)[[contrast[1]]], "factor"))\n        stopifnot(all(contrast[2:3] %in% levels(colData(dds)[[contrast[1]]])))\n      } else {\n        message("resultsNames from the expanded model matrix to be referenced by \'contrast\':")\n        message(paste0("\'",paste(resNames, collapse="\', \'"),"\'"))\n      }\n      contrast <- checkContrast(contrast, resNames)\n    }\n    attr(dds,"modelMatrixType") <- modelMatrixType\n    betaPriorVar <- estimateBetaPriorVar(dds, modelMatrix=modelMatrix)\n    stopifnot(length(betaPriorVar) > 0)\n    # parallel fork\n    if (!parallel) {\n      dds.shr <- nbinomWaldTest(dds,\n                                betaPrior=TRUE,\n                                betaPriorVar=betaPriorVar,\n                                modelMatrix=modelMatrix,\n                                modelMatrixType=modelMatrixType,\n                                quiet=TRUE)\n    } else {\n      dds.shr <- do.call(rbind, bplapply(levels(parallelIdx), function(l) {\n        nbinomWaldTest(dds[parallelIdx == l,,drop=FALSE],\n                       betaPrior=TRUE,\n                       betaPriorVar=betaPriorVar,\n                       modelMatrix=modelMatrix,\n                       modelMatrixType=modelMatrixType,\n                       quiet=TRUE)\n      }, BPPARAM=BPPARAM))\n    }\n    if (missing(contrast)) {\n      # parallel not necessary here\n      res.shr <- results(dds.shr, name=coefAlpha, lfcThreshold=lfcThreshold)\n    } else {\n      # parallel may be useful here as novel contrasts can take a while with big designs\n      res.shr <- results(dds.shr, contrast=contrast, lfcThreshold=lfcThreshold,\n                         parallel=parallel, BPPARAM=BPPARAM)\n    }\n\n    if (lfcThreshold > 0) {\n      change.cols <- c("log2FoldChange","lfcSE","stat","pvalue","padj")\n    } else {\n      change.cols <- c("log2FoldChange","lfcSE")\n    }\n    for (column in change.cols) {\n      res[[column]] <- res.shr[[column]]\n    }\n    mcols(res,use.names=TRUE)[change.cols,"description"] <- mcols(res.shr,use.names=TRUE)[change.cols,"description"]\n        \n  } else if (type == "apeglm") {\n\n    ############\n    ## apeglm ##\n    ############\n    \n    if (!requireNamespace("apeglm", quietly=TRUE)) {\n      stop("type=\'apeglm\' requires installing the Bioconductor package \'apeglm\'")\n    }\n    if (!missing(contrast)) {\n      stop("type=\'apeglm\' shrinkage only for use with \'coef\'")\n    }\n    stopifnot(!missing(coef))\n    # if we are using adaptive prior, get the LFC columns\n    if (apeAdapt) {\n      incomingCoef <- gsub(" ","_",sub("log2 fold change \\\\(MLE\\\\): ","",mcols(res)$description[2]))\n      if (coefAlpha != incomingCoef) {\n        stop("\'coef\' should specify same coefficient as in results \'res\'")\n      }\n    }\n\n    if (!quiet) message("using \'apeglm\' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895")\n    \n    Y <- counts(dds)\n    modelMatrixType <- attr(dds, "modelMatrixType")\n    if (!is.null(modelMatrixType) && modelMatrixType == "user-supplied") {\n      design <- attr(dds, "modelMatrix")\n    } else {\n      design <- model.matrix(design(dds), data=colData(dds))\n    }\n    disps <- dispersions(dds)\n    if (is.null(normalizationFactors(dds))) {\n      offset <- matrix(log(sizeFactors(dds)),\n                       nrow=nrow(dds), ncol=ncol(dds), byrow=TRUE)\n    } else {\n      offset <- log(normalizationFactors(dds))\n    }\n    if ("weights" %in% assayNames(dds)) {\n      weights <- assays(dds)[["weights"]]\n    } else {\n      weights <- matrix(1, nrow=nrow(dds), ncol=ncol(dds))\n    }\n    if (apeAdapt) {\n      mle <- log(2) * cbind(res$log2FoldChange, res$lfcSE)\n    } else {\n      mle <- NULL\n    }\n    if (apeMethod == "general") {\n      log.lik <- apeglm::logLikNB\n    } else {\n      log.lik <- NULL\n    }\n    if (lfcThreshold > 0) {\n      message(paste0("computing FSOS \'false sign or small\' s-values (T=",round(lfcThreshold,3),")"))\n      svalue <- TRUE\n      apeT <- log(2) * lfcThreshold\n    } else {\n      apeT <- NULL\n    }\n\n    # parallel fork\n    if (!parallel) {\n      fit <- apeglm::apeglm(Y=Y, x=design, log.lik=log.lik, param=disps,\n                            coef=coefNum, mle=mle, threshold=apeT,\n                            weights=weights, offset=offset,\n                            method=apeMethod, ...)\n    } else {\n      fitList <- bplapply(levels(parallelIdx), function(l) {\n        idx <- parallelIdx == l\n        apeglm::apeglm(Y=Y[idx,,drop=FALSE], x=design, log.lik=log.lik, param=disps[idx],\n                       coef=coefNum, mle=mle, threshold=apeT,\n                       weights=weights[idx,,drop=FALSE], offset=offset[idx,,drop=FALSE],\n                       method=apeMethod, ...)\n      })\n      # collate the objects from the split\n      fit <- list()\n      ape.cols <- c("map","sd","fsr","svalue","interval","diag")\n      if (lfcThreshold > 0) {\n        ape.cols <- c(ape.cols, "thresh")\n      }\n      for (param in ape.cols) {\n        fit[[param]] <- do.call(rbind, lapply(fitList, `[[`, param))\n      }\n      fit$prior.control <- fitList[[1]]$prior.control\n      fit$svalue <- apeglm::svalue(fit$fsr[,1])\n    }\n    \n    stopifnot(nrow(fit$map) == nrow(dds))\n    conv <- fit$diag[,"conv"]\n    if (!all(conv[!is.na(conv)] == 0)) {\n      message("some rows did not converge in finding the MAP")\n    }\n    res$log2FoldChange <- log2(exp(1)) * fit$map[,coefNum]\n    res$lfcSE <- log2(exp(1)) * fit$sd[,coefNum]\n    mcols(res)$description[2] <- sub("MLE","MAP",mcols(res)$description[2])\n    mcols(res)$description[3] <- sub("standard error","posterior SD",mcols(res)$description[3])\n    if (svalue) {\n      coefAlphaSpaces <- gsub("_"," ",coefAlpha)\n      res <- res[,1:3]\n      if (lfcThreshold > 0) {\n        res$svalue <- as.numeric(apeglm::svalue(fit$thresh))\n        description <- paste0("FSOS s-value (T=",round(lfcThreshold,3),"): ",coefAlphaSpaces)\n      } else {\n        res$svalue <- as.numeric(fit$svalue)\n        description <- paste0("s-value: ",coefAlphaSpaces)\n      }\n      mcols(res)[4,] <- DataFrame(type="results", description=description)\n    } else {\n      res <- res[,c(1:3,5:6)]\n    }\n\n  } else if (type == "ashr") {\n\n    ##########\n    ## ashr ##\n    ##########\n    \n    if (!requireNamespace("ashr", quietly=TRUE)) {\n      stop("type=\'ashr\' requires installing the CRAN package \'ashr\'")\n    }\n    \n    if (!quiet) message("using \'ashr\' for LFC shrinkage. If used in published research, please cite:\n    Stephens, M. (2016) False discovery rates: a new deal. Biostatistics, 18:2.\n    https://doi.org/10.1093/biostatistics/kxw041")\n\n    betahat <- res$log2FoldChange\n    sebetahat <- res$lfcSE\n    fit <- ashr::ash(betahat, sebetahat,\n                     mixcompdist="normal", method="shrink", ...)\n    res$log2FoldChange <- fit$result$PosteriorMean\n    res$lfcSE <- fit$result$PosteriorSD\n    mcols(res)$description[2] <- sub("MLE","MMSE",mcols(res)$description[2])\n    mcols(res)$description[3] <- sub("standard error","posterior SD",mcols(res)$description[3])\n\n    # coefficient name (in words, with spaces)\n    coefAlphaSpaces <- sub(".*p-value: ","",mcols(res)$description[5])\n\n    # switch on whether LFC threshold is > 0\n    if (lfcThreshold == 0) {\n      if (svalue) {\n        res <- res[,1:3]\n        res$svalue <- fit$result$svalue\n      } else {\n        res <- res[,c(1:3,5:6)]\n      }\n    } else {\n      message(paste0("computing FSOS \'false sign or small\' s-values (T=",round(lfcThreshold,3),")"))\n      # code contributed by Frederik Ziebell 2022\n      svalue <- TRUE\n      cdf_pos_lfc <- ashr::cdf_post(fit$fitted_g, lfcThreshold,\n                                    ashr::set_data(betahat, sebetahat))\n      cdf_neg_lfc <- ashr::cdf_post(fit$fitted_g, -lfcThreshold,\n                                    ashr::set_data(betahat, sebetahat))\n      lfsr <- ifelse(res$log2FoldChange > 0, cdf_pos_lfc, 1 - cdf_neg_lfc)\n      res$svalue <- apeglm_svalue(lfsr)\n    }\n  }\n  \n  # add metadata column for svalue\n  if (svalue) {\n    mcols(res)[4,] <- DataFrame(\n      type="results",\n      description=paste("s-value:",coefAlphaSpaces))\n  }\n\n  # stash lfcThreshold and type/pkg details\n  metadata(res)[["lfcThreshold"]] <- lfcThreshold\n  pkg <- if (type == "normal") "DESeq2" else type\n  priorInfo(res) <- list(type=type,\n                         package=pkg,\n                         version=packageVersion(pkg))\n\n  # information on the fitted prior\n  if (type == "normal") {\n    priorInfo(res) <- c(priorInfo(res), list(betaPriorVar=betaPriorVar))\n  } else if (type == "apeglm") {\n    priorInfo(res) <- c(priorInfo(res), list(prior.control=fit$prior.control))\n  } else if (type == "ashr") {\n    priorInfo(res) <- c(priorInfo(res), list(fitted_g=fit$fitted_g))\n  }\n    \n  res <- resultsFormatSwitch(object=dds, res=res, format=format, saveCols=saveCols)\n\n  if (returnList) {\n    return(list(res=res, fit=fit))\n  } else {\n    return(res)\n  }\n\n}\n\n# copied from apeglm package to avoid extra package installation for ashr shrinkage\napeglm_svalue <- function(lfsr) {\n  lfsr.sorted <- sort(lfsr, na.last = TRUE)\n  cumsum.idx <- seq_along(lfsr)\n  cumsum.lfsr <- cumsum(lfsr.sorted)\n  (cumsum.lfsr/cumsum.idx)[rank(lfsr, ties.method = "first", na.last = TRUE)]\n}\n'