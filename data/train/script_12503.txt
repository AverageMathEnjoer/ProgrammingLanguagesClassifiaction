b'#define WIN32_LEAN_AND_MEAN\n#define NOMINMAX\n#include <Windows.h>\n#include <tchar.h>\n#include "../libStringConverter/convert.h"\n\n#include <string>\n#include <cstring>\n#include <vector>\n\nstatic std::string getModuleBaseDir(HINSTANCE hInstance)\n{\n\tstd::string baseDir;\n\tstd::vector<TCHAR> baseDirT;\n\tsize_t ownPathLen = MAX_PATH;\n\twhile (true)\n\t{\n\t\tbaseDirT.resize(ownPathLen + 1, 0);\n\t\tSetLastError(0);\n\t\tDWORD result = GetModuleFileName(hInstance, baseDirT.data(), (DWORD)ownPathLen);\n\t\tif (result == 0)\n\t\t{\n\t\t\tbaseDirT.clear();\n\t\t\tbreak;\n\t\t}\n\t\telse if (result == ownPathLen && GetLastError() == ERROR_INSUFFICIENT_BUFFER)\n\t\t\townPathLen += MAX_PATH;\n\t\telse\n\t\t\tbreak;\n\t}\n\tsize_t ownPathStrlen = _tcslen(baseDirT.data());\n\tfor (size_t i = ownPathStrlen-1; i > 0; i--)\n\t{\n\t\tif (baseDirT[i] == TEXT(\'\\\\\'))\n\t\t{\n\t\t\tbaseDirT.resize(i + 1);\n\t\t\tbaseDirT[i] = 0;\n\t\t\townPathStrlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsize_t outLen = 0;\n\tchar *baseDirA = _TCHARToMultiByte(baseDirT.data(), outLen);\n\tbaseDir.assign(baseDirA);\n\t_FreeCHAR(baseDirA);\n\treturn baseDir;\n}\n\n#include "../UABE_Win32/Win32AppContext.h"\nint APIENTRY _tWinMain(HINSTANCE hInstance,\n                     HINSTANCE hPrevInstance,\n                     LPTSTR    lpCmdLine,\n                     int       nCmdShow)\n{\n\tstd::string baseDir = getModuleBaseDir(hInstance);\n\tstd::vector<char> argvBuf8;\n\tsize_t totalArgvLen = 0;\n\tchar **argv8 = new char*[__argc+1];\n\tfor (int i = 0; i < __argc; i++)\n\t{\n\t\tsize_t len16 = wcslen(__wargv[i]);\n\t\tif (len16 > INT_MAX) len16 = INT_MAX;\n\t\tsize_t len8 = (size_t)WideCharToMultiByte(CP_UTF8, 0, __wargv[i], (int)len16, NULL, 0, NULL, NULL);\n\t\tsize_t argvBufOffset = argvBuf8.size();\n\t\targvBuf8.resize(argvBuf8.size() + len8 + 1);\n\t\tWideCharToMultiByte(CP_UTF8, 0, __wargv[i], (int)len16, &argvBuf8[argvBufOffset], (int)len8, NULL, NULL);\n\t\targvBuf8[argvBufOffset + len8] = 0;\n\t\targv8[i] = (char*)argvBufOffset;\n\t}\n\tfor (int i = 0; i < __argc; i++)\n\t{\n\t\targv8[i] = argvBuf8.data() + (size_t)argv8[i];\n\t}\n\targv8[__argc] = nullptr;\n\tint ret;\n\tif (HMODULE hUABEWin32 = GetModuleHandle(TEXT("UABE_Win32.dll")))\n\t{\n\t\tWin32AppContext appContext(hUABEWin32, baseDir);\n\t\tret = appContext.Run(__argc, argv8);\n\t}\n\tdelete[] argv8;\n\treturn ret;\n}\n'