b'{-# LANGUAGE\n    CPP\n  , OverloadedStrings\n  #-}\nmodule Rest.Gen.Base.JSON\n  ( showExample\n  , showExamples\n  ) where\n\nimport Control.Applicative ((<|>))\nimport Data.Aeson ((.=))\nimport Data.JSON.Schema\nimport Data.List (transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Maybe\nimport Text.PrettyPrint.HughesPJ\nimport qualified Data.Aeson  as A\nimport qualified Data.Text   as T\nimport qualified Data.Vector as V\n\nimport Rest.Gen.Base.JSON.Pretty\n\nshowExample :: Schema -> String\nshowExample = render . pp_value . showExample\'\n  where\n    showExample\' s = case s of\n      Choice []    -> A.Null -- Cannot create zero value\n      Choice (x:_) -> showExample\' x\n      Object fs    -> A.object $ map (\\f -> key f .= showExample\' (content f)) fs\n      Map v        -> A.object ["<key>" .= showExample\' v]\n      Tuple vs     -> A.Array $ V.fromList $ map showExample\' vs\n      Array l _ v  -> A.Array $ V.fromList $ replicate (lengthBoundExample l `max` 1) (showExample\' v)\n      Value _      -> A.String "value"\n      Boolean      -> A.Bool True\n      Number b     -> A.Number . boundExample $ b\n      Any          -> A.String "<value>"\n      Constant v   -> v\n#if !MIN_VERSION_json_schema(0,7,0)\n      Null         -> A.Null\n#endif\n\n\n-- | Generate enough examples as to mention every possible field\n--   at least once\nshowExamples :: Schema -> [String]\nshowExamples = map (render . pp_value) . showExamples\'\n  where\n    -- Recursive types have infinite schemas, so we must ensure\n    -- that we don\'t generate infinitely deep examples in that case.\n    -- We thus impose a limit to the number of nestings\n    showExamples\' = fst . go (10 :: Int)\n\n    -- Idea: @go n x == (showExamples\' n x, length (showExamples\' n x))@\n    -- and note that @snd (go x) >= 1@\n    go 0 _ = ([A.String "..."],1)\n    go n s = case s of\n      Choice []   -> ([A.Null], 1)\n\n      Choice xs   -> let (examples, numExamples) = unzip $ map (go $ n-1) xs\n                     in (concat examples, sum numExamples)\n\n      Object []   -> ([A.object []], 1)\n\n      Object fs   -> let (esByFld, numEsByFld) = unzip $ map (fieldExs n) fs\n                         numExamples = maximum numEsByFld\n                         examples = map A.object $ take numExamples $ transpose $ map cycle esByFld\n                     in (examples, numExamples)\n\n      Map v       -> let (examples, _) = go (n-1) v\n                         mkKey i = T.pack $ "<key " ++ show (i :: Int) ++ ">"\n                     in ([A.object [mkKey i .= e | (i,e) <- zip [1..] examples]], 1)\n\n      Tuple []    -> ([A.Array V.empty], 1)\n\n      Tuple vs    -> let (esByPos,numEsByPos) = unzip $ map (go $ n-1) vs\n                         numExamples = maximum numEsByPos\n                         examples = take numExamples $ transpose $ map cycle esByPos\n                     in (map (A.Array . V.fromList) examples, numExamples)\n\n      Array l _ v -> let minLen = fromMaybe 0 (lowerLength l)\n                         maxLen = fromMaybe (numCases `max` minLen) (upperLength l)\n                         (cases,numCases) = go (n-1) v\n                         (q,r) = numCases `divMod` maxLen\n                         numExamples = q + signum r\n                         examples = chunksOf maxLen $ cases ++ take (minLen - r) cases\n                     in if maxLen == 0 then ([A.Array V.empty], 1)\n                        else (map (A.Array . V.fromList) examples, numExamples)\n\n      Value _     -> ([A.String "value"], 1)\n\n      Boolean     -> ([A.Bool True], 1)\n\n      Number b    -> ([A.Number $ boundExample b], 1)\n\n      Any         -> ([A.String "<value>"],1)\n\n      Constant v  -> ([v], 1)\n\n#if !MIN_VERSION_json_schema(0,7,0)\n      Null        -> ([A.Null], 1)\n#endif\n\n    fieldExs n f = let (examples,num_examples) = go (n-1) (content f)\n                   in (map (key f .=) examples, num_examples)\n\n\nboundExample :: Num a => Bound -> a\nboundExample b = fromIntegral . fromMaybe 0 $ upper b <|> lower b\n\nlengthBoundExample :: Num a => LengthBound -> a\nlengthBoundExample b = fromIntegral $ fromMaybe 0 (upperLength b <|> lowerLength b)\n'