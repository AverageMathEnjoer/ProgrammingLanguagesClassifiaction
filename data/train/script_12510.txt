b'/* \n * QR Code generator library (Java)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.qrcodegen;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\n\n/**\n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * <p>The mid-level way to create a segment is to take the payload data and call a\n * static factory function such as {@link QrSegment#makeNumeric(CharSequence)}. The low-level\n * way to create a segment is to custom-make the bit buffer and call the {@link\n * QrSegment#QrSegment(Mode,int,BitBuffer) constructor} with appropriate values.</p>\n * <p>This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n * This class can represent kanji mode segments, but provides no help in encoding them\n * - see {@link QrSegmentAdvanced} for full kanji support.</p>\n */\npublic final class QrSegment {\n\t\n\t/*---- Static factory functions (mid level) ----*/\n\t\n\t/**\n\t * Returns a segment representing the specified binary data\n\t * encoded in byte mode. All input byte arrays are acceptable.\n\t * <p>Any text string can be converted to UTF-8 bytes ({@code\n\t * s.getBytes(StandardCharsets.UTF_8)}) and encoded as a byte mode segment.</p>\n\t * @param data the binary data (not {@code null})\n\t * @return a segment (not {@code null}) containing the data\n\t * @throws NullPointerException if the array is {@code null}\n\t */\n\tpublic static QrSegment makeBytes(byte[] data) {\n\t\tObjects.requireNonNull(data);\n\t\tBitBuffer bb = new BitBuffer();\n\t\tfor (byte b : data)\n\t\t\tbb.appendBits(b & 0xFF, 8);\n\t\treturn new QrSegment(Mode.BYTE, data.length, bb);\n\t}\n\t\n\t\n\t/**\n\t * Returns a segment representing the specified string of decimal digits encoded in numeric mode.\n\t * @param digits the text (not {@code null}), with only digits from 0 to 9 allowed\n\t * @return a segment (not {@code null}) containing the text\n\t * @throws NullPointerException if the string is {@code null}\n\t * @throws IllegalArgumentException if the string contains non-digit characters\n\t */\n\tpublic static QrSegment makeNumeric(CharSequence digits) {\n\t\tObjects.requireNonNull(digits);\n\t\tif (!isNumeric(digits))\n\t\t\tthrow new IllegalArgumentException("String contains non-numeric characters");\n\t\t\n\t\tBitBuffer bb = new BitBuffer();\n\t\tfor (int i = 0; i < digits.length(); ) {  // Consume up to 3 digits per iteration\n\t\t\tint n = Math.min(digits.length() - i, 3);\n\t\t\tbb.appendBits(Integer.parseInt(digits.subSequence(i, i + n).toString()), n * 3 + 1);\n\t\t\ti += n;\n\t\t}\n\t\treturn new QrSegment(Mode.NUMERIC, digits.length(), bb);\n\t}\n\t\n\t\n\t/**\n\t * Returns a segment representing the specified text string encoded in alphanumeric mode.\n\t * The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n\t * dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t * @param text the text (not {@code null}), with only certain characters allowed\n\t * @return a segment (not {@code null}) containing the text\n\t * @throws NullPointerException if the string is {@code null}\n\t * @throws IllegalArgumentException if the string contains non-encodable characters\n\t */\n\tpublic static QrSegment makeAlphanumeric(CharSequence text) {\n\t\tObjects.requireNonNull(text);\n\t\tif (!isAlphanumeric(text))\n\t\t\tthrow new IllegalArgumentException("String contains unencodable characters in alphanumeric mode");\n\t\t\n\t\tBitBuffer bb = new BitBuffer();\n\t\tint i;\n\t\tfor (i = 0; i <= text.length() - 2; i += 2) {  // Process groups of 2\n\t\t\tint temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n\t\t\ttemp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n\t\t\tbb.appendBits(temp, 11);\n\t\t}\n\t\tif (i < text.length())  // 1 character remaining\n\t\t\tbb.appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6);\n\t\treturn new QrSegment(Mode.ALPHANUMERIC, text.length(), bb);\n\t}\n\t\n\t\n\t/**\n\t * Returns a list of zero or more segments to represent the specified Unicode text string.\n\t * The result may use various segment modes and switch modes to optimize the length of the bit stream.\n\t * @param text the text to be encoded, which can be any Unicode string\n\t * @return a new mutable list (not {@code null}) of segments (not {@code null}) containing the text\n\t * @throws NullPointerException if the text is {@code null}\n\t */\n\tpublic static List<QrSegment> makeSegments(CharSequence text) {\n\t\tObjects.requireNonNull(text);\n\t\t\n\t\t// Select the most efficient segment encoding automatically\n\t\tList<QrSegment> result = new ArrayList<>();\n\t\tif (text.equals(""));  // Leave result empty\n\t\telse if (isNumeric(text))\n\t\t\tresult.add(makeNumeric(text));\n\t\telse if (isAlphanumeric(text))\n\t\t\tresult.add(makeAlphanumeric(text));\n\t\telse\n\t\t\tresult.add(makeBytes(text.toString().getBytes(StandardCharsets.UTF_8)));\n\t\treturn result;\n\t}\n\t\n\t\n\t/**\n\t * Returns a segment representing an Extended Channel Interpretation\n\t * (ECI) designator with the specified assignment value.\n\t * @param assignVal the ECI assignment number (see the AIM ECI specification)\n\t * @return a segment (not {@code null}) containing the data\n\t * @throws IllegalArgumentException if the value is outside the range [0, 10<sup>6</sup>)\n\t */\n\tpublic static QrSegment makeEci(int assignVal) {\n\t\tBitBuffer bb = new BitBuffer();\n\t\tif (assignVal < 0)\n\t\t\tthrow new IllegalArgumentException("ECI assignment value out of range");\n\t\telse if (assignVal < (1 << 7))\n\t\t\tbb.appendBits(assignVal, 8);\n\t\telse if (assignVal < (1 << 14)) {\n\t\t\tbb.appendBits(0b10, 2);\n\t\t\tbb.appendBits(assignVal, 14);\n\t\t} else if (assignVal < 1_000_000) {\n\t\t\tbb.appendBits(0b110, 3);\n\t\t\tbb.appendBits(assignVal, 21);\n\t\t} else\n\t\t\tthrow new IllegalArgumentException("ECI assignment value out of range");\n\t\treturn new QrSegment(Mode.ECI, 0, bb);\n\t}\n\t\n\t\n\t/**\n\t * Tests whether the specified string can be encoded as a segment in numeric mode.\n\t * A string is encodable iff each character is in the range 0 to 9.\n\t * @param text the string to test for encodability (not {@code null})\n\t * @return {@code true} iff each character is in the range 0 to 9.\n\t * @throws NullPointerException if the string is {@code null}\n\t * @see #makeNumeric(CharSequence)\n\t */\n\tpublic static boolean isNumeric(CharSequence text) {\n\t\treturn NUMERIC_REGEX.matcher(text).matches();\n\t}\n\t\n\t\n\t/**\n\t * Tests whether the specified string can be encoded as a segment in alphanumeric mode.\n\t * A string is encodable iff each character is in the following set: 0 to 9, A to Z\n\t * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t * @param text the string to test for encodability (not {@code null})\n\t * @return {@code true} iff each character is in the alphanumeric mode character set\n\t * @throws NullPointerException if the string is {@code null}\n\t * @see #makeAlphanumeric(CharSequence)\n\t */\n\tpublic static boolean isAlphanumeric(CharSequence text) {\n\t\treturn ALPHANUMERIC_REGEX.matcher(text).matches();\n\t}\n\t\n\t\n\t\n\t/*---- Instance fields ----*/\n\t\n\t/** The mode indicator of this segment. Not {@code null}. */\n\tpublic final Mode mode;\n\t\n\t/** The length of this segment\'s unencoded data. Measured in characters for\n\t * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t * Always zero or positive. Not the same as the data\'s bit length. */\n\tpublic final int numChars;\n\t\n\t// The data bits of this segment. Not null. Accessed through getData().\n\tfinal BitBuffer data;\n\t\n\t\n\t/*---- Constructor (low level) ----*/\n\t\n\t/**\n\t * Constructs a QR Code segment with the specified attributes and data.\n\t * The character count (numCh) must agree with the mode and the bit buffer length,\n\t * but the constraint isn\'t checked. The specified bit buffer is cloned and stored.\n\t * @param md the mode (not {@code null})\n\t * @param numCh the data length in characters or bytes, which is non-negative\n\t * @param data the data bits (not {@code null})\n\t * @throws NullPointerException if the mode or data is {@code null}\n\t * @throws IllegalArgumentException if the character count is negative\n\t */\n\tpublic QrSegment(Mode md, int numCh, BitBuffer data) {\n\t\tmode = Objects.requireNonNull(md);\n\t\tObjects.requireNonNull(data);\n\t\tif (numCh < 0)\n\t\t\tthrow new IllegalArgumentException("Invalid value");\n\t\tnumChars = numCh;\n\t\tthis.data = data.clone();  // Make defensive copy\n\t}\n\t\n\t\n\t/*---- Methods ----*/\n\t\n\t/**\n\t * Returns the data bits of this segment.\n\t * @return a new copy of the data bits (not {@code null})\n\t */\n\tpublic BitBuffer getData() {\n\t\treturn data.clone();  // Make defensive copy\n\t}\n\t\n\t\n\t// Calculates the number of bits needed to encode the given segments at the given version.\n\t// Returns a non-negative number if successful. Otherwise returns -1 if a segment has too\n\t// many characters to fit its length field, or the total bits exceeds Integer.MAX_VALUE.\n\tstatic int getTotalBits(List<QrSegment> segs, int version) {\n\t\tObjects.requireNonNull(segs);\n\t\tlong result = 0;\n\t\tfor (QrSegment seg : segs) {\n\t\t\tObjects.requireNonNull(seg);\n\t\t\tint ccbits = seg.mode.numCharCountBits(version);\n\t\t\tif (seg.numChars >= (1 << ccbits))\n\t\t\t\treturn -1;  // The segment\'s length doesn\'t fit the field\'s bit width\n\t\t\tresult += 4L + ccbits + seg.data.bitLength();\n\t\t\tif (result > Integer.MAX_VALUE)\n\t\t\t\treturn -1;  // The sum will overflow an int type\n\t\t}\n\t\treturn (int)result;\n\t}\n\t\n\t\n\t/*---- Constants ----*/\n\t\n\t// Describes precisely all strings that are encodable in numeric mode.\n\tprivate static final Pattern NUMERIC_REGEX = Pattern.compile("[0-9]*");\n\t\n\t// Describes precisely all strings that are encodable in alphanumeric mode.\n\tprivate static final Pattern ALPHANUMERIC_REGEX = Pattern.compile("[A-Z0-9 $%*+./:-]*");\n\t\n\t// The set of all legal characters in alphanumeric mode, where\n\t// each character value maps to the index in the string.\n\tstatic final String ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";\n\t\n\t\n\t\n\t/*---- Public helper enumeration ----*/\n\t\n\t/**\n\t * Describes how a segment\'s data bits are interpreted.\n\t */\n\tpublic enum Mode {\n\t\t\n\t\t/*-- Constants --*/\n\t\t\n\t\tNUMERIC     (0x1, 10, 12, 14),\n\t\tALPHANUMERIC(0x2,  9, 11, 13),\n\t\tBYTE        (0x4,  8, 16, 16),\n\t\tKANJI       (0x8,  8, 10, 12),\n\t\tECI         (0x7,  0,  0,  0);\n\t\t\n\t\t\n\t\t/*-- Fields --*/\n\t\t\n\t\t// The mode indicator bits, which is a uint4 value (range 0 to 15).\n\t\tfinal int modeBits;\n\t\t\n\t\t// Number of character count bits for three different version ranges.\n\t\tprivate final int[] numBitsCharCount;\n\t\t\n\t\t\n\t\t/*-- Constructor --*/\n\t\t\n\t\tprivate Mode(int mode, int... ccbits) {\n\t\t\tmodeBits = mode;\n\t\t\tnumBitsCharCount = ccbits;\n\t\t}\n\t\t\n\t\t\n\t\t/*-- Method --*/\n\t\t\n\t\t// Returns the bit width of the character count field for a segment in this mode\n\t\t// in a QR Code at the given version number. The result is in the range [0, 16].\n\t\tint numCharCountBits(int ver) {\n\t\t\tassert QrCode.MIN_VERSION <= ver && ver <= QrCode.MAX_VERSION;\n\t\t\treturn numBitsCharCount[(ver + 7) / 17];\n\t\t}\n\t\t\n\t}\n\t\n}\n'