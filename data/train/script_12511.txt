b'-- | This module allows to use QuickCheck properties in tasty.\n{-# LANGUAGE GeneralizedNewtypeDeriving, DeriveDataTypeable #-}\nmodule Test.Tasty.QuickCheck\n  ( testProperty\n  , testProperties\n  , QuickCheckTests(..)\n  , QuickCheckReplay(..)\n  , QuickCheckShowReplay(..)\n  , QuickCheckMaxSize(..)\n  , QuickCheckMaxRatio(..)\n  , QuickCheckVerbose(..)\n  , QuickCheckMaxShrinks(..)\n    -- * Re-export of Test.QuickCheck\n  , module Test.QuickCheck\n    -- * Internal\n    -- | If you are building a test suite, you don\'t need these functions.\n    --\n    -- They may be used by other tasty add-on packages (such as tasty-hspec).\n  , QC(..)\n  , optionSetToArgs\n  ) where\n\nimport Test.Tasty ( testGroup )\nimport Test.Tasty.Providers\nimport Test.Tasty.Options\nimport qualified Test.QuickCheck as QC\nimport Test.Tasty.Runners (formatMessage)\nimport Test.QuickCheck hiding -- for re-export\n  ( quickCheck\n  , Args(..)\n  , Result\n  , stdArgs\n  , quickCheckWith\n  , quickCheckWithResult\n  , quickCheckResult\n  , verboseCheck\n  , verboseCheckWith\n  , verboseCheckWithResult\n  , verboseCheckResult\n  , verbose\n  -- Template Haskell functions\n#if MIN_VERSION_QuickCheck(2,11,0)\n  , allProperties\n#endif\n  , forAllProperties\n  , quickCheckAll\n  , verboseCheckAll\n  )\n\nimport Data.Typeable\nimport Data.List\nimport Text.Printf\nimport Test.QuickCheck.Random (mkQCGen)\nimport Options.Applicative (metavar)\nimport System.Random (getStdRandom, randomR)\n#if !MIN_VERSION_base(4,9,0)\nimport Control.Applicative\nimport Data.Monoid\n#endif\n\nnewtype QC = QC QC.Property\n  deriving Typeable\n\n-- | Create a \'TestTree\' for a QuickCheck \'QC.Testable\' property\ntestProperty :: QC.Testable a => TestName -> a -> TestTree\ntestProperty name prop = singleTest name $ QC $ QC.property prop\n\n-- | Create a test from a list of QuickCheck properties. To be used\n-- with \'Test.QuickCheck.allProperties\'. E.g.\n--\n-- >tests :: TestTree\n-- >tests = testProperties "Foo" $allProperties\ntestProperties :: TestName -> [(String, Property)] -> TestTree\ntestProperties name = testGroup name . map (uncurry testProperty)\n\n-- | Number of test cases for QuickCheck to generate\nnewtype QuickCheckTests = QuickCheckTests Int\n  deriving (Num, Ord, Eq, Real, Enum, Integral, Typeable)\n\nnewtype QuickCheckReplay = QuickCheckReplay (Maybe Int)\n  deriving (Typeable)\n\n-- | If a test case fails unexpectedly, show the replay token\nnewtype QuickCheckShowReplay = QuickCheckShowReplay Bool\n  deriving (Typeable)\n\n-- | Size of the biggest test cases\nnewtype QuickCheckMaxSize = QuickCheckMaxSize Int\n  deriving (Num, Ord, Eq, Real, Enum, Integral, Typeable)\n\n-- | Maximum number of of discarded tests per successful test before giving up.\nnewtype QuickCheckMaxRatio = QuickCheckMaxRatio Int\n  deriving (Num, Ord, Eq, Real, Enum, Integral, Typeable)\n\n-- | Show the test cases that QuickCheck generates\nnewtype QuickCheckVerbose = QuickCheckVerbose Bool\n  deriving (Typeable)\n\n-- | Number of shrinks allowed before QuickCheck will fail a test.\n--\n-- @since 0.10.2\nnewtype QuickCheckMaxShrinks = QuickCheckMaxShrinks Int\n  deriving (Num, Ord, Eq, Real, Enum, Integral, Typeable)\n\ninstance IsOption QuickCheckTests where\n  defaultValue = 100\n  parseValue =\n    -- We allow numeric underscores for readability; see\n    -- https://github.com/UnkindPartition/tasty/issues/263\n    fmap QuickCheckTests . safeRead . filter (/= \'_\')\n  optionName = return "quickcheck-tests"\n  optionHelp = return "Number of test cases for QuickCheck to generate. Underscores accepted: e.g. 10_000_000"\n  optionCLParser = mkOptionCLParser $ metavar "NUMBER"\n\ninstance IsOption QuickCheckReplay where\n  defaultValue = QuickCheckReplay Nothing\n  -- Reads a replay int seed\n  parseValue v = QuickCheckReplay . Just <$> safeRead v\n  optionName = return "quickcheck-replay"\n  optionHelp = return "Random seed to use for replaying a previous test run (use same --quickcheck-max-size)"\n  optionCLParser = mkOptionCLParser $ metavar "SEED"\n\ninstance IsOption QuickCheckShowReplay where\n  defaultValue = QuickCheckShowReplay False\n  parseValue = fmap QuickCheckShowReplay . safeReadBool\n  optionName = return "quickcheck-show-replay"\n  optionHelp = return "Show a replay token for replaying tests"\n  optionCLParser = flagCLParser Nothing (QuickCheckShowReplay True)\n\ndefaultMaxSize :: Int\ndefaultMaxSize = QC.maxSize QC.stdArgs\n\ninstance IsOption QuickCheckMaxSize where\n  defaultValue = fromIntegral defaultMaxSize\n  parseValue = fmap QuickCheckMaxSize . safeRead\n  optionName = return "quickcheck-max-size"\n  optionHelp = return "Size of the biggest test cases quickcheck generates"\n  optionCLParser = mkOptionCLParser $ metavar "NUMBER"\n\ninstance IsOption QuickCheckMaxRatio where\n  defaultValue = fromIntegral $ QC.maxDiscardRatio QC.stdArgs\n  parseValue = fmap QuickCheckMaxRatio . safeRead\n  optionName = return "quickcheck-max-ratio"\n  optionHelp = return "Maximum number of discared tests per successful test before giving up"\n  optionCLParser = mkOptionCLParser $ metavar "NUMBER"\n\ninstance IsOption QuickCheckVerbose where\n  defaultValue = QuickCheckVerbose False\n  parseValue = fmap QuickCheckVerbose . safeReadBool\n  optionName = return "quickcheck-verbose"\n  optionHelp = return "Show the generated test cases"\n  optionCLParser = mkFlagCLParser mempty (QuickCheckVerbose True)\n\ninstance IsOption QuickCheckMaxShrinks where\n  defaultValue = QuickCheckMaxShrinks (QC.maxShrinks QC.stdArgs)\n  parseValue = fmap QuickCheckMaxShrinks . safeRead\n  optionName = return "quickcheck-shrinks"\n  optionHelp = return "Number of shrinks allowed before QuickCheck will fail a test"\n  optionCLParser = mkOptionCLParser $ metavar "NUMBER"\n\n-- | Convert tasty options into QuickCheck options.\n--\n-- This is a low-level function that was originally added for tasty-hspec\n-- but may be used by others.\n--\n-- @since 0.9.1\noptionSetToArgs :: OptionSet -> IO (Int, QC.Args)\noptionSetToArgs opts = do\n  replaySeed <- case mReplay of\n    Nothing -> getStdRandom (randomR (1,999999))\n    Just seed -> return seed\n\n  let args = QC.stdArgs\n        { QC.chatty          = False\n        , QC.maxSuccess      = nTests\n        , QC.maxSize         = maxSize\n        , QC.replay          = Just (mkQCGen replaySeed, 0)\n        , QC.maxDiscardRatio = maxRatio\n        , QC.maxShrinks      = maxShrinks\n        }\n\n  return (replaySeed, args)\n\n  where\n    QuickCheckTests      nTests     = lookupOption opts\n    QuickCheckReplay     mReplay    = lookupOption opts\n    QuickCheckMaxSize    maxSize    = lookupOption opts\n    QuickCheckMaxRatio   maxRatio   = lookupOption opts\n    QuickCheckMaxShrinks maxShrinks = lookupOption opts\n\ninstance IsTest QC where\n  testOptions = return\n    [ Option (Proxy :: Proxy QuickCheckTests)\n    , Option (Proxy :: Proxy QuickCheckReplay)\n    , Option (Proxy :: Proxy QuickCheckShowReplay)\n    , Option (Proxy :: Proxy QuickCheckMaxSize)\n    , Option (Proxy :: Proxy QuickCheckMaxRatio)\n    , Option (Proxy :: Proxy QuickCheckVerbose)\n    , Option (Proxy :: Proxy QuickCheckMaxShrinks)\n    ]\n\n  run opts (QC prop) _yieldProgress = do\n    (replaySeed, args) <- optionSetToArgs opts\n\n    let\n      QuickCheckShowReplay showReplay = lookupOption opts\n      QuickCheckVerbose    verbose    = lookupOption opts\n      maxSize = QC.maxSize args\n      testRunner = if verbose\n                     then QC.verboseCheckWithResult\n                     else QC.quickCheckWithResult\n      replayMsg = makeReplayMsg replaySeed maxSize\n\n    -- Quickcheck already catches exceptions, no need to do it here.\n    r <- testRunner args prop\n\n    qcOutput <- formatMessage $ QC.output r\n    let qcOutputNl =\n          if "\\n" `isSuffixOf` qcOutput\n            then qcOutput\n            else qcOutput ++ "\\n"\n        testSuccessful = successful r\n        putReplayInDesc = (not testSuccessful) || showReplay\n    return $\n      (if testSuccessful then testPassed else testFailed)\n      (qcOutputNl ++\n        (if putReplayInDesc then replayMsg else ""))\n\nsuccessful :: QC.Result -> Bool\nsuccessful r =\n  case r of\n    QC.Success {} -> True\n    _ -> False\n\nmakeReplayMsg :: Int -> Int -> String\nmakeReplayMsg seed size = let\n    sizeStr = if (size /= defaultMaxSize)\n                 then printf " --quickcheck-max-size=%d" size\n                 else ""\n  in printf "Use --quickcheck-replay=%d%s to reproduce." seed sizeStr\n'