b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2004 May 26\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains code use to manipulate "Mem" structure.  A "Mem"\n    ** stores a single value in the VDBE.  Mem is an opaque structure visible\n    ** only within the VDBE.  Interface routines refer to a Mem using the\n    ** name sqlite_value\n    **\n    ** $Id: vdbemem.c,v 1.152 2009/07/22 18:07:41 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include "vdbeInt.h"\n\n    /*\n    ** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)\n    ** P if required.\n    */\n    //#define expandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)\n    static void expandBlob( Mem P )\n    { if ( ( P.flags & MEM_Zero ) != 0 ) sqlite3VdbeMemExpandBlob( P ); } // TODO -- Convert to inline for speed\n\n    /*\n    ** If pMem is an object with a valid string representation, this routine\n    ** ensures the internal encoding for the string representation is\n    ** \'desiredEnc\', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE.\n    **\n    ** If pMem is not a string object, or the encoding of the string\n    ** representation is already stored using the requested encoding, then this\n    ** routine is a no-op.\n    **\n    ** SQLITE_OK is returned if the conversion is successful (or not required).\n    ** SQLITE_NOMEM may be returned if a malloc() fails during conversion\n    ** between formats.\n    */\n    static int sqlite3VdbeChangeEncoding( Mem pMem, int desiredEnc )\n    {\n      int rc;\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      Debug.Assert( desiredEnc == SQLITE_UTF8 || desiredEnc == SQLITE_UTF16LE\n      || desiredEnc == SQLITE_UTF16BE );\n      if ( ( pMem.flags & MEM_Str ) == 0 || pMem.enc == desiredEnc )\n      {\n        if ( pMem.z == null && pMem.zBLOB != null ) pMem.z = Encoding.UTF8.GetString( pMem.zBLOB );\n        return SQLITE_OK;\n      }\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n#if  SQLITE_OMIT_UTF16\n      return SQLITE_ERROR;\n#else\n\n/* MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,\n** then the encoding of the value may not have changed.\n*/\nrc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);\nDebug.Assert(rc==SQLITE_OK    || rc==SQLITE_NOMEM);\nDebug.Assert(rc==SQLITE_OK    || pMem.enc!=desiredEnc);\nDebug.Assert(rc==SQLITE_NOMEM || pMem.enc==desiredEnc);\nreturn rc;\n#endif\n    }\n\n    /*\n    ** Make sure pMem.z points to a writable allocation of at least\n    ** n bytes.\n    **\n    ** If the memory cell currently contains string or blob data\n    ** and the third argument passed to this function is true, the\n    ** current content of the cell is preserved. Otherwise, it may\n    ** be discarded.\n    **\n    ** This function sets the MEM_Dyn flag and clears any xDel callback.\n    ** It also clears MEM_Ephem and MEM_Static. If the preserve flag is\n    ** not set, Mem.n is zeroed.\n    */\n    static int sqlite3VdbeMemGrow( Mem pMem, int n, int preserve )\n    {\n      // TODO -- What do we want to do about this routine?\n      //Debug.Assert( 1 >=\n      //  ((pMem.zMalloc !=null )? 1 : 0) + //&& pMem.zMalloc==pMem.z) ? 1 : 0) +\n      //  (((pMem.flags & MEM_Dyn)!=0 && pMem.xDel!=null) ? 1 : 0) +\n      //  ((pMem.flags & MEM_Ephem)!=0 ? 1 : 0) +\n      //  ((pMem.flags & MEM_Static)!=0 ? 1 : 0)\n      //);\n      //assert( (pMem->flags&MEM_RowSet)==0 );\n\n      //if( n<32 ) n = 32;\n      //if( sqlite3DbMallocSize(pMem->db, pMem.zMalloc)<n ){\n      if ( preserve != 0 )\n      {//& pMem.z==pMem.zMalloc ){\n        if ( pMem.z == null ) pMem.z = "";//      sqlite3DbReallocOrFree( pMem.db, pMem.z, n );\n        else pMem.z = pMem.z.Substring( 0, n );\n        preserve = 0;\n      }\n      else\n      {\n        //  //sqlite3DbFree(pMem->db,ref pMem.zMalloc);\n        pMem.z = "";//   sqlite3DbMallocRaw( pMem.db, n );\n      }\n      //}\n\n      //  if( pMem->z && preserve && pMem->zMalloc && pMem->z!=pMem->zMalloc ){\n      // memcpy(pMem.zMalloc, pMem.z, pMem.n);\n      //}\n      if ( ( pMem.flags & MEM_Dyn ) != 0 && pMem.xDel != null )\n      {\n        pMem.xDel( ref pMem.z );\n      }\n\n      // TODO --pMem.z = pMem.zMalloc;\n      if ( pMem.z == null )\n      {\n        pMem.flags = MEM_Null;\n      }\n      else\n      {\n        pMem.flags = (u16)( pMem.flags & ~( MEM_Ephem | MEM_Static ) );\n      }\n      pMem.xDel = null;\n      return pMem.z != null ? SQLITE_OK : SQLITE_NOMEM;\n    }\n\n    /*\n    ** Make the given Mem object MEM_Dyn.  In other words, make it so\n    ** that any TEXT or BLOB content is stored in memory obtained from\n    ** malloc().  In this way, we know that the memory is safe to be\n    ** overwritten or altered.\n    **\n    ** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.\n    */\n    static int sqlite3VdbeMemMakeWriteable( Mem pMem )\n    {\n      int f;\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      expandBlob( pMem );\n      f = pMem.flags;\n      if ( ( f & ( MEM_Str | MEM_Blob ) ) != 0 ) // TODO -- && pMem.z != pMem.zMalloc )\n      {\n        //if ( sqlite3VdbeMemGrow( pMem, pMem.n + 2, 1 ) != 0 )\n        //{\n        //  return SQLITE_NOMEM;\n        //}\n        //pMem.z[pMem->n] = 0;\n        //pMem.z[pMem->n + 1] = 0;\n        pMem.flags |= MEM_Term;\n      }\n\n      return SQLITE_OK;\n    }\n    /*\n    ** If the given Mem* has a zero-filled tail, turn it into an ordinary\n    ** blob stored in dynamically allocated space.\n    */\n#if !SQLITE_OMIT_INCRBLOB\nstatic int sqlite3VdbeMemExpandBlob( Mem pMem )\n{\nif ( ( pMem.flags & MEM_Zero ) != 0 )\n{\nu32 nByte;\nDebug.Assert( ( pMem.flags & MEM_Blob ) != 0 );\nDebug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\nDebug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n/* Set nByte to the number of bytes required to store the expanded blob. */\nnByte = (u32)( pMem.n + pMem.u.nZero );\nif ( nByte <= 0 )\n{\nnByte = 1;\n}\nif ( sqlite3VdbeMemGrow( pMem, (int)nByte, 1 ) != 0 )\n{\nreturn SQLITE_NOMEM;\n} /* Set nByte to the number of bytes required to store the expanded blob. */\nnByte = (u32)( pMem.n + pMem.u.nZero );\nif ( nByte <= 0 )\n{\nnByte = 1;\n}\nif ( sqlite3VdbeMemGrow( pMem, (int)nByte, 1 ) != 0 )\n{\nreturn SQLITE_NOMEM;\n}\n//memset(&pMem->z[pMem->n], 0, pMem->u.nZero);\npMem.zBLOB = Encoding.UTF8.GetBytes( pMem.z );\npMem.z = null;\npMem.n += (int)pMem.u.nZero;\npMem.u.i = 0;\npMem.flags = (u16)( pMem.flags & ~( MEM_Zero | MEM_Static | MEM_Ephem | MEM_Term ) );\npMem.flags |= MEM_Dyn;\n}\nreturn SQLITE_OK;\n}\n#endif\n\n\n    /*\n** Make sure the given Mem is \\u0000 terminated.\n*/\n    static int sqlite3VdbeMemNulTerminate( Mem pMem )\n    {\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      if ( ( pMem.flags & MEM_Term ) != 0 || ( pMem.flags & MEM_Str ) == 0 )\n      {\n        return SQLITE_OK;   /* Nothing to do */\n      }\n      //if ( pMem.n != 0 && sqlite3VdbeMemGrow( pMem, pMem.n + 2, 1 ) != 0 )\n      //{\n      //  return SQLITE_NOMEM;\n      //}\n      //  pMem.z[pMem->n] = 0;\n      //  pMem.z[pMem->n+1] = 0;\n      if ( pMem.z != null && pMem.n < pMem.z.Length ) pMem.z = pMem.z.Substring( 0, pMem.n );\n      pMem.flags |= MEM_Term;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Add MEM_Str to the set of representations for the given Mem.  Numbers\n    ** are converted using sqlite3_snprintf().  Converting a BLOB to a string\n    ** is a no-op.\n    **\n    ** Existing representations MEM_Int and MEM_Real are *not* invalidated.\n    **\n    ** A MEM_Null value will never be passed to this function. This function is\n    ** used for converting values to text for returning to the user (i.e. via\n    ** sqlite3_value_text()), or for ensuring that values to be used as btree\n    ** keys are strings. In the former case a NULL pointer is returned the\n    ** user and the later is an internal programming error.\n    */\n    static int sqlite3VdbeMemStringify( Mem pMem, int enc )\n    {\n      int rc = SQLITE_OK;\n      int fg = pMem.flags;\n      const int nByte = 32;\n\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      Debug.Assert( ( fg & MEM_Zero ) == 0 );\n      Debug.Assert( ( fg & ( MEM_Str | MEM_Blob ) ) == 0 );\n      Debug.Assert( ( fg & ( MEM_Int | MEM_Real ) ) != 0 );\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      //assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n      if ( sqlite3VdbeMemGrow( pMem, nByte, 0 ) != 0 )\n      {\n        return SQLITE_NOMEM;\n      }\n\n      /* For a Real or Integer, use sqlite3_snprintf() to produce the UTF-8\n      ** string representation of the value. Then, if the required encoding\n      ** is UTF-16le or UTF-16be do a translation.\n      **\n      ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.\n      */\n      if ( ( fg & MEM_Int ) != 0 )\n      {\n        pMem.z = pMem.u.i.ToString(); //sqlite3_snprintf(nByte, pMem.z, "%lld", pMem->u.i);\n      }\n      else\n      {\n        Debug.Assert( ( fg & MEM_Real ) != 0 );\n        if ( Double.IsNegativeInfinity( pMem.r ) ) pMem.z = "-Inf";\n        else if ( Double.IsInfinity( pMem.r ) ) pMem.z = "Inf";\n        else if ( Double.IsPositiveInfinity( pMem.r ) ) pMem.z = "+Inf";\n        else if ( pMem.r.ToString().Contains( "." ) ) pMem.z = pMem.r.ToString().ToLower();//sqlite3_snprintf(nByte, pMem.z, "%!.15g", pMem->r);\n        else pMem.z = pMem.r.ToString() + ".0";\n      }\n      pMem.n = sqlite3Strlen30( pMem.z );\n      pMem.enc = SQLITE_UTF8;\n      pMem.flags |= MEM_Str | MEM_Term;\n      sqlite3VdbeChangeEncoding( pMem, enc );\n      return rc;\n    }\n\n    /*\n    ** Memory cell pMem contains the context of an aggregate function.\n    ** This routine calls the finalize method for that function.  The\n    ** result of the aggregate is stored back into pMem.\n    **\n    ** Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK\n    ** otherwise.\n    */\n    static int sqlite3VdbeMemFinalize( Mem pMem, FuncDef pFunc )\n    {\n      int rc = SQLITE_OK;\n      if ( ALWAYS( pFunc != null && pFunc.xFinalize != null ) )\n      {\n        sqlite3_context ctx = new sqlite3_context();\n        Debug.Assert( ( pMem.flags & MEM_Null ) != 0 || pFunc == pMem.u.pDef );\n        Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n        //memset(&ctx, 0, sizeof(ctx));\n        ctx.s.flags = MEM_Null;\n        ctx.s.db = pMem.db;\n        ctx.pMem = pMem;\n        ctx.pFunc = pFunc;\n        pFunc.xFinalize( ctx );\n        Debug.Assert( 0 == ( pMem.flags & MEM_Dyn ) && pMem.xDel == null );\n        //sqlite3DbFree(pMem.db,ref pMem.zMalloc);\n        ctx.s.CopyTo( pMem );//memcpy(pMem, &ctx.s, sizeof(ctx.s));\n        rc = ctx.isError;\n      }\n      return rc;\n    }\n\n    /*\n    ** If the memory cell contains a string value that must be freed by\n    ** invoking an external callback, free it now. Calling this function\n    ** does not free any Mem.zMalloc buffer.\n    */\n    static void sqlite3VdbeMemReleaseExternal( Mem p )\n    {\n      Debug.Assert( p.db == null || sqlite3_mutex_held( p.db.mutex ) );\n      if ( ( p.flags & ( MEM_Agg | MEM_Dyn | MEM_RowSet ) ) != 0 )\n      {\n        if ( ( p.flags & MEM_Agg ) != 0 )\n        {\n          sqlite3VdbeMemFinalize( p, p.u.pDef );\n          Debug.Assert( ( p.flags & MEM_Agg ) == 0 );\n          sqlite3VdbeMemRelease( p );\n        }\n        else if ( ( p.flags & MEM_Dyn ) != 0 && p.xDel != null )\n        {\n          Debug.Assert( ( p.flags & MEM_RowSet ) == 0 );\n          p.xDel( ref p.z );\n          p.xDel = null;\n        }\n        else if ( ( p.flags & MEM_RowSet ) != 0 )\n        {\n          sqlite3RowSetClear( p.u.pRowSet );\n        }\n      }\n      p.n = 0;\n      p.z = null;\n      p.zBLOB = null;\n      //\n      // Release additional C# pointers for backlinks\n      p._Mem = null;\n      p._SumCtx = null;\n      p._MD5Context = null;\n      p._MD5Context = null;\n    }\n\n    /*\n    ** Release any memory held by the Mem. This may leave the Mem in an\n    ** inconsistent state, for example with (Mem.z==0) and\n    ** (Mem.type==SQLITE_TEXT).\n    */\n    static void sqlite3VdbeMemRelease( Mem p )\n    {\n      sqlite3VdbeMemReleaseExternal( p );\n      //sqlite3DbFree(p.db,ref p.zMalloc);\n      p.zBLOB = null;\n      p.z = null;\n      //p.zMalloc = null;\n      p.xDel = null;\n    }\n\n    /*\n    ** Convert a 64-bit IEEE double into a 64-bit signed integer.\n    ** If the double is too large, return 0x8000000000000000.\n    **\n    ** Most systems appear to do this simply by assigning\n    ** variables and without the extra range tests.  But\n    ** there are reports that windows throws an expection\n    ** if the floating point value is out of range. (See ticket #2880.)\n    ** Because we do not completely understand the problem, we will\n    ** take the conservative approach and always do range tests\n    ** before attempting the conversion.\n    */\n    static i64 doubleToInt64( double r )\n    {\n      /*\n      ** Many compilers we encounter do not define constants for the\n      ** minimum and maximum 64-bit integers, or they define them\n      ** inconsistently.  And many do not understand the "LL" notation.\n      ** So we define our own static constants here using nothing\n      ** larger than a 32-bit integer constant.\n      */\n      const i64 maxInt = LARGEST_INT64;\n      const i64 minInt = SMALLEST_INT64;\n\n      if ( r < (double)minInt )\n      {\n        return minInt;\n      }\n      else if ( r > (double)maxInt )\n      {\n        /* minInt is correct here - not maxInt.  It turns out that assigning\n        ** a very large positive number to an integer results in a very large\n        ** negative integer.  This makes no sense, but it is what x86 hardware\n        ** does so for compatibility we will do the same in software. */\n        return minInt;\n      }\n      else\n      {\n        return (i64)r;\n      }\n    }\n\n    /*\n    ** Return some kind of integer value which is the best we can do\n    ** at representing the value that *pMem describes as an integer.\n    ** If pMem is an integer, then the value is exact.  If pMem is\n    ** a floating-point then the value returned is the integer part.\n    ** If pMem is a string or blob, then we make an attempt to convert\n    ** it into a integer and return that.  If pMem represents an\n    ** an SQL-NULL value, return 0.\n    **\n    ** If pMem represents a string value, its encoding might be changed.\n    */\n    static i64 sqlite3VdbeIntValue( Mem pMem )\n    {\n      int flags;\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      // assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n      flags = pMem.flags;\n      if ( ( flags & MEM_Int ) != 0 )\n      {\n        return pMem.u.i;\n      }\n      else if ( ( flags & MEM_Real ) != 0 )\n      {\n        return doubleToInt64( pMem.r );\n      }\n      else if ( ( flags & ( MEM_Str | MEM_Blob ) ) != 0 )\n      {\n        i64 value = 0;\n        pMem.flags |= MEM_Str;\n        if ( sqlite3VdbeChangeEncoding( pMem, SQLITE_UTF8 ) != 0\n        || ( sqlite3VdbeMemNulTerminate( pMem ) != 0 ) )\n        {\n          return 0;\n        }\n        if ( pMem.z == null ) return 0;\n        Debug.Assert( pMem.z != null );\n        sqlite3Atoi64( pMem.z, ref value );\n        return value;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n\n    /*\n    ** Return the best representation of pMem that we can get into a\n    ** double.  If pMem is already a double or an integer, return its\n    ** value.  If it is a string or blob, try to convert it to a double.\n    ** If it is a NULL, return 0.0.\n    */\n    static double sqlite3VdbeRealValue( Mem pMem )\n    {\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      //assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n      if ( ( pMem.flags & MEM_Real ) != 0 )\n      {\n        return pMem.r;\n      }\n      else if ( ( pMem.flags & MEM_Int ) != 0 )\n      {\n        return (double)pMem.u.i;\n      }\n      else if ( ( pMem.flags & ( MEM_Str | MEM_Blob ) ) != 0 )\n      {\n        /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n        double val = (double)0;\n        pMem.flags |= MEM_Str;\n        if ( sqlite3VdbeChangeEncoding( pMem, SQLITE_UTF8 ) != 0\n        || sqlite3VdbeMemNulTerminate( pMem ) != 0 )\n        {\n          /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n          return (double)0;\n        }\n        if ( pMem.zBLOB != null ) sqlite3AtoF( Encoding.UTF8.GetString( pMem.zBLOB ), ref val );\n        else if ( pMem.z != null ) sqlite3AtoF( pMem.z, ref val );\n        else val = 0.0;\n        return val;\n      }\n      else\n      {\n        /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n        return (double)0;\n      }\n    }\n\n    /*\n    ** The MEM structure is already a MEM_Real.  Try to also make it a\n    ** MEM_Int if we can.\n    */\n    static void sqlite3VdbeIntegerAffinity( Mem pMem )\n    {\n      Debug.Assert( ( pMem.flags & MEM_Real ) != 0 );\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      //assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n      pMem.u.i = doubleToInt64( pMem.r );\n\n      /* Only mark the value as an integer if\n      **\n      **    (1) the round-trip conversion real->int->real is a no-op, and\n      **    (2) The integer is neither the largest nor the smallest\n      **        possible integer (ticket #3922)\n      **\n      ** The second term in the following conditional enforces the second\n      ** condition under the assumption that additional overflow causes\n      ** values to wrap around.\n      */\n      if ( pMem.r == (double)pMem.u.i && ( pMem.u.i - 1 ) < ( pMem.u.i + 1 ) )\n      {\n        pMem.flags |= MEM_Int;\n      }\n    }\n\n    /*\n    ** Convert pMem to type integer.  Invalidate any prior representations.\n    */\n    static int sqlite3VdbeMemIntegerify( Mem pMem )\n    {\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      //assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n      pMem.u.i = sqlite3VdbeIntValue( pMem );\n      MemSetTypeFlag( pMem, MEM_Int );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Convert pMem so that it is of type MEM_Real.\n    ** Invalidate any prior representations.\n    */\n    static int sqlite3VdbeMemRealify( Mem pMem )\n    {\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      //assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n      pMem.r = sqlite3VdbeRealValue( pMem );\n      MemSetTypeFlag( pMem, MEM_Real );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Convert pMem so that it has types MEM_Real or MEM_Int or both.\n    ** Invalidate any prior representations.\n    */\n    static int sqlite3VdbeMemNumerify( Mem pMem )\n    {\n      double r1, r2;\n      i64 i;\n      Debug.Assert( ( pMem.flags & ( MEM_Int | MEM_Real | MEM_Null ) ) == 0 );\n      Debug.Assert( ( pMem.flags & ( MEM_Blob | MEM_Str ) ) != 0 );\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      r1 = sqlite3VdbeRealValue( pMem );\n      i = doubleToInt64( r1 );\n      r2 = (double)i;\n      if ( r1 == r2 )\n      {\n        sqlite3VdbeMemIntegerify( pMem );\n      }\n      else\n      {\n        pMem.r = r1;\n        MemSetTypeFlag( pMem, MEM_Real );\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Delete any previous value and set the value stored in pMem to NULL.\n    */\n    static void sqlite3VdbeMemSetNull( Mem pMem )\n    {\n      if ( ( pMem.flags & MEM_RowSet ) != 0 )\n      {\n        sqlite3RowSetClear( pMem.u.pRowSet );\n      }\n      MemSetTypeFlag( pMem, MEM_Null );\n      pMem.zBLOB = null;\n      pMem.z = null;\n      pMem.type = SQLITE_NULL;\n    }\n\n    /*\n    ** Delete any previous value and set the value to be a BLOB of length\n    ** n containing all zeros.\n    */\n    static void sqlite3VdbeMemSetZeroBlob( Mem pMem, int n )\n    {\n      sqlite3VdbeMemRelease( pMem );\n      pMem.flags = MEM_Blob | MEM_Zero;\n      pMem.type = SQLITE_BLOB;\n      pMem.n = 0;\n      if ( n < 0 ) n = 0;\n      pMem.u.nZero = n;\n      pMem.enc = SQLITE_UTF8;\n#if SQLITE_OMIT_INCRBLOB\n  sqlite3VdbeMemGrow(pMem, n, 0);\n  //if( pMem.z!= null ){\n   pMem.n = n;\n   pMem.z = null;//memset(pMem.z, 0, n);\n   pMem.zBLOB = new byte[n];\n   //}\n#endif\n    }\n\n    /*\n    ** Delete any previous value and set the value stored in pMem to val,\n    ** manifest type INTEGER.\n    */\n    static void sqlite3VdbeMemSetInt64( Mem pMem, i64 val )\n    {\n      sqlite3VdbeMemRelease( pMem );\n      pMem.u.i = val;\n      pMem.flags = MEM_Int;\n      pMem.type = SQLITE_INTEGER;\n    }\n\n    /*\n    ** Delete any previous value and set the value stored in pMem to val,\n    ** manifest type REAL.\n    */\n    static void sqlite3VdbeMemSetDouble( Mem pMem, double val )\n    {\n      if ( sqlite3IsNaN( val ) )\n      {\n        sqlite3VdbeMemSetNull( pMem );\n      }\n      else\n      {\n        sqlite3VdbeMemRelease( pMem );\n        pMem.r = val;\n        pMem.flags = MEM_Real;\n        pMem.type = SQLITE_FLOAT;\n      }\n    }\n\n    /*\n    ** Delete any previous value and set the value of pMem to be an\n    ** empty boolean index.\n    */\n    static void sqlite3VdbeMemSetRowSet( Mem pMem )\n    {\n      sqlite3 db = pMem.db;\n      Debug.Assert( db != null );\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      sqlite3VdbeMemRelease( pMem );\n      //pMem.zMalloc = sqlite3DbMallocRaw( db, 64 );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  pMem.flags = MEM_Null;\n      //}\n      //else\n      {\n        //Debug.Assert( pMem.zMalloc );\n        pMem.u.pRowSet = new RowSet( db, 5 );// sqlite3RowSetInit( db, pMem.zMalloc,\n        //     sqlite3DbMallocSize( db, pMem.zMalloc ) );\n        Debug.Assert( pMem.u.pRowSet != null );\n        pMem.flags = MEM_RowSet;\n      }\n    }\n\n    /*\n    ** Return true if the Mem object contains a TEXT or BLOB that is\n    ** too large - whose size exceeds p.db.aLimit[SQLITE_LIMIT_LENGTH].\n    */\n    static bool sqlite3VdbeMemTooBig( Mem p )\n    {\n      Debug.Assert( p.db != null );\n      if ( ( p.flags & ( MEM_Str | MEM_Blob ) ) != 0 )\n      {\n        int n = p.n;\n        if ( ( p.flags & MEM_Zero ) != 0 )\n        {\n          n += p.u.nZero;\n        }\n        return n > p.db.aLimit[SQLITE_LIMIT_LENGTH];\n      }\n      return false;\n    }\n\n    /*\n    ** Size of struct Mem not including the Mem.zMalloc member.\n    */\n    //#define MEMCELLSIZE (size_t)(&(((Mem *)0).zMalloc))\n\n    /*\n    ** Make an shallow copy of pFrom into pTo.  Prior contents of\n    ** pTo are freed.  The pFrom.z field is not duplicated.  If\n    ** pFrom.z is used, then pTo.z points to the same thing as pFrom.z\n    ** and flags gets srcType (either MEM_Ephem or MEM_Static).\n    */\n    static void sqlite3VdbeMemShallowCopy( Mem pTo, Mem pFrom, int srcType )\n    {\n      Debug.Assert( ( pFrom.flags & MEM_RowSet ) == 0 );\n      sqlite3VdbeMemReleaseExternal( pTo );\n      pFrom.CopyTo( pTo );//  memcpy(pTo, pFrom, MEMCELLSIZE);\n      pTo.xDel = null;\n      if ( ( pFrom.flags & MEM_Dyn ) != 0 )\n      {//|| pFrom.z==pFrom.zMalloc ){\n        pTo.flags = (u16)( pFrom.flags & ~( MEM_Dyn | MEM_Static | MEM_Ephem ) );\n        Debug.Assert( srcType == MEM_Ephem || srcType == MEM_Static );\n        pTo.flags |= (u16)srcType;\n      }\n    }\n\n    /*\n    ** Make a full copy of pFrom into pTo.  Prior contents of pTo are\n    ** freed before the copy is made.\n    */\n    static int sqlite3VdbeMemCopy( Mem pTo, Mem pFrom )\n    {\n      int rc = SQLITE_OK;\n\n      Debug.Assert( ( pFrom.flags & MEM_RowSet ) == 0 );\n      sqlite3VdbeMemReleaseExternal( pTo );\n      pFrom.CopyTo( pTo );// memcpy(pTo, pFrom, MEMCELLSIZE);\n      pTo.flags = (u16)( pTo.flags & ~MEM_Dyn );\n\n      if ( ( pTo.flags & ( MEM_Str | MEM_Blob ) ) != 0 )\n      {\n        if ( 0 == ( pFrom.flags & MEM_Static ) )\n        {\n          pTo.flags |= MEM_Ephem;\n          rc = sqlite3VdbeMemMakeWriteable( pTo );\n        }\n      }\n\n      return rc;\n    }\n\n\n\n\n    /*\n    ** Transfer the contents of pFrom to pTo. Any existing value in pTo is\n    ** freed. If pFrom contains ephemeral data, a copy is made.\n    **\n    ** pFrom contains an SQL NULL when this routine returns.\n    */\n    static void sqlite3VdbeMemMove( Mem pTo, Mem pFrom )\n    {\n      Debug.Assert( pFrom.db == null || sqlite3_mutex_held( pFrom.db.mutex ) );\n      Debug.Assert( pTo.db == null || sqlite3_mutex_held( pTo.db.mutex ) );\n      Debug.Assert( pFrom.db == null || pTo.db == null || pFrom.db == pTo.db );\n      sqlite3VdbeMemRelease( pTo );\n      pFrom.CopyTo( pTo );// memcpy(pTo, pFrom, Mem).Length;\n      pFrom.flags = MEM_Null;\n      pFrom.xDel = null;\n      pFrom.z = null;\n      pFrom.zBLOB = null;\n      //pFrom.zMalloc=null;\n    }\n\n    /*\n    ** Change the value of a Mem to be a string or a BLOB.\n    **\n    ** The memory management strategy depends on the value of the xDel\n    ** parameter. If the value passed is SQLITE_TRANSIENT, then the\n    ** string is copied into a (possibly existing) buffer managed by the\n    ** Mem structure. Otherwise, any existing buffer is freed and the\n    ** pointer copied.\n    **\n    ** If the string is too large (if it exceeds the SQLITE_LIMIT_LENGTH\n    ** size limit) then no memory allocation occurs.  If the string can be\n    ** stored without allocating memory, then it is.  If a memory allocation\n    ** is required to store the string, then value of pMem is unchanged.  In\n    ** either case, SQLITE_TOOBIG is returned.\n    */\n    static int sqlite3VdbeMemSetStr(\n    Mem pMem,           /* Memory cell to set to string value */\n    string z,           /* String pointer */\n    int n,              /* Bytes in string, or negative */\n    u8 enc,             /* Encoding of z.  0 for BLOBs */\n    dxDel xDel//)(void*)/* Destructor function */\n    )\n    {\n      int nByte = n;      /* New value for pMem->n */\n      int iLimit;         /* Maximum allowed string or blob size */\n      u16 flags = 0;      /* New value for pMem->flags */\n\n      Debug.Assert( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex ) );\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n\n      /* If z is a NULL pointer, set pMem to contain an SQL NULL. */\n      if ( z == null )\n      {\n        sqlite3VdbeMemSetNull( pMem );\n        return SQLITE_OK;\n      }\n\n      if ( pMem.db != null )\n      {\n        iLimit = pMem.db.aLimit[SQLITE_LIMIT_LENGTH];\n      }\n      else\n      {\n        iLimit = SQLITE_MAX_LENGTH;\n      }\n      flags = (u16)( enc == 0 ? MEM_Blob : MEM_Str );\n      if ( nByte < 0 )\n      {\n        Debug.Assert( enc != 0 );\n        if ( enc == SQLITE_UTF8 )\n        {\n          for ( nByte = 0 ; nByte <= iLimit && nByte < z.Length && z[nByte] != 0 ; nByte++ ) { }\n        }\n        else\n        {\n          for ( nByte = 0 ; nByte <= iLimit && z[nByte] != 0 || z[nByte + 1] != 0 ; nByte += 2 ) { }\n        }\n        flags |= MEM_Term;\n      }\n\n      /* The following block sets the new values of Mem.z and Mem.xDel. It\n      ** also sets a flag in local variable "flags" to indicate the memory\n      ** management (one of MEM_Dyn or MEM_Static).\n      */\n      if ( xDel == SQLITE_TRANSIENT )\n      {\n        u32 nAlloc = (u32)nByte;\n        if ( ( flags & MEM_Term ) != 0 )\n        {\n          nAlloc += (u32)( enc == SQLITE_UTF8 ? 1 : 2 );\n        }\n        if ( nByte > iLimit )\n        {\n          return SQLITE_TOOBIG;\n        }\n        if ( sqlite3VdbeMemGrow( pMem, (int)nAlloc, 0 ) != 0 )\n        {\n          return SQLITE_NOMEM;\n        }\n        //if ( nAlloc < z.Length )\n        //{ pMem.z = new byte[nAlloc]; Buffer.BlockCopy( z, 0, pMem.z, 0, (int)nAlloc ); }\n        //else\n        if ( enc == 0 )\n        {\n          pMem.z = null;\n          pMem.zBLOB = new byte[n];\n          for ( int i = 0 ; i < n && i < z.Length ; i++ ) pMem.zBLOB[i] = (byte)z[i];\n        }\n        else\n        {\n          pMem.z = z;//memcpy(pMem.z, z, nAlloc);\n          pMem.zBLOB = null;\n        }\n      }\n      else if ( xDel == SQLITE_DYNAMIC )\n      {\n        sqlite3VdbeMemRelease( pMem );\n        //pMem.zMalloc = pMem.z = (char*)z;\n        if ( enc == 0 )\n        {\n          pMem.z = null;\n          pMem.zBLOB = Encoding.UTF8.GetBytes( z );\n        }\n        else\n        {\n          pMem.z = z;//memcpy(pMem.z, z, nAlloc);\n          pMem.zBLOB = null;\n        }\n        pMem.xDel = null;\n      }\n      else\n      {\n        sqlite3VdbeMemRelease( pMem );\n        if ( enc == 0 )\n        {\n          pMem.z = null;\n          pMem.zBLOB = Encoding.UTF8.GetBytes( z );\n        }\n        else\n        {\n          pMem.z = z;//memcpy(pMem.z, z, nAlloc);\n          pMem.zBLOB = null;\n        }\n        pMem.xDel = xDel;\n        flags |= (u16)( ( xDel == SQLITE_STATIC ) ? MEM_Static : MEM_Dyn );\n      }\n      pMem.n = nByte;\n      pMem.flags = flags;\n      pMem.enc = ( enc == 0 ? SQLITE_UTF8 : enc );\n      pMem.type = ( enc == 0 ? SQLITE_BLOB : SQLITE_TEXT );\n\n#if !SQLITE_OMIT_UTF16\nif( pMem.enc!=SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem)!=0 ){\nreturn SQLITE_NOMEM;\n}\n#endif\n\n      if ( nByte > iLimit )\n      {\n        return SQLITE_TOOBIG;\n      }\n\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Compare the values contained by the two memory cells, returning\n    ** negative, zero or positive if pMem1 is less than, equal to, or greater\n    ** than pMem2. Sorting order is NULL\'s first, followed by numbers (integers\n    ** and reals) sorted numerically, followed by text ordered by the collating\n    ** sequence pColl and finally blob\'s ordered by memcmp().\n    **\n    ** Two NULL values are considered equal by this function.\n    */\n    static int sqlite3MemCompare( Mem pMem1, Mem pMem2, CollSeq pColl )\n    {\n      int rc;\n      int f1, f2;\n      int combined_flags;\n\n      /* Interchange pMem1 and pMem2 if the collating sequence specifies\n      ** DESC order.\n      */\n      f1 = pMem1.flags;\n      f2 = pMem2.flags;\n      combined_flags = f1 | f2;\n      Debug.Assert( ( combined_flags & MEM_RowSet ) == 0 );\n\n      /* If one value is NULL, it is less than the other. If both values\n      ** are NULL, return 0.\n      */\n      if ( ( combined_flags & MEM_Null ) != 0 )\n      {\n        return ( f2 & MEM_Null ) - ( f1 & MEM_Null );\n      }\n\n      /* If one value is a number and the other is not, the number is less.\n      ** If both are numbers, compare as reals if one is a real, or as integers\n      ** if both values are integers.\n      */\n      if ( ( combined_flags & ( MEM_Int | MEM_Real ) ) != 0 )\n      {\n        if ( ( f1 & ( MEM_Int | MEM_Real ) ) == 0 )\n        {\n          return 1;\n        }\n        if ( ( f2 & ( MEM_Int | MEM_Real ) ) == 0 )\n        {\n          return -1;\n        }\n        if ( ( f1 & f2 & MEM_Int ) == 0 )\n        {\n          double r1, r2;\n          if ( ( f1 & MEM_Real ) == 0 )\n          {\n            r1 = (double)pMem1.u.i;\n          }\n          else\n          {\n            r1 = pMem1.r;\n          }\n          if ( ( f2 & MEM_Real ) == 0 )\n          {\n            r2 = (double)pMem2.u.i;\n          }\n          else\n          {\n            r2 = pMem2.r;\n          }\n          if ( r1 < r2 ) return -1;\n          if ( r1 > r2 ) return 1;\n          return 0;\n        }\n        else\n        {\n          Debug.Assert( ( f1 & MEM_Int ) != 0 );\n          Debug.Assert( ( f2 & MEM_Int ) != 0 );\n          if ( pMem1.u.i < pMem2.u.i ) return -1;\n          if ( pMem1.u.i > pMem2.u.i ) return 1;\n          return 0;\n        }\n      }\n\n      /* If one value is a string and the other is a blob, the string is less.\n      ** If both are strings, compare using the collating functions.\n      */\n      if ( ( combined_flags & MEM_Str ) != 0 )\n      {\n        if ( ( f1 & MEM_Str ) == 0 )\n        {\n          return 1;\n        }\n        if ( ( f2 & MEM_Str ) == 0 )\n        {\n          return -1;\n        }\n\n        Debug.Assert( pMem1.enc == pMem2.enc );\n        Debug.Assert( pMem1.enc == SQLITE_UTF8 ||\n        pMem1.enc == SQLITE_UTF16LE || pMem1.enc == SQLITE_UTF16BE );\n\n        /* The collation sequence must be defined at this point, even if\n        ** the user deletes the collation sequence after the vdbe program is\n        ** compiled (this was not always the case).\n        */\n        Debug.Assert( pColl == null || pColl.xCmp != null );\n\n        if ( pColl != null )\n        {\n          if ( pMem1.enc == pColl.enc )\n          {\n            /* The strings are already in the correct encoding.  Call the\n            ** comparison function directly */\n            return pColl.xCmp( pColl.pUser, pMem1.n, pMem1.z, pMem2.n, pMem2.z );\n          }\n          else\n          {\n            string v1, v2;\n            int n1, n2;\n            Mem c1;\n            Mem c2;\n            c1 = new Mem();// memset( &c1, 0, sizeof( c1 ) );\n            c2 = new Mem();//memset( &c2, 0, sizeof( c2 ) );\n            sqlite3VdbeMemShallowCopy( c1, pMem1, MEM_Ephem );\n            sqlite3VdbeMemShallowCopy( c2, pMem2, MEM_Ephem );\n            v1 = sqlite3ValueText( (sqlite3_value)c1, pColl.enc );\n            n1 = v1 == null ? 0 : c1.n;\n            v2 = sqlite3ValueText( (sqlite3_value)c2, pColl.enc );\n            n2 = v2 == null ? 0 : c2.n;\n            rc = pColl.xCmp( pColl.pUser, n1, v1, n2, v2 );\n            sqlite3VdbeMemRelease( c1 );\n            sqlite3VdbeMemRelease( c2 );\n            return rc;\n          }\n        }\n        /* If a NULL pointer was passed as the collate function, fall through\n        ** to the blob case and use memcmp().  */\n      }\n\n      /* Both values must be blobs.  Compare using memcmp().  */\n      if ( ( pMem1.flags & MEM_Blob ) != 0 )\n        if ( pMem1.zBLOB != null ) rc = memcmp( pMem1.zBLOB, pMem2.zBLOB, ( pMem1.n > pMem2.n ) ? pMem2.n : pMem1.n );\n        else rc = memcmp( pMem1.z, pMem2.zBLOB, ( pMem1.n > pMem2.n ) ? pMem2.n : pMem1.n );\n      else\n        rc = memcmp( pMem1.z, pMem2.z, ( pMem1.n > pMem2.n ) ? pMem2.n : pMem1.n );\n      if ( rc == 0 )\n      {\n        rc = pMem1.n - pMem2.n;\n      }\n      return rc;\n    }\n\n    /*\n    ** Move data out of a btree key or data field and into a Mem structure.\n    ** The data or key is taken from the entry that pCur is currently pointing\n    ** to.  offset and amt determine what portion of the data or key to retrieve.\n    ** key is true to get the key or false to get data.  The result is written\n    ** into the pMem element.\n    **\n    ** The pMem structure is assumed to be uninitialized.  Any prior content\n    ** is overwritten without being freed.\n    **\n    ** If this routine fails for any reason (malloc returns NULL or unable\n    ** to read from the disk) then the pMem is left in an inconsistent state.\n    */\n    static int sqlite3VdbeMemFromBtree(\n    BtCursor pCur,    /* Cursor pointing at record to retrieve. */\n    int offset,       /* Offset from the start of data to return bytes from. */\n    int amt,          /* Number of bytes to return. */\n    bool key,         /* If true, retrieve from the btree key, not data. */\n    Mem pMem          /* OUT: Return data in this Mem structure. */\n    )\n    {\n      byte[] zData;       /* Data from the btree layer */\n      int available = 0; /* Number of bytes available on the local btree page */\n      int rc = SQLITE_OK; /* Return code */\n\n      Debug.Assert( sqlite3BtreeCursorIsValid(pCur) );\n\n\t/* Note: the calls to BtreeKeyFetch() and DataFetch() below assert()\n      ** that both the BtShared and database handle mutexes are held. */\n      Debug.Assert( ( pMem.flags & MEM_RowSet ) == 0 );\n      int outOffset = -1;\n      if ( key )\n      {\n        zData = sqlite3BtreeKeyFetch( pCur, ref available, ref outOffset );\n      }\n      else\n      {\n        zData = sqlite3BtreeDataFetch( pCur, ref available, ref outOffset );\n      }\n      Debug.Assert( zData != null );\n\n      if ( offset + amt <= available && ( pMem.flags & MEM_Dyn ) == 0 )\n      {\n        sqlite3VdbeMemRelease( pMem );\n        pMem.zBLOB = new byte[amt];\n        Buffer.BlockCopy( zData, offset, pMem.zBLOB, 0, amt );//pMem.z = &zData[offset];\n        pMem.flags = MEM_Blob | MEM_Ephem;\n      }\n      else if ( SQLITE_OK == ( rc = sqlite3VdbeMemGrow( pMem, amt + 2, 0 ) ) )\n      {\n        pMem.enc = 0;\n        pMem.type = SQLITE_BLOB;\n        pMem.z = null;\n        pMem.zBLOB = new byte[amt];\n        pMem.flags = MEM_Blob | MEM_Dyn | MEM_Term;\n        if ( key )\n        {\n          rc = sqlite3BtreeKey( pCur, (u32)offset, (u32)amt,  pMem.zBLOB );\n        }\n        else\n        {\n          rc = sqlite3BtreeData( pCur, (u32)offset, (u32)amt, pMem.zBLOB );//pMem.z =  pMem_z ;\n        }\n        //pMem.z[amt] = 0;\n        //pMem.z[amt+1] = 0;\n        if ( rc != SQLITE_OK )\n        {\n          sqlite3VdbeMemRelease( pMem );\n        }\n      }\n      pMem.n = amt;\n\n      return rc;\n    }\n\n    /* This function is only available internally, it is not part of the\n    ** external API. It works in a similar way to sqlite3_value_text(),\n    ** except the data returned is in the encoding specified by the second\n    ** parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or\n    ** SQLITE_UTF8.\n    **\n    ** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.\n    ** If that is the case, then the result must be aligned on an even byte\n    ** boundary.\n    */\n    static string sqlite3ValueText( sqlite3_value pVal, int enc )\n    {\n      if ( pVal == null ) return null;\n\n      Debug.Assert( pVal.db == null || sqlite3_mutex_held( pVal.db.mutex ) );\n      Debug.Assert( ( enc & 3 ) == ( enc & ~SQLITE_UTF16_ALIGNED ) );\n      Debug.Assert( ( pVal.flags & MEM_RowSet ) == 0 );\n\n      if ( ( pVal.flags & MEM_Null ) != 0 )\n      {\n        return null;\n      }\n      Debug.Assert( ( MEM_Blob >> 3 ) == MEM_Str );\n      pVal.flags |= (u16)( ( pVal.flags & MEM_Blob ) >> 3 );\n      if ( ( pVal.flags & MEM_Zero ) != 0 ) sqlite3VdbeMemExpandBlob( pVal ); // expandBlob(pVal);\n      if ( ( pVal.flags & MEM_Str ) != 0 )\n      {\n        sqlite3VdbeChangeEncoding( pVal, enc & ~SQLITE_UTF16_ALIGNED );\n        if ( ( enc & SQLITE_UTF16_ALIGNED ) != 0 && 1 == ( 1 & ( pVal.z[0] ) ) )  //1==(1&SQLITE_PTR_TO_INT(pVal.z))\n        {\n          Debug.Assert( ( pVal.flags & ( MEM_Ephem | MEM_Static ) ) != 0 );\n          if ( sqlite3VdbeMemMakeWriteable( pVal ) != SQLITE_OK )\n          {\n            return null;\n          }\n        }\n        sqlite3VdbeMemNulTerminate( pVal );\n      }\n      else\n      {\n        Debug.Assert( ( pVal.flags & MEM_Blob ) == 0 );\n        sqlite3VdbeMemStringify( pVal, enc );\n        //  assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );\n      }\n      Debug.Assert( pVal.enc == ( enc & ~SQLITE_UTF16_ALIGNED ) || pVal.db == null\n      //|| pVal.db.mallocFailed != 0\n      );\n      if ( pVal.enc == ( enc & ~SQLITE_UTF16_ALIGNED ) )\n      {\n        return pVal.z;\n      }\n      else\n      {\n        return null;\n      }\n    }\n\n    /*\n    ** Create a new sqlite3_value object.\n    */\n    static sqlite3_value sqlite3ValueNew( sqlite3 db )\n    {\n      Mem p = new Mem();//sqlite3DbMallocZero(db, sizeof(*p));\n      if ( p != null )\n      {\n        p.flags = MEM_Null;\n        p.type = SQLITE_NULL;\n        p.db = db;\n      }\n      return p;\n    }\n\n    /*\n    ** Create a new sqlite3_value object, containing the value of pExpr.\n    **\n    ** This only works for very simple expressions that consist of one constant\n    ** token (i.e. "5", "5.1", "\'a string\'"). If the expression can\n    ** be converted directly into a value, then the value is allocated and\n    ** a pointer written to ppVal. The caller is responsible for deallocating\n    ** the value by passing it to sqlite3ValueFree() later on. If the expression\n    ** cannot be converted to a value, then ppVal is set to NULL.\n    */\n    static int sqlite3ValueFromExpr(\n    sqlite3 db,              /* The database connection */\n    Expr pExpr,              /* The expression to evaluate */\n    int enc,                   /* Encoding to use */\n    char affinity,              /* Affinity to use */\n    ref sqlite3_value ppVal     /* Write the new value here */\n    )\n    {\n      int op;\n      string zVal = "";\n      sqlite3_value pVal = null;\n\n      if ( pExpr == null )\n      {\n        ppVal = null;\n        return SQLITE_OK;\n      }\n      op = pExpr.op;\n\n      if ( op == TK_STRING || op == TK_FLOAT || op == TK_INTEGER )\n      {\n        pVal = sqlite3ValueNew( db );\n        if ( pVal == null ) goto no_mem;\n        if ( ExprHasProperty( pExpr, EP_IntValue ) )\n        {\n          sqlite3VdbeMemSetInt64( pVal, (i64)pExpr.u.iValue );\n        }\n        else\n        {\n          zVal = pExpr.u.zToken;// sqlite3DbStrDup( db, pExpr.u.zToken );\n          if ( zVal == null ) goto no_mem;\n          sqlite3ValueSetStr( pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC );\n        }\n        if ( ( op == TK_INTEGER || op == TK_FLOAT ) && affinity == SQLITE_AFF_NONE )\n        {\n          sqlite3ValueApplyAffinity( pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8 );\n        }\n        else\n        {\n          sqlite3ValueApplyAffinity( pVal, affinity, SQLITE_UTF8 );\n        }\n        if ( enc != SQLITE_UTF8 )\n        {\n          sqlite3VdbeChangeEncoding( pVal, enc );\n        }\n      }\n      if ( enc != SQLITE_UTF8 )\n      {\n        sqlite3VdbeChangeEncoding( pVal, enc );\n      }\n      else if ( op == TK_UMINUS )\n      {\n        if ( SQLITE_OK == sqlite3ValueFromExpr( db, pExpr.pLeft, enc, affinity, ref pVal ) )\n        {\n          pVal.u.i = -1 * pVal.u.i;\n          /* (double)-1 In case of SQLITE_OMIT_FLOATING_POINT... */\n          pVal.r = (double)-1 * pVal.r;\n        }\n      }\n#if !SQLITE_OMIT_BLOB_LITERAL\n      else if ( op == TK_BLOB )\n      {\n        int nVal;\n        Debug.Assert( pExpr.u.zToken[0] == \'x\' || pExpr.u.zToken[0] == \'X\' );\n        Debug.Assert( pExpr.u.zToken[1] == \'\\\'\' );\n        pVal = sqlite3ValueNew( db );\n        if ( null == pVal ) goto no_mem;\n        zVal = pExpr.u.zToken.Substring( 2 );\n        nVal = sqlite3Strlen30( zVal ) - 1;\n        Debug.Assert( zVal[nVal] == \'\\\'\' );\n        sqlite3VdbeMemSetStr( pVal, Encoding.UTF8.GetString( sqlite3HexToBlob( db, zVal, nVal ) ), nVal / 2,\n        0, SQLITE_DYNAMIC );\n      }\n#endif\n\n      ppVal = pVal;\n      return SQLITE_OK;\n\nno_mem:\n      //db.mallocFailed = 1;\n      //sqlite3DbFree( db, ref zVal );\n      pVal = null;// sqlite3ValueFree(pVal);\n      ppVal = null;\n      return SQLITE_NOMEM;\n    }\n\n    /*\n    ** Change the string value of an sqlite3_value object\n    */\n    static void sqlite3ValueSetStr(\n    sqlite3_value v,     /* Value to be set */\n    int n,               /* Length of string z */\n    string z,            /* Text of the new string */\n    u8 enc,              /* Encoding to use */\n    dxDel xDel//)(void*) /* Destructor for the string */\n    )\n    {\n      if ( v != null ) sqlite3VdbeMemSetStr( v, z, n, enc, xDel );\n    }\n\n    /*\n    ** Free an sqlite3_value object\n    */\n    static void sqlite3ValueFree( ref sqlite3_value v )\n    {\n      if ( v == null ) return;\n      sqlite3VdbeMemRelease( v );\n      //sqlite3DbFree( v.db, ref v );\n    }\n\n    /*\n    ** Return the number of bytes in the sqlite3_value object assuming\n    ** that it uses the encoding "enc"\n    */\n    static int sqlite3ValueBytes( sqlite3_value pVal, int enc )\n    {\n      Mem p = (Mem)pVal;\n      if ( ( p.flags & MEM_Blob ) != 0 || sqlite3ValueText( pVal, enc ) != null )\n      {\n        if ( ( p.flags & MEM_Zero ) != 0 )\n        {\n          return p.n + p.u.nZero;\n        }\n        else\n        {\n          return p.z == null ? p.zBLOB.Length : p.n;\n        }\n      }\n      return 0;\n    }\n  }\n}\n'