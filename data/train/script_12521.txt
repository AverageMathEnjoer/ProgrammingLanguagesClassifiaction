b'{-# LANGUAGE ImpredicativeTypes #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nimport Prelude hiding (lookup)\n\nimport Database.Beam hiding (withDatabaseDebug)\nimport qualified Database.Beam as Beam\nimport Database.Beam.Backend.SQL\nimport Database.Beam.Backend.Types\nimport Database.Beam.Sqlite hiding (runBeamSqliteDebug)\nimport qualified Database.Beam.Sqlite as Sqlite\nimport Database.SQLite.Simple\nimport Database.SQLite.Simple.FromField\nimport Text.Read\nimport Data.Time\n\nimport Lens.Micro\n\nimport Data.Text (Text)\nimport Data.Int\n\nimport Control.Monad\n\nimport Data.IORef\n\ndata UserT f\n    = User\n    { _userEmail     :: Columnar f Text\n    , _userFirstName :: Columnar f Text\n    , _userLastName  :: Columnar f Text\n    , _userPassword  :: Columnar f Text }\n    deriving Generic\n\ntype User = UserT Identity\ntype UserId = PrimaryKey UserT Identity\n\nderiving instance Show User\nderiving instance Eq User\n\ninstance Beamable UserT\n\ninstance Table UserT where\n    data PrimaryKey UserT f = UserId (Columnar f Text) deriving Generic\n    primaryKey = UserId . _userEmail\ninstance Beamable (PrimaryKey UserT)\n\ndata AddressT f = Address\n                { _addressId    :: C f Int32\n                , _addressLine1 :: C f Text\n                , _addressLine2 :: C f (Maybe Text)\n                , _addressCity  :: C f Text\n                , _addressState :: C f Text\n                , _addressZip   :: C f Text\n\n                , _addressForUser :: PrimaryKey UserT f }\n                  deriving Generic\ntype Address = AddressT Identity\nderiving instance Show (PrimaryKey UserT Identity)\nderiving instance Show Address\n\ninstance Table AddressT where\n    data PrimaryKey AddressT f = AddressId (Columnar f Int32) deriving Generic\n    primaryKey = AddressId . _addressId\ntype AddressId = PrimaryKey AddressT Identity -- For convenience\n\ninstance Beamable AddressT\ninstance Beamable (PrimaryKey AddressT)\n\ndata ProductT f = Product\n                { _productId          :: C f Int32\n                , _productTitle       :: C f Text\n                , _productDescription :: C f Text\n                , _productPrice       :: C f Int32 {- Price in cents -} }\n                  deriving Generic\ntype Product = ProductT Identity\nderiving instance Show Product\n\ninstance Table ProductT where\n  data PrimaryKey ProductT f = ProductId (Columnar f Int32)\n                               deriving Generic\n  primaryKey = ProductId . _productId\n\ninstance Beamable ProductT\ninstance Beamable (PrimaryKey ProductT)\nderiving instance Show (PrimaryKey AddressT Identity)\n\ndata OrderT f = Order\n              { _orderId      :: Columnar f Int32\n              , _orderDate    :: Columnar f LocalTime\n              , _orderForUser :: PrimaryKey UserT f\n              , _orderShipToAddress :: PrimaryKey AddressT f\n              , _orderShippingInfo :: PrimaryKey ShippingInfoT (Nullable f) }\n                deriving Generic\ntype Order = OrderT Identity\nderiving instance Show Order\n\ninstance Table OrderT where\n    data PrimaryKey OrderT f = OrderId (Columnar f Int32)\n                               deriving Generic\n    primaryKey = OrderId . _orderId\n\ninstance Beamable OrderT\ninstance Beamable (PrimaryKey OrderT)\n\ndata ShippingCarrier = USPS | FedEx | UPS | DHL\n                       deriving (Show, Read, Eq, Ord, Enum)\n\ninstance HasSqlValueSyntax be String => HasSqlValueSyntax be ShippingCarrier where\n  sqlValueSyntax = autoSqlValueSyntax\ninstance FromField ShippingCarrier where\n  fromField f = do x <- readMaybe <$> fromField f\n                   case x of\n                     Nothing -> returnError ConversionFailed f "Could not \'read\' value for \'ShippingCarrier\'"\n                     Just x -> pure x\ninstance (BeamBackend be, BackendFromField be ShippingCarrier) => FromBackendRow be ShippingCarrier\n\ndata ShippingInfoT f = ShippingInfo\n                     { _shippingInfoId             :: Columnar f Int32\n                     , _shippingInfoCarrier        :: Columnar f ShippingCarrier\n                     , _shippingInfoTrackingNumber :: Columnar f Text }\n                       deriving Generic\ntype ShippingInfo = ShippingInfoT Identity\nderiving instance Show ShippingInfo\n\ninstance Table ShippingInfoT where\n    data PrimaryKey ShippingInfoT f = ShippingInfoId (Columnar f Int32)\n                                      deriving Generic\n    primaryKey = ShippingInfoId . _shippingInfoId\n\ninstance Beamable ShippingInfoT\ninstance Beamable (PrimaryKey ShippingInfoT)\nderiving instance Show (PrimaryKey ShippingInfoT (Nullable Identity))\n\nderiving instance Show (PrimaryKey OrderT Identity)\nderiving instance Show (PrimaryKey ProductT Identity)\n\ndata LineItemT f = LineItem\n                 { _lineItemInOrder    :: PrimaryKey OrderT f\n                 , _lineItemForProduct :: PrimaryKey ProductT f\n                 , _lineItemQuantity   :: Columnar f Int32 }\n                   deriving Generic\ntype LineItem = LineItemT Identity\nderiving instance Show LineItem\n\ninstance Table LineItemT where\n    data PrimaryKey LineItemT f = LineItemId (PrimaryKey OrderT f) (PrimaryKey ProductT f)\n                                  deriving Generic\n    primaryKey = LineItemId <$> _lineItemInOrder <*> _lineItemForProduct\n\ninstance Beamable LineItemT\ninstance Beamable (PrimaryKey LineItemT)\n\n\ndata ShoppingCartDb f = ShoppingCartDb\n                      { _shoppingCartUsers         :: f (TableEntity UserT)\n                      , _shoppingCartUserAddresses :: f (TableEntity AddressT)\n                      , _shoppingCartProducts      :: f (TableEntity ProductT)\n                      , _shoppingCartOrders        :: f (TableEntity OrderT)\n                      , _shoppingCartShippingInfos :: f (TableEntity ShippingInfoT)\n                      , _shoppingCartLineItems     :: f (TableEntity LineItemT) }\n                        deriving Generic\n\ninstance Database be ShoppingCartDb\n\nShoppingCartDb (TableLens shoppingCartUsers) (TableLens shoppingCartUserAddresses)\n               (TableLens shoppingCartProducts) (TableLens shoppingCartOrders)\n               (TableLens shoppingCartShippingInfos) (TableLens shoppingCartLineItems) = dbLenses\n\nshoppingCartDb :: DatabaseSettings be ShoppingCartDb\nshoppingCartDb = defaultDbSettings `withDbModification`\n                 dbModification {\n                   _shoppingCartUserAddresses =\n                     modifyTable (\\_ -> "addresses") $\n                     tableModification {\n                       _addressLine1 = fieldNamed "address1",\n                       _addressLine2 = fieldNamed "address2"\n                     },\n                   _shoppingCartProducts = modifyTable (\\_ -> "products") tableModification,\n                   _shoppingCartOrders = modifyTable (\\_ -> "orders") $\n                                         tableModification {\n                                           _orderShippingInfo = ShippingInfoId "shipping_info__id"\n                                         },\n                   _shoppingCartShippingInfos = modifyTable (\\_ -> "shipping_info") $\n                                                tableModification {\n                                                  _shippingInfoId = "id",\n                                                  _shippingInfoCarrier = "carrier",\n                                                  _shippingInfoTrackingNumber = "tracking_number"\n                                                },\n                   _shoppingCartLineItems = modifyTable (\\_ -> "line_items") tableModification\n                 }\n\nAddress (LensFor addressId)    (LensFor addressLine1)\n        (LensFor addressLine2) (LensFor addressCity)\n        (LensFor addressState) (LensFor addressZip)\n        (UserId (LensFor addressForUserId)) =\n        tableLenses\n\nUser (LensFor userEmail)    (LensFor userFirstName)\n     (LensFor userLastName) (LensFor userPassword) =\n     tableLenses\n\nLineItem _ _ (LensFor lineItemQuantity) = tableLenses\nProduct (LensFor productId) (LensFor productTitle) (LensFor productDescription) (LensFor productPrice) = tableLenses\n\nmain :: IO ()\nmain =\n  do conn <- open ":memory:"\n\n     execute_ conn "CREATE TABLE cart_users (email VARCHAR NOT NULL, first_name VARCHAR NOT NULL, last_name VARCHAR NOT NULL, password VARCHAR NOT NULL, PRIMARY KEY( email ));"\n     execute_ conn "CREATE TABLE addresses ( id INTEGER PRIMARY KEY AUTOINCREMENT, address1 VARCHAR NOT NULL, address2 VARCHAR, city VARCHAR NOT NULL, state VARCHAR NOT NULL, zip VARCHAR NOT NULL, for_user__email VARCHAR NOT NULL );"\n     execute_ conn "CREATE TABLE products ( id INTEGER PRIMARY KEY AUTOINCREMENT, title VARCHAR NOT NULL, description VARCHAR NOT NULL, price INT NOT NULL );"\n     execute_ conn "CREATE TABLE orders ( id INTEGER PRIMARY KEY AUTOINCREMENT, date TIMESTAMP NOT NULL, for_user__email VARCHAR NOT NULL, ship_to_address__id INT NOT NULL, shipping_info__id INT);"\n     execute_ conn "CREATE TABLE shipping_info ( id INTEGER PRIMARY KEY AUTOINCREMENT, carrier VARCHAR NOT NULL, tracking_number VARCHAR NOT NULL);"\n     execute_ conn "CREATE TABLE line_items (item_in_order__id INTEGER NOT NULL, item_for_product__id INTEGER NOT NULL, item_quantity INTEGER NOT NULL)"\n\n     let users@[james, betty, sam] =\n           [ User "james@example.com" "James" "Smith"  "b4cc344d25a2efe540adbf2678e2304c" {- james -}\n           , User "betty@example.com" "Betty" "Jones"  "82b054bd83ffad9b6cf8bdb98ce3cc2f" {- betty -}\n           , User "sam@example.com"   "Sam"   "Taylor" "332532dcfaa1cbf61e2a266bd723612c" {- sam -} ]\n\n         addresses = [ Address default_ (val_ "123 Little Street") (val_ Nothing) (val_ "Boston") (val_ "MA") (val_ "12345") (pk james)\n                     , Address default_ (val_ "222 Main Street") (val_ (Just "Ste 1")) (val_ "Houston") (val_ "TX") (val_ "8888") (pk betty)\n                     , Address default_ (val_ "9999 Residence Ave") (val_ Nothing) (val_ "Sugarland") (val_ "TX") (val_ "8989") (pk betty) ]\n\n         products = [ Product default_ (val_ "Red Ball") (val_ "A bright red, very spherical ball") (val_ 1000)\n                    , Product default_ (val_ "Math Textbook") (val_ "Contains a lot of important math theorems and formulae") (val_ 2500)\n                    , Product default_ (val_ "Intro to Haskell") (val_ "Learn the best programming language in the world") (val_ 3000)\n                    , Product default_ (val_ "Suitcase") (val_ "A hard durable suitcase") (val_ 15000) ]\n\n     (jamesAddress1, bettyAddress1, bettyAddress2, redBall, mathTextbook, introToHaskell, suitcase) <-\n       runBeamSqlite conn $ do\n         runInsert $ insert (shoppingCartDb ^. shoppingCartUsers) $\n           insertValues users\n\n         [jamesAddress1, bettyAddress1, bettyAddress2] <-\n           runInsertReturningList $\n           insertReturning (shoppingCartDb ^. shoppingCartUserAddresses) $ insertExpressions addresses\n\n         [redBall, mathTextbook, introToHaskell, suitcase] <-\n           runInsertReturningList $\n           insertReturning (shoppingCartDb ^. shoppingCartProducts) $ insertExpressions products\n\n         pure ( jamesAddress1, bettyAddress1, bettyAddress2, redBall, mathTextbook, introToHaskell, suitcase )\n\n     bettyShippingInfo <-\n       runBeamSqlite conn $ do\n         [bettyShippingInfo] <-\n           runInsertReturningList $\n           insertReturning (shoppingCartDb ^. shoppingCartShippingInfos) $\n           insertExpressions [ ShippingInfo default_ (val_ USPS) (val_ "12345790ABCDEFGHI") ]\n         pure bettyShippingInfo\n\n'