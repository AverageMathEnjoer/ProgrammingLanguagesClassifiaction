b'{-\n  quick and dirty solution to sort of the thing mentioned in\n  http://stackoverflow.com/questions/9202302/mastermind-game-in-c\n  driven by brute force, and probably not very good.\n  written mostly to vent after having failed miserably\n  the last few hours with a non-brute force backtracking\n  solution...\n\n  the guesses variable contains a test set of constraints\n  with two possible valid solutions.\n\n      *Main> valids guesses\n      [[1,2,3,4,5],[5,2,9,4,5]]\n      *Main> existsSolution guesses\n      True\n\n  when there exists trivial solutions the existsSolutions function\n  is pretty quick since it just needs the first solution to know\n  that there are solutions at all.\n\n  I have in mind a more effecient implementation where you just\n  existentially prove that there indeed *are* solutions, simply by\n  testing the guesses for contradictions. This will not give you any\n  solutions, but if there are no contradictions in the guesses,\n  there exists at least one solution.\n\n-}\n\nmodule Main where\n\nimport Control.Monad\n\n\n-- a list of pairs of "guess" and "number of correct numbers"\nguesses = [([5, 2, 3, 1, 7], 2),\n           ([1, 3, 9, 5, 2], 1),\n           ([7, 3, 8, 9, 3], 0),\n           ([7, 2, 8, 4, 5], 3)]\n\n\n-- works out how many correct numbers there are for a specific guess\ncorrects real guess =\n  fromIntegral . length . filter id $ zipWith (\\(a,b) if a == b then 1 else 0) real guess\n\n-- checks if a candidate guess has the right number of numbers correct\nvalid candidate guess correctness = corrects candidate guess == correctness\n\n-- filters out all the invalid candidates from a list of all the candidates there could possibly be\n-- this is the brute force bit...\nvalids guesses = do\n  candidate <- replicateM 5 [1..9]\n  guard $ all (uncurry (valid candidate)) guesses\n  return candidate\n\n-- lazily check if there is at least one solution\nexistsSolution = not . null . take 1 . valids'