b'package com.bennyhuo.kotlin.coroutinesupdate\n\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.channels.*\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.selects.select\nimport kotlinx.coroutines.withContext\n\nsuspend fun main() {\n    val channel = Channel<Int>()\n//    channel.trySend(1).isSuccess // offer\n//    channel.tryReceive().getOrNull() // poll\n//\n//    channel.trySendBlocking(1) // sendBlocking\n\n    withContext(Dispatchers.Default) {\n        val producer = launch {\n            (0 .. 5).forEach {\n                channel.send(it)\n            }\n            channel.close()\n        }\n\n        val consumer = launch {\n            while (isActive && !channel.isClosedForReceive) {\n                select<Unit> {\n                    channel.onReceiveCatching {\n                        println("$it - ${it.isClosed}")\n                    }\n                }\n\n                // or\n                // val value = channel.onReceiveCatching()\n            }\n        }\n\n        select<Unit> {\n            consumer.onJoin\n        }\n\n\n        val consumer1 = produce<Int> {\n\n        }\n\n        val producer1 = actor<Int> {\n\n        }\n\n\n        BroadcastChannel<Int>(1)\n        ConflatedBroadcastChannel<Int>()\n\n    }\n}'