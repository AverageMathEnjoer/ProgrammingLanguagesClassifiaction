b'#include "Mesh.h"\n#include "AssimpMesh.h"\n#include "../libStringConverter/convert.h"\n#include "../UABE_Generic/AssetPluginUtil.h"\n#include "../UABE_Generic/FileContextInfo.h"\n#include "../UABE_Generic/AppContext.h"\n#include "../AssetsTools/AssetsReplacer.h"\n#include "../AssetsTools/AssetsFileTable.h"\n#include "../AssetsTools/ResourceManagerFile.h"\n#include <unordered_map>\n#include <array>\n#include <format>\n#include <atomic>\n#include <mutex>\n\n//void OpenExportFile(HWND hParentWnd, IPluginInterface *pInterface,\n//\tchar *outFolderPath, const char *fileName, IAssetInterface *pAsset, const char *extension, const wchar_t *extensionFilters,\n//\tchar **prevAssetNames, size_t i, size_t assetCount,\n//\tIAssetsWriter *&pWriter);\n\n//Throws an AssetUtilError if the GameObject type cannot be resolved.\nbool GetTransformName(AppContext &appContext, AssetIdentifier &asset, TypeTemplateCache &typeCache,\n\tAssetTypeValueField *pTransformValue, std::string &name)\n{\n\tname.clear();\n\tAssetTypeValueField *pGameObjectField = pTransformValue->Get("m_GameObject");\n\tAssetTypeValueField *pGameObjectFileIDField = pGameObjectField->Get("m_FileID");\n\tAssetTypeValueField *pGameObjectPathIDField = pGameObjectField->Get("m_PathID");\n\tif (!pGameObjectFileIDField->GetValue() || !pGameObjectPathIDField->GetValue())\n\t\treturn false;\n\tif (!asset.resolve(appContext))\n\t\treturn false;\n\tunsigned int targetFileID = asset.pFile->resolveRelativeFileID(pGameObjectFileIDField->GetValue()->AsUInt());\n\tAssetIdentifier gameObjectAsset(targetFileID, (pathid_t)pGameObjectPathIDField->GetValue()->AsUInt64());\n\tif (!gameObjectAsset.resolve(appContext))\n\t\treturn false;\n\tIAssetsReader_ptr pAssetReader = gameObjectAsset.makeReader();\n\tif (pAssetReader == nullptr)\n\t\treturn false;\n\tQWORD assetSize = 0;\n\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\treturn false;\n\tAssetTypeTemplateField &gameObjectBase = typeCache.getTemplateField(appContext, gameObjectAsset);\n\tAssetTypeTemplateField *pGameObjectBase = &gameObjectBase;\n\tAssetTypeInstance gameObjectInstance(1, &pGameObjectBase, assetSize, pAssetReader.get(), gameObjectAsset.isBigEndian());\n\n\tAssetTypeValueField *pBaseField = gameObjectInstance.GetBaseField();\n\tAssetTypeValueField *pNameField = nullptr;\n\tif (pBaseField && (pNameField = pBaseField->Get("m_Name"))->GetValue() && pNameField->GetValue()->AsString())\n\t{\n\t\tname.assign(pNameField->GetValue()->AsString());\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nstruct BoneLocation\n{\n\tBoneLocation(){hierarchyIndex = (unsigned int)-1; fileID = 0; pathID = 0;}\n\tunsigned int hierarchyIndex;\n\tunsigned int fileID; pathid_t pathID;\n};\nclass BoneHierarchy\n{\npublic:\n\tBoneHierarchy(){level = -1; fileID = 0; pathID = 0;}\n\tstd::string name;\n\tint level;\n\tunsigned int fileID; pathid_t pathID;\n\taiMatrix4x4 transform; //relative to the parent transform\n};\nvoid RestoreBoneHierarchy(AppContext &appContext, TypeTemplateCache& typeCache,\n\tstd::vector<BoneHierarchy> &output, std::vector<BoneLocation> &bones, BoneLocation &baseBoneTransform)\n{\n\tclass HierarchyStackEntry\n\t{\n\tpublic:\n\t\tAssetIdentifier transformAsset; //not necessarily a bone\n\t\taiMatrix4x4 transform; //updated (i.e. multiplied with the current transform) if processedBase==true\n\t\tint level; //level of the next children fields (increased by 1 if !processedBase and transformDesc is a bone).\n\t\tbool processedBase = false; //says if transformDesc was already processed (i.e. checked if it is a bone and added to output in case it is).\n\t\tbool isBone = false; //assigned if processedBase==true\n\t\tstd::unique_ptr<AssetTypeInstance> pInstance;\n\t\tAssetTypeValueField *pChildrenField = nullptr; //pInstance->GetBaseField()->Get("m_Children")->Get("Array")\n\t\tunsigned int curChildIndex = 0; //next transform child index to check in pChildrenField\n\tpublic:\n\t\tHierarchyStackEntry(unsigned int fileID, pathid_t pathID, const aiMatrix4x4 &transform, int level)\n\t\t\t: transformAsset(fileID, pathID), transform(transform), level(level)\n\t\t{}\n\t};\n\tstd::vector<HierarchyStackEntry> stack;\n\tstack.push_back(HierarchyStackEntry(baseBoneTransform.fileID, baseBoneTransform.pathID, aiMatrix4x4(), 0));\n\twhile (stack.size())\n\t{\n\t\tHierarchyStackEntry *pCurEntry = &stack[stack.size()-1];\n\t\tif ((stack.size() > 512)\n\t\t\t|| (output.size() > 0x7FFFFFFE) \n\t\t\t|| (!pCurEntry->transformAsset.resolve(appContext)))\n\t\t{\n\t\t\tstack.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tbool doFree = false;\n\t\tAssetTypeTemplateField& transformTemplate = typeCache.getTemplateField(appContext, pCurEntry->transformAsset);\n\n\t\t//If necessary, generate a type instance.\n\t\tif (!pCurEntry->pInstance)\n\t\t{\n\t\t\tIAssetsReader_ptr pAssetReader = pCurEntry->transformAsset.makeReader();\n\t\t\tif (pAssetReader == nullptr)\n\t\t\t{\n\t\t\t\tstack.pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQWORD transformAssetSize = 0;\n\t\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(transformAssetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\t{\n\t\t\t\tstack.pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAssetTypeTemplateField* pTransformTemplate = &transformTemplate;\n\t\t\tpCurEntry->pInstance.reset(\n\t\t\t\tnew AssetTypeInstance(1, &pTransformTemplate, transformAssetSize, pAssetReader.get(), pCurEntry->transformAsset.isBigEndian()));\n\t\t}\n\t\tAssetTypeValueField *pBaseField;\n\t\tif ((pBaseField = pCurEntry->pInstance->GetBaseField()) == nullptr || pBaseField->IsDummy())\n\t\t{\n\t\t\tstack.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (!pCurEntry->processedBase)\n\t\t{\n\t\t\t//Multiply this node\'s base transform (i.e. transform of the parent) with the local transform.\n\t\t\tAssetTypeValueField *pRotationField = pBaseField->Get("m_LocalRotation");\n\t\t\tAssetTypeValueField *pPositionField = pBaseField->Get("m_LocalPosition");\n\t\t\tAssetTypeValueField *pScaleField = pBaseField->Get("m_LocalScale");\n\t\t\tif (!pRotationField->IsDummy() && !pPositionField->IsDummy() && !pScaleField->IsDummy())\n\t\t\t{\n\t\t\t\tQuaternionf rot;\n\t\t\t\tVector3f pos;\n\t\t\t\tVector3f scale;\n\t\t\t\tif (rot.Read(pRotationField) && pos.Read(pPositionField) && scale.Read(pScaleField))\n\t\t\t\t{\n\t\t\t\t\taiMatrix4x4 transform;\n\t\t\t\t\tComposeMatrix(rot, pos, scale, transform);\n\t\t\t\t\t//Account for the negated x vertex coordinates (see AssimpMesh.cpp in the bind pose loop for a detailed explanation comment).\n\t\t\t\t\t//Even though the root node has no flipped transformation, we\'re not getting into trouble since it starts at (0 0 0).\n\t\t\t\t\t//The child nodes will have flipped x coordinates to match the flipped vertices.\n\t\t\t\t\ttransform.a2 *= -1;\n\t\t\t\t\ttransform.a3 *= -1;\n\t\t\t\t\ttransform.a4 *= -1;\n\t\t\t\t\ttransform.b1 *= -1;\n\t\t\t\t\ttransform.c1 *= -1;\n\t\t\t\t\tpCurEntry->transform *= transform;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Find the matching bone entry and add it to the bone hierarchy (if it exists).\n\t\t\tBoneLocation *pBaseBoneEntry = nullptr;\n\t\t\tfor (size_t i = 0; i < bones.size(); i++)\n\t\t\t{\n\t\t\t\tif (bones[i].hierarchyIndex == (unsigned int)-1\n\t\t\t\t\t&& bones[i].fileID == pCurEntry->transformAsset.fileID\n\t\t\t\t\t&& bones[i].pathID == pCurEntry->transformAsset.pathID)\n\t\t\t\t{\n\t\t\t\t\tpBaseBoneEntry = &bones[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pBaseBoneEntry)\n\t\t\t{\n\t\t\t\tBoneHierarchy newOutEntry;\n\t\t\t\tnewOutEntry.level = pCurEntry->level++; //Increase the level to assign to child transforms.\n\t\t\t\tnewOutEntry.fileID = pCurEntry->transformAsset.fileID;\n\t\t\t\tnewOutEntry.pathID = pCurEntry->transformAsset.pathID;\n\t\t\t\tnewOutEntry.transform = pCurEntry->transform;\n\t\t\t\tpBaseBoneEntry->hierarchyIndex = (unsigned int)output.size();\n\t\t\t\toutput.push_back(newOutEntry);\n\t\t\t\t//Set the bone name.\n\t\t\t\tGetTransformName(appContext, pCurEntry->transformAsset, typeCache, pBaseField, output[pBaseBoneEntry->hierarchyIndex].name);\n\t\t\t\t//Escape the bone name (should not inject XML tags / be multiple elements in a Collada Name_array or IDREF_array).\n\t\t\t\tfor (size_t i = 0; i < output[pBaseBoneEntry->hierarchyIndex].name.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tswitch (output[pBaseBoneEntry->hierarchyIndex].name[i])\n\t\t\t\t\t{\n\t\t\t\t\tcase \' \':\n\t\t\t\t\tcase \'<\':\n\t\t\t\t\tcase \'>\':\n\t\t\t\t\t\toutput[pBaseBoneEntry->hierarchyIndex].name[i] = \'_\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpCurEntry->isBone = true; //Do not pass on the transformation matrix since it\'s always relative to the parent bone in the hierarchy.\n\t\t\t}\n\t\t\tpCurEntry->processedBase = true;\n\t\t}\n\t\t//Locate the child array of the transform.\n\t\tif (!pCurEntry->pChildrenField)\n\t\t{\n\t\t\tpCurEntry->pChildrenField = pBaseField->Get("m_Children")->Get("Array");\n\t\t\tif (pCurEntry->pChildrenField->GetValue() == nullptr || pCurEntry->pChildrenField->GetValue()->GetType() != ValueType_Array)\n\t\t\t\tpCurEntry->pChildrenField = nullptr;\n\t\t}\n\t\tif (pCurEntry->pChildrenField)\n\t\t{\n\t\t\t//Add a stack entry for the next valid child transform, or remove the current entry.\n\t\t\tbool addedNewEntry = false;\n\t\t\tfor (; pCurEntry->curChildIndex < pCurEntry->pChildrenField->GetChildrenCount(); pCurEntry->curChildIndex++)\n\t\t\t{\n\t\t\t\tAssetTypeValueField *pCurChild = pCurEntry->pChildrenField->Get(pCurEntry->curChildIndex);\n\t\t\t\tAssetTypeValueField *pFileIDField = pCurChild->Get("m_FileID");\n\t\t\t\tAssetTypeValueField *pPathIDField = pCurChild->Get("m_PathID");\n\t\t\t\tif (pFileIDField->GetValue() && pPathIDField->GetValue())\n\t\t\t\t{\n\t\t\t\t\tunsigned int targetFileID = pCurEntry->transformAsset.pFile->resolveRelativeFileID(pFileIDField->GetValue()->AsUInt());\n\t\t\t\t\tif (targetFileID != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpCurEntry->curChildIndex++;\n\t\t\t\t\t\tstack.push_back(HierarchyStackEntry(targetFileID,\n\t\t\t\t\t\t\tpPathIDField->GetValue()->AsInt64(),\n\t\t\t\t\t\t\tpCurEntry->isBone ? aiMatrix4x4() : pCurEntry->transform, pCurEntry->level)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpCurEntry = &stack[stack.size()-2]; //Precaution\n\t\t\t\t\t\taddedNewEntry = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!addedNewEntry && pCurEntry->curChildIndex >= pCurEntry->pChildrenField->GetChildrenCount())\n\t\t\t\tdoFree = true;\n\t\t}\n\t\telse\n\t\t\tdoFree = true;\n\t\tif (doFree)\n\t\t{\n\t\t\tstack.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t}\n\n}\n\n//skeletonName should be unique and will be a prefix for all bone names!\nvoid AddBoneHierarchyToScene(aiScene &scene, std::vector<BoneHierarchy> &bones, const char *skeletonName)\n{\n\tif (!scene.mRootNode)\n\t\tscene.mRootNode = new aiNode("Root");\n\taiNode *baseNode = new aiNode(skeletonName ? skeletonName : "");\n\tbaseNode->mParent = scene.mRootNode;\n\taiNode **newChildNodes = new aiNode*[scene.mRootNode->mNumChildren + 1];\n\tmemcpy(newChildNodes, scene.mRootNode->mChildren, scene.mRootNode->mNumChildren * sizeof(aiNode*));\n\tnewChildNodes[scene.mRootNode->mNumChildren++] = baseNode;\n\tdelete[] scene.mRootNode->mChildren;\n\tscene.mRootNode->mChildren = newChildNodes;\n\n\tclass NodeLevelStackEntry\n\t{\n\tpublic:\n\t\taiNode *pNode;\n\t\tunsigned int childBufferSize;\n\t\tNodeLevelStackEntry(aiNode *pNode, unsigned int childBufferSize)\n\t\t\t: pNode(pNode), childBufferSize(childBufferSize)\n\t\t{}\n\t};\n\tstd::vector<NodeLevelStackEntry> nodeLevelStack;\n\tnodeLevelStack.push_back(NodeLevelStackEntry(baseNode, 0));\n\tfor (size_t i = 0; i < bones.size(); i++)\n\t{\n\t\tif (nodeLevelStack.size() == 0)\n\t\t\tbreak;\n\t\tNodeLevelStackEntry *pCurEntry = &nodeLevelStack[nodeLevelStack.size()-1];\n\t\tif (i > 0 && bones[i].level > bones[i-1].level)\n\t\t{\n\t\t\tif (bones[i].level != (bones[i-1].level + 1))\n\t\t\t\tbreak;\n\t\t\tif (pCurEntry->pNode->mNumChildren == 0)\n\t\t\t\tbreak;\n\t\t\tnodeLevelStack.push_back(NodeLevelStackEntry(pCurEntry->pNode->mChildren[pCurEntry->pNode->mNumChildren-1], 0));\n\t\t\tpCurEntry = &nodeLevelStack[nodeLevelStack.size()-1];\n\t\t}\n\t\telse if (i > 0 && bones[i].level < bones[i-1].level)\n\t\t{\n\t\t\tif (bones[i].level < 0)\n\t\t\t\tbreak;\n\t\t\tnodeLevelStack.erase(nodeLevelStack.end() - (bones[i-1].level - bones[i].level), nodeLevelStack.end());\n\t\t\tif (nodeLevelStack.size() == 0)\n\t\t\t\tbreak;\n\t\t\tpCurEntry = &nodeLevelStack[nodeLevelStack.size()-1];\n\t\t}\n\t\tif (pCurEntry->childBufferSize == 0)\n\t\t{\n\t\t\tsize_t sameLevelCount = 1;\n\t\t\tfor (size_t j = i+1; j < bones.size(); j++)\n\t\t\t{\n\t\t\t\tif (bones[j].level == bones[i].level)\n\t\t\t\t\tsameLevelCount++;\n\t\t\t\telse if (bones[j].level < bones[i].level)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sameLevelCount > 0x7FFFFFFE)\n\t\t\t\tbreak;\n\t\t\tpCurEntry->pNode->mNumChildren = 0;\n\t\t\tpCurEntry->pNode->mChildren = new aiNode*[sameLevelCount]();\n\t\t\tpCurEntry->childBufferSize = (unsigned int)sameLevelCount;\n\t\t}\n\t\tif ((pCurEntry->pNode->mNumChildren + 1) > pCurEntry->childBufferSize)\n\t\t\tbreak;\n\t\taiNode *pNewNode = new aiNode(skeletonName ? (std::string(skeletonName) + "_" + bones[i].name) : bones[i].name);\n\t\tpNewNode->mParent = pCurEntry->pNode;\n\t\tpNewNode->mTransformation = bones[i].transform;\n\t\tpCurEntry->pNode->mChildren[pCurEntry->pNode->mNumChildren++] = pNewNode;\n\t}\n}\n\nclass MeshDAEExportTask : public AssetExportTask\n{\n\tAppContext& appContext;\n\tTypeTemplateCache templateCache;\n\tbool combineToSingleFile;\n\tstd::mutex combinedSceneMutex;\n\taiScene combinedScene;\n\tstd::atomic_uint assetCounter;\npublic:\n\tMeshDAEExportTask(AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> _assets, std::string _baseDir, bool combineToSingleFile,\n\t\tbool stopOnError = false)\n\n\t\t: AssetExportTask(std::move(_assets), "Export Mesh", ".dae", std::move(_baseDir), stopOnError, combineToSingleFile),\n\t\tappContext(appContext), combineToSingleFile(combineToSingleFile)\n\t{}\n\tvoid onCompletion(const std::string& outputPath, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (combineToSingleFile && combinedScene.mRootNode != nullptr && combinedScene.mNumMeshes > 0)\n\t\t{\n\t\t\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(outputPath.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\tif (pWriter == nullptr)\n\t\t\t\tthrow AssetUtilError("Unable to create the output file.");\n\t\t\tif (!WriteScene(combinedScene, pWriter.get()))\n\t\t\t\tthrow AssetUtilError("Unable to write the data.");\n\t\t}\n\t}\n\n\tbool exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (desc.asset.pFile == nullptr)\n\t\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\n\t\tIAssetsReader_ptr pAssetReader = desc.asset.makeReader();\n\t\tif (pAssetReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\tQWORD assetSize = 0;\n\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\t\tAssetTypeTemplateField& templateBaseInitial = templateCache.getTemplateField(appContext, desc.asset);\n\t\tAssetTypeTemplateField* pTemplateBase = &templateBaseInitial;\n\n\t\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), desc.asset.isBigEndian());\n\t\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\t\tAssetIdentifier actualMeshAsset = desc.asset;\n\t\t\t\n\t\tstd::vector<std::string> boneNames;\n\t\tstd::vector<BoneHierarchy> bones;\n\t\t\n\t\tif (desc.asset.getClassID(appContext) != 0x2B //\'heuristic\' comparison with the original Mesh ID to save GetClassName_ calls.\n\t\t\t&& desc.asset.pFile->GetClassName_(appContext, desc.asset.getClassID(), desc.asset.getMonoScriptID(), &desc.asset)\n\t\t\t    == "SkinnedMeshRenderer")\n\t\t{\n\t\t\tAssetTypeValueField *pMeshField = pBaseField->Get("m_Mesh"); //PPtr<Mesh>\n\t\t\tAssetTypeValueField *pMeshFileIDField = pMeshField->Get("m_FileID"); //int\n\t\t\tAssetTypeValueField *pMeshPathIDField = pMeshField->Get("m_PathID"); //int or SInt64\n\t\n\t\t\tAssetTypeValueField *pBonesField = pBaseField->Get("m_Bones")->Get("Array"); //Array<PPtr<Transform>>\n\t\n\t\t\tAssetTypeValueField *pRootBoneField = pBaseField->Get("m_RootBone"); //PPtr<Transform>\n\t\t\tAssetTypeValueField *pRootBoneFileIDField = pRootBoneField->Get("m_FileID"); //int\n\t\t\tAssetTypeValueField *pRootBonePathIDField = pRootBoneField->Get("m_PathID"); //int or SInt64\n\t\n\t\t\tif (pBonesField->GetValue() && pBonesField->GetValue()->GetType() == ValueType_Array\n\t\t\t\t&& pRootBoneFileIDField->GetValue() && pRootBoneFileIDField->GetValue())\n\t\t\t{\n\t\t\t\t//Reconstruct the bone hierarchy.\n\t\t\t\tAssetTypeTemplateField transformTemplateBase, gameObjectTemplateBase;\n\t\t\t\tbones.reserve(pBonesField->GetChildrenCount());\n\t\t\t\tstd::vector<BoneLocation> boneLocations(pBonesField->GetChildrenCount());\n\t\t\t\tfor (unsigned int i = 0; i < pBonesField->GetChildrenCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tAssetTypeValueField *pCurEntry = pBonesField->Get(i);\n\t\t\t\t\tAssetTypeValueField *pFileIDField = pCurEntry->Get("m_FileID");\n\t\t\t\t\tAssetTypeValueField *pPathIDField = pCurEntry->Get("m_PathID");\n\t\t\t\t\tif (pFileIDField->GetValue() && pPathIDField->GetValue())\n\t\t\t\t\t{\n\t\t\t\t\t\tboneLocations[i].fileID = desc.asset.pFile->resolveRelativeFileID(pFileIDField->GetValue()->AsUInt());\n\t\t\t\t\t\tboneLocations[i].pathID = pPathIDField->GetValue()->AsUInt64();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tboneLocations[i].fileID = 0;\n\t\t\t\t\t\tboneLocations[i].pathID = 0;\n\t\t\t\t\t}\n\t\t\t\t\tboneLocations[i].hierarchyIndex = (unsigned int)-1;\n\t\t\t\t}\n\t\t\t\tBoneLocation rootLocation;\n\t\t\t\trootLocation.fileID = desc.asset.pFile->resolveRelativeFileID(pRootBoneFileIDField->GetValue()->AsUInt());\n\t\t\t\trootLocation.pathID = pRootBonePathIDField->GetValue()->AsUInt64();\n\t\t\t\trootLocation.hierarchyIndex = (unsigned int)-1;\n\t\t\t\tRestoreBoneHierarchy(appContext, templateCache, bones, boneLocations, rootLocation);\n\t\t\t\tfor (size_t i = 0; i < boneLocations.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (boneLocations[i].hierarchyIndex == (unsigned int)-1 && boneLocations[i].fileID != 0 && boneLocations[i].pathID != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::vector<BoneLocation> tempLocations; tempLocations.push_back(boneLocations[i]);\n\t\t\t\t\t\tRestoreBoneHierarchy(appContext, templateCache, bones, tempLocations, boneLocations[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboneNames.resize(boneLocations.size());\n\t\t\t\tfor (size_t i = 0; i < boneLocations.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (boneLocations[i].hierarchyIndex < bones.size())\n\t\t\t\t\t\tboneNames[i] = bones[boneLocations[i].hierarchyIndex].name;\n\t\t\t\t\telse\n\t\t\t\t\t\tboneNames[i] = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (progressManager)\n\t\t\t\tprogressManager->get().logMessage(std::format(\n\t\t\t\t\t"WARNING: Unable to locate the bone list (SkinnedMeshRenderer File ID {}, Path ID {}).",\n\t\t\t\t\tdesc.asset.fileID, desc.asset.pathID)\n\t\t\t\t);\n\t\n\t\t\tif (pMeshFileIDField->GetValue() && pMeshPathIDField->GetValue())\n\t\t\t{\n\t\t\t\tunsigned int targetFileID = desc.asset.pFile->resolveRelativeFileID(pMeshFileIDField->GetValue()->AsUInt());\n\t\t\t\tpathid_t targetPathID = pMeshPathIDField->GetValue()->AsUInt64();\n\t\t\t\tif (targetPathID == 0) //can happen\n\t\t\t\t{\n\t\t\t\t\tif (progressManager)\n\t\t\t\t\t\tprogressManager->get().logMessage(std::format(\n\t\t\t\t\t\t\t"WARNING: Unable to locate the actual mesh (SkinnedMeshRenderer File ID {}, Path ID {}).",\n\t\t\t\t\t\t\tdesc.asset.fileID, desc.asset.pathID)\n\t\t\t\t\t\t);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tactualMeshAsset = AssetIdentifier(targetFileID, targetPathID);\n\t\t\t\tif (!actualMeshAsset.resolve(appContext))\n\t\t\t\t{\n\t\t\t\t\tthrow AssetUtilError(std::format(\n\t\t\t\t\t\t"Unable to find the referenced mesh asset (File ID {}, Path ID {}).",\n\t\t\t\t\t\ttargetFileID, targetPathID)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpTemplateBase = &templateCache.getTemplateField(appContext, actualMeshAsset);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow AssetUtilError(std::format(\n\t\t\t\t\t"Unable to find the referenced mesh asset (SkinnedMeshRenderer File ID {}, Path ID {}).",\n\t\t\t\t\tdesc.asset.fileID, desc.asset.pathID)\n\t\t\t\t);\n\t\t\t}\n\t\t\tpAssetReader = actualMeshAsset.makeReader();\n\t\t\tif (pAssetReader == nullptr)\n\t\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\t\tassetSize = 0;\n\t\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\t\tassetInstance = AssetTypeInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), actualMeshAsset.isBigEndian());\n\t\t\tpBaseField = assetInstance.GetBaseField();\n\t\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\t\t}\n\n\t\tbool isU5 = actualMeshAsset.pFile->getAssetsFileContext()->getAssetsFile()->header.format >= 0x0D;\n\t\tMesh mesh(pBaseField, isU5, appContext, actualMeshAsset);\n\t\tconst char *errorMessage = NULL;\n\t\tif (!mesh.wasAbleToRead)\n\t\t\tthrow AssetUtilError("Unable to read the mesh asset! (unknown asset format)");\n\t\telse if (mesh.m_MeshCompression != 0)\n\t\t\tthrow AssetUtilError("Compressed meshes are not supported! Use .obj export instead.");\n\t\telse if (mesh.m_VertexData.m_Streams.size() == 0)\n\t\t\tthrow AssetUtilError("Invalid vertex data (no streams available)!");\n\t\telse if (mesh.m_VertexData.m_Channels.size() < 6)\n\t\t\tthrow AssetUtilError("Invalid shader channels (less than 6 channels)!");\n\t\telse if (mesh.m_VertexData.m_Channels[0].dimension != 3)\n\t\t\tthrow AssetUtilError("Invalid shader channels (vertex position doesn\'t have 3 floats)!");\n\n\t\tif (!combineToSingleFile) //Max. one mesh and skeleton per file.\n\t\t{\n\t\t\taiScene curScene;\n\t\t\tif (!AddMeshToScene(curScene, mesh, boneNames, isU5))\n\t\t\t\tthrow AssetUtilError("Unable to process the mesh.");\n\t\t\tAddBoneHierarchyToScene(curScene, bones, nullptr);\n\n\t\t\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(path.c_str(), true, true, RWOpenFlags_Immediately));\n\t\t\tif (pWriter == nullptr)\n\t\t\t\tthrow AssetUtilError("Unable to create the output file.");\n\n\t\t\tif (!WriteScene(curScene, pWriter.get()))\n\t\t\t\tthrow AssetUtilError("Unable to write the data.");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunsigned int exportIndex = this->assetCounter++;\n\t\t\tstd::string meshIndexStr = std::format("skeleton{}_", exportIndex);\n\t\n\t\t\tfor (size_t i = 0; i < boneNames.size(); i++)\n\t\t\t{\n\t\t\t\tboneNames[i].insert(0, meshIndexStr);\n\t\t\t}\n\t\t\t\n\t\t\t//For proper parallelism with combined meshes, \n\t\t\t// working on per-thread sub scenes and reducing them in onCompletion\n\t\t\t// may be a viable approach.\n\t\t\tstd::scoped_lock<std::mutex> combinedSceneLock(combinedSceneMutex);\n\t\t\tif (!AddMeshToScene(combinedScene, mesh, boneNames, isU5))\n\t\t\t\tthrow AssetUtilError("Unable to process the mesh.");\n\t\t\tmeshIndexStr.pop_back(); //Remove the "_" character.\n\t\t\tAddBoneHierarchyToScene(combinedScene, bones, meshIndexStr.c_str());\n\t\t}\n\n\n\t\treturn true;\n\t}\n};\n\nclass MeshOBJExportTask : public AssetExportTask\n{\n\tAppContext& appContext;\n\tTypeTemplateCache templateCache;\npublic:\n\tMeshOBJExportTask(AppContext& appContext,\n\t\tstd::vector<AssetUtilDesc> _assets, std::string _baseDir,\n\t\tbool stopOnError = false)\n\n\t\t: AssetExportTask(std::move(_assets), "Export Mesh", ".obj", std::move(_baseDir), stopOnError),\n\t\tappContext(appContext)\n\t{}\n\n\tbool exportAsset(AssetUtilDesc& desc, std::string path, std::optional<std::reference_wrapper<TaskProgressManager>> progressManager)\n\t{\n\t\tif (desc.asset.pFile == nullptr)\n\t\t\tthrow AssetUtilError("Unable to find the target .assets file.");\n\n\t\tIAssetsReader_ptr pAssetReader = desc.asset.makeReader();\n\t\tif (pAssetReader == nullptr)\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\t\tQWORD assetSize = 0;\n\t\tif (!pAssetReader->Seek(AssetsSeek_End, 0) || !pAssetReader->Tell(assetSize) || !pAssetReader->Seek(AssetsSeek_Begin, 0))\n\t\t\tthrow AssetUtilError("Unable to read the asset.");\n\n\t\tAssetTypeTemplateField& templateBase = templateCache.getTemplateField(appContext, desc.asset);\n\t\tAssetTypeTemplateField* pTemplateBase = &templateBase;\n\n\t\tAssetTypeInstance assetInstance(1, &pTemplateBase, assetSize, pAssetReader.get(), desc.asset.isBigEndian());\n\t\tAssetTypeValueField* pBaseField = assetInstance.GetBaseField();\n\t\tif (pBaseField == nullptr || pBaseField->IsDummy())\n\t\t\tthrow AssetUtilError("Unable to deserialize the asset.");\n\n\t\tbool isU5 = desc.asset.pFile->getAssetsFileContext()->getAssetsFile()->header.format >= 0x0D;\n\t\tMesh mesh(pBaseField, isU5, appContext, desc.asset);\n\n\t\tconst char* errorMessage = NULL;\n\t\tif (!mesh.wasAbleToRead)\n\t\t\tthrow AssetUtilError("Unable to read the mesh asset. (unknown or unsupported asset format)");\n\t\telse if (mesh.m_MeshCompression != 0 && !mesh.m_CompressedMesh.wasAbleToRead)\n\t\t\tthrow AssetUtilError("The compressed mesh has an unknown format.");\n\t\telse if (mesh.m_VertexData.m_Streams.size() == 0)\n\t\t\tthrow AssetUtilError("Invalid vertex data (no streams available).");\n\t\telse if (mesh.m_MeshCompression == 0)\n\t\t{\n\t\t\tif (mesh.m_VertexData.m_Channels.size() < 6)\n\t\t\t\tthrow AssetUtilError("Invalid shader channels (less than 6 channels).");\n\t\t\telse if (mesh.m_VertexData.m_Channels[0].dimension != 3)\n\t\t\t\tthrow AssetUtilError("Invalid shader channels (vertex position doesn\'t have 3 floats).");\n\t\t\telse if (!mesh.m_VertexData.IsFloatFormat(mesh.m_VertexData.m_Channels[0].format, isU5))\n\t\t\t\tthrow AssetUtilError("Invalid shader channels (vertex position is not a float vector).");\n\t\t}\n\n\t\tstd::unique_ptr<IAssetsWriter> pWriter(Create_AssetsWriterToFile(path.c_str(), true, true, RWOpenFlags_Immediately));\n\t\tif (pWriter == nullptr)\n\t\t\tthrow AssetUtilError("Unable to create the output file.");\n\n\t\tauto _writerputs = [&pWriter](const std::string& msg) {pWriter->Write(msg.size(), msg.data()); };\n\t\tstd::string formatTmp;\n\t\tunsigned int vertexCount = 0, indexCount = 0;\n\t\tfor (size_t i = 0; i < mesh.m_SubMeshes.size(); i++)\n\t\t{\n\t\t\tSubMesh& subMesh = mesh.m_SubMeshes[i];\n\t\t\tvertexCount = subMesh.firstVertex + subMesh.vertexCount;\n\t\t\tindexCount += subMesh.indexCount;\n\t\t}\n\t\t//if (!vertexCount && mesh.m_MeshCompression != 0)\n\t\t//\tvertexCount = mesh.m_CompressedMesh.m_Vertices.m_NumItems / 3;\n\t\tunsigned int bitsPerVertex = 0;\n\t\tif (!mesh.m_MeshCompression)\n\t\t{\n\t\t\tunsigned int bytesPerVertex = 0;\n\t\t\tfor (size_t i = 0; i < mesh.m_VertexData.m_Streams.size(); i++)\n\t\t\t\tbytesPerVertex += mesh.m_VertexData.m_Streams[i].stride;\n\t\t\tunsigned int expectedVertexBytes = vertexCount * bytesPerVertex;\n\t\t\tif (expectedVertexBytes > (unsigned int)mesh.m_VertexData.dataByteCount)\n\t\t\t{\n\t\t\t\tthrow AssetUtilError(std::format("Expected {} vertices ({} bytes) but got only {} bytes.", \n\t\t\t\t\tvertexCount, expectedVertexBytes, mesh.m_VertexData.dataByteCount));\n\n\t\t\t\tvertexCount = mesh.m_VertexData.dataByteCount / expectedVertexBytes;\n\t\t\t}\n\t\t\tbitsPerVertex = bytesPerVertex * 8;\n\t\t}\n\t\telse// if (mesh.m_VertexData.m_VertexCount > 0)\n\t\t{\n\t\t\tunsigned int totalVertexCount = mesh.m_CompressedMesh.m_Vertices.m_NumItems / 3;\n\t\t\tif (totalVertexCount > 0)\n\t\t\t{\n\t\t\t\tif (mesh.m_CompressedMesh.m_Vertices.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_Vertices.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_Vertices.m_NumItems / totalVertexCount); //should be m_BitSize*3\n\t\t\t\tif (mesh.m_CompressedMesh.m_UV.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_UV.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_UV.m_NumItems / totalVertexCount); //should be m_BitSize*2,4,6 or 8 (uv1-4)\n\t\t\t\t//Bind poses don\'t belong to the vertex data; 4x4 float matrices;\n\n\t\t\t\t//Contains the normals data without sign bit (the bit vectors are unsigned);\n\t\t\t\t//The m_NormalSigns value has the sign bit of the third component, z.\n\t\t\t\t//The length of the normal vector |v| = sqrt(x\xb2+y\xb2+z\xb2) = 1\xb2; z is not stored, so z = sqrt(1\xb2-x\xb2-y\xb2).\n\t\t\t\tif (mesh.m_CompressedMesh.m_Normals.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_Normals.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_Normals.m_NumItems / totalVertexCount); //shuold be m_BitSize*2\n\t\t\t\t//Tangents are stored like normals, so the description above applies to tangents, too.\n\t\t\t\tif (mesh.m_CompressedMesh.m_Tangents.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_Tangents.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_Tangents.m_NumItems / totalVertexCount); //should be m_BitSize * 2\n\t\t\t\t//Weights don\'t belong to the vertex data; Assumed single floats;\n\t\t\t\tif (mesh.m_CompressedMesh.m_NormalSigns.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_NormalSigns.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_NormalSigns.m_NumItems / totalVertexCount); //should be m_BitSize\n\t\t\t\tif (mesh.m_CompressedMesh.m_TangentSigns.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_TangentSigns.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_TangentSigns.m_NumItems / totalVertexCount); //should be m_BitSize\n\t\t\t\tif (mesh.m_CompressedMesh.m_FloatColors.wasAbleToRead && mesh.m_CompressedMesh.m_FloatColors.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_FloatColors.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_FloatColors.m_NumItems / totalVertexCount); //should be m_BitSize*3\n\t\t\t\telse if (mesh.m_CompressedMesh.m_Colors.wasAbleToRead && mesh.m_CompressedMesh.m_Colors.m_NumItems)\n\t\t\t\t\tbitsPerVertex += mesh.m_CompressedMesh.m_Colors.m_BitSize *\n\t\t\t\t\t(mesh.m_CompressedMesh.m_Colors.m_NumItems / totalVertexCount); //should be m_BitSize\n\t\t\t}\n\t\t}\n\t\tstd::format_to(std::back_inserter(formatTmp), "# Mesh \\"{}\\" exported with UABE; {} vertices, {} indices, {} bits per vertex\\n",\n\t\t\tmesh.m_Name, vertexCount, indexCount, bitsPerVertex);\n\t\t_writerputs(formatTmp);\n\t\tformatTmp.clear();\n\t\tstd::format_to(std::back_inserter(formatTmp), "g {}\\n", mesh.m_Name);\n\t\t_writerputs(formatTmp);\n\t\tformatTmp.clear();\n\t\tif (!mesh.m_MeshCompression)\n\t\t{\n\t\t\tChannelInfo& posChannel = mesh.m_VertexData.m_Channels[0];\n\t\t\tChannelInfo& normalChannel = mesh.m_VertexData.m_Channels[1];\n\t\t\tChannelInfo& colorChannel = mesh.m_VertexData.m_Channels[2];\n\t\t\tChannelInfo& uv1Channel = mesh.m_VertexData.m_Channels[3];\n\t\t\tChannelInfo& uv2Channel = mesh.m_VertexData.m_Channels[4];\n\t\t\t//m_Channels[5] : UV3 for Unity >= 5.0, else tangents\n\t\t\t//m_Channels[6] : UV4\n\t\t\t//m_Channels[7] : Tangents\n\t\t\tChannelInfo* pUVChannel = &uv1Channel;\n\n\t\t\tStreamInfo& posStream = mesh.m_VertexData.m_Streams[posChannel.stream];\n\t\t\tStreamInfo& normalStream = mesh.m_VertexData.m_Streams[normalChannel.stream];\n\t\t\tStreamInfo& colorStream = mesh.m_VertexData.m_Streams[colorChannel.stream];\n\t\t\tStreamInfo& uv1Stream = mesh.m_VertexData.m_Streams[uv1Channel.stream];\n\t\t\tStreamInfo& uv2Stream = mesh.m_VertexData.m_Streams[uv2Channel.stream];\n\t\t\tStreamInfo* pUVStream = &uv1Stream;\n\n\t\t\tbool hasNormals = (mesh.m_VertexData.m_Channels[1].dimension == 3 || mesh.m_VertexData.m_Channels[1].dimension == 4)\n\t\t\t\t&& mesh.m_VertexData.IsFloatFormat(mesh.m_VertexData.m_Channels[1].format, isU5);\n\t\t\tbool hasColors = mesh.m_VertexData.m_Channels[2].dimension > 0;\n\t\t\tbool hasUV1 = mesh.m_VertexData.m_Channels[3].dimension == 2 && mesh.m_VertexData.IsFloatFormat(mesh.m_VertexData.m_Channels[3].format, isU5);\n\t\t\tbool hasUV2 = mesh.m_VertexData.m_Channels[4].dimension == 2 && mesh.m_VertexData.IsFloatFormat(mesh.m_VertexData.m_Channels[4].format, isU5);\n\t\t\tif (!hasUV1)\n\t\t\t{\n\t\t\t\tpUVChannel = (hasUV2 ? &uv2Channel : NULL);\n\t\t\t\tpUVStream = (hasUV2 ? &uv2Stream : NULL);\n\t\t\t}\n\t\t\tuint8_t vertexPosElementSize = mesh.m_VertexData.ChannelElementSize(posChannel.format, isU5);\n\t\t\tuint8_t vertexNormalElementSize = mesh.m_VertexData.ChannelElementSize(normalChannel.format, isU5);\n\t\t\tuint8_t vertexUVElementSize = pUVChannel ? mesh.m_VertexData.ChannelElementSize(pUVChannel->format, isU5) : 0;\n\n\t\t\tstd::string_view faceFormat;\n\t\t\t{\n\t\t\t\tfaceFormat = " {}";\n\t\t\t\tif (hasUV1 || hasUV2)\n\t\t\t\t{\n\t\t\t\t\tif (hasNormals)\n\t\t\t\t\t\tfaceFormat = " {}/{}/{}";\n\t\t\t\t\telse\n\t\t\t\t\t\tfaceFormat = " {}/{}";\n\t\t\t\t}\n\t\t\t\telse if (hasNormals)\n\t\t\t\t\tfaceFormat = " {}//{}";\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < mesh.m_SubMeshes.size(); i++)\n\t\t\t{\n\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "# SubMesh {}\\n# Vertices\\n", i);\n\t\t\t\t_writerputs(formatTmp);\n\t\t\t\tformatTmp.clear();\n\t\t\t\t/*#define MeshChannel_Pos 0\n\t\t\t\t#define MeshChannel_Normal 1\n\t\t\t\t#define MeshChannel_Color 2\n\t\t\t\t#define MeshChannel_UV1 3\n\t\t\t\t#define MeshChannel_UV2 4*/\n\t\t\t\tSubMesh& subMesh = mesh.m_SubMeshes[i];\n\t\t\t\tfor (unsigned int j = subMesh.firstVertex; j < (subMesh.firstVertex + subMesh.vertexCount) && j < vertexCount; j++)\n\t\t\t\t{\n\t\t\t\t\tvoid *pCurPosVertex = &((uint8_t*)mesh.m_VertexData.m_DataSize)[posStream.offset + j * posStream.stride];\n\t\t\t\t\tvoid *pCurColorVertex = &((uint8_t*)mesh.m_VertexData.m_DataSize)[colorStream.offset + j * colorStream.stride];\n\t\t\t\t\tvoid *pCurUVVertex = NULL;\n\t\t\t\t\tif (pUVStream)\n\t\t\t\t\t\tpCurUVVertex = &((uint8_t*)mesh.m_VertexData.m_DataSize)[pUVStream->offset + j * pUVStream->stride];\n\t\t\t\t\tvoid *pCurNormalVertex = &((uint8_t*)mesh.m_VertexData.m_DataSize)[normalStream.offset + j * normalStream.stride];\n\t\t\t\t\t//PVOID pCurStreamVertex = &((BYTE*)mesh.m_VertexData.m_DataSize)[j * mesh.m_VertexData.m_Streams[pos];\n\t\t\t\t\tVector3f vertexPos;\n\t\t\t\t\tif ((posStream.offset + j * posStream.stride + posChannel.offset + 3 * vertexPosElementSize) <= mesh.m_VertexData.dataByteCount)\n\t\t\t\t\t\tmesh.m_VertexData.ConvertChannelFloat(\n\t\t\t\t\t\t\t&((uint8_t*)pCurPosVertex)[posChannel.offset],\n\t\t\t\t\t\t\tposChannel.format, 3, (float*)&vertexPos,\n\t\t\t\t\t\t\tisU5\n\t\t\t\t\t\t);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow AssetUtilError("Invalid vertex data (out of bounds).");\n\t\t\t\t\t}\n\t\t\t\t\t_writerputs(std::format("v {} {} {}\\n", \n\t\t\t\t\t\t-vertexPos.x/* * subMesh.localAABB.m_Extent.x*//* + subMesh.localAABB.m_Center.x*/,\n\t\t\t\t\t\tvertexPos.y/* * subMesh.localAABB.m_Extent.y*//* + subMesh.localAABB.m_Center.y*/,\n\t\t\t\t\t\tvertexPos.z/* * subMesh.localAABB.m_Extent.z*//* + subMesh.localAABB.m_Center.z*/));\n\t\t\t\t\tif (hasColors)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t* colors = (uint32_t*)&((uint8_t*)pCurColorVertex)[colorChannel.offset];\n\t\t\t\t\t\t//TODO : add an additional .mtl file; usemtl, mtllib\n\t\t\t\t\t}\n\t\t\t\t\tif (pUVChannel)\n\t\t\t\t\t{\n\t\t\t\t\t\tVector2f vertexUV1;\n\t\t\t\t\t\tif ((pUVStream->offset + j * pUVStream->stride + pUVChannel->offset + 2 * vertexUVElementSize) <= mesh.m_VertexData.dataByteCount)\n\t\t\t\t\t\t\tmesh.m_VertexData.ConvertChannelFloat(\n\t\t\t\t\t\t\t\t&((uint8_t*)pCurUVVertex)[pUVChannel->offset],\n\t\t\t\t\t\t\t\tpUVChannel->format, 2, (float*)&vertexUV1,\n\t\t\t\t\t\t\t\tisU5\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow AssetUtilError("Invalid vertex data (out of bounds).");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Vector2f *vertexUV1 = (Vector2f*)&((BYTE*)pCurVertex)[mesh.m_VertexData.m_Channels[3].offset];\n\t\t\t\t\t\t_writerputs(std::format("vt {} {}\\n", vertexUV1.x, vertexUV1.y));\n\t\t\t\t\t}\n\t\t\t\t\tif (hasNormals)\n\t\t\t\t\t{\n\t\t\t\t\t\tVector3f vertexNormals;\n\t\t\t\t\t\tif ((normalStream.offset + j * normalStream.stride + normalChannel.offset + 3 * vertexNormalElementSize) <= mesh.m_VertexData.dataByteCount)\n\t\t\t\t\t\t\tmesh.m_VertexData.ConvertChannelFloat(\n\t\t\t\t\t\t\t\t&((uint8_t*)pCurNormalVertex)[normalChannel.offset],\n\t\t\t\t\t\t\t\tnormalChannel.format, 3, (float*)&vertexNormals,\n\t\t\t\t\t\t\t\tisU5\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow AssetUtilError("Invalid vertex data (out of bounds).");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Vector3f *vertexNormals = (Vector3f*)&((BYTE*)pCurVertex)[mesh.m_VertexData.m_Channels[1].offset];\n\t\t\t\t\t\t_writerputs(std::format("vn {} {} {}\\n", -vertexNormals.x, vertexNormals.y, vertexNormals.z));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "# Faces (%u to %u)\\n",\n\t\t\t\t\tsubMesh.firstVertex + 1, (subMesh.firstVertex + subMesh.vertexCount));\n\t\t\t\t_writerputs(formatTmp);\n\t\t\t\tformatTmp.clear();\n\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "g %s_%u\\n", mesh.m_Name, i);\n\t\t\t\t_writerputs(formatTmp);\n\t\t\t\tformatTmp.clear();\n\t\t\t\t//sprintf_s(sprntTmp, "usemtl %s_%u\\n", mesh.m_Name, i);\n\t\t\t\t//fputs(sprntTmp, pFile);\n\t\t\t\t//sprintf_s(sprntTmp, "usemap %s_%u\\n", mesh.m_Name, i);\n\t\t\t\t//fputs(sprntTmp, pFile);\n\t\t\t\tunsigned int curIndexCount = 0;\n\t\t\t\tint triIndices[3];\n\t\t\t\tunsigned int definedVertices = (subMesh.firstVertex + subMesh.vertexCount);\n\t\t\t\tunsigned int firstIndex = subMesh.firstByte / ((mesh.m_IndexFormat == 1) ? 4 : 2);\n\t\t\t\tfor (unsigned int i = firstIndex; i < (firstIndex + subMesh.indexCount) && i < mesh.m_IndexBuffer.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (!curIndexCount)\n\t\t\t\t\t\t_writerputs("f");\n\n\t\t\t\t\ttriIndices[curIndexCount] = (int)(mesh.m_IndexBuffer[i] + subMesh.baseVertex - (subMesh.firstVertex + subMesh.vertexCount));\n\t\t\t\t\tcurIndexCount++;\n\n\t\t\t\t\tif (curIndexCount == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (subMesh.topology && (i & 1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//always switch the winding\n\t\t\t\t\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), faceFormat, triIndices[i], triIndices[i], triIndices[i]);\n\t\t\t\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int i = 2; i >= 0; i--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), faceFormat, triIndices[i], triIndices[i], triIndices[i]);\n\t\t\t\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_writerputs("\\n");\n\t\t\t\t\t\tcurIndexCount = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/*int relIndex = mesh.m_IndexBuffer[i] - (subMesh.firstVertex+subMesh.vertexCount);\n\t\t\t\t\tsprintf_s(sprntTmp, faceFormat, relIndex, relIndex, relIndex);\n\t\t\t\t\t//sprintf_s(sprntTmp, faceFormat, mesh.m_IndexBuffer[i]+1, mesh.m_IndexBuffer[i]+1, mesh.m_IndexBuffer[i]+1);\n\t\t\t\t\t//sprintf_s(sprntTmp, " %d", mesh.m_IndexBuffer[i]);\n\t\t\t\t\tfputs(sprntTmp, pFile);*/\n\t\t\t\t}\n\t\t\t\t_writerputs("\\n");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunsigned int vertexDim = 3;\n\t\t\tunsigned int uvCount = 0;\n\t\t\tbool hasNormals = false;\n\t\t\tbool hasNormalSigns = false;\n\t\t\t/*bool hasFloatColors = false;\n\t\t\tbool has32BitColors = false;*/\n\t\t\tif (mesh.m_VertexData.m_VertexCount > 0)\n\t\t\t{\n\t\t\t\tvertexDim = (mesh.m_CompressedMesh.m_Vertices.m_NumItems / mesh.m_VertexData.m_VertexCount);\n\t\t\t\tuvCount = (mesh.m_CompressedMesh.m_UV.m_NumItems / mesh.m_VertexData.m_VertexCount) / 2;\n\t\t\t\thasNormals = mesh.m_CompressedMesh.m_Normals.m_NumItems != 0 &&\n\t\t\t\t\t(mesh.m_CompressedMesh.m_Normals.m_NumItems / mesh.m_VertexData.m_VertexCount) == 2;\n\t\t\t\thasNormalSigns = (mesh.m_CompressedMesh.m_NormalSigns.m_NumItems / mesh.m_CompressedMesh.m_Normals.m_NumItems) == 2;\n\t\t\t\t/*hasFloatColors = mesh.m_CompressedMesh.m_FloatColors.m_NumItems != 0 &&\n\t\t\t\t\t(mesh.m_CompressedMesh.m_FloatColors.m_NumItems / mesh.m_VertexData.m_VertexCount) == 4;\n\t\t\t\thas32BitColors = mesh.m_CompressedMesh.m_Colors.m_NumItems != 0 &&\n\t\t\t\t\t(mesh.m_CompressedMesh.m_Colors.m_NumItems / mesh.m_VertexData.m_VertexCount) == 4;*/\n\t\t\t}\n\t\t\tif (vertexDim < 2 || vertexDim > 3)\n\t\t\t{\n\t\t\t\tthrow AssetUtilError(std::format("Expected vertex dimension 2 or 3 but got {}.", vertexDim));\n\t\t\t}\n\t\t\tstd::string_view faceFormat;\n\t\t\t{\n\t\t\t\tfaceFormat = " {}";\n\t\t\t\tif (uvCount > 0)\n\t\t\t\t{\n\t\t\t\t\tif (hasNormals)\n\t\t\t\t\t\tfaceFormat = " {}/{}/{}";\n\t\t\t\t\telse\n\t\t\t\t\t\tfaceFormat = " {}/{}";\n\t\t\t\t}\n\t\t\t\telse if (hasNormals)\n\t\t\t\t\tfaceFormat = " {}//{}";\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < mesh.m_SubMeshes.size(); i++)\n\t\t\t{\n\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "# SubMesh {}\\n# Vertices\\n", i);\n\t\t\t\t_writerputs(formatTmp);\n\t\t\t\tformatTmp.clear();\n\n\t\t\t\tSubMesh& subMesh = mesh.m_SubMeshes[i];\n\t\t\t\tfor (unsigned int j = subMesh.firstVertex; j < (subMesh.firstVertex + subMesh.vertexCount) && j < mesh.m_CompressedMesh.m_Vertices.m_NumItems; j++)\n\t\t\t\t{\n\t\t\t\t\tfloat position[3] = { 0,0,0 };\n\t\t\t\t\tfor (unsigned int k = 0; k < vertexDim; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int index = j * vertexDim + k;\n\t\t\t\t\t\tif (!mesh.m_CompressedMesh.m_Vertices.ReadValueFloat(index, position[k]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow AssetUtilError(std::format("Unable to read vertex position {} (m_Vertices item {}).", j, index));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfloat uv[2] = { 0,0 };\n\t\t\t\t\tif (uvCount > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (unsigned int k = 0; k < 2; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunsigned int index = j * (2 * uvCount) + k;\n\t\t\t\t\t\t\tif (!mesh.m_CompressedMesh.m_UV.ReadValueFloat(index, uv[k]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow AssetUtilError(std::format("Unable to read vertex uv {} (m_UV item {}).", j, index));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfloat normals[3] = { 0,0,0 };\n\t\t\t\t\tif (hasNormals)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (unsigned int k = 0; k < 2; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunsigned int index = j * 2 + k;\n\t\t\t\t\t\t\tif (!mesh.m_CompressedMesh.m_Normals.ReadValueFloat(index, normals[k]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow AssetUtilError(std::format("Unable to read vertex normal {} (m_Normals item {}).", j, index));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnormals[2] = sqrt(1 - normals[0] * normals[0] - normals[1] * normals[1]);\n\t\t\t\t\t\tif (hasNormalSigns)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunsigned int sign = 0;\n\t\t\t\t\t\t\tif (!mesh.m_CompressedMesh.m_NormalSigns.ReadValue(j, sign))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow AssetUtilError(std::format("Unable to read vertex normal sign {}.", j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!sign)\n\t\t\t\t\t\t\t\tnormals[2] = -normals[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vertexDim == 2)\n\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "v {} {}\\n", -position[0], position[1]);\n\t\t\t\t\telse\n\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "v {} {} {}\\n", -position[0], position[1], position[2]);\n\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\tif (uvCount > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "vt {} {}\\n", uv[0], uv[1]);\n\t\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\t}\n\t\t\t\t\tif (hasNormals)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "vn {} {} {}\\n", -normals[0], normals[1], normals[2]);\n\t\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "# Faces (%u to %u)\\n",\n\t\t\t\t\tsubMesh.firstVertex + 1, (subMesh.firstVertex + subMesh.vertexCount));\n\t\t\t\t_writerputs(formatTmp);\n\t\t\t\tformatTmp.clear();\n\n\t\t\t\tstd::format_to(std::back_inserter(formatTmp), "g %s_%u\\n", mesh.m_Name, i);\n\t\t\t\t_writerputs(formatTmp);\n\t\t\t\tformatTmp.clear();\n\n\t\t\t\t//sprintf_s(sprntTmp, "usemtl %s_%u\\n", mesh.m_Name, i);\n\t\t\t\t//fputs(sprntTmp, pFile);\n\t\t\t\t//sprintf_s(sprntTmp, "usemap %s_%u\\n", mesh.m_Name, i);\n\t\t\t\t//fputs(sprntTmp, pFile);\n\n\t\t\t\tint curIndexCount = 0;\n\t\t\t\tint triIndices[3];\n\t\t\t\tunsigned int definedVertices = (subMesh.firstVertex + subMesh.vertexCount);\n\t\t\t\tunsigned int firstIndex = subMesh.firstByte / 2;\n\t\t\t\tfor (unsigned int j = firstIndex; j < (firstIndex + subMesh.indexCount)\n\t\t\t\t\t&& i < mesh.m_CompressedMesh.m_Triangles.m_NumItems; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!curIndexCount)\n\t\t\t\t\t\t_writerputs("f");\n\t\t\t\t\tunsigned int curIndex = 0;\n\t\t\t\t\tif (!mesh.m_CompressedMesh.m_Triangles.ReadValue(j, curIndex))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow AssetUtilError(std::format("Unable to read triangle index {}.", j));\n\t\t\t\t\t}\n\n\t\t\t\t\ttriIndices[curIndexCount] = ((int)curIndex) - (subMesh.firstVertex + subMesh.vertexCount);\n\t\t\t\t\tcurIndexCount++;\n\n\t\t\t\t\tif (curIndexCount == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (subMesh.topology && (j & 1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//always switch the winding\n\t\t\t\t\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), faceFormat, triIndices[k], triIndices[k], triIndices[k]);\n\t\t\t\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int k = 2; k >= 0; k--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstd::format_to(std::back_inserter(formatTmp), faceFormat, triIndices[k], triIndices[k], triIndices[k]);\n\t\t\t\t\t\t\t\t_writerputs(formatTmp);\n\t\t\t\t\t\t\t\tformatTmp.clear();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_writerputs("\\n");\n\t\t\t\t\t\tcurIndexCount = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_writerputs("\\n");\n\t\t\t}\n\t\t}\n\n\n\t\treturn true;\n\t}\n};\n\nenum class MeshExportMode\n{\n\tOBJ,\n\tDAESeparate,\n\tDAECombined\n};\nstatic bool SupportsElements(AppContext& appContext, std::vector<AssetUtilDesc>& elements, MeshExportMode mode)\n{\n\tbool allowSkinnedMeshRenderer = (mode != MeshExportMode::OBJ);\n\tif (mode == MeshExportMode::DAECombined && elements.size() < 2)\n\t\treturn false;\n\tstd::unordered_map<AssetsFileContextInfo*, std::array<int32_t,2>> meshClassIDs;\n\tfor (size_t i = 0; i < elements.size(); i++)\n\t{\n\t\tif (elements[i].asset.pFile == nullptr)\n\t\t\treturn false;\n\t\tAssetsFileContextInfo* pFile = elements[i].asset.pFile.get();\n\t\tauto classIDsit = meshClassIDs.find(pFile);\n\t\tstd::array<int32_t, 2> ids = { -1, -1 };\n\t\tif (classIDsit == meshClassIDs.end())\n\t\t{\n\t\t\tids[0] = pFile->GetClassByName("Mesh");\n\t\t\tids[1] = pFile->GetClassByName("SkinnedMeshRenderer");\n\t\t\tmeshClassIDs[pFile] = ids;\n\t\t}\n\t\telse\n\t\t\tids = classIDsit->second;\n\t\tint32_t classId = elements[i].asset.getClassID();\n\t\tif (classId == -1 || (classId != ids[0] && (!allowSkinnedMeshRenderer || classId != ids[1])))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nclass MeshExportProvider : public IAssetOptionProviderGeneric\n{\n\tMeshExportMode mode;\npublic:\n\tinline MeshExportProvider(MeshExportMode mode)\n\t\t: mode(mode)\n\t{}\n\tclass Runner : public IOptionRunner\n\t{\n\t\tAppContext& appContext;\n\t\tstd::vector<AssetUtilDesc> selection;\n\t\tMeshExportMode mode;\n\tpublic:\n\t\tRunner(AppContext& appContext, std::vector<AssetUtilDesc> _selection, MeshExportMode mode)\n\t\t\t: appContext(appContext), selection(std::move(_selection)), mode(mode)\n\t\t{}\n\t\tvoid operator()()\n\t\t{\n\t\t\tstd::string exportLocation;\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase MeshExportMode::OBJ:\n\t\t\t\texportLocation = appContext.QueryAssetExportLocation(selection, ".obj", "*.obj|OBJ file:");\n\t\t\t\tbreak;\n\t\t\tcase MeshExportMode::DAESeparate:\n\t\t\t\texportLocation = appContext.QueryAssetExportLocation(selection, ".dae", "*.dae|Collada file:");\n\t\t\t\tbreak;\n\t\t\tcase MeshExportMode::DAECombined:\n\t\t\t\tif (!selection.empty())\n\t\t\t\t\texportLocation = appContext.QueryAssetExportLocation({ selection[0] }, ".dae", "*.dae|Collada file:");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!exportLocation.empty())\n\t\t\t{\n\t\t\t\tstd::shared_ptr<ITask> pTask = nullptr;\n\t\t\t\tswitch (mode)\n\t\t\t\t{\n\t\t\t\tcase MeshExportMode::OBJ:\n\t\t\t\t\tpTask = std::make_shared<MeshOBJExportTask>(appContext, std::move(selection), std::move(exportLocation));\n\t\t\t\t\tbreak;\n\t\t\t\tcase MeshExportMode::DAESeparate:\n\t\t\t\t\tpTask = std::make_shared<MeshDAEExportTask>(appContext, std::move(selection), std::move(exportLocation), false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MeshExportMode::DAECombined:\n\t\t\t\t\tpTask = std::make_shared<MeshDAEExportTask>(appContext, std::move(selection), std::move(exportLocation), true);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t\t}\n\t\t}\n\t};\n\tEAssetOptionType getType()\n\t{\n\t\treturn EAssetOptionType::Export;\n\t}\n\tstd::unique_ptr<IOptionRunner> prepareForSelection(\n\t\tclass AppContext& appContext,\n\t\tstd::vector<struct AssetUtilDesc> selection,\n\t\tstd::string& optionName)\n\t{\n\t\tif (!SupportsElements(appContext, selection, mode))\n\t\t\treturn nullptr;\n\t\tconst char* modeDesc = "";\n\t\tswitch (mode)\n\t\t{\n\t\tcase MeshExportMode::OBJ:\n\t\t\tmodeDesc = ".obj";\n\t\t\tbreak;\n\t\tcase MeshExportMode::DAESeparate:\n\t\t\tmodeDesc = ".dae";\n\t\t\tbreak;\n\t\tcase MeshExportMode::DAECombined:\n\t\t\tmodeDesc = ".dae (combined)";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn nullptr;\n\t\t}\n\t\toptionName = std::string("Export mesh to ") + modeDesc;\n\t\treturn std::make_unique<Runner>(appContext, std::move(selection), mode);\n\t}\n};\n\nclass MeshPluginDesc : public IPluginDesc\n{\n\tstd::vector<std::shared_ptr<IOptionProvider>> pProviders;\npublic:\n\tMeshPluginDesc()\n\t{\n\t\tpProviders = {\n\t\t\tstd::make_shared<MeshExportProvider>(MeshExportMode::OBJ),\n\t\t\tstd::make_shared<MeshExportProvider>(MeshExportMode::DAESeparate),\n\t\t\tstd::make_shared<MeshExportProvider>(MeshExportMode::DAECombined)\n\t\t};\n\t}\n\tstd::string getName()\n\t{\n\t\treturn "Mesh";\n\t}\n\tstd::string getAuthor()\n\t{\n\t\treturn "";\n\t}\n\tstd::string getDescriptionText()\n\t{\n\t\treturn "Export Mesh and SkinnedMeshRenderer assets.";\n\t}\n\t//The IPluginDesc object should keep a reference to the returned options, as the caller may keep only std::weak_ptrs.\n\t//Note: May be called early, e.g. before program UI initialization.\n\tstd::vector<std::shared_ptr<IOptionProvider>> getPluginOptions(class AppContext& appContext)\n\t{\n\t\treturn pProviders;\n\t}\n};\n\nIPluginDesc* GetUABEPluginDesc1(size_t sizeof_AppContext, size_t sizeof_BundleFileContextInfo)\n{\n\tif (sizeof_AppContext != sizeof(AppContext) || sizeof_BundleFileContextInfo != sizeof(BundleFileContextInfo))\n\t{\n\t\tassert(false);\n\t\treturn nullptr;\n\t}\n\treturn new MeshPluginDesc();\n}\n\n'