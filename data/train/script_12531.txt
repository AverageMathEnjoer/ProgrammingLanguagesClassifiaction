b'{-# LANGUAGE BangPatterns #-}\nmodule Board where\n\nimport Wins\n\nimport Data.List\nimport Control.Parallel\n-- import Control.Parallel.Strategies\nimport Control.DeepSeq\n\nboardDim = 4\n\ntype Board = [Row] \ntype Row = [Piece]\ndata Piece = X | O | Empty deriving (Eq,Show)\n\nisEmpty Empty = True\nisEmpty _     = False\n\nshowBoard :: Board -> String\nshowBoard board = intercalate "\\n--------\\n" (map showRow board) ++ "\\n"\n where showRow r = intercalate "|" (map showPiece r)\n\nshowPiece :: Piece -> String\nshowPiece X = "X"\nshowPiece O = "O"\nshowPiece Empty = " "\n\nplacePiece :: Piece -> Board -> (Int,Int) -> Board\nplacePiece new board pos\n  = [[ if (x,y) == pos then new else old\n     | (x,old) <- zip [1..] row ]\n     | (y,row) <- zip [1..] board ]\n\nempty :: (Int,Int) -> Board -> Bool\nempty (x,y) board = isEmpty ((board !! (y-1)) !! (x-1))\n\nfullBoard b = all (not.isEmpty) (concat b)\n\nnewPositions :: Piece -> Board -> [Board]\nnewPositions piece board = \n--  [ placePiece piece board (x,y) | (x,y) <- empties board ]\n    goRows piece id board\n\ngoRows p rowsL [] = []\ngoRows p rowsL (row:rowsR) \n  = goRow p rowsL id row rowsR ++ goRows p (rowsL . (row:)) rowsR\n\ngoRow p rowsL psL [] rowsR = []\ngoRow p rowsL psL (Empty:psR) rowsR\n    = (rowsL $ (psL $ (p:psR)) : rowsR) : goRow p rowsL (psL . (Empty:)) psR rowsR\ngoRow p rowsL psL (p\':psR) rowsR = goRow p rowsL (psL . (p\':)) psR rowsR\n\nempties board = [ (x,y) | (y,row)   <- zip [1..] board,\n                          (x,Empty) <- zip [1..] row ]\n\n\ninitialBoard :: Board\ninitialBoard = replicate boardDim (replicate boardDim Empty)\n\ndata Evaluation = OWin | Score {-# UNPACK #-}!Int | XWin\n  -- higher scores denote a board in X\'s favour\n  deriving (Show,Eq)\n\ninstance NFData Evaluation where\n  rnf x = x `seq` ()\n\nmaxE :: Evaluation -> Evaluation -> Evaluation\nmaxE XWin _ = XWin\nmaxE _ XWin = XWin\nmaxE b OWin = b\nmaxE OWin b = b\nmaxE a@(Score x) b@(Score y) \t| x>y = a\n\t\t\t \t| otherwise = b\n\nminE :: Evaluation -> Evaluation -> Evaluation\nminE OWin _ = OWin\nminE _ OWin = OWin\nminE b XWin = b\nminE XWin b = b\nminE a@(Score x) b@(Score y) \t| x<y = a\n\t\t\t\t| otherwise = b\n\neval n | n  == boardDim = XWin\n       | -n == boardDim = OWin\n       | otherwise      = Score n\n\nstatic :: Board -> Evaluation\nstatic board = interpret 0 (score board)\n\ninterpret :: Int -> [Evaluation] -> Evaluation\ninterpret x [] = (Score x)\ninterpret x (Score y:l) = interpret (x+y) l\ninterpret x (XWin:l) = XWin\ninterpret x (OWin:l) = OWin\n\nscorePiece X     = 1\nscorePiece O     = -1\nscorePiece Empty = 0\n\nscoreString !n [] = n\nscoreString !n (X:ps)     = scoreString (n+1) ps\nscoreString !n (O:ps)     = scoreString (n-1) ps\nscoreString !n (Empty:ps) = scoreString n ps\n\nscore :: Board -> [Evaluation]\nscore board = \n   [ eval (scoreString 0 row) | row <- board ] ++\n   [ eval (scoreString 0 col) | col <- transpose board ] ++\n   [ eval (scoreString 0 (zipWith (!!) board [0..])),\n     eval (scoreString 0 (zipWith (!!) board [boardDim-1,boardDim-2 ..])) ]\n\n{-\n#if 0\n-- This looks very much like a zipWith f to me\nmap2 :: (a -> b -> c) -> [a] -> [b] -> [c]\nmap2 f [] x = []\nmap2 f x [] = []\nmap2 f (x:xs) (y:ys) = f x y:map2 f xs ys\n#endif\n-}\n'