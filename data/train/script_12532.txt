b'{-# LANGUAGE NoImplicitPrelude #-}\n\nmodule Course.MonadTutorial where\n\nimport Control.Category(Category((.)))\nimport Control.Monad(Monad(..), (=<<))\nimport Data.Eq(Eq)\nimport Data.Foldable(foldr)\nimport Data.Functor(Functor(fmap))\nimport Data.Int(Int)\nimport Data.String(IsString(fromString))\nimport Prelude(Show)\nimport System.IO(IO)\n\n{-\n\n--------------------------------------------------------------------------------\nWARNING: DO NOT PROCEED\n-----------------------\n\nIt is strongly advised that pre-requisite exercises have been covered prior to\nutilising this tutorial. Refusing this advice increases likelihood of a crash\nand burn result.\n\nPlease complete the following exercises before proceeding:\n* Course/Functor\n* Course/Applicative\n--------------------------------------------------------------------------------\n\nIn this source file, you will find a recurring pattern:\n\n* A data structure definition.\n* A function named @bind<name>@ for that data structure. The bind function will\n  follow a specific pattern in its type:\n\n  @(a -> f b) -> f a -> f b@\n\n* A function named @pure<name>@ for that data structure. The pure function will\n  follow a specific pattern in its type:\n\n  @a -> f a@\n\n* A function named @sequence<name>@ for that data structure. The sequence\n  function will follow a specific pattern in its type:\n\n  @[f a] -> f [a]\n\nNote that the sequence functions are written in terms of the bind and pure\nfunctions for that data type. The goal is to first acknowledge the repeating\ncode in the sequence functions, and then construct a plan to refactor out the\nsimilarities. Ultimately, there should be only a single sequence function that is\nwritten in terms of "things that have bind and pure functions."\n\nA type-class denoting "things that have bind and pure functions" is provided. It\nis named @BindAndPure@.\n\nExamine the existing data structures, their implementations of bind and pure,\nthen implement a single sequence function that generalises all the specific\nsequence functions.\n\nThe data structures given are:\n* Id\n* Optional\n* IntReader\n* Reader\n* IntState\n* State\n* Or\n* ListFree\n* IntReaderFree\n* ReaderFree\n* Free\n* IO\n\n-}\n\ndata Id a =\n  Id a\n  deriving (Eq, Show)\n\nbindId ::\n  (a -> Id b)\n  -> Id a\n  -> Id b\nbindId f (Id a) =\n  f a\n\npureId ::\n  a\n  -> Id a\npureId =\n  Id\n\nsequenceId ::\n  [Id a]\n  -> Id [a]\nsequenceId =\n  foldr (\\a as ->\n    bindId (\\a\' ->\n    bindId (\\as\' ->\n    pureId (a\' : as\')) as) a)\n  (pureId [])\n\n----\n\ndata Optional a =\n  Empty\n  | Full a\n  deriving (Eq, Show)\n\nbindOptional ::\n  (a -> Optional b)\n  -> Optional a\n  -> Optional b\nbindOptional _ Empty =\n  Empty\nbindOptional f (Full a) =\n  f a\n\npureOptional ::\n  a\n  -> Optional a\npureOptional =\n  Full\n\nsequenceOptional ::\n  [Optional a]\n  -> Optional [a]\nsequenceOptional =\n  foldr (\\a as ->\n    bindOptional (\\a\' ->\n    bindOptional (\\as\' ->\n    pureOptional (a\' : as\')) as) a)\n  (pureOptional [])\n\n----\n\ndata IntReader a =\n  IntReader (Int -> a)\n\nbindIntReader ::\n  (a -> IntReader b)\n  -> IntReader a\n  -> IntReader b\nbindIntReader f (IntReader g) =\n  IntReader (\\x -> let IntReader r = f (g x) in r x)\n\npureIntReader ::\n  a\n  -> IntReader a\npureIntReader =\n  IntReader . return\n\nsequenceIntReader ::\n  [IntReader a]\n  -> IntReader [a]\nsequenceIntReader =\n  foldr (\\a as ->\n    bindIntReader (\\a\' ->\n    bindIntReader (\\as\' ->\n    pureIntReader (a\' : as\')) as) a)\n  (pureIntReader [])\n\n----\n\ndata Reader r a =\n  Reader (r -> a)\n  \nbindReader ::\n  (a -> Reader r b)\n  -> Reader r a\n  -> Reader r b\nbindReader f (Reader g) =\n  Reader (\\x -> let Reader r = f (g x) in r x)\n\npureReader ::\n  a\n  -> Reader r a\npureReader =\n  Reader . return\n\nsequenceReader ::\n  [Reader r a]\n  -> Reader r [a]\nsequenceReader =\n  foldr (\\a as ->\n    bindReader (\\a\' ->\n    bindReader (\\as\' ->\n    pureReader (a\' : as\')) as) a)\n  (pureReader [])\n\n----\n\ndata IntState a =\n  IntState (Int -> (a, Int))\n  \nbindIntState ::\n  (a -> IntState b)\n  -> IntState a\n  -> IntState b\nbindIntState f (IntState g) =\n  IntState (\\i -> \n    let (a, j) = g i\n        IntState h = f a\n    in h j)\n\npureIntState ::\n  a\n  -> IntState a\npureIntState a =\n  IntState (\\i -> (a, i))\n\nsequenceIntState ::\n  [IntState a]\n  -> IntState [a]\nsequenceIntState =\n  foldr (\\a as ->\n    bindIntState (\\a\' ->\n    bindIntState (\\as\' ->\n    pureIntState (a\' : as\')) as) a)\n  (pureIntState [])\n\n----\n\ndata State s a =\n  State (s -> (a, s))\n\nbindState ::\n  (a -> State s b)\n  -> State s a\n  -> State s b\nbindState f (State g) =\n  State (\\s -> \n    let (a, t) = g s\n        State h = f a\n    in h t)\n\npureState ::\n  a\n  -> State s a\npureState a =\n  State (\\s -> (a, s))\n\nsequenceState ::\n  [State s a]\n  -> State s [a]\nsequenceState =\n  foldr (\\a as ->\n    bindState (\\a\' ->\n    bindState (\\as\' ->\n    pureState (a\' : as\')) as) a)\n  (pureState [])\n\n----\n\ndata Or t a =\n  This t\n  | That a\n  deriving (Eq, Show)\n\nbindOr ::\n  (a -> Or t b)\n  -> Or t a\n  -> Or t b\nbindOr _ (This t) =\n  This t\nbindOr f (That a) =\n  f a\n\npureOr ::\n  a\n  -> Or t a\npureOr =\n  That\n\nsequenceOr ::\n  [Or t a]\n  -> Or t [a]\nsequenceOr =\n  foldr (\\a as ->\n    bindOr (\\a\' ->\n    bindOr (\\as\' ->\n    pureOr (a\' : as\')) as) a)\n  (pureOr [])\n\n----\n\ndata ListFree a =\n  ListDone a\n  | ListMore [ListFree a]\n  deriving (Eq, Show)\n\nbindListFree ::\n  (a -> ListFree b)\n  -> ListFree a\n  -> ListFree b\nbindListFree f (ListDone a) =\n  f a\nbindListFree f (ListMore r) =\n  ListMore (fmap (bindListFree f) r)\n\npureListFree ::\n  a\n  -> ListFree a\npureListFree =\n  ListDone\n\nsequenceListFree ::\n  [ListFree a]\n  -> ListFree [a]\nsequenceListFree =\n  foldr (\\a as ->\n    bindListFree (\\a\' ->\n    bindListFree (\\as\' ->\n    pureListFree (a\' : as\')) as) a)\n  (pureListFree [])\n\n----\n\ndata IntReaderFree a =\n  IntReaderDone a\n  | IntReaderMore [IntReaderFree a]\n  deriving (Eq, Show)\n\nbindIntReaderFree ::\n  (a -> IntReaderFree b)\n  -> IntReaderFree a\n  -> IntReaderFree b\nbindIntReaderFree f (IntReaderDone a) =\n  f a\nbindIntReaderFree f (IntReaderMore r) =\n  IntReaderMore (fmap (bindIntReaderFree f) r)\n\npureIntReaderFree ::\n  a\n  -> IntReaderFree a\npureIntReaderFree =\n  IntReaderDone\n\nsequenceIntReaderFree ::\n  [IntReaderFree a]\n  -> IntReaderFree [a]\nsequenceIntReaderFree =\n  foldr (\\a as ->\n    bindIntReaderFree (\\a\' ->\n    bindIntReaderFree (\\as\' ->\n    pureIntReaderFree (a\' : as\')) as) a)\n  (pureIntReaderFree [])\n\n----\n\ndata ReaderFree r a =\n  ReaderDone a\n  | ReaderMore (Reader r (ReaderFree r a))\n\nbindReaderFree ::\n  (a -> ReaderFree r b)\n  -> ReaderFree r a\n  -> ReaderFree r b\nbindReaderFree f (ReaderDone a) =\n  f a\nbindReaderFree f (ReaderMore (Reader r)) =\n  ReaderMore (Reader (bindReaderFree f . r))\n\npureReaderFree ::\n  a\n  -> ReaderFree r a\npureReaderFree =\n  ReaderDone\n\nsequenceReaderFree ::\n  [ReaderFree r a]\n  -> ReaderFree r [a]\nsequenceReaderFree =\n  foldr (\\a as ->\n    bindReaderFree (\\a\' ->\n    bindReaderFree (\\as\' ->\n    pureReaderFree (a\' : as\')) as) a)\n  (pureReaderFree [])\n\n----\n\ndata Free f a =\n  Done a\n  | More (f (Free f a))\n\nbindFree ::\n  Functor f =>\n  (a -> Free f b)\n  -> Free f a\n  -> Free f b\nbindFree f (Done a) =\n  f a\nbindFree f (More r) =\n  More (fmap (bindFree f) r)\n\npureFree ::\n  a\n  -> Free f a\npureFree =\n  Done\n\nsequenceFree ::\n  Functor f =>\n  [Free f a]\n  -> Free f [a]\nsequenceFree =\n  foldr (\\a as ->\n    bindFree (\\a\' ->\n    bindFree (\\as\' ->\n    pureFree (a\' : as\')) as) a)\n  (pureFree [])\n\n----\n\n-- data IO = \xe2\x80\xa6\n\nbindIO ::\n  (a -> IO b)\n  -> IO a\n  -> IO b\nbindIO f o =\n  f =<< o\n\npureIO ::\n  a\n  -> IO a\npureIO =\n  return\n\nsequenceIO ::\n  [IO a]\n  -> IO [a]\nsequenceIO =\n  foldr (\\a as ->\n    bindIO (\\a\' ->\n    bindIO (\\as\' ->\n    pureIO (a\' : as\')) as) a)\n  (pureIO [])\n\n----\n\nclass BindAndPure f where\n  bind ::\n    (a -> f b)\n    -> f a\n    -> f b\n  pure ::\n    a\n    -> f a\n    \n'