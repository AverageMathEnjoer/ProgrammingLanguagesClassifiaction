b'{-# LANGUAGE OverloadedStrings #-}\nmodule Devices.I3 (\n      connectI3\n    , command\n    , getWorkspaces\n    , getWorkspacesConfig\n    , getOutputs\n    , getTree\n    , getMarks\n    , getBarConfig\n    , Message\n    , MessagePayload\n    , WorkspaceConfig (..)\n    ) where\n\nimport System.IO (hPutStr, hClose)\nimport System.Process.Typed\nimport qualified Control.Exception as Exception\nimport qualified Data.ByteString.UTF8 as U\nimport qualified Data.ByteString.Lazy as L\nimport qualified Data.ByteString.Lazy.Char8 as L8\nimport qualified Data.Binary as Binary\nimport qualified Data.Aeson as JSON\nimport Data.Binary.Get\nimport Network.Socket hiding (recv)\nimport Network.Socket.ByteString (recv, sendAll)\nimport Data.Int\nimport Data.Aeson\nimport Data.HashMap.Strict ((!))\nimport qualified Data.Vector as Vector\nimport Data.Scientific (floatingOrInteger)\nimport Data.List.Index\n\ndata Workspace = Workspace { _urgent :: Bool, _visible :: Bool, _number :: Int }\n    deriving (Eq, Show)\n\n\ngetWorkspacesConfig :: Socket -> IO [WorkspaceConfig]\ngetWorkspacesConfig socket = do\n    workspaces <- getWorkspaces socket\n    case workspaces of\n        Right (Array a) -> do xs <- mapM getWorkspace a\n                              return $ foldl convertWorkspace (replicate 14 WorkspaceEmpty) xs\n        _ -> return []\n\nconvertWorkspace xs Workspace { _urgent = urgent, _visible = active, _number = i } = setAt (i - 1) new xs\n    where new = case (urgent, active) of\n                        (_, True) -> WorkspaceActive\n                        (True, _) -> WorkspaceUrgent \n                        _ -> WorkspaceWindow\n\ngetWorkspace :: Value -> IO Workspace\ngetWorkspace s = case s of Object o -> case (o ! "urgent", o ! "visible", o ! "num") of\n                            (Bool urgent, Bool active, Number num) -> do\n                                case floatingOrInteger num of\n                                    Right n -> return (Workspace urgent active n)\n\ndata WorkspaceConfig = WorkspaceEmpty \n                     | WorkspaceWindow \n                     | WorkspaceUrgent \n                     | WorkspaceActive\n    deriving (Show)\n\ntype MessagePayload = String\ndata Message = Command MessagePayload\n             | GetWorkspaces\n             | Subscribe\n             | GetOutputs\n             | GetTree\n             | GetMarks\n             | GetBarConfig\n\nencodeMessage :: Message -> U.ByteString\nencodeMessage msg = U.fromString messageString\n    where messageString :: String\n          messageString = header <> messageLength <> messageType <> payload\n          messageLength :: String\n          messageLength = case msg of\n            Command payload -> reverse . L8.unpack . Binary.encode $ (fromIntegral (length payload) :: Int32)\n            otherwise -> "\\x00\\x00\\x00\\x00"\n          messageType :: String\n          messageType = case msg of\n            (Command _)   -> "\\x00\\x00\\x00\\x00"\n            GetWorkspaces -> "\\x01\\x00\\x00\\x00"\n            Subscribe     -> "\\x02\\x00\\x00\\x00"\n            GetOutputs    -> "\\x03\\x00\\x00\\x00"\n            GetTree       -> "\\x04\\x00\\x00\\x00"\n            GetMarks      -> "\\x05\\x00\\x00\\x00"\n            GetBarConfig  -> "\\x06\\x00\\x00\\x00"\n          header = "i3-ipc"\n          payload :: String\n          payload = case msg of \n            Command p -> p\n            otherwise -> ""\n\ndeserializeHeader :: Get (Integer, Integer, L8.ByteString)\ndeserializeHeader = do\n    header <- getLazyByteString 6\n    if header == "i3-ipc" then do\n        i1 <- getInt32le\n        i2 <- getInt32le\n        payload <- getRemainingLazyByteString\n        return (fromIntegral i1, fromIntegral i2, payload)\n    else fail "wrong header"\n\ndecodeMessage :: U.ByteString -> L8.ByteString\ndecodeMessage input =\n    let (messageLength, messageType, payload) = runGet deserializeHeader (L8.pack $ U.toString input)\n     in payload\n\n\ngetSocketPath :: IO String\ngetSocketPath = do\n    (out, err) <- readProcess_ "i3 --get-socketpath"\n    let unpacked = L8.unpack out\n    let ret = take (length unpacked - 1) unpacked\n    return ret\n\ncommand :: Socket -> String -> IO (Either String JSON.Value)\ncommand sock msg = getFromI3 sock (Command msg)\n\ngetWorkspaces :: Socket -> IO (Either String JSON.Value)\ngetWorkspaces sock = getFromI3 sock GetWorkspaces\n\ngetOutputs :: Socket -> IO (Either String JSON.Value)\ngetOutputs sock = getFromI3 sock GetOutputs\n\ngetTree :: Socket -> IO (Either String JSON.Value)\ngetTree sock = getFromI3 sock GetTree\n\ngetMarks :: Socket -> IO (Either String JSON.Value)\ngetMarks sock = getFromI3 sock GetMarks\n\ngetBarConfig :: Socket -> IO (Either String JSON.Value)\ngetBarConfig sock = getFromI3 sock GetBarConfig\n\ni3msg :: Socket -> Message -> IO L8.ByteString\ni3msg sock inputMessage = withSocketsDo $ do\n    let messageToSend = encodeMessage inputMessage\n    sendAll sock messageToSend\n    msg <- recv sock 8192\n    let payload = decodeMessage msg\n    return payload\n\ngetFromI3 :: Socket -> Message -> IO (Either String JSON.Value)\ngetFromI3 sock inputMessage = do\n    response <- i3msg sock inputMessage\n    return (JSON.eitherDecode response :: Either String JSON.Value)\n\nconnectI3 :: IO Socket \nconnectI3 = do\n    path <- getSocketPath\n    sock <- socket AF_UNIX Stream defaultProtocol\n    connect sock $ SockAddrUnix path\n    return sock'