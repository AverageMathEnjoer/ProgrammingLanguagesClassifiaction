b'{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE CPP #-}\n\nmodule Database.Beam.Query.SQL92\n    ( buildSql92Query\' ) where\n\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Backend.SQL\n\nimport           Control.Monad.Free.Church\nimport           Control.Monad.Free\n\nimport           Data.Kind (Type)\nimport           Data.Maybe\nimport           Data.Proxy (Proxy(Proxy))\nimport           Data.String\nimport qualified Data.Text as T\n\n-- * Beam queries\n\nandE\' :: IsSql92ExpressionSyntax expr =>\n         Maybe expr -> Maybe expr -> Maybe expr\nandE\' Nothing Nothing = Nothing\nandE\' (Just x) Nothing = Just x\nandE\' Nothing (Just y) = Just y\nandE\' (Just x) (Just y) = Just (andE x y)\n\nnewtype PreserveLeft a b = PreserveLeft { unPreserveLeft :: (a, b) }\ninstance (Monoid a, ProjectibleWithPredicate c syntax res b) => ProjectibleWithPredicate c syntax res (PreserveLeft a b) where\n  project\' context be f (PreserveLeft (a, b)) =\n    PreserveLeft . (a,) <$> project\' context be f b\n\n  projectSkeleton\' ctxt be mkM =\n    PreserveLeft . (mempty,) <$> projectSkeleton\' ctxt be mkM\n\ntype SelectStmtFn be\n  =  BeamSqlBackendSelectTableSyntax be\n -> [BeamSqlBackendOrderingSyntax be]\n -> Maybe Integer {-^ LIMIT -}\n -> Maybe Integer {-^ OFFSET -}\n -> BeamSqlBackendSelectSyntax be\n\ndata QueryBuilder be\n  = QueryBuilder\n  { qbNextTblRef :: Int\n  , qbFrom  :: Maybe (BeamSqlBackendFromSyntax be)\n  , qbWhere :: Maybe (BeamSqlBackendExpressionSyntax be) }\n\ndata SelectBuilder be (db :: (Type -> Type) -> Type) a where\n  SelectBuilderQ :: ( BeamSqlBackend be\n                    , Projectible be a )\n                 => a -> QueryBuilder be -> SelectBuilder be db a\n  SelectBuilderGrouping\n      :: ( BeamSqlBackend be\n         , Projectible be a )\n      => a -> QueryBuilder be\n      -> Maybe (BeamSqlBackendGroupingSyntax be)\n      -> Maybe (BeamSqlBackendExpressionSyntax be)\n      -> Maybe (BeamSqlBackendSetQuantifierSyntax be)\n      -> SelectBuilder be db a\n  SelectBuilderSelectSyntax :: Bool {- Whether or not this contains UNION, INTERSECT, EXCEPT, etc -}\n                            -> a -> BeamSqlBackendSelectTableSyntax be\n                            -> SelectBuilder be db a\n  SelectBuilderTopLevel ::\n    { sbLimit, sbOffset :: Maybe Integer\n    , sbOrdering        :: [ BeamSqlBackendOrderingSyntax be ]\n    , sbTable           :: SelectBuilder be db a\n    , sbSelectFn        :: Maybe (SelectStmtFn be)\n                        -- ^ Which \'SelectStmtFn\' to use to build this select. If \'Nothing\', use the default\n    } -> SelectBuilder be db a\n\nsbContainsSetOperation :: SelectBuilder syntax db a -> Bool\nsbContainsSetOperation (SelectBuilderSelectSyntax contains _ _) = contains\nsbContainsSetOperation (SelectBuilderTopLevel { sbTable = tbl }) = sbContainsSetOperation tbl\nsbContainsSetOperation _ = False\n\nfieldNameFunc :: IsSql92ExpressionSyntax expr =>\n                 (T.Text -> Sql92ExpressionFieldNameSyntax expr) -> Int\n              -> expr\nfieldNameFunc mkField i = fieldE (mkField ("res" <> fromString (show i)))\n\nnextTblPfx :: TablePrefix -> TablePrefix\nnextTblPfx = ("sub_" <>)\n\ndefaultProjection :: Projectible be x\n                  => Proxy be -> TablePrefix -> x -> [ ( BeamSqlBackendExpressionSyntax be , Maybe T.Text ) ]\ndefaultProjection be pfx =\n    zipWith (\\i e -> (e, Just (fromString "res" <> fromString (show (i :: Integer)))))\n            [0..] . flip (project be) (nextTblPfx pfx)\n\nbuildSelect :: forall be db a\n             . ( BeamSqlBackend be, Projectible be a )\n            => TablePrefix -> SelectBuilder be db a -> BeamSqlBackendSelectSyntax be\nbuildSelect _ (SelectBuilderTopLevel limit offset ordering (SelectBuilderSelectSyntax _ _ table) selectStmt\') =\n    (fromMaybe selectStmt selectStmt\') table ordering limit offset\nbuildSelect pfx (SelectBuilderTopLevel limit offset ordering (SelectBuilderQ proj (QueryBuilder _ from where_)) selectStmt\') =\n    (fromMaybe selectStmt selectStmt\') (selectTableStmt Nothing (projExprs (defaultProjection (Proxy @be) pfx proj)) from where_ Nothing Nothing) ordering limit offset\nbuildSelect pfx (SelectBuilderTopLevel limit offset ordering (SelectBuilderGrouping proj (QueryBuilder _ from where_) grouping having distinct) selectStmt\') =\n    (fromMaybe selectStmt selectStmt\') (selectTableStmt distinct (projExprs (defaultProjection (Proxy @be) pfx proj)) from where_ grouping having) ordering limit offset\nbuildSelect pfx x = buildSelect pfx (SelectBuilderTopLevel Nothing Nothing [] x Nothing)\n\nselectBuilderToTableSource :: forall be db a\n                            . ( BeamSqlBackend be, Projectible be a )\n                           => TablePrefix -> SelectBuilder be db a -> BeamSqlBackendSelectTableSyntax be\nselectBuilderToTableSource _ (SelectBuilderSelectSyntax _ _ x) = x\nselectBuilderToTableSource pfx (SelectBuilderQ x (QueryBuilder _ from where_)) =\n  selectTableStmt Nothing (projExprs (defaultProjection (Proxy @be) pfx x)) from where_ Nothing Nothing\nselectBuilderToTableSource pfx (SelectBuilderGrouping x (QueryBuilder _ from where_) grouping having distinct) =\n  selectTableStmt distinct (projExprs (defaultProjection (Proxy @be) pfx x)) from where_ grouping having\nselectBuilderToTableSource pfx sb =\n    let (x, QueryBuilder _ from where_) = selectBuilderToQueryBuilder pfx sb\n    in selectTableStmt Nothing (projExprs (defaultProjection (Proxy @be) pfx x)) from where_ Nothing Nothing\n\nselectBuilderToQueryBuilder :: forall be db a\n                             . ( BeamSqlBackend be, Projectible be a)\n                            => TablePrefix -> SelectBuilder be db a -> (a, QueryBuilder be)\nselectBuilderToQueryBuilder pfx sb =\n    let select = buildSelect pfx sb\n        x\' = reproject (Proxy @be) (fieldNameFunc (qualifiedField t0)) (sbProj sb)\n        t0 = pfx <> "0"\n    in (x\', QueryBuilder 1 (Just (fromTable (tableFromSubSelect select) (Just (t0, Nothing)))) Nothing)\n\nemptyQb :: QueryBuilder select\nemptyQb = QueryBuilder 0 Nothing Nothing\n\nsbProj :: SelectBuilder syntax db a -> a\nsbProj (SelectBuilderQ proj _) = proj\nsbProj (SelectBuilderGrouping proj _ _ _ _) = proj\nsbProj (SelectBuilderSelectSyntax _ proj _) = proj\nsbProj (SelectBuilderTopLevel _ _ _ sb _) = sbProj sb\n\nsetSelectBuilderProjection :: Projectible be b\n                           => SelectBuilder be db a -> b -> SelectBuilder be db b\nsetSelectBuilderProjection (SelectBuilderQ _ q) proj = SelectBuilderQ proj q\nsetSelectBuilderProjection (SelectBuilderGrouping _ q grouping having d) proj = SelectBuilderGrouping proj q grouping having d\nsetSelectBuilderProjection (SelectBuilderSelectSyntax containsSetOp _ q) proj = SelectBuilderSelectSyntax containsSetOp proj q\nsetSelectBuilderProjection (SelectBuilderTopLevel limit offset ord sb s) proj =\n    SelectBuilderTopLevel limit offset ord (setSelectBuilderProjection sb proj) s\n\nlimitSelectBuilder, offsetSelectBuilder :: Integer -> SelectBuilder syntax db a -> SelectBuilder syntax db a\nlimitSelectBuilder limit (SelectBuilderTopLevel limit\' offset ordering tbl build) =\n    SelectBuilderTopLevel (Just $ maybe limit (min limit) limit\') offset ordering tbl build\nlimitSelectBuilder limit x = SelectBuilderTopLevel (Just limit) Nothing [] x Nothing\n\noffsetSelectBuilder offset (SelectBuilderTopLevel Nothing offset\' ordering tbl build) =\n    SelectBuilderTopLevel Nothing (Just $ offset + fromMaybe 0 offset\') ordering tbl build\noffsetSelectBuilder offset (SelectBuilderTopLevel (Just limit) offset\' ordering tbl build) =\n    SelectBuilderTopLevel (Just $ max 0 (limit - offset)) (Just $ offset + fromMaybe 0 offset\') ordering tbl build\noffsetSelectBuilder offset x = SelectBuilderTopLevel Nothing (Just offset) [] x Nothing\n\nexprWithContext :: TablePrefix -> WithExprContext a -> a\nexprWithContext pfx = ($ nextTblPfx pfx)\n\nbuildJoinTableSourceQuery\n  :: forall be x\n   . ( BeamSqlBackend be, Projectible be x )\n  => TablePrefix -> BeamSqlBackendSelectSyntax be\n  -> x -> QueryBuilder be\n  -> (x, QueryBuilder be)\nbuildJoinTableSourceQuery tblPfx tblSource x qb =\n  let qb\' = QueryBuilder (tblRef + 1) from\' (qbWhere qb)\n      !tblRef = qbNextTblRef qb\n      from\' = case qbFrom qb of\n                Nothing -> Just newSource\n                Just oldFrom -> Just (innerJoin oldFrom newSource Nothing)\n      newSource = fromTable (tableFromSubSelect tblSource) (Just (newTblNm, Nothing))\n      newTblNm = tblPfx <> fromString (show tblRef)\n  in (reproject (Proxy @be) (fieldNameFunc (qualifiedField newTblNm)) x, qb\')\n\nbuildInnerJoinQuery\n  :: forall be r\n   . BeamSqlBackend be\n  => TablePrefix -> (TablePrefix -> T.Text -> BeamSqlBackendFromSyntax be)\n  -> (T.Text -> r)\n  -> (r-> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be)))\n  -> QueryBuilder be -> (T.Text, r, QueryBuilder be)\nbuildInnerJoinQuery tblPfx mkFrom mkTbl mkOn qb =\n  let qb\' = QueryBuilder (tblRef + 1) from\' where\'\n      tblRef = qbNextTblRef qb\n      newTblNm = tblPfx <> fromString (show tblRef)\n      newSource = mkFrom (nextTblPfx tblPfx) newTblNm\n      (from\', where\') =\n        case qbFrom qb of\n          Nothing -> (Just newSource, andE\' (qbWhere qb) (exprWithContext tblPfx <$> mkOn newTbl))\n          Just oldFrom -> (Just (innerJoin oldFrom newSource (exprWithContext tblPfx <$> mkOn newTbl)), qbWhere qb)\n\n      newTbl = mkTbl newTblNm\n  in (newTblNm, newTbl, qb\')\n\nnextTbl :: BeamSqlBackend be\n        => QueryBuilder be -> TablePrefix\n        -> (T.Text -> r)\n        -> ( r, T.Text, QueryBuilder be )\nnextTbl qb tblPfx mkTbl =\n  let tblRef = qbNextTblRef qb\n      newTblNm = tblPfx <> fromString (show tblRef)\n      newTbl = mkTbl newTblNm\n  in (newTbl, newTblNm, qb { qbNextTblRef = qbNextTblRef qb + 1})\n\nprojOrder :: Projectible be x\n          => Proxy be -> x -> WithExprContext [ BeamSqlBackendExpressionSyntax be ]\nprojOrder = project -- (Proxy @AnyType) (\\_ x -> tell [x] >> pure x)\n\n-- | Convenience functions to construct an arbitrary SQL92 select syntax type\n-- from a \'Q\'. Used by most backends as the default implementation of\n-- \'buildSqlQuery\' in \'HasQBuilder\'.\nbuildSql92Query\' :: forall be db s a\n                  . ( BeamSqlBackend be, Projectible be a)\n                 => Bool {-^ Whether this backend supports arbitrary nested UNION, INTERSECT, EXCEPT -}\n                 -> T.Text {-^ Table prefix -}\n                 -> Q be db s a\n                 -> BeamSqlBackendSelectSyntax be\nbuildSql92Query\' arbitrarilyNestedCombinations baseTblPfx (Q q) =\n    buildSelect baseTblPfx (buildQuery baseTblPfx (fromF q))\n  where\n    be :: Proxy be\n    be = Proxy\n\n    buildQuery :: forall s x\n                . Projectible be x\n               => T.Text\n               -> Free (QF be db s) x\n               -> SelectBuilder be db x\n    buildQuery _ (Pure x) = SelectBuilderQ x emptyQb\n    buildQuery tblPfx (Free (QGuard _ next)) = buildQuery tblPfx next\n    buildQuery tblPfx f@(Free QAll {}) = buildJoinedQuery tblPfx f emptyQb\n    buildQuery tblPfx f@(Free QArbitraryJoin {}) = buildJoinedQuery tblPfx f emptyQb\n    buildQuery tblPfx f@(Free QTwoWayJoin {}) = buildJoinedQuery tblPfx f emptyQb\n    buildQuery tblPfx (Free (QSubSelect q\' next)) =\n        let sb = buildQuery tblPfx (fromF q\')\n            (proj, qb) = selectBuilderToQueryBuilder tblPfx sb\n        in buildJoinedQuery tblPfx (next proj) qb\n    buildQuery tblPfx (Free (QDistinct nubType q\' next)) =\n      let (proj, qb, gp, hv) =\n            case buildQuery tblPfx (fromF q\') of\n              SelectBuilderQ proj qb ->\n                ( proj, qb, Nothing, Nothing)\n              SelectBuilderGrouping proj qb gp hv Nothing ->\n                ( proj, qb, gp, hv)\n              sb ->\n                let (proj, qb) = selectBuilderToQueryBuilder tblPfx sb\n                in ( proj, qb, Nothing, Nothing)\n      in case next proj of\n           Pure x -> SelectBuilderGrouping x qb gp hv (Just (exprWithContext tblPfx (nubType proj)))\n           _ -> let ( proj\', qb\' ) = selectBuilderToQueryBuilder tblPfx (SelectBuilderGrouping proj qb gp hv (Just (exprWithContext tblPfx (nubType proj))))\n                in buildJoinedQuery tblPfx (next proj\') qb\'\n    buildQuery tblPfx (Free (QAggregate mkAgg q\' next)) =\n        let sb = buildQuery tblPfx (fromF q\')\n            (groupingSyntax, aggProj) = mkAgg (sbProj sb) (nextTblPfx tblPfx)\n        in case tryBuildGuardsOnly tblPfx (next aggProj) Nothing of\n            Just (proj, having) ->\n                case sb of\n                  SelectBuilderQ _ q\'\' -> SelectBuilderGrouping proj q\'\' groupingSyntax having Nothing\n\n                  -- We\'ll have to generate a subselect\n                  _ -> let (subProj, qb) = selectBuilderToQueryBuilder tblPfx sb --(setSelectBuilderProjection sb aggProj)\n                           (groupingSyntax, aggProj\') = mkAgg subProj (nextTblPfx tblPfx)\n                       in case tryBuildGuardsOnly tblPfx (next aggProj\') Nothing of\n                            Nothing -> error "buildQuery (Free (QAggregate ...)): Impossible"\n                            Just (aggProj\'\', having\') ->\n                              SelectBuilderGrouping aggProj\'\' qb groupingSyntax having\' Nothing\n            Nothing ->\n              let (_, having) = tryCollectHaving tblPfx (next aggProj\') Nothing\n                  (next\', _) = tryCollectHaving tblPfx (next x\') Nothing\n                  (groupingSyntax\', aggProj\', qb) =\n                    case sb of\n                      SelectBuilderQ _ q\'\' -> (groupingSyntax, aggProj, q\'\')\n                      _ -> let (proj\', qb\'\'\') = selectBuilderToQueryBuilder tblPfx sb\n                               (groupingSyntax\', aggProj\') = mkAgg proj\' (nextTblPfx tblPfx)\n                           in (groupingSyntax\', aggProj\', qb\'\'\')\n                  (x\', qb\') = selectBuilderToQueryBuilder tblPfx $\n                              SelectBuilderGrouping aggProj\' qb groupingSyntax\' having Nothing\n              in buildJoinedQuery tblPfx next\' qb\'\n\n    buildQuery tblPfx (Free (QOrderBy mkOrdering q\' next)) =\n        let sb = buildQuery tblPfx (fromF q\')\n            proj = sbProj sb\n            ordering = exprWithContext tblPfx (mkOrdering proj)\n\n            doJoined =\n                let sb\' = case sb of\n                            SelectBuilderQ {} ->\n                                SelectBuilderTopLevel Nothing Nothing ordering sb Nothing\n                            SelectBuilderGrouping {} ->\n                                SelectBuilderTopLevel Nothing Nothing ordering sb Nothing\n                            SelectBuilderSelectSyntax {} ->\n                                SelectBuilderTopLevel Nothing Nothing ordering sb Nothing\n                            SelectBuilderTopLevel Nothing Nothing [] sb\' build ->\n                                SelectBuilderTopLevel Nothing Nothing ordering sb\' build\n                            SelectBuilderTopLevel Nothing (Just 0) [] sb\' build ->\n                                SelectBuilderTopLevel Nothing (Just 0) ordering sb\' build\n                            SelectBuilderTopLevel {}\n                                | (proj\'\', qb) <- selectBuilderToQueryBuilder tblPfx sb ->\n                                    SelectBuilderTopLevel Nothing Nothing (exprWithContext tblPfx (mkOrdering proj\'\')) (SelectBuilderQ proj\'\' qb) Nothing\n                                | otherwise -> error "buildQuery (Free (QOrderBy ...)): query inspected expression"\n\n                    (joinedProj, qb) = selectBuilderToQueryBuilder tblPfx sb\'\n                in buildJoinedQuery tblPfx (next joinedProj) qb\n        in case next proj of\n             Pure proj\' ->\n               case ordering of\n                 [] -> setSelectBuilderProjection sb proj\'\n                 ordering ->\n                     case sb of\n                       SelectBuilderQ {} ->\n                           SelectBuilderTopLevel Nothing Nothing ordering (setSelectBuilderProjection sb proj\') Nothing\n                       SelectBuilderGrouping {} ->\n                           SelectBuilderTopLevel Nothing Nothing ordering (setSelectBuilderProjection sb proj\') Nothing\n                       SelectBuilderSelectSyntax {} ->\n                           SelectBuilderTopLevel Nothing Nothing ordering (setSelectBuilderProjection sb proj\') Nothing\n                       SelectBuilderTopLevel Nothing Nothing [] sb\' build ->\n                           SelectBuilderTopLevel Nothing Nothing ordering (setSelectBuilderProjection sb\' proj\') build\n                       SelectBuilderTopLevel (Just 0) (Just 0) [] sb\' build ->\n                           SelectBuilderTopLevel (Just 0) (Just 0) ordering (setSelectBuilderProjection sb\' proj\') build\n                       SelectBuilderTopLevel {}\n                           | (proj\'\', qb) <- selectBuilderToQueryBuilder tblPfx sb,\n                             Pure proj\'\'\' <- next proj\'\' ->\n                               SelectBuilderTopLevel Nothing Nothing (exprWithContext tblPfx (mkOrdering proj\'\')) (SelectBuilderQ proj\'\'\' qb) Nothing\n                           | otherwise -> error "buildQuery (Free (QOrderBy ...)): query inspected expression"\n             _ -> doJoined\n\n    buildQuery tblPfx (Free (QWindowOver mkWindows mkProjection q\' next)) =\n        let sb = buildQuery tblPfx (fromF q\')\n\n            x = sbProj sb\n            windows = mkWindows x\n            projection = mkProjection x windows\n        in case next projection of\n             Pure x\' ->\n               -- Windowing makes this automatically a top-level (this prevents aggregates from being added directly)\n               case setSelectBuilderProjection sb x\' of\n                 sb\'@SelectBuilderTopLevel {} -> sb\'\n                 sb\' -> SelectBuilderTopLevel Nothing Nothing [] sb\' Nothing\n             _       ->\n               let (x\', qb) = selectBuilderToQueryBuilder tblPfx (setSelectBuilderProjection sb projection)\n               in buildJoinedQuery tblPfx (next x\') qb\n\n    buildQuery tblPfx (Free (QLimit limit q\' next)) =\n        let sb = limitSelectBuilder limit (buildQuery tblPfx (fromF q\'))\n            x = sbProj sb\n        -- In the case of limit, we must directly return whatever was given\n        in case next x of\n             Pure x\' -> setSelectBuilderProjection sb x\'\n\n             -- Otherwise, this is going to be part of a join...\n             _ -> let (x\', qb) = selectBuilderToQueryBuilder tblPfx sb\n                  in buildJoinedQuery tblPfx (next x\') qb\n\n    buildQuery tblPfx (Free (QOffset offset q\' next)) =\n        let sb = offsetSelectBuilder offset (buildQuery tblPfx (fromF q\'))\n            x = sbProj sb\n        -- In the case of limit, we must directly return whatever was given\n        in case next x of\n             Pure x\' -> setSelectBuilderProjection sb x\'\n             -- Otherwise, this is going to be part of a join...\n             _ -> let (x\', qb) = selectBuilderToQueryBuilder tblPfx sb\n                  in buildJoinedQuery tblPfx (next x\') qb\n\n    buildQuery tblPfx (Free (QSetOp combine left right next)) =\n      buildTableCombination tblPfx combine left right next\n\n    buildQuery tblPfx (Free (QForceSelect selectStmt\' over next)) =\n      let sb = buildQuery tblPfx (fromF over)\n          x = sbProj sb\n\n          selectStmt\'\' = selectStmt\' (sbProj sb)\n\n          sb\' = case sb of\n                  SelectBuilderTopLevel { sbSelectFn = Nothing } ->\n                    sb { sbSelectFn = Just selectStmt\'\' }\n                  SelectBuilderTopLevel { sbSelectFn = Just {} } ->\n                    error "Force select too hard"\n                  _ -> SelectBuilderTopLevel Nothing Nothing [] sb (Just selectStmt\'\')\n      in case next (sbProj sb\') of\n           Pure x\' -> setSelectBuilderProjection sb\' x\'\n           _ -> let (x\', qb) = selectBuilderToQueryBuilder tblPfx sb\'\n                in buildJoinedQuery tblPfx (next x\') qb\n\n    tryBuildGuardsOnly :: forall s x\n                        . T.Text\n                       -> Free (QF be db s) x\n                       -> Maybe (BeamSqlBackendExpressionSyntax be)\n                       -> Maybe (x, Maybe (BeamSqlBackendExpressionSyntax be))\n    tryBuildGuardsOnly tblPfx next having =\n      case tryCollectHaving tblPfx next having of\n        (Pure x, having\') -> Just (x, having\')\n        _ -> Nothing\n\n    tryCollectHaving :: forall s x\n                      . T.Text\n                     -> Free (QF be db s) x\n                     -> Maybe (BeamSqlBackendExpressionSyntax be)\n                     -> (Free (QF be db s) x, Maybe (BeamSqlBackendExpressionSyntax be))\n    tryCollectHaving tblPfx (Free (QGuard cond next)) having = tryCollectHaving tblPfx next (andE\' having (Just (exprWithContext tblPfx cond)))\n    tryCollectHaving _ next having = (next, having)\n\n    buildTableCombination\n      :: forall s x r\n       . ( Projectible be r, Projectible be x )\n      => T.Text\n      -> (BeamSqlBackendSelectTableSyntax be -> BeamSqlBackendSelectTableSyntax be -> BeamSqlBackendSelectTableSyntax be)\n      -> QM be db (QNested s) x -> QM be db (QNested s) x -> (x -> Free (QF be db s) r) -> SelectBuilder be db r\n    buildTableCombination tblPfx combineTables left right next =\n        let leftSb = buildQuery tblPfx (fromF left)\n            leftTb = selectBuilderToTableSource tblPfx leftSb\n            rightSb = buildQuery tblPfx (fromF right)\n            rightTb = selectBuilderToTableSource tblPfx rightSb\n\n            proj = reproject be (fieldNameFunc unqualifiedField) (sbProj leftSb)\n\n            leftTb\' | arbitrarilyNestedCombinations = leftTb\n                    | sbContainsSetOperation leftSb =\n                      let (x\', qb) = selectBuilderToQueryBuilder tblPfx leftSb\n                      in selectBuilderToTableSource tblPfx (SelectBuilderQ x\' qb)\n                    | otherwise = leftTb\n            rightTb\' | arbitrarilyNestedCombinations = rightTb\n                     | sbContainsSetOperation rightSb =\n                       let (x\', qb) = selectBuilderToQueryBuilder tblPfx rightSb\n                       in selectBuilderToTableSource tblPfx (SelectBuilderQ x\' qb)\n                     | otherwise = rightTb\n\n            sb = SelectBuilderSelectSyntax True proj (combineTables leftTb\' rightTb\')\n        in case next proj of\n             Pure proj\'\n               | projOrder be proj (nextTblPfx tblPfx) == projOrder be proj\' (nextTblPfx tblPfx) ->\n                   setSelectBuilderProjection sb proj\'\n             _ -> let (x\', qb) = selectBuilderToQueryBuilder tblPfx sb\n                  in buildJoinedQuery tblPfx (next x\') qb\n\n    buildJoinedQuery :: forall s x\n                      . Projectible be x\n                     => T.Text -> Free (QF be db s) x -> QueryBuilder be -> SelectBuilder be db x\n    buildJoinedQuery _ (Pure x) qb = SelectBuilderQ x qb\n    buildJoinedQuery tblPfx (Free (QAll mkFrom mkTbl on next)) qb =\n        let (newTblNm, newTbl, qb\') = buildInnerJoinQuery tblPfx mkFrom mkTbl on qb\n        in buildJoinedQuery tblPfx (next (newTblNm, newTbl)) qb\'\n    buildJoinedQuery tblPfx (Free (QArbitraryJoin q tblNs mkJoin on next)) qb =\n      case fromF q of\n        Free (QAll mkDbFrom dbMkTbl on\' next\')\n          | (newTbl, newTblNm, qb\') <- nextTbl qb tblPfx dbMkTbl,\n            Nothing <- exprWithContext tblPfx <$> on\' newTbl,\n            Pure proj <- next\' (newTblNm, newTbl) ->\n            let newSource = mkDbFrom (nextTblPfx tblPfx) newTblNm\n                on\'\' = exprWithContext tblPfx <$> on proj\n                (from\', where\') =\n                  case qbFrom qb\' of\n                    Nothing -> (Just newSource, andE\' (qbWhere qb) on\'\')\n                    Just oldFrom -> (Just (mkJoin oldFrom newSource on\'\'), qbWhere qb)\n            in buildJoinedQuery tblPfx (next proj) (qb\' { qbFrom = from\', qbWhere = where\' })\n\n        q\' -> let tblPfx\' = tblPfx <> tblNs\n\n                  sb = buildQuery tblPfx\' q\'\n                  tblSource = buildSelect tblPfx\' sb\n                  newTblNm = tblPfx <> fromString (show (qbNextTblRef qb))\n\n                  newSource = fromTable (tableFromSubSelect tblSource) (Just (newTblNm, Nothing))\n\n                  proj\' = reproject be (fieldNameFunc (qualifiedField newTblNm)) (sbProj sb)\n                  on\' = exprWithContext tblPfx <$> on proj\'\n\n                  (from\', where\') =\n                    case qbFrom qb of\n                      Nothing -> (Just newSource, andE\' (qbWhere qb) on\')\n                      Just oldFrom -> (Just (mkJoin oldFrom newSource on\'), qbWhere qb)\n\n              in buildJoinedQuery tblPfx (next proj\') (qb { qbNextTblRef = qbNextTblRef qb + 1\n                                                          , qbFrom = from\', qbWhere = where\' })\n    buildJoinedQuery tblPfx (Free (QTwoWayJoin a b mkJoin on next)) qb =\n      let (aProj, aSource, qb\') =\n            case fromF a of\n              Free (QAll mkDbFrom dbMkTbl on\' next\')\n                | (newTbl, newTblNm, qb\') <- nextTbl qb tblPfx dbMkTbl,\n                  Nothing <- on\' newTbl, Pure proj <- next\' (newTblNm, newTbl) ->\n                    (proj, mkDbFrom (nextTblPfx tblPfx) newTblNm, qb\')\n\n              a -> let sb = buildQuery tblPfx a\n                       tblSource = buildSelect tblPfx sb\n\n                       newTblNm = tblPfx <> fromString (show (qbNextTblRef qb))\n\n                       proj\' = reproject be (fieldNameFunc (qualifiedField newTblNm)) (sbProj sb)\n                   in (proj\', fromTable (tableFromSubSelect tblSource) (Just (newTblNm, Nothing)), qb { qbNextTblRef = qbNextTblRef qb + 1 })\n\n          (bProj, bSource, qb\'\') =\n            case fromF b of\n              Free (QAll mkDbFrom dbMkTbl on\' next\')\n                | (newTbl, newTblNm, qb\'\') <- nextTbl qb\' tblPfx dbMkTbl,\n                  Nothing <- on\' newTbl, Pure proj <- next\' (newTblNm, newTbl) ->\n                    (proj, mkDbFrom (nextTblPfx tblPfx) newTblNm, qb\'\')\n\n              b -> let sb = buildQuery tblPfx b\n                       tblSource = buildSelect tblPfx sb\n\n                       newTblNm = tblPfx <> fromString (show (qbNextTblRef qb))\n\n                       proj\' = reproject be (fieldNameFunc (qualifiedField newTblNm)) (sbProj sb)\n                   in (proj\', fromTable (tableFromSubSelect tblSource) (Just (newTblNm, Nothing)), qb { qbNextTblRef = qbNextTblRef qb + 1 })\n\n          abSource = mkJoin aSource bSource (exprWithContext tblPfx <$> on (aProj, bProj))\n\n          from\' =\n            case qbFrom qb\'\' of\n              Nothing -> Just abSource\n              Just oldFrom -> Just (innerJoin oldFrom abSource Nothing)\n\n      in buildJoinedQuery tblPfx (next (aProj, bProj)) (qb\'\' { qbFrom = from\' })\n    buildJoinedQuery tblPfx (Free (QGuard cond next)) qb =\n        buildJoinedQuery tblPfx next (qb { qbWhere = andE\' (qbWhere qb) (Just (exprWithContext tblPfx cond)) })\n    buildJoinedQuery tblPfx now qb =\n      onlyQ now\n        (\\now\' next ->\n           let sb = buildQuery tblPfx now\'\n               tblSource = buildSelect tblPfx sb\n               (x\', qb\') = buildJoinTableSourceQuery tblPfx tblSource (sbProj sb) qb\n           in buildJoinedQuery tblPfx (next x\') qb\')\n\n    onlyQ :: forall s x.\n             Free (QF be db s) x\n          -> (forall a\'. Projectible be a\' => Free (QF be db s) a\' -> (a\' -> Free (QF be db s) x) -> SelectBuilder be db x)\n          -> SelectBuilder be db x\n    onlyQ (Free (QAll entityNm mkTbl mkOn next)) f =\n      f (Free (QAll entityNm mkTbl mkOn (Pure . PreserveLeft))) (next . unPreserveLeft)\n--      f (Free (QAll entityNm mkTbl mkOn (Pure . PreserveLeft))) (next . unPreserveLeft)\n    onlyQ (Free (QArbitraryJoin entity tblNs mkJoin mkOn next)) f =\n      f (Free (QArbitraryJoin entity tblNs mkJoin mkOn Pure)) next\n    onlyQ (Free (QTwoWayJoin a b mkJoin mkOn next)) f =\n      f (Free (QTwoWayJoin a b mkJoin mkOn Pure)) next\n    onlyQ (Free (QSubSelect q\' next)) f =\n      f (Free (QSubSelect q\' Pure)) next\n    onlyQ (Free (QLimit limit q\' next)) f =\n      f (Free (QLimit limit q\' Pure)) next\n    onlyQ (Free (QOffset offset q\' next)) f =\n      f (Free (QOffset offset q\' Pure)) next\n    onlyQ (Free (QSetOp combine a b next)) f =\n      f (Free (QSetOp combine a b Pure)) next\n    onlyQ (Free (QOrderBy mkOrdering q\' next)) f =\n      f (Free (QOrderBy mkOrdering q\' Pure)) next\n    onlyQ (Free (QWindowOver mkWindow mkProj q\' next)) f =\n      f (Free (QWindowOver mkWindow mkProj q\' Pure)) next\n    onlyQ (Free (QAggregate mkAgg q\' next)) f =\n      f (Free (QAggregate mkAgg q\' Pure)) next\n    onlyQ (Free (QDistinct d q\' next)) f =\n      f (Free (QDistinct d q\' Pure)) next\n    onlyQ (Free (QForceSelect s over next)) f =\n      f (Free (QForceSelect s over Pure)) next\n    onlyQ _ _ = error "impossible"\n'