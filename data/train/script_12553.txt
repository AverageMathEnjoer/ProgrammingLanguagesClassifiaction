b'{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n-- | See <http://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html> for the\n-- full awk grammar.\n--\n-- @since 1.0\nmodule Test.Tasty.Patterns.Parser\n  ( Parser\n  , runParser\n  , ParseResult(..)\n  , expr\n  , parseAwkExpr\n  )\n  where\n\nimport Prelude hiding (Ordering(..))\nimport Text.ParserCombinators.ReadP hiding (many, optional)\nimport Text.ParserCombinators.ReadPrec (readPrec_to_P, minPrec)\nimport Text.Read (readPrec)\nimport Data.Functor\nimport Data.Char\nimport Control.Applicative\nimport Control.Monad\nimport Test.Tasty.Patterns.Types\nimport Test.Tasty.Patterns.Expr\n\ntype Token = ReadP\n\n-- | A separate \'Parser\' data type ensures that we don\'t forget to skip\n-- spaces.\n--\n-- @since 1.0\nnewtype Parser a = Parser (ReadP a)\n  deriving (Functor, Applicative, Alternative, Monad, MonadPlus)\n\n-- | @since 1.0\ndata ParseResult a = Success a | Invalid | Ambiguous [a]\n  deriving\n  ( Show\n  , Eq -- ^ @since 1.4.2\n  )\n\ntoken :: Token a -> Parser a\ntoken a = Parser (a <* skipSpaces)\n\nsym :: Char -> Parser ()\nsym = void . token . char\n\nstr :: String -> Parser ()\nstr = void . token . string\n\n-- | Run a parser\n--\n-- @since 1.0\nrunParser\n  :: Parser a\n  -> String -- ^ text to parse\n  -> ParseResult a\nrunParser (Parser p) s =\n  case filter (null . snd) $ readP_to_S (skipSpaces *> p) s of\n    [(a, _)] -> Success a\n    [] -> Invalid\n    as -> Ambiguous (fst <$> as)\n\nintP :: Parser Int\nintP = token $\n  -- we cannot use the standard Int ReadP parser because it recognizes\n  -- negative numbers, making -1 ambiguous\n  read <$> munch1 isDigit\n\nstrP :: Parser String\nstrP = token $ readPrec_to_P readPrec minPrec\n  -- this deviates somewhat from the awk string literals, by design\n\n-- | An awk ERE token such as @/foo/@. No special characters are recognized\n-- at the moment, except @\\@ as an escape character for @/@ and itself.\npatP :: Parser String\npatP = token $ char \'/\' *> many ch <* char \'/\'\n  where\n    ch =\n      satisfy (`notElem` "/\\\\") <|>\n      (char \'\\\\\' *> satisfy (`elem` "/\\\\"))\n\nnfP :: Parser ()\nnfP = token $ void $ string "NF"\n\n-- | Built-in functions\nbuiltin :: Parser Expr\nbuiltin = msum\n  [ fn "length" $ LengthFn <$> optional expr\n    -- we don\'t support length without parentheses at all,\n    -- because that makes length($1) ambiguous\n    -- (we don\'t require spaces for concatenation)\n  , fn "toupper" $ ToUpperFn <$> expr\n  , fn "tolower" $ ToLowerFn <$> expr\n  , fn "match" $ MatchFn <$> expr <* sym \',\' <*> patP\n  , fn "substr" $ SubstrFn <$> expr <* sym \',\' <*> expr <*>\n      optional (sym \',\' *> expr)\n  ]\n  where\n    fn :: String -> Parser a -> Parser a\n    fn name args = token (string name) *> sym \'(\' *> args <* sym \')\'\n\n-- | Atomic expressions\nexpr0 :: Parser Expr\nexpr0 =\n  (sym \'(\' *> expr <* sym \')\') <|>\n  (IntLit <$> intP) <|>\n  (StringLit <$> strP) <|>\n  (ERE <$> patP) <|>\n  (NF <$ nfP) <|>\n  builtin\n\n-- | Arguments to unary operators: atomic expressions and field\n-- expressions\nexpr1 :: Parser Expr\nexpr1 = makeExprParser expr0\n  [ [ Prefix  (Field <$ sym \'$\') ] ]\n\n-- | Whether a parser is unary or non-unary.\n--\n-- This roughly corresponds to the @unary_expr@ and @non_unary_expr@\n-- non-terminals in the awk grammar.\n-- (Why roughly? See @expr2@.)\ndata Unary = Unary | NonUnary\n\n-- | Arithmetic expressions.\n--\n-- Unlike awk, non-unary expressions disallow unary operators everywhere,\n-- not just in the leading position, to avoid extra complexity in\n-- @makeExprParser@.\n--\n-- For example, the expression\n--\n-- >1 3 + -4\n--\n-- is valid in awk because @3 + -4@ is non-unary, but we disallow it here\n-- because @makeExprParser@ does not allow us to distinguish it from\n--\n-- >1 -4 + 3\n--\n-- which is ambiguous.\nexpr2 :: Unary -> Parser Expr\nexpr2 unary = makeExprParser expr1\n  [ [ Prefix  (Not <$ sym \'!\') ] ++\n    (case unary of\n      Unary -> [ Prefix  (Neg <$ sym \'-\') ]\n      NonUnary -> []\n    )\n  , [ InfixL  (Add <$ sym \'+\')\n    , InfixL  (Sub <$ sym \'-\')\n    ]\n  ]\n\n-- | Expressions that may include string concatenation\nexpr3 :: Parser Expr\nexpr3 = concatExpr <|> expr2 Unary\n  where\n    -- The awk spec mandates that concatenation associates to the left.\n    -- But concatenation is associative, so why would we care.\n    concatExpr = Concat <$> nonUnary <*> (nonUnary <|> concatExpr)\n    nonUnary = expr2 NonUnary\n\n-- | Everything with lower precedence than concatenation\nexpr4 :: Parser Expr\nexpr4 = makeExprParser expr3\n  [ [ InfixN (LT <$ sym \'<\')\n    , InfixN (GT <$ sym \'>\')\n    , InfixN (LE <$ str "<=")\n    , InfixN (GE <$ str ">=")\n    , InfixN (EQ <$ str "==")\n    , InfixN (NE <$ str "!=")\n    ]\n  , [ Postfix (flip Match <$ sym \'~\' <*> patP)\n    , Postfix (flip NoMatch <$ str "!~" <*> patP)\n    ]\n  , [ InfixL (And <$ str "&&") ]\n  , [ InfixL (Or  <$ str "||") ]\n  , [ TernR  ((If <$ sym \':\') <$ sym \'?\') ]\n  ]\n\n-- | The awk-like expression parser.\n--\n-- @since 1.0\nexpr :: Parser Expr\nexpr = expr4\n\n-- | Parse an awk expression.\n--\n-- @since 1.1\nparseAwkExpr :: String -> Maybe Expr\nparseAwkExpr s =\n  case runParser expr s of\n    Success e -> Just e\n    _ -> Nothing\n'