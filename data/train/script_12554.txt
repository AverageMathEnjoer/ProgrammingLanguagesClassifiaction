b'#include "stdafx.h"\n#include "ModPackageLoader.h"\n#include "FileDialog.h"\n#include "resource.h"\n#include "../libStringConverter/convert.h"\n#include "../ModInstaller/ModInstaller.h"\n#include <Shlwapi.h>\n#include <WindowsX.h>\n\nWin32ModPackageLoader::Win32ModPackageLoader(Win32AppContext &appContext)\n\t: Win32ModTreeDialogBase(appContext)\n{}\n\nvoid Win32ModPackageLoader::open()\n{\n\tWCHAR *packageFilePath = NULL;\n\tif (FAILED(ShowFileOpenDialog(appContext.getMainWindow().getWindow(), &packageFilePath,\n\t\tL"*.emip|UABE Mod Installer Package:*.exe|UABE Installer:",\n\t\tnullptr, nullptr, nullptr, UABE_FILEDIALOG_FILE_GUID)))\n\t\treturn;\n\tstd::shared_ptr<IAssetsReader> pPackageFileReader(Create_AssetsReaderFromFile(packageFilePath, true, RWOpenFlags_Immediately), Free_AssetsReader);\n\tFreeCOMFilePathBuf(&packageFilePath);\n\tif (!pPackageFileReader)\n\t{\n\t\tMessageBox(appContext.getMainWindow().getWindow(), TEXT("Unable to open the package file!"), TEXT("ERROR"), 16);\n\t\treturn;\n\t}\n\tbool closeReader = true;\n\tInstallerPackageFile packageFile;\n\tQWORD filePos = 0;\n\tbool success = packageFile.Read(filePos, pPackageFileReader/*, true*/);\n\tif (!success)\n\t{\n\t\tsize_t overlayOffset = GetPEOverlayOffset(pPackageFileReader.get());\n\t\tif (overlayOffset != 0)\n\t\t{\n\t\t\tfilePos = overlayOffset;\n\t\t\tsuccess = packageFile.Read(filePos, pPackageFileReader);\n\t\t}\n\t}\n\tif (!success)\n\t{\n\t\tMessageBox(appContext.getMainWindow().getWindow(), TEXT("Unable to understand the package file!\\n")\\\n\t\t\tTEXT("Make sure the selected file actually is a valid package file."), TEXT("ERROR"), 16);\n\t\treturn;\n\t}\n\n\tvisibleFiles.clear();\n\tvisibleFiles.reserve(packageFile.affectedAssets.size());\n\tfor (size_t i = 0; i < packageFile.affectedAssets.size(); ++i)\n\t{\n\t\tvisibleFiles.push_back(VisibleFileEntry(this->appContext, packageFile.affectedAssets[i]));\n\t}\n\tDialogBoxParam(appContext.getMainWindow().getHInstance(),\n\t\tMAKEINTRESOURCE(IDD_LOADFROMPACKAGE),\n\t\tappContext.getMainWindow().getWindow(),\n\t\tDialogProc, (LPARAM)this);\n\t\n\tfor (size_t i = 0; i < visibleFiles.size(); ++i)\n\t{\n\t\tbool basedOnExistingFile = true;\n\t\tif (visibleFiles[i].fileType == FileContext_Resources)\n\t\t{\n\t\t\t//Allow new resource files to be created.\n\t\t\t//-> Check if the resource replacer is based on an existing file.\n\t\t\t//   If not, allow CreateFileOpenTask to open a \'zero length\' in-memory reader\n\t\t\t//    instead of the actual file.\n\t\t\tassert(visibleFiles[i].replacers.size() == 1);\n\t\t\tif (visibleFiles[i].replacers.size() == 1\n\t\t\t\t&& !reinterpret_cast<BundleReplacer*>(visibleFiles[i].replacers[0].pReplacer.get())->RequiresEntryReader())\n\t\t\t\tbasedOnExistingFile = false;\n\t\t}\n\t\tstd::shared_ptr<ITask> pTask = appContext.CreateFileOpenTask(visibleFiles[i].pathOrName, basedOnExistingFile);\n\t\tif (pTask != nullptr)\n\t\t{\n\t\t\tappContext.OpenTask_SetModifications(pTask.get(), std::unique_ptr<VisibleFileEntry>(new VisibleFileEntry(std::move(visibleFiles[i]))));\n\t\t\tappContext.taskManager.enqueue(pTask);\n\t\t}\n\t}\n\tvisibleFiles.clear();\n}\n\nvoid Win32ModPackageLoader::FillModifiedFilesTree()\n{\n\tUpdateModsTree(false);\n\n\tTVITEM item;\n\titem.hItem = bundleBaseEntry;\n\titem.mask = TVIF_HANDLE | TVIF_STATE;\n\titem.stateMask = TVIS_STATEIMAGEMASK;\n\titem.state = 0 << 12;\n\tTreeView_SetItem(hTreeModifications, &item);\n\n\titem.hItem = assetsBaseEntry;\n\titem.mask = TVIF_HANDLE | TVIF_STATE;\n\titem.stateMask = TVIS_STATEIMAGEMASK;\n\titem.state = 0 << 12;\n\tTreeView_SetItem(hTreeModifications, &item);\n}\n\nvoid Win32ModPackageLoader::OnChangeBaseFolderEdit()\n{\n\tHWND hEditBaseFolder = GetDlgItem(hDlg, IDC_EBASEFOLDER);\n\tif (!hEditBaseFolder)\n\t\treturn;\n\tsize_t textLen = (size_t)Edit_GetTextLength(hEditBaseFolder);\n\tstd::vector<wchar_t> newBasePath(textLen+1);\n\tEdit_GetText(hEditBaseFolder, newBasePath.data(), (int)(textLen + 1));\n\tnewBasePath[textLen] = 0;\n\n\tsize_t wBasePathLen = wcslen(newBasePath.data());\n\tfor (size_t i = 0; i < this->visibleFiles.size(); i++)\n\t{\n\t\tsize_t wPathLen = 0;\n\t\tauto wPath = unique_MultiByteToWide(this->visibleFiles[i].pathOrName.c_str(), wPathLen);\n\t\tstd::vector<wchar_t> combinedPathBuf(std::max<size_t>(wBasePathLen + wPathLen + 16, MAX_PATH+1));\n\t\t//TODO: Use a long path compatible function.\n\t\tbool changePath = PathCombine(combinedPathBuf.data(), newBasePath.data(), wPath.get()) != NULL;\n\t\tif (changePath)\n\t\t{\n\t\t\tTVITEMEX item = {};\n\t\t\titem.hItem = (HTREEITEM)this->visibleFiles[i].treeViewEntry;\n\t\t\titem.mask = TVIF_HANDLE | TVIF_TEXT;\n\t\t\titem.pszText = combinedPathBuf.data();\n\t\t\tTreeView_SetItem(hTreeModifications, &item);\n\t\t}\n\t}\n}\n\nvoid Win32ModPackageLoader::OnCheck(HTREEITEM item, bool isChecked)\n{\n\tstruct _Lambda_RecursiveCheck{\n\t\tHWND hTreeModifications;\n\t\tbool isChecked;\n\t\t_Lambda_RecursiveCheck(HWND hTreeModifications, bool isChecked)\n\t\t\t: hTreeModifications(hTreeModifications), isChecked(isChecked)\n\t\t{}\n\t\tvoid operator()(VisibleFileEntry &file)\n\t\t{\n\t\t\tif (!file.treeViewEntry)\n\t\t\t\treturn;\n\t\t\tTreeView_SetCheckState(hTreeModifications, (HTREEITEM)file.treeViewEntry, isChecked);\n\t\t\tfor (size_t i = 0; i < file.subFiles.size(); ++i)\n\t\t\t\t(*this)(file.subFiles[i]);\n\t\t}\n\t\tbool operator()(HTREEITEM base, VisibleFileEntry &file)\n\t\t{\n\t\t\tif (!file.treeViewEntry)\n\t\t\t\treturn false;\n\t\t\tif (file.treeViewEntry == (uintptr_t)base)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < file.subFiles.size(); ++i)\n\t\t\t\t\t(*this)(file.subFiles[i]);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < file.subFiles.size(); ++i)\n\t\t\t\t{\n\t\t\t\t\tif ((*this)(base, file.subFiles[i]))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t} recursiveCheck(hTreeModifications, isChecked);\n\tif (item == assetsBaseEntry || item == NULL)\n\t{\n\t\tfor (size_t i = 0; i < visibleFiles.size(); i++)\n\t\t{\n\t\t\tif (visibleFiles[i].fileType == FileContext_Assets)\n\t\t\t\trecursiveCheck(visibleFiles[i]);\n\t\t}\n\t}\n\tif (item == bundleBaseEntry || item == NULL)\n\t{\n\t\tfor (size_t i = 0; i < visibleFiles.size(); i++)\n\t\t{\n\t\t\tif (visibleFiles[i].fileType == FileContext_Bundle)\n\t\t\t\trecursiveCheck(visibleFiles[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (size_t i = 0; i < visibleFiles.size(); i++)\n\t\t{\n\t\t\tif (recursiveCheck(item, visibleFiles[i]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nvoid Win32ModPackageLoader::RemoveUnchecked()\n{\n\tstruct _Lambda_RecursiveRemoveIfUnchecked {\n\t\tHWND hTreeModifications;\n\t\t_Lambda_RecursiveRemoveIfUnchecked(HWND hTreeModifications)\n\t\t\t: hTreeModifications(hTreeModifications)\n\t\t{}\n\t\tbool operator()(VisibleFileEntry &file)\n\t\t{\n\t\t\tif (file.treeViewEntry == NULL || !TreeView_GetCheckState(hTreeModifications, file.treeViewEntry))\n\t\t\t\treturn true;\n\t\t\tfor (size_t _i = file.subFiles.size(); _i > 0; --_i)\n\t\t\t{\n\t\t\t\tsize_t i = _i - 1;\n\t\t\t\tif ((*this)(file.subFiles[i]))\n\t\t\t\t{\n\t\t\t\t\tif (file.subFiles[i].treeViewEntry != NULL)\n\t\t\t\t\t\tTreeView_DeleteItem(hTreeModifications, file.subFiles[i].treeViewEntry);\n\t\t\t\t\tfile.subFiles.erase(file.subFiles.begin() + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t} recursiveRemoveIfUnchecked(hTreeModifications);\n\tfor (size_t _i = visibleFiles.size(); _i > 0; --_i)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tif (recursiveRemoveIfUnchecked(visibleFiles[i]))\n\t\t{\n\t\t\tif (visibleFiles[i].treeViewEntry != NULL)\n\t\t\t\tTreeView_DeleteItem(hTreeModifications, visibleFiles[i].treeViewEntry);\n\t\t\tvisibleFiles.erase(visibleFiles.begin() + i);\n\t\t}\n\t}\n}\nvoid Win32ModPackageLoader::OnClose()\n{\n\tif (this->hTreeModifications == NULL)\n\t\treturn;\n\tthis->RemoveUnchecked();\n\t\n\tHWND hEditBaseFolder = GetDlgItem(hDlg, IDC_EBASEFOLDER);\n\tsize_t baseDirLen = (size_t)Edit_GetTextLength(hEditBaseFolder);\n\tstd::vector<TCHAR> tBaseDir(baseDirLen + 1);\n\tEdit_GetText(hEditBaseFolder, tBaseDir.data(), (int)(baseDirLen + 1));\n\ttBaseDir[baseDirLen] = 0;\n\n\tstd::vector<TCHAR> pathBuffer;\n\tfor (size_t i = 0; i < this->visibleFiles.size(); i++)\n\t{\n\t\tTVITEM item;\n\t\titem.mask = TVIF_HANDLE | TVIF_STATE;\n\t\titem.hItem = (HTREEITEM)this->visibleFiles[i].treeViewEntry;\n\t\titem.state = 0;\n\n\t\tsize_t newPathLen = baseDirLen + this->visibleFiles[i].pathOrName.size() + 1;\n\t\tif (newPathLen <= MAX_PATH) newPathLen = MAX_PATH + 1;\n\t\t\t\n\t\t//Retrieve the absolute paths from the TreeView.\n\t\tTVITEMEX itemex;\n\t\tdo {\n\t\t\tif (newPathLen >= INT_MAX-1) newPathLen = INT_MAX-2;\n\t\t\tif (pathBuffer.size() < newPathLen) pathBuffer.resize(newPathLen);\n\t\t\titemex.hItem = (HTREEITEM)this->visibleFiles[i].treeViewEntry;\n\t\t\titemex.mask = TVIF_HANDLE | TVIF_TEXT;\n\t\t\titemex.pszText = pathBuffer.data();\n\t\t\titemex.cchTextMax = (int)pathBuffer.size();\n\t\t\tTreeView_GetItem(hTreeModifications, &itemex);\n\t\t\tpathBuffer[pathBuffer.size() - 1] = 0;\n\t\t\tnewPathLen += MAX_PATH;\n\t\t} while (newPathLen < INT_MAX-2 && _tcslen(itemex.pszText) >= pathBuffer.size() - 1);\n\t\t\n\t\tif (pathBuffer[0] != 0)\n\t\t{\n\t\t\t//Put the absolute path in the file entries.\n\t\t\tauto newPath8 = unique_TCHARToMultiByte(pathBuffer.data());\n\t\t\tthis->visibleFiles[i].pathOrName = newPath8.get();\n\t\t}\n\t}\n\n\tTreeView_DeleteAllItems(hTreeModifications);\n\tHIMAGELIST hCBImageList = TreeView_GetImageList(hTreeModifications, TVSIL_STATE);\n\tif (hCBImageList)\n\t\tImageList_Destroy(hCBImageList);\n}\n\nINT_PTR CALLBACK Win32ModPackageLoader::DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tWin32ModPackageLoader *pThis = reinterpret_cast<Win32ModPackageLoader*>(GetWindowLongPtr(hDlg, GWLP_USERDATA));\n\tint wmId, wmEvent;\n\tUNREFERENCED_PARAMETER(lParam);\n\tswitch (message)\n\t{\n\t\tcase WM_INITDIALOG:\n\t\t{\n\t\t\tSetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);\n\t\t\tpThis = reinterpret_cast<Win32ModPackageLoader*>(lParam);\n\t\t\tpThis->hDlg = hDlg;\n\t\t\tpThis->hTreeModifications = GetDlgItem(hDlg, IDC_TREECHANGES);\n\n\t\t\tDWORD dwStyle = GetWindowLong(pThis->hTreeModifications, GWL_STYLE);\n\t\t\tdwStyle |= TVS_CHECKBOXES;\n\t\t\tSetWindowLong(pThis->hTreeModifications, GWL_STYLE, dwStyle);\n\n\t\t\tShowWindow(pThis->hTreeModifications, SW_HIDE);\n\t\t\tpThis->FillModifiedFilesTree();\n\t\t\tShowWindow(pThis->hTreeModifications, SW_SHOW);\n\t\t\tSetWindowPos(hDlg, NULL, 0, 0, 255, 360, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\t\t//Also see http://stackoverflow.com/questions/22441747/creating-treeview-with-nodes-and-checkboxes\n\t\tcase WM_NOTIFY:\n\t\tif (pThis != nullptr)\n\t\t{\n\t\t\tNMHDR *pNotifHdr = (NMHDR*)lParam;\n\n\t\t\tif (pNotifHdr->idFrom != IDC_TREECHANGES)\n\t\t\t\tbreak;\n\t\t\tswitch (pNotifHdr->code)\n\t\t\t{\n\t\t\t\tcase TVN_KEYDOWN:\n\t\t\t\t\tif (((NMTVKEYDOWN*)lParam)->wVKey == VK_SPACE)\n\t\t\t\t\t{\n\t\t\t\t\t\tHTREEITEM checkedItem = TreeView_GetSelection(pNotifHdr->hwndFrom);\n\t\t\t\t\t\tbool isChecked = TreeView_GetCheckState(pNotifHdr->hwndFrom, checkedItem) == 0; //will be checked, isn\'t at the moment\n\t\t\t\t\t\tpThis->OnCheck(checkedItem, isChecked);\n\t\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase NM_CLICK:\n\t\t\t\t{\n\t\t\t\t\tTVHITTESTINFO hitTest = {};\n\t\t\t\t\tDWORD posval = GetMessagePos();\n\t\t\t\t\thitTest.pt.x = GET_X_LPARAM(posval);\n\t\t\t\t\thitTest.pt.y = GET_Y_LPARAM(posval);\n\t\t\t\t\tMapWindowPoints(NULL, pNotifHdr->hwndFrom, &hitTest.pt, 1);\n\t\t\t\t\tTreeView_HitTest(pNotifHdr->hwndFrom, &hitTest);\n\t\t\t\t\tif (hitTest.flags & TVHT_ONITEMSTATEICON)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool isChecked = TreeView_GetCheckState(pNotifHdr->hwndFrom, hitTest.hItem) == 0; //will be checked, isn\'t at the moment\n\t\t\t\t\t\tpThis->OnCheck(hitTest.hItem, isChecked);\n\t\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn (INT_PTR)FALSE;\n\t\tcase WM_SIZE:\n\t\t\t{\n\t\t\t\tint width = LOWORD(lParam); int height = HIWORD(lParam);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_SDESCRIPTION), NULL, 9, 11, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_TREECHANGES), NULL, 9, 26, width - 18, height - 108, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_SBASEFOLDER), NULL, 9, height - 80, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_EBASEFOLDER), NULL, 9, height - 63, (int)((float)(width - 23) * 0.69F), 23, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDC_BTNBASEFOLDER), NULL, (int)((float)width * 0.69F - 1.87F), height - 62, (int)((float)(width - 23) * 0.31F), 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDOK), NULL, 9, height - 33, width / 3, 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t\tSetWindowPos(GetDlgItem(hDlg, IDCANCEL), NULL, width - 9 - width / 3, height - 33, width / 3, 21, SWP_NOZORDER | SWP_NOACTIVATE);\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase WM_CLOSE:\n\t\tcase WM_DESTROY:\n\t\t\tif (pThis) pThis->OnClose();\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase WM_COMMAND:\n\t\t\twmId    = LOWORD(wParam);\n\t\t\twmEvent = HIWORD(wParam);\n\t\t\tswitch (wmId)\n\t\t\t{\n\t\t\t\tcase IDC_EBASEFOLDER:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpThis->OnChangeBaseFolderEdit();\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\tcase IDC_BTNBASEFOLDER:\n\t\t\t\t\tif (!pThis)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t{\n\t\t\t\t\t\tHWND hEditBaseFolder = GetDlgItem(hDlg, IDC_EBASEFOLDER);\n\t\t\t\t\t\tWCHAR *folderPath = NULL;\n\t\t\t\t\t\tif (hEditBaseFolder && ShowFolderSelectDialog(hDlg, &folderPath, L"Select a base directory", UABE_FILEDIALOG_FILE_GUID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEdit_SetText(hEditBaseFolder, folderPath);\n\t\t\t\t\t\t\tFreeCOMFilePathBuf(&folderPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t\t}\n\t\t\t\tcase IDOK:\n\t\t\t\t\tif (pThis) pThis->OnClose();\n\t\t\t\t\tEndDialog(hDlg, (INT_PTR)0);\n\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\tcase IDCANCEL:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pThis)\n\t\t\t\t\t\t\tpThis->OnCheck(NULL, false);\n\t\t\t\t\t\tif (pThis) pThis->OnClose();\n\t\t\t\t\t\tEndDialog(hDlg, (INT_PTR)0);\n\t\t\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\treturn (INT_PTR)FALSE;\n}\n'