b'{-# OPTIONS_GHC -fno-warn-name-shadowing #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Provides a syntax \'SqlSyntaxBuilder\' that uses a\n--   \'Data.ByteString.Builder.Builder\' to construct SQL expressions as strings.\n--   Mainly serves as documentation for how to write a syntax for backends. Note\n--   that, although you can use this to turn most \'Q\' and \'QGenExpr\'s into\n--   \'ByteString\' queries, it is /very unwise/ to ship these to the database.\n--   This module does not take into account server-specific quoting. Some\n--   backends are very particular to quoting, and shipping arbitrary\n--   \'ByteString\'s as queries can expose you to SQL injection vulnerabilities.\n--   Always use the provided backends to submit queries and data manipulation\n--   commands to the database.\nmodule Database.Beam.Backend.SQL.Builder\n  ( SqlSyntaxBuilder(..) --, SqlSyntaxBackend\n  , buildSepBy\n  , quoteSql\n  , renderSql ) where\n\nimport           Database.Beam.Backend.Internal.Compat\nimport           Database.Beam.Backend.SQL\n\nimport           Control.Monad.IO.Class\n\nimport           Data.ByteString (ByteString)\nimport           Data.ByteString.Builder\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.Text as T\nimport           Data.Text (Text)\n\nimport           Data.Coerce\nimport           Data.Hashable\nimport           Data.Int\nimport           Data.String\nimport qualified Control.Monad.Fail as Fail\nimport           GHC.TypeLits\n\n-- | The main syntax. A wrapper over \'Builder\'\nnewtype SqlSyntaxBuilder\n  = SqlSyntaxBuilder { buildSql :: Builder }\n\ninstance Hashable SqlSyntaxBuilder where\n  hashWithSalt salt (SqlSyntaxBuilder b) = hashWithSalt salt (toLazyByteString b)\n\ninstance Show SqlSyntaxBuilder where\n  showsPrec prec (SqlSyntaxBuilder s) =\n    showParen (prec > 10) $\n    showString "SqlSyntaxBuilder (" .\n    shows (toLazyByteString s) .\n    showString ")"\n\ninstance Eq SqlSyntaxBuilder where\n  a == b = toLazyByteString (buildSql a) == toLazyByteString (buildSql b)\n\ninstance Semigroup SqlSyntaxBuilder where\n  SqlSyntaxBuilder a <> SqlSyntaxBuilder b =  SqlSyntaxBuilder (a <> b)\n\ninstance Monoid SqlSyntaxBuilder where\n  mempty = SqlSyntaxBuilder mempty\n  mappend = (<>)\n\ninstance IsSql92Syntax SqlSyntaxBuilder where\n  type Sql92SelectSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92InsertSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92DeleteSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92UpdateSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  selectCmd = id\n  insertCmd = id\n  updateCmd = id\n  deleteCmd = id\n\ninstance IsSql92SelectSyntax SqlSyntaxBuilder where\n  type Sql92SelectSelectTableSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92SelectOrderingSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  selectStmt tableSrc ordering limit offset =\n      SqlSyntaxBuilder $\n      buildSql tableSrc <>\n      ( case ordering of\n          [] -> mempty\n          _ -> byteString " ORDER BY " <>\n               buildSepBy (byteString ", ") (map buildSql ordering) ) <>\n      maybe mempty (\\l -> byteString " LIMIT " <> byteString (fromString (show l))) limit <>\n      maybe mempty (\\o -> byteString " OFFSET " <> byteString (fromString (show o))) offset\n\ninstance IsSql92GroupingSyntax SqlSyntaxBuilder where\n  type Sql92GroupingExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  groupByExpressions es =\n    SqlSyntaxBuilder $\n    buildSepBy (byteString ", ") (map buildSql es)\n\ninstance IsSql92SelectTableSyntax SqlSyntaxBuilder where\n  type Sql92SelectTableSelectSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92SelectTableExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92SelectTableProjectionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92SelectTableFromSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92SelectTableGroupingSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92SelectTableSetQuantifierSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  selectTableStmt setQuantifier proj from where_ grouping having =\n    SqlSyntaxBuilder $\n    byteString "SELECT " <>\n    maybe mempty (\\setQuantifier\' -> buildSql setQuantifier\' <> byteString " ") setQuantifier <>\n    buildSql proj <>\n    maybe mempty ((byteString " FROM " <>) . buildSql) from <>\n    maybe mempty (\\w -> byteString " WHERE " <> buildSql w) where_ <>\n    maybe mempty (\\g -> byteString " GROUP BY " <> buildSql g) grouping <>\n    maybe mempty (\\e -> byteString " HAVING " <> buildSql e) having\n\n  unionTables = tableOp "UNION"\n  intersectTables  = tableOp "INTERSECT"\n  exceptTable = tableOp "EXCEPT"\n\ntableOp :: ByteString -> Bool -> SqlSyntaxBuilder -> SqlSyntaxBuilder -> SqlSyntaxBuilder\ntableOp op all a b =\n  SqlSyntaxBuilder $\n  byteString "(" <> buildSql a <> byteString ") " <>\n  byteString op <> if all then byteString " ALL " else mempty <>\n  byteString " (" <> buildSql b <> byteString ")"\n\ninstance IsSql92InsertSyntax SqlSyntaxBuilder where\n  type Sql92InsertValuesSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92InsertTableNameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  insertStmt tblNm fields values =\n    SqlSyntaxBuilder $\n    byteString "INSERT INTO " <> buildSql tblNm <>\n    byteString "(" <> buildSepBy (byteString ", ") (map quoteSql fields) <> byteString ") " <>\n    buildSql values\n\ninstance IsSql92InsertValuesSyntax SqlSyntaxBuilder where\n  type Sql92InsertValuesExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92InsertValuesSelectSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  insertSqlExpressions values =\n    SqlSyntaxBuilder $\n    byteString "VALUES " <>\n    buildSepBy (byteString ", ") (map mkValues values)\n    where mkValues values\' =\n            byteString "(" <>\n            buildSepBy (byteString ", ") (map buildSql values\') <>\n            byteString ")"\n\n  insertFromSql select = select\n\ninstance IsSql92UpdateSyntax SqlSyntaxBuilder where\n  type Sql92UpdateFieldNameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92UpdateExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92UpdateTableNameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  updateStmt tblNm set where_ =\n    SqlSyntaxBuilder $\n    byteString "UPDATE " <> buildSql tblNm <>\n    (case set of\n       [] -> mempty\n       es -> byteString " SET " <> buildSepBy (byteString ", ") (map (\\(field, expr) -> buildSql field <> byteString "=" <> buildSql expr) es)) <>\n    maybe mempty (\\where_ -> byteString " WHERE " <> buildSql where_) where_\n\ninstance IsSql92DeleteSyntax SqlSyntaxBuilder where\n  type Sql92DeleteExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92DeleteTableNameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  deleteStmt tblNm alias where_ =\n    SqlSyntaxBuilder $\n    byteString "DELETE FROM " <> buildSql tblNm <>\n    maybe mempty (\\alias_ -> byteString " AS " <> quoteSql alias_) alias <>\n    maybe mempty (\\where_ -> byteString " WHERE " <> buildSql where_) where_\n\n  deleteSupportsAlias _ = True\n\ninstance IsSql92FieldNameSyntax SqlSyntaxBuilder where\n  qualifiedField a b =\n    SqlSyntaxBuilder $\n    byteString "`" <> stringUtf8 (T.unpack a) <> byteString "`.`" <>\n    stringUtf8 (T.unpack b) <> byteString "`"\n  unqualifiedField a =\n    SqlSyntaxBuilder $\n    byteString "`" <> stringUtf8 (T.unpack a) <> byteString "`"\n\ninstance IsSql92QuantifierSyntax SqlSyntaxBuilder where\n  quantifyOverAll = SqlSyntaxBuilder "ALL"\n  quantifyOverAny = SqlSyntaxBuilder "ANY"\n\ninstance IsSql92ExtractFieldSyntax SqlSyntaxBuilder where\n  secondsField = SqlSyntaxBuilder (byteString "SECOND")\n  minutesField = SqlSyntaxBuilder (byteString "MINUTE")\n  hourField    = SqlSyntaxBuilder (byteString "HOUR")\n  dayField     = SqlSyntaxBuilder (byteString "DAY")\n  monthField   = SqlSyntaxBuilder (byteString "MONTH")\n  yearField    = SqlSyntaxBuilder (byteString "YEAR")\n\ninstance IsSql92ExpressionSyntax SqlSyntaxBuilder where\n  type Sql92ExpressionValueSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92ExpressionSelectSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92ExpressionFieldNameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92ExpressionQuantifierSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92ExpressionCastTargetSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92ExpressionExtractFieldSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  rowE vs = SqlSyntaxBuilder $\n            byteString "(" <>\n            buildSepBy (byteString ", ") (map buildSql (coerce vs)) <>\n            byteString ")"\n  isNotNullE = sqlPostFixOp "IS NOT NULL"\n  isNullE = sqlPostFixOp "IS NULL"\n  isTrueE = sqlPostFixOp "IS TRUE"\n  isFalseE = sqlPostFixOp "IS FALSE"\n  isUnknownE = sqlPostFixOp "IS UNKNOWN"\n  isNotTrueE = sqlPostFixOp "IS NOT TRUE"\n  isNotFalseE = sqlPostFixOp "IS NOT FALSE"\n  isNotUnknownE = sqlPostFixOp "IS NOT UNKNOWN"\n  caseE cases else_ =\n    SqlSyntaxBuilder $\n    byteString "CASE " <>\n    foldMap (\\(cond, res) -> byteString "WHEN " <> buildSql cond <>\n                             byteString " THEN " <> buildSql res <> byteString " ") cases <>\n    byteString "ELSE " <> buildSql else_ <> byteString " END"\n  fieldE = id\n\n  nullIfE a b = sqlFuncOp "NULLIF" $\n                SqlSyntaxBuilder $\n                byteString "(" <> buildSql a <> byteString "), (" <>\n                buildSql b <> byteString ")"\n  positionE needle haystack =\n    SqlSyntaxBuilder $ byteString "POSITION(" <> buildSql needle <> byteString ") IN (" <> buildSql haystack <> byteString ")"\n  extractE what from =\n    SqlSyntaxBuilder $ byteString "EXTRACT(" <> buildSql what <> byteString " FROM (" <> buildSql from <> byteString "))"\n  absE = sqlFuncOp "ABS"\n  charLengthE = sqlFuncOp "CHAR_LENGTH"\n  bitLengthE = sqlFuncOp "BIT_LENGTH"\n  octetLengthE = sqlFuncOp "OCTET_LENGTH"\n  lowerE = sqlFuncOp "LOWER"\n  upperE = sqlFuncOp "UPPER"\n  trimE = sqlFuncOp "TRIM"\n\n  addE = sqlBinOp "+"\n  likeE = sqlBinOp "LIKE"\n  subE = sqlBinOp "-"\n  mulE = sqlBinOp "*"\n  divE = sqlBinOp "/"\n  modE = sqlBinOp "%"\n  overlapsE = sqlBinOp "OVERLAPS"\n  andE = sqlBinOp "AND"\n  orE  = sqlBinOp "OR"\n  castE a ty = SqlSyntaxBuilder $\n    byteString "CAST((" <> buildSql a <> byteString ") AS " <> buildSql ty <> byteString ")"\n  coalesceE es = SqlSyntaxBuilder $\n    byteString "COALESCE(" <>\n    buildSepBy (byteString ", ") (map (\\e -> byteString"(" <> buildSql e <> byteString ")") es) <>\n    byteString ")"\n  betweenE a b c = SqlSyntaxBuilder $\n    byteString "(" <> buildSql a <> byteString ") BETWEEN (" <> buildSql b <> byteString ") AND (" <> buildSql c <> byteString ")"\n  eqE  = sqlCompOp "="\n  neqE = sqlCompOp "<>"\n  ltE  = sqlCompOp "<"\n  gtE  = sqlCompOp ">"\n  leE  = sqlCompOp "<="\n  geE  = sqlCompOp ">="\n  negateE = sqlUnOp "-"\n  notE = sqlUnOp "NOT"\n  existsE = sqlUnOp "EXISTS"\n  uniqueE = sqlUnOp "UNIQUE"\n  subqueryE a = SqlSyntaxBuilder $ byteString "(" <> buildSql a <> byteString ")"\n  valueE = id\n\n  currentTimestampE = SqlSyntaxBuilder (byteString "CURRENT_TIMESTAMP")\n\n  defaultE = SqlSyntaxBuilder (byteString "DEFAULT")\n  inE a es = SqlSyntaxBuilder (byteString "(" <> buildSql a <> byteString ") IN (" <>\n                               buildSepBy (byteString ", ") (map buildSql es) <> byteString ")")\n  inSelectE a sel = SqlSyntaxBuilder (byteString "(" <> buildSql a <> byteString ") IN (" <>\n                                      buildSql sel <> byteString ")")\n\ninstance IsSql99FunctionExpressionSyntax SqlSyntaxBuilder where\n  functionNameE fn = SqlSyntaxBuilder (byteString (TE.encodeUtf8 fn))\n  functionCallE function args =\n    SqlSyntaxBuilder $\n    buildSql function <>\n    byteString "(" <>\n    buildSepBy (byteString ", ") (map buildSql args) <>\n    byteString ")"\n\ninstance IsSql99ExpressionSyntax SqlSyntaxBuilder where\n  distinctE = sqlUnOp "DISTINCT"\n  similarToE = sqlBinOp "SIMILAR TO"\n\n  instanceFieldE e fieldNm =\n    SqlSyntaxBuilder $\n    byteString "(" <> buildSql e <> byteString ")." <> byteString (TE.encodeUtf8 fieldNm)\n  refFieldE e fieldNm =\n    SqlSyntaxBuilder $\n    byteString "(" <> buildSql e <> byteString ")->" <> byteString (TE.encodeUtf8 fieldNm)\n\ninstance IsSql2003ExpressionSyntax SqlSyntaxBuilder where\n  type Sql2003ExpressionWindowFrameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  overE expr frame =\n      SqlSyntaxBuilder $\n      buildSql expr <> buildSql frame\n  rowNumberE = SqlSyntaxBuilder (byteString "ROW_NUMBER()")\n\ninstance IsSql2003WindowFrameSyntax SqlSyntaxBuilder where\n  type Sql2003WindowFrameExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql2003WindowFrameOrderingSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql2003WindowFrameBoundsSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  frameSyntax partition_ ordering_ bounds_ =\n      SqlSyntaxBuilder $\n      byteString " OVER (" <>\n      maybe mempty (\\p -> byteString "PARTITION BY " <> buildSepBy (byteString ", ") (map buildSql p)) partition_ <>\n      maybe mempty (\\o -> byteString " ORDER BY " <> buildSepBy (byteString ", ") (map buildSql o)) ordering_ <>\n      maybe mempty (\\b -> byteString " ROWS " <> buildSql b) bounds_ <>\n      byteString ")"\n\ninstance IsSql2003ExpressionElementaryOLAPOperationsSyntax SqlSyntaxBuilder where\n  filterAggE agg_ filter_ =\n    SqlSyntaxBuilder $\n    buildSql agg_ <> byteString " FILTER (WHERE " <> buildSql filter_ <> byteString ")"\n  rankAggE = SqlSyntaxBuilder "RANK()"\n\ninstance IsSql2003ExpressionAdvancedOLAPOperationsSyntax SqlSyntaxBuilder where\n  denseRankAggE = SqlSyntaxBuilder "DENSE_RANK()"\n  percentRankAggE = SqlSyntaxBuilder "PERCENT_RANK()"\n  cumeDistAggE = SqlSyntaxBuilder "CUME_DIST()"\n\ndata SqlWindowFrameBound = SqlWindowFrameUnbounded\n                         | SqlWindowFrameBounded Int\n                           deriving Show\n\ninstance IsSql2003WindowFrameBoundsSyntax SqlSyntaxBuilder where\n  type Sql2003WindowFrameBoundsBoundSyntax SqlSyntaxBuilder = SqlWindowFrameBound\n\n  fromToBoundSyntax SqlWindowFrameUnbounded Nothing = SqlSyntaxBuilder "UNBOUNDED PRECEDING"\n  fromToBoundSyntax (SqlWindowFrameBounded 0) Nothing = SqlSyntaxBuilder "CURRENT ROW"\n  fromToBoundSyntax (SqlWindowFrameBounded n) Nothing = SqlSyntaxBuilder (fromString (show n) <> " PRECEDING")\n  fromToBoundSyntax SqlWindowFrameUnbounded (Just SqlWindowFrameUnbounded) =\n      SqlSyntaxBuilder "BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING"\n  fromToBoundSyntax SqlWindowFrameUnbounded (Just (SqlWindowFrameBounded 0)) =\n      SqlSyntaxBuilder "BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"\n  fromToBoundSyntax SqlWindowFrameUnbounded (Just (SqlWindowFrameBounded n)) =\n      SqlSyntaxBuilder ("BETWEEN UNBOUNDED PRECEDING AND " <> fromString (show n) <> " FOLLOWING")\n  fromToBoundSyntax (SqlWindowFrameBounded 0) (Just SqlWindowFrameUnbounded) =\n      SqlSyntaxBuilder "BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING"\n  fromToBoundSyntax (SqlWindowFrameBounded 0) (Just (SqlWindowFrameBounded 0)) =\n      SqlSyntaxBuilder "BETWEEN CURRENT ROW AND CURRENT ROW"\n  fromToBoundSyntax (SqlWindowFrameBounded 0) (Just (SqlWindowFrameBounded n)) =\n      SqlSyntaxBuilder ("BETWEEN CURRENT ROW AND " <> fromString (show n) <> " FOLLOWING")\n  fromToBoundSyntax (SqlWindowFrameBounded n) (Just SqlWindowFrameUnbounded) =\n      SqlSyntaxBuilder ("BETWEEN " <> fromString (show n) <> " PRECEDING AND UNBOUNDED FOLLOWING")\n  fromToBoundSyntax (SqlWindowFrameBounded n) (Just (SqlWindowFrameBounded 0)) =\n      SqlSyntaxBuilder ("BETWEEN " <> fromString (show n) <> " PRECEDING AND CURRENT ROW")\n  fromToBoundSyntax (SqlWindowFrameBounded n1) (Just (SqlWindowFrameBounded n2)) =\n      SqlSyntaxBuilder ("BETWEEN " <> fromString (show n1) <> " PRECEDING AND " <> fromString (show n2) <> " FOLLOWING")\n\ninstance IsSql2003WindowFrameBoundSyntax SqlWindowFrameBound where\n  unboundedSyntax = SqlWindowFrameUnbounded\n  nrowsBoundSyntax = SqlWindowFrameBounded\n\ninstance IsSql92AggregationExpressionSyntax SqlSyntaxBuilder where\n  type Sql92AggregationSetQuantifierSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  countAllE = SqlSyntaxBuilder (byteString "COUNT(*)")\n  countE q x = SqlSyntaxBuilder (byteString "COUNT(" <> maybe mempty (\\q\' -> buildSql q\' <> byteString " ") q <> buildSql x <> byteString ")")\n  avgE q x = SqlSyntaxBuilder (byteString "AVG(" <>  maybe mempty (\\q\' -> buildSql q\' <> byteString " ") q <> buildSql x <> byteString ")")\n  minE q x = SqlSyntaxBuilder (byteString "MIN(" <> maybe mempty (\\q\' -> buildSql q\' <> byteString " ") q <> buildSql x <> byteString ")")\n  maxE q x = SqlSyntaxBuilder (byteString "MAX(" <> maybe mempty (\\q\' -> buildSql q\' <> byteString " ") q <> buildSql x <> byteString ")")\n  sumE q x = SqlSyntaxBuilder (byteString "SUM(" <> maybe mempty (\\q\' -> buildSql q\' <> byteString " ") q <> buildSql x <> byteString ")")\n\ninstance IsSql92AggregationSetQuantifierSyntax SqlSyntaxBuilder where\n  setQuantifierAll = SqlSyntaxBuilder (byteString "ALL")\n  setQuantifierDistinct = SqlSyntaxBuilder (byteString "DISTINCT")\n\ninstance IsSql92ProjectionSyntax SqlSyntaxBuilder where\n  type Sql92ProjectionExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  projExprs exprs =\n      SqlSyntaxBuilder $\n      buildSepBy (byteString ", ")\n                 (map (\\(expr, nm) -> buildSql expr <>\n                                      maybe mempty (\\nm -> byteString " AS " <> quoteSql nm) nm) exprs)\n\ninstance IsSql92OrderingSyntax SqlSyntaxBuilder where\n  type Sql92OrderingExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  ascOrdering expr = SqlSyntaxBuilder (buildSql expr <> byteString " ASC")\n  descOrdering expr = SqlSyntaxBuilder (buildSql expr <> byteString " DESC")\n\ninstance IsSql92TableSourceSyntax SqlSyntaxBuilder where\n  type Sql92TableSourceTableNameSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92TableSourceSelectSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n  type Sql92TableSourceExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n  tableNamed = id\n  tableFromSubSelect query = SqlSyntaxBuilder (byteString "(" <> buildSql query <> byteString ")")\n  tableFromValues vss =\n      SqlSyntaxBuilder $\n      byteString "VALUES " <>\n      buildSepBy (byteString ", ")\n       (map (\\vs -> byteString "(" <>\n                    buildSepBy (byteString ", ") (map buildSql vs) <>\n                    byteString ")") vss)\n\ninstance IsSql92TableNameSyntax SqlSyntaxBuilder where\n  tableName Nothing t  = SqlSyntaxBuilder $ quoteSql t\n  tableName (Just s) t = SqlSyntaxBuilder $ quoteSql s <> byteString "." <> quoteSql t\n\ninstance IsSql92FromSyntax SqlSyntaxBuilder where\n    type Sql92FromTableSourceSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n    type Sql92FromExpressionSyntax SqlSyntaxBuilder = SqlSyntaxBuilder\n\n    fromTable t Nothing = t\n    fromTable t (Just (nm, colNms)) =\n        SqlSyntaxBuilder (buildSql t <> byteString " AS " <> quoteSql nm <>\n                          maybe mempty (\\colNms\' -> byteString "(" <> buildSepBy (byteString ", ") (map quoteSql colNms\') <> byteString ")") colNms)\n\n    innerJoin = join "INNER JOIN"\n    leftJoin = join "LEFT JOIN"\n    rightJoin = join "RIGHT JOIN"\n\ninstance IsSql92DataTypeSyntax SqlSyntaxBuilder where\n    domainType nm = SqlSyntaxBuilder (quoteSql nm)\n    charType prec charSet = SqlSyntaxBuilder ("CHAR" <> sqlOptPrec prec <> sqlOptCharSet charSet)\n    varCharType prec charSet = SqlSyntaxBuilder ("VARCHAR" <> sqlOptPrec prec <> sqlOptCharSet charSet)\n    nationalCharType prec = SqlSyntaxBuilder ("NATIONAL CHAR" <> sqlOptPrec prec)\n    nationalVarCharType prec = SqlSyntaxBuilder ("NATIONAL CHARACTER VARYING" <> sqlOptPrec prec)\n\n    bitType prec = SqlSyntaxBuilder ("BIT" <> sqlOptPrec prec)\n    varBitType prec = SqlSyntaxBuilder ("BIT VARYING" <> sqlOptPrec prec)\n\n    numericType prec = SqlSyntaxBuilder ("NUMERIC" <> sqlOptNumericPrec prec)\n    decimalType prec = SqlSyntaxBuilder ("DECIMAL" <> sqlOptNumericPrec prec)\n\n    intType = SqlSyntaxBuilder "INT"\n    smallIntType = SqlSyntaxBuilder "SMALLINT"\n\n    floatType prec = SqlSyntaxBuilder ("FLOAT" <> sqlOptPrec prec)\n    doubleType = SqlSyntaxBuilder "DOUBLE PRECISION"\n    realType = SqlSyntaxBuilder "REAL"\n    dateType = SqlSyntaxBuilder "DATE"\n    timeType prec withTz =\n        SqlSyntaxBuilder ("TIME" <> sqlOptPrec prec <> if withTz then " WITH TIME ZONE" else mempty)\n    timestampType prec withTz =\n        SqlSyntaxBuilder ("TIMESTAMP" <> sqlOptPrec prec <> if withTz then " WITH TIME ZONE" else mempty)\n\nsqlOptPrec :: Maybe Word -> Builder\nsqlOptPrec Nothing = mempty\nsqlOptPrec (Just x) = "(" <> byteString (fromString (show x)) <> ")"\n\nsqlOptCharSet :: Maybe T.Text -> Builder\nsqlOptCharSet Nothing = mempty\nsqlOptCharSet (Just cs) = " CHARACTER SET " <> byteString (TE.encodeUtf8 cs)\n\nsqlOptNumericPrec :: Maybe (Word, Maybe Word) -> Builder\nsqlOptNumericPrec Nothing = mempty\nsqlOptNumericPrec (Just (prec, Nothing)) = sqlOptPrec (Just prec)\nsqlOptNumericPrec (Just (prec, Just dec)) = "(" <> fromString (show prec) <> ", " <> fromString (show dec) <> ")"\n\n-- TODO These instances are wrong (Text doesn\'t handle quoting for example)\ninstance HasSqlValueSyntax SqlSyntaxBuilder Int32 where\n  sqlValueSyntax x = SqlSyntaxBuilder $\n    byteString (fromString (show x))\ninstance HasSqlValueSyntax SqlSyntaxBuilder Bool where\n  sqlValueSyntax True = SqlSyntaxBuilder (byteString "TRUE")\n  sqlValueSyntax False = SqlSyntaxBuilder (byteString "FALSE")\ninstance HasSqlValueSyntax SqlSyntaxBuilder Text where\n  sqlValueSyntax x = SqlSyntaxBuilder $\n    byteString (fromString (show x))\ninstance HasSqlValueSyntax SqlSyntaxBuilder SqlNull where\n  sqlValueSyntax _ = SqlSyntaxBuilder (byteString "NULL")\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlValueSyntax SqlSyntaxBuilder Int where\n  sqlValueSyntax x = SqlSyntaxBuilder $\n    byteString (fromString (show x))\n\nrenderSql :: SqlSyntaxBuilder -> String\nrenderSql (SqlSyntaxBuilder b) = BL.unpack (toLazyByteString b)\n\nbuildSepBy :: Builder -> [Builder] -> Builder\nbuildSepBy _   [] = mempty\nbuildSepBy _   [x] = x\nbuildSepBy sep (x:xs) = x <> sep <> buildSepBy sep xs\n\n-- TODO actual quoting\nquoteSql :: Text -> Builder\nquoteSql table =\n    byteString "\\"" <> byteString (TE.encodeUtf8 table) <> byteString "\\""\n\njoin :: ByteString\n     -> SqlSyntaxBuilder -> SqlSyntaxBuilder\n     -> Maybe SqlSyntaxBuilder -> SqlSyntaxBuilder\njoin type_ a b on =\n    SqlSyntaxBuilder $\n    buildSql a <> byteString " " <>  byteString type_ <> byteString " " <> buildSql b <>\n    case on of\n      Nothing -> mempty\n      Just on -> byteString " ON (" <> buildSql on <> byteString ")"\nsqlPostFixOp, sqlUnOp :: ByteString -> SqlSyntaxBuilder -> SqlSyntaxBuilder\nsqlUnOp op a =\n  SqlSyntaxBuilder $\n  byteString op <> byteString " (" <> buildSql a <> byteString ")"\nsqlPostFixOp op a =\n  SqlSyntaxBuilder $\n  byteString "(" <> buildSql a <> byteString ") " <> byteString op\nsqlCompOp :: ByteString -> Maybe SqlSyntaxBuilder\n          -> SqlSyntaxBuilder -> SqlSyntaxBuilder\n          -> SqlSyntaxBuilder\nsqlCompOp op quant a b =\n    SqlSyntaxBuilder $\n    byteString "(" <> buildSql a <> byteString ") " <>\n    byteString op <>\n    maybe mempty (\\quant -> byteString " " <> buildSql quant) quant <>\n    byteString " (" <> buildSql b <> byteString ")"\nsqlBinOp :: ByteString -> SqlSyntaxBuilder -> SqlSyntaxBuilder\n         -> SqlSyntaxBuilder\nsqlBinOp op a b =\n    SqlSyntaxBuilder $\n    byteString "(" <> buildSql a <> byteString ") " <>\n    byteString op <>\n    byteString " (" <> buildSql b <> byteString ")"\nsqlFuncOp :: ByteString -> SqlSyntaxBuilder -> SqlSyntaxBuilder\nsqlFuncOp fun a =\n  SqlSyntaxBuilder $\n  byteString fun <> byteString "(" <> buildSql a <> byteString")"\n\n\n-- * Fake \'MonadBeam\' instance (for using \'SqlSyntaxBuilder\' with migrations mainly)\n\n-- data SqlSyntaxBackend\n\n-- class Trivial a\n-- instance Trivial a\n\nnewtype SqlSyntaxM a = SqlSyntaxM (IO a)\n  deriving (Applicative, Functor, Monad, MonadIO, Fail.MonadFail)\n'