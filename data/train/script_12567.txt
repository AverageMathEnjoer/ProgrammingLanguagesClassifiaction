b'import System.Environment   \nimport System.Console.GetOpt\n\n-- Make a 2-D array of size z given a function f\nmkArray :: (Integral a) => (a -> a -> a) -> a -> [[a]]\nmkArray f z = [ [f x y | x <- [0..z]] | y <- [0..z]]\n\n-- Stringify a 1-D array\nformatArray :: (Show a, Integral a) => [a] -> String\nformatArray [] = ""\nformatArray (x:xs) = show x ++ "\\t" ++ formatArray xs\n\n-- Stringify a 2-D array\nformat2DArray :: (Show a, Integral a) => [[a]] -> String\nformat2DArray [] = ""\nformat2DArray (x:xs) = formatArray x ++ "\\n" ++ format2DArray xs\n\n-- Jack\'s first solution\ninvert_a :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_a f z = [(x, y) | x <- [0..z ], y <- [0..z ], f x  y == z]\n\n-- Theo\'s slight improvement\ninvert_b :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_b f z = [(x, y) | x <- [0..z], y <- [0..z - x], f x y == z]\n\n-- Anne reduces it further\nfind_c :: (Integral a) => (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_c (u, v) f z = [(x, y) | x <- [u .. z ], y <- [v, v - 1..0], f x y == z]\n\ninvert_c :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_c f z = find_c (0, z) f z\n\n-- And more efficiently\nfind_d :: (Integral a) => (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_d (u, v) f z\n    | u > z || v < 0   = []\n    | z\' < z           = find_d (u + 1, v) f z\n    | z\' == z          = (u, v) : find_d (u + 1, v - 1) f z\n    | z\' > z           = find_d (u, v - 1) f z\n    where z\' = f u v\n\ninvert_d :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_d f z = find_d (0, z) f z\n\n-- Theo\'s improvement\nbsearch :: (Integral a) => (a -> a) -> (a, a) -> a -> a\nbsearch g (a, b) z\n    | a + 1 == b    = a\n    | g m <= z      = bsearch g (m, b) z\n    | otherwise     = bsearch g (a, m) z\n    where m = (a + b) `div` 2\n\nfind_e :: (Integral a) => (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_e (u, v) f z\n    | u > n || n < 0   = []\n    | z\' < z           = find_e (u + 1, v) f z\n    | z\' == z          = (u, v) : find_e (u + 1, v - 1) f z\n    | z\' > z           = find_e (u, v - 1) f z\n    where z\' = f u v\n          n = maximum (filter (\\x -> (f x 0) <= z) [0..z])\n\ninvert_e :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_e f z = find_e (0, m) f z\n    where m = bsearch (\\y -> f 0 y) (-1, z + 1) z\n\n-- Final version\nfind_f :: (Integral a) => (a, a) -> (a, a) -> (a -> a -> a) -> a -> [(a, a)]\nfind_f (u, v) (r, s) f z\n    | u > r || v < s    = []\n    | v - s <= r - u    = rfind (bsearch (\\x -> f x q) (u - 1, r + 1) z)\n    | otherwise         = cfind (bsearch (\\y -> f p y) (s - 1, v + 1) z)\n    where p = (u + r) `div` 2\n          q = (v + s) `div` 2\n          rfind p = (if f p q == z then (p, q) : find_f (u, v) (p - 1, q + 1) f z\n                        else find_f (u, v) (p, q + 1) f z) ++\n                    find_f (p + 1, q - 1) (r , s) f z\n          cfind q = find_f (u, v) (p - 1, q + 1) f z ++\n                    (if f p q == z then(p, q) : find_f (p + 1, q - 1) (r , s) f z\n                        else find_f (p + 1, q) (r , s) f z)\n\ninvert_f :: (Integral a) => (a -> a -> a) -> a -> [(a, a)]\ninvert_f f z = find_f (0, m) (n, 0) f z\n    where m = bsearch (\\y -> f 0 y) (-1, z + 1) z\n          n = bsearch (\\x -> f x 0) (-1, z + 1) z\n\n-- Test functions\n\nf0 :: Integer -> Integer -> Integer\nf0 x y = 2^y*(2*x + 1) - 1\n\nf1 :: Integer -> Integer -> Integer\nf1 x y = x*2^x + y*2^y + 2*x + y\n\nf2 :: Integer -> Integer -> Integer\nf2 x y = 3*x + 27*y + y*y\n\nf3 :: Integer -> Integer -> Integer\nf3 x y = x*x + y*y + x + y\n\nf4 :: Integer -> Integer -> Integer\nf4 x y = x + 2^y + y - 1\n\nf5 :: Integer -> Integer -> Integer\nf5 x y = x + y\n\nmethodDispatch :: [(String,  (Integer -> Integer -> Integer) -> Integer -> [(Integer, Integer)])]\nmethodDispatch = [ ("A", invert_a),\n             ("B", invert_b),\n             ("C", invert_c),\n             ("D", invert_d),\n             ("E", invert_e),\n             ("F", invert_f)]\n\ncommandDispatch :: [(String,  Integer -> Integer -> Integer)]\ncommandDispatch = [ ("f0", f0),\n             ("f1", f1),\n             ("f2", f2),\n             ("f3", f3),\n             ("f4", f4),\n             ("f5", f5)]\n\nmain = do\n    args <- getArgs  \n    let method = args!!0\n    let command = args!!1\n    let number = read (args!!2) :: Integer\n    let (Just action) = lookup command commandDispatch  \n    let (Just invert_method) = lookup method methodDispatch  \n    putStrLn $ show $ invert_method action number\n'