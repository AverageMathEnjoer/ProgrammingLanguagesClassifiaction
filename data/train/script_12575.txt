b'{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Control.Monad.Trans.Crtn.Driver where\n\nimport Control.Monad.Reader (ReaderT (..))\nimport Control.Monad.Trans (MonadIO)\nimport Control.Monad.Trans.Crtn\n  ( request,\n    (<==|),\n  )\nimport Control.Monad.Trans.Crtn.Event\n  ( ActionOrder,\n    EvOrAct,\n  )\nimport Control.Monad.Trans.Crtn.Logger\n  ( LogServer,\n    MonadLog,\n  )\nimport Control.Monad.Trans.Crtn.Object\n  ( Arg (..),\n    CObjT,\n    EStT,\n    Res (..),\n    SObjBT,\n    SObjT,\n    query,\n  )\nimport Control.Monad.Trans.Crtn.World\n  ( World,\n    WorldOp,\n    flushLog,\n    flushQueue,\n    giveEvent,\n  )\nimport Control.Monad.Trans.Except (ExceptT (..), runExceptT)\nimport Data.Foldable (foldrM)\n\n-- | signature of IO event driver\ndata DrvOp e i o where\n  Dispatch :: DrvOp e e (Maybe (ActionOrder e))\n\n-- | driver\ntype Driver e m = SObjT (DrvOp e) m\n\n-- | driver client\ntype DrvClient e m r = CObjT (DrvOp e) m r\n\n-- |\ndispatch :: (Monad m) => e -> DrvClient e m (Maybe (ActionOrder e))\ndispatch ev = do\n  res <- request (Arg Dispatch ev)\n  case res of\n    Res Dispatch r -> return r\n    Ign -> error "dispatch: Ignore happened"\n\n-- | basic driver\ndriver ::\n  forall m e.\n  (Monad m, MonadLog m, MonadIO m) =>\n  LogServer (SObjBT (DrvOp e) m) () ->\n  SObjT (WorldOp e (SObjBT (DrvOp e) m)) (SObjBT (DrvOp e) m) () ->\n  Driver e m ()\ndriver logger world =\n  ReaderT (driverW logger world)\n  where\n    driverW ::\n      LogServer (SObjBT (DrvOp e) m) () ->\n      SObjT (WorldOp e (SObjBT (DrvOp e) m)) (SObjBT (DrvOp e) m) () ->\n      Arg (DrvOp e) ->\n      SObjBT (DrvOp e) m ()\n    driverW logobj worldobj (Arg Dispatch ev) = do\n      (logobj\', worldobj\') <- multiDispatchTillEnd (logobj, worldobj) [Right ev]\n      req <- request (Res Dispatch Nothing)\n      driverW logobj\' worldobj\' req\n\n-- | single event dispatch\nsingleDispatch ::\n  (Monad m) =>\n  Either (ActionOrder e) e ->\n  ( LogServer (SObjBT (DrvOp e) m) (),\n    World e (SObjBT (DrvOp e) m) (),\n    [EvOrAct e]\n  ) ->\n  SObjBT\n    (DrvOp e)\n    m\n    ( LogServer (SObjBT (DrvOp e) m) (),\n      World e (SObjBT (DrvOp e) m) (),\n      [EvOrAct e]\n    )\nsingleDispatch (Right ev) (logobj, worldobj, evacc) = do\n  -- Right (logobj\',worldobj\',events) <-\n  r <-\n    runExceptT $ do\n      (worldobj1, _) <- ExceptT (worldobj <==| giveEvent ev)\n      (worldobj2, logobj1) <- ExceptT (worldobj1 <==| flushLog logobj)\n      (worldobj3, events) <- ExceptT (worldobj2 <==| flushQueue)\n      return (logobj1, worldobj3, events)\n  case r of\n    Left _ ->\n      -- resuming original (this must be refined. resume point must be defined )\n      return (logobj, worldobj, evacc)\n    Right (logobj\', worldobj\', events) -> return (logobj\', worldobj\', evacc ++ events)\nsingleDispatch (Left act) (logobj, worldobj, evacc) = do\n  Arg Dispatch ev <- request (Res Dispatch (Just act))\n  return (logobj, worldobj, evacc ++ [Right ev])\n\n-- | a single feedback step of multiple event dispatch\nmultiDispatch ::\n  (Monad m) =>\n  ( LogServer (SObjBT (DrvOp e) m) (),\n    World e (SObjBT (DrvOp e) m) ()\n  ) ->\n  [EvOrAct e] ->\n  SObjBT\n    (DrvOp e)\n    m\n    ( LogServer (SObjBT (DrvOp e) m) (),\n      World e (SObjBT (DrvOp e) m) (),\n      [EvOrAct e]\n    )\nmultiDispatch (logobj, worldobj) events = do\n  foldrM singleDispatch (logobj, worldobj, []) events\n\n-- | full multiple event dispatch with feedback\nmultiDispatchTillEnd ::\n  (Monad m) =>\n  ( LogServer (SObjBT (DrvOp e) m) (),\n    World e (SObjBT (DrvOp e) m) ()\n  ) ->\n  [EvOrAct e] ->\n  SObjBT\n    (DrvOp e)\n    m\n    ( LogServer (SObjBT (DrvOp e) m) (),\n      World e (SObjBT (DrvOp e) m) ()\n    )\nmultiDispatchTillEnd (logobj, worldobj) events =\n  go (logobj, worldobj, events)\n  where\n    go (l, w, evs) = do\n      (l\', w\', evs\') <- multiDispatch (l, w) evs\n      if (not . null) evs\'\n        then go (l\', w\', evs\')\n        else return (l\', w\')\n\n-- | convenience routine for driver\nfire ::\n  (Monad m, MonadLog m) =>\n  e ->\n  EStT\n    (Driver e m ())\n    m\n    (Maybe (ActionOrder e))\nfire = query . dispatch\n'