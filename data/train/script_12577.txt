b'/*\n * Copyright (C) 2012 Andrew Neal\n * Copyright (C) 2014 The CyanogenMod Project\n * Licensed under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\npackage com.naman14.timber.dataloaders;\n\nimport android.content.Context;\nimport android.database.AbstractCursor;\nimport android.database.Cursor;\nimport android.os.RemoteException;\nimport android.provider.BaseColumns;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Audio.AudioColumns;\nimport android.util.Log;\n\nimport com.naman14.timber.MusicPlayer;\n\nimport java.util.Arrays;\n\nimport static com.naman14.timber.MusicPlayer.mService;\n\n\npublic class NowPlayingCursor extends AbstractCursor {\n\n    private static final String[] PROJECTION = new String[]{\n\n            BaseColumns._ID,\n\n            AudioColumns.TITLE,\n\n            AudioColumns.ARTIST,\n\n            AudioColumns.ALBUM_ID,\n\n            AudioColumns.ALBUM,\n\n            AudioColumns.DURATION,\n\n            AudioColumns.TRACK,\n\n            AudioColumns.ARTIST_ID,\n\n            AudioColumns.TRACK,\n    };\n\n    private final Context mContext;\n\n    private long[] mNowPlaying;\n\n    private long[] mCursorIndexes;\n\n    private int mSize;\n\n    private int mCurPos;\n\n    private Cursor mQueueCursor;\n\n\n    public NowPlayingCursor(final Context context) {\n        mContext = context;\n        makeNowPlayingCursor();\n    }\n\n\n    @Override\n    public int getCount() {\n        return mSize;\n    }\n\n\n    @Override\n    public boolean onMove(final int oldPosition, final int newPosition) {\n        if (oldPosition == newPosition) {\n            return true;\n        }\n\n        if (mNowPlaying == null || mCursorIndexes == null || newPosition >= mNowPlaying.length) {\n            return false;\n        }\n\n        final long id = mNowPlaying[newPosition];\n        final int cursorIndex = Arrays.binarySearch(mCursorIndexes, id);\n        mQueueCursor.moveToPosition(cursorIndex);\n        mCurPos = newPosition;\n        return true;\n    }\n\n    @Override\n    public String getString(final int column) {\n        try {\n            return mQueueCursor.getString(column);\n        } catch (final Exception ignored) {\n            onChange(true);\n            return "";\n        }\n    }\n\n\n    @Override\n    public short getShort(final int column) {\n        return mQueueCursor.getShort(column);\n    }\n\n\n    @Override\n    public int getInt(final int column) {\n        try {\n            return mQueueCursor.getInt(column);\n        } catch (final Exception ignored) {\n            onChange(true);\n            return 0;\n        }\n    }\n\n\n    @Override\n    public long getLong(final int column) {\n        try {\n            return mQueueCursor.getLong(column);\n        } catch (final Exception ignored) {\n            onChange(true);\n            return 0;\n        }\n    }\n\n\n    @Override\n    public float getFloat(final int column) {\n        return mQueueCursor.getFloat(column);\n    }\n\n\n    @Override\n    public double getDouble(final int column) {\n        return mQueueCursor.getDouble(column);\n    }\n\n\n    @Override\n    public int getType(final int column) {\n        return mQueueCursor.getType(column);\n    }\n\n    @Override\n    public boolean isNull(final int column) {\n        return mQueueCursor.isNull(column);\n    }\n\n\n    @Override\n    public String[] getColumnNames() {\n        return PROJECTION;\n    }\n\n\n    @SuppressWarnings("deprecation")\n    @Override\n    public void deactivate() {\n        if (mQueueCursor != null) {\n            mQueueCursor.deactivate();\n        }\n    }\n\n    @Override\n    public boolean requery() {\n        makeNowPlayingCursor();\n        return true;\n    }\n\n\n    @Override\n    public void close() {\n        try {\n            if (mQueueCursor != null) {\n                mQueueCursor.close();\n                mQueueCursor = null;\n            }\n        } catch (final Exception close) {\n        }\n        super.close();\n    }\n\n\n    private void makeNowPlayingCursor() {\n        mQueueCursor = null;\n        mNowPlaying = MusicPlayer.getQueue();\n        Log.d("lol1", mNowPlaying.toString() + "   " + mNowPlaying.length);\n        mSize = mNowPlaying.length;\n        if (mSize == 0) {\n            return;\n        }\n\n        final StringBuilder selection = new StringBuilder();\n        selection.append(MediaStore.Audio.Media._ID + " IN (");\n        for (int i = 0; i < mSize; i++) {\n            selection.append(mNowPlaying[i]);\n            if (i < mSize - 1) {\n                selection.append(",");\n            }\n        }\n        selection.append(")");\n\n        mQueueCursor = mContext.getContentResolver().query(\n                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, PROJECTION, selection.toString(),\n                null, MediaStore.Audio.Media._ID);\n\n        if (mQueueCursor == null) {\n            mSize = 0;\n            return;\n        }\n\n        final int playlistSize = mQueueCursor.getCount();\n        mCursorIndexes = new long[playlistSize];\n        mQueueCursor.moveToFirst();\n        final int columnIndex = mQueueCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);\n        for (int i = 0; i < playlistSize; i++) {\n            mCursorIndexes[i] = mQueueCursor.getLong(columnIndex);\n            mQueueCursor.moveToNext();\n        }\n        mQueueCursor.moveToFirst();\n        mCurPos = -1;\n\n        int removed = 0;\n        for (int i = mNowPlaying.length - 1; i >= 0; i--) {\n            final long trackId = mNowPlaying[i];\n            final int cursorIndex = Arrays.binarySearch(mCursorIndexes, trackId);\n            if (cursorIndex < 0) {\n                removed += MusicPlayer.removeTrack(trackId);\n            }\n        }\n        if (removed > 0) {\n            mNowPlaying = MusicPlayer.getQueue();\n            mSize = mNowPlaying.length;\n            if (mSize == 0) {\n                mCursorIndexes = null;\n                return;\n            }\n        }\n    }\n\n\n    public boolean removeItem(final int which) {\n        try {\n            if (mService.removeTracks(which, which) == 0) {\n                return false;\n            }\n            int i = which;\n            mSize--;\n            while (i < mSize) {\n                mNowPlaying[i] = mNowPlaying[i + 1];\n                i++;\n            }\n            onMove(-1, mCurPos);\n        } catch (final RemoteException ignored) {\n        }\n        return true;\n    }\n}\n'