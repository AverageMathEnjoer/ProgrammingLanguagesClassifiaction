b'package com.rd.animation.type;\n\nimport android.animation.IntEvaluator;\nimport android.animation.PropertyValuesHolder;\nimport android.animation.ValueAnimator;\nimport androidx.annotation.NonNull;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport com.rd.animation.controller.ValueController;\nimport com.rd.animation.data.type.FillAnimationValue;\n\npublic class FillAnimation extends ColorAnimation {\n\n    private static final String ANIMATION_RADIUS_REVERSE = "ANIMATION_RADIUS_REVERSE";\n    private static final String ANIMATION_RADIUS = "ANIMATION_RADIUS";\n\n    private static final String ANIMATION_STROKE_REVERSE = "ANIMATION_STROKE_REVERSE";\n    private static final String ANIMATION_STROKE = "ANIMATION_STROKE";\n\n    public static final int DEFAULT_STROKE_DP = 1;\n    private FillAnimationValue value;\n\n    private int radius;\n    private int stroke;\n\n    public FillAnimation(@NonNull ValueController.UpdateListener listener) {\n        super(listener);\n        value = new FillAnimationValue();\n    }\n\n    @NonNull\n    @Override\n    public ValueAnimator createAnimator() {\n        ValueAnimator animator = new ValueAnimator();\n        animator.setDuration(BaseAnimation.DEFAULT_ANIMATION_TIME);\n        animator.setInterpolator(new AccelerateDecelerateInterpolator());\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                onAnimateUpdated(animation);\n            }\n        });\n\n        return animator;\n    }\n\n    @NonNull\n    public FillAnimation with(int colorStart, int colorEnd, int radius, int stroke) {\n        if (animator != null && hasChanges(colorStart, colorEnd, radius, stroke)) {\n\n            this.colorStart = colorStart;\n            this.colorEnd = colorEnd;\n\n            this.radius = radius;\n            this.stroke = stroke;\n\n            PropertyValuesHolder colorHolder = createColorPropertyHolder(false);\n            PropertyValuesHolder reverseColorHolder = createColorPropertyHolder(true);\n\n            PropertyValuesHolder radiusHolder = createRadiusPropertyHolder(false);\n            PropertyValuesHolder radiusReverseHolder = createRadiusPropertyHolder(true);\n\n            PropertyValuesHolder strokeHolder = createStrokePropertyHolder(false);\n            PropertyValuesHolder strokeReverseHolder = createStrokePropertyHolder(true);\n\n            animator.setValues(\n                    colorHolder,\n                    reverseColorHolder,\n\n                    radiusHolder,\n                    radiusReverseHolder,\n\n                    strokeHolder,\n                    strokeReverseHolder);\n        }\n\n        return this;\n    }\n\n    @NonNull\n    private PropertyValuesHolder createRadiusPropertyHolder(boolean isReverse) {\n        String propertyName;\n        int startRadiusValue;\n        int endRadiusValue;\n\n        if (isReverse) {\n            propertyName = ANIMATION_RADIUS_REVERSE;\n            startRadiusValue = radius / 2;\n            endRadiusValue = radius;\n        } else {\n            propertyName = ANIMATION_RADIUS;\n            startRadiusValue = radius;\n            endRadiusValue = radius / 2;\n        }\n\n        PropertyValuesHolder holder = PropertyValuesHolder.ofInt(propertyName, startRadiusValue, endRadiusValue);\n        holder.setEvaluator(new IntEvaluator());\n\n        return holder;\n    }\n\n    @NonNull\n    private PropertyValuesHolder createStrokePropertyHolder(boolean isReverse) {\n        String propertyName;\n        int startStrokeValue;\n        int endStrokeValue;\n\n        if (isReverse) {\n            propertyName = ANIMATION_STROKE_REVERSE;\n            startStrokeValue = radius;\n            endStrokeValue = 0;\n        } else {\n            propertyName = ANIMATION_STROKE;\n            startStrokeValue = 0;\n            endStrokeValue = radius;\n        }\n\n        PropertyValuesHolder holder = PropertyValuesHolder.ofInt(propertyName, startStrokeValue, endStrokeValue);\n        holder.setEvaluator(new IntEvaluator());\n\n        return holder;\n    }\n\n    private void onAnimateUpdated(@NonNull ValueAnimator animation) {\n        int color = (int) animation.getAnimatedValue(ANIMATION_COLOR);\n        int colorReverse = (int) animation.getAnimatedValue(ANIMATION_COLOR_REVERSE);\n\n        int radius = (int) animation.getAnimatedValue(ANIMATION_RADIUS);\n        int radiusReverse = (int) animation.getAnimatedValue(ANIMATION_RADIUS_REVERSE);\n\n        int stroke = (int) animation.getAnimatedValue(ANIMATION_STROKE);\n        int strokeReverse = (int) animation.getAnimatedValue(ANIMATION_STROKE_REVERSE);\n\n        value.setColor(color);\n        value.setColorReverse(colorReverse);\n\n        value.setRadius(radius);\n        value.setRadiusReverse(radiusReverse);\n\n        value.setStroke(stroke);\n        value.setStrokeReverse(strokeReverse);\n\n        if (listener != null) {\n            listener.onValueUpdated(value);\n        }\n    }\n\n    @SuppressWarnings("RedundantIfStatement")\n    private boolean hasChanges(int colorStart, int colorEnd, int radiusValue, int strokeValue) {\n        if (this.colorStart != colorStart) {\n            return true;\n        }\n\n        if (this.colorEnd != colorEnd) {\n            return true;\n        }\n\n        if (radius != radiusValue) {\n            return true;\n        }\n\n        if (stroke != strokeValue) {\n            return true;\n        }\n\n        return false;\n    }\n}\n'