b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Coroutine.Network where\n\nimport Control.Concurrent\n  ( MVar,\n    ThreadId,\n    forkIO,\n    killThread,\n    newEmptyMVar,\n    putMVar,\n    readMVar,\n  )\nimport Control.Lens (view)\nimport Control.Monad (forM_, forever)\nimport Control.Monad.Loops (unfoldM_)\nimport Control.Monad.State (get, liftIO)\nimport Control.Monad.Trans (lift)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport qualified Data.Binary as Bi\nimport qualified Data.ByteString.Char8 as B\nimport qualified Data.ByteString.Lazy.Char8 as LB\nimport Data.IORef (newIORef, readIORef, writeIORef)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport Data.Word (Word32)\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Coroutine.Draw (invalidateInBBox, nextevent)\nimport Hoodle.Script.Hook (getIPaddress)\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum\n  ( DrawFlag (Efficient),\n  )\nimport Hoodle.Type.Event\n  ( AllEvent (UsrEv),\n    NetworkEvent\n      ( NetworkCloseDialog,\n        NetworkClosed,\n        NetworkInitialized,\n        NetworkReceived\n      ),\n    UserEvent\n      ( NetworkProcess,\n        OkCancel,\n        UpdateCanvas\n      ),\n  )\nimport Hoodle.Type.HoodleState (hookSet)\nimport Network.Info\n  ( IPv4 (..),\n    MAC (..),\n    NetworkInterface (ipv4, mac),\n    getNetworkInterfaces,\n  )\nimport Network.Simple.TCP\n  ( HostPreference (Host),\n    accept,\n    listen,\n    recv,\n    send,\n  )\n\nserver :: (AllEvent -> IO ()) -> HostPreference -> T.Text -> IO ()\nserver evhandler ip txtorig = do\n  ref <- newIORef txtorig\n  forever $\n    listen ip "4040" $ \\(lsock, _) ->\n      accept lsock $ \\(sock, addr) -> do\n        txt <- readIORef ref\n        let bstr = TE.encodeUtf8 txt\n            bstr_size :: Word32 = (fromIntegral . B.length) bstr\n            bstr_size_binary = (mconcat . LB.toChunks . Bi.encode) bstr_size\n        putStrLn $ "TCP connection established from " ++ show addr\n        send sock (bstr_size_binary <> TE.encodeUtf8 txt)\n        unfoldM_ $ do\n          mbstr <- runMaybeT $ do\n            bstr\' <- MaybeT (recv sock 4)\n            let getsize :: B.ByteString -> Word32\n                getsize = Bi.decode . LB.fromChunks . return\n                size = (fromIntegral . getsize) bstr\'\n                go s bs = do\n                  liftIO $ putStrLn ("requested size = " ++ show s)\n                  bstr1 <- MaybeT (recv sock s)\n                  let s\' = B.length bstr1\n                  liftIO $ putStrLn ("obtained size = " ++ show s\')\n                  if s <= s\'\n                    then return (bs <> bstr1)\n                    else go (s - s\') (bs <> bstr1)\n            go size B.empty\n          forM_ mbstr $ \\bstr\' -> do\n            let txt\' = TE.decodeUtf8 bstr\'\n            (evhandler . UsrEv . NetworkProcess . NetworkReceived) txt\'\n            writeIORef ref txt\'\n          return mbstr\n        putStrLn "FINISHED"\n\nnetworkTextInputBody ::\n  T.Text ->\n  -- | (ip address,thread id,lock)\n  MainCoroutine (String, ThreadId, MVar ())\nnetworkTextInputBody txt = do\n  mipscr <- runMaybeT $ do\n    hkset <- MaybeT (view hookSet <$> lift get)\n    (MaybeT . return) (getIPaddress hkset)\n  let ipfind = do\n        let ipv4num (IPv4 x) = x\n            ismacnull (MAC a b c d e f) =\n              a == 0 && b == 0 && c == 0\n                && d\n                == 0\n                && e\n                == 0\n                && f\n                == 0\n        ifcs <- liftIO getNetworkInterfaces\n        let ifcs2 =\n              Prelude.filter (not . ismacnull . mac)\n                . Prelude.filter ((0 /=) . ipv4num . ipv4)\n                $ ifcs\n        return (if Prelude.null ifcs2 then "127.0.0.1" else (show . ipv4 . head) ifcs2)\n  ip <- maybe ipfind liftIO mipscr\n  doIOaction $ \\evhandler -> do\n    done <- newEmptyMVar\n    tid <- forkIO (server evhandler (Host ip) txt)\n    (return . UsrEv . NetworkProcess) (NetworkInitialized tid done)\n  let go = do\n        r <- nextevent\n        case r of\n          UpdateCanvas cid -> invalidateInBBox Nothing Efficient cid >> go\n          NetworkProcess (NetworkInitialized tid done) -> return (tid, done)\n          _ -> go\n  (tid, done) <- go\n  return (ip, tid, done)\n\nnetworkTextInput :: T.Text -> MainCoroutine (Maybe T.Text)\nnetworkTextInput txt = do\n  (ip, tid, done) <- networkTextInputBody txt\n  let ipdialog msg _evhandler = do\n        dialog <-\n          Gtk.messageDialogNew\n            Nothing\n            [Gtk.DialogModal]\n            Gtk.MessageQuestion\n            Gtk.ButtonsOkCancel\n            msg\n        _ <- forkIO $ do\n          readMVar done\n          Gtk.dialogResponse dialog Gtk.ResponseOk\n        res <- Gtk.dialogRun dialog\n        let b = case res of\n              Gtk.ResponseOk -> True\n              _ -> False\n        Gtk.widgetDestroy dialog\n        return (UsrEv (OkCancel b))\n  doIOaction (ipdialog ("networkedit " ++ ip ++ " 4040"))\n  --\n  let actf t = do\n        r <- nextevent\n        case r of\n          UpdateCanvas cid ->\n            invalidateInBBox Nothing Efficient cid\n              >> actf t\n          OkCancel True -> (return . Just) t\n          OkCancel False -> return Nothing\n          NetworkProcess (NetworkReceived txt\') -> do\n            doIOaction $ \\_ ->\n              Gtk.postGUISync (putMVar done ())\n                >> (return . UsrEv . NetworkProcess) NetworkCloseDialog\n            actf txt\'\n          _ -> actf t\n  ntxt <- actf txt\n  --\n  doIOaction $ \\_evhandler -> do\n    killThread tid\n    (return . UsrEv . NetworkProcess) NetworkClosed\n  --\n  return ntxt\n'