b'{-# OPTIONS_GHC -fwarn-unused-imports #-}\n\nmodule Main(main) where\n\n-- TEMP: Fixing the trace scheduler because of its runParAsync support:\nimport Control.Monad.Par.Scheds.Trace\nimport Control.Monad.Par.Scheds.TraceInternal (runParAsync)\nimport Control.Monad.Par.Stream as S\nimport Control.Monad.Par.Logging\nimport Control.Exception\nimport Data.Complex\nimport GHC.Conc as Conc\nimport Debug.Trace\nimport Math.FFT (dft)\n\ntype Elt = Complex Double\n\nfft_kern :: Window Elt -> Window Elt\nfft_kern arr = dft arr\n\n--   -- TEMP, evaluate one element to make sure the fft really gets called:\n-- --  trace ("One elt sample: "++ show (arr!10)) $\n--   case arr2 ! 10 of _ -> arr2\n--  where arr2 = dft arr\n\n--------------------------------------------------------------------------------\n-- Main script\n\n-- target  = maxBound\ntarget  = 10 * 1000 * 1000\nbufsize = 1024\n\nmain = do\n  putStrLn$ "numCapabilities: "++ show numCapabilities\n  putStrLn$ "  Frequency in measurable ticks:  "++ commaint oneSecond ++ "\\n"\n\n\n  putStrLn$ "Performing FFT of "++ commaint target ++" numbers windowed into buffers of size "++ show bufsize ++"\\n"\n\n  results <- evaluate $ runParAsync$ do \n\n       strm1 <- countupWin bufsize target :: Par (WStream Elt)\n\n       print_$ "\\n Next, applying FFT filter... "\n       strm2 <- streamMap fft_kern strm1 \n\n-- Make a pipeline of 10 stages:\n--       strm2 <- foldl (\\ s _ -> streamMap kern0) strm1 [1..10]\n\n       print_$ "\\n Stream graph constructed, returning from Par computation... "\n       return strm2\n\n  measureRate results\n  putStrLn$ "End of stream reached.  All done."\n\n\nprint_ msg = trace msg $ return ()\n\n-- work pop 1 peek N push 1 \n-- float->float filter \n-- firFilter n coefs = \n-- {\n\n--     float sum = 0;\n--     for (int i = 0; i < N; i++)\n--       sum += peek(i) * COEFF[N-1-i];\n--     pop();\n--     push(sum);\n--   }\n-- }\n\n\n{-\n Notes:\n\n\n\n -}\n'