b"{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies, CPP #-}\n\n-- | This scheduler uses sparks (par/pseq) directly, but only supplies\n--   the @Monad.Par.Class.ParFuture@ interface.\n\nmodule Control.Monad.Par.Scheds.Sparks\n (\n   Par(..), Future(..),\n   runPar, \n   get, spawn, spawn_, spawnP, fixPar\n ) \nwhere \n\nimport Control.Applicative\nimport Control.Monad\nimport Control.DeepSeq\nimport Control.Parallel\nimport qualified Control.Monad.Par.Class as PC\nimport Control.Monad.Fix (MonadFix (mfix))\n-- import Control.Parallel.Strategies (rpar)\n\n#ifdef NEW_GENERIC\nimport qualified       Control.Par.Class as PN\nimport qualified       Control.Par.Class.Unsafe as PU\nimport System.IO.Unsafe (unsafePerformIO)\n#endif\n\n\n{-# INLINE runPar #-}\n{-# INLINE spawn #-}\n{-# INLINE spawn_ #-}\n{-# INLINE spawnP #-}\n{-# INLINE get #-}\n\ndata Par    a = Done   a\ndata Future a = Future a\n\nrunPar :: Par a -> a\nrunPar (Done x) = x\n\nspawn_ :: Par a -> Par (Future a)\n-- spawn_ a = do a' <- rpar (runPar a); return (Future a')\nspawn_ a = let a' = runPar a in a' `par` return (Future a')\n\nspawn :: NFData a => Par a -> Par (Future a)\nspawn a = let a' = runPar a in a' `par` return (Future (rnf a' `pseq` a'))\n\nspawnP :: NFData a => a -> Par (Future a)\nspawnP a = a `par` return (Future (rnf a `pseq` a))\n\nget :: Future a -> Par a\nget (Future a) = a `pseq` return a\n\n--------------------------------------------------------------------------------\n-- <boilerplate>\n\ninstance Monad Par where\n  return = pure\n  Done x >>= k = k x\n\ninstance PC.ParFuture Future Par  where \n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance Functor Par where\n   fmap f xs = xs >>= return . f\n\ninstance Applicative Par where\n   (<*>) = ap\n   pure  = Done\n\ninstance MonadFix Par where\n   mfix = fixPar\n\n-- | Take the monadic fixpoint of a 'Par' computation. This is\n-- the definition of 'mfix' for 'Par'.\nfixPar :: (a -> Par a) -> Par a\nfixPar f =\n  let fr = f (case fr of Done x -> x)\n  in fr\n\n#ifdef NEW_GENERIC\ndoio :: IO a -> Par a\ndoio io = let x = unsafePerformIO io in\n          return $! x\n\ninstance PU.ParMonad Par where\n  -- This is a No-Op for this monad.  Because there are no side-effects permitted,\n  -- there is no way to observe whether anything happens on the child thread.\n  -- fork _m = return ()\n  -- FIXME: except for exceptions!!\n\n  -- This version doesn't work, because the spark may get spilled/dropped:\n  -- fork m = spawn m\n\n  -- I think this is all that we're left with:\n  fork m = m\n  internalLiftIO = doio\n\ninstance PU.ParThreadSafe Par where\n  unsafeParIO = doio\n\ninstance PN.ParFuture Par where\n  type Future Par = Future\n  type FutContents Par a = ()\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n#endif\n\n-- </boilerplate>\n--------------------------------------------------------------------------------\n"