b'{-# LANGUAGE RankNTypes, NamedFieldPuns, BangPatterns,\n             ExistentialQuantification, MultiParamTypeClasses, CPP #-}\n{- OPTIONS_GHC -Wall -fno-warn-name-shadowing -fwarn-unused-imports -}\n\n{-# LANGUAGE TypeFamilies #-}\n\n{- | This is the scheduler described in the paper "A Monad for\n     Deterministic Parallelism".  It is based on a lazy @Trace@ data\n     structure that separates the scheduler from the @Par@ monad\n     method implementations.\n\n -}\n\nmodule Control.Monad.Par.Scheds.Trace (\n    Par, runPar, runParIO, fork,\n    IVar, new, newFull, newFull_, get, put, put_,\n    spawn, spawn_, spawnP, fixPar, FixParException (..)\n  ) where\n\nimport qualified Control.Monad.Par.Class as PC\nimport Control.Monad.Par.Scheds.TraceInternal\nimport Control.DeepSeq\nimport Control.Monad as M hiding (mapM, sequence, join)\nimport Prelude hiding (mapM, sequence, head,tail)\n\n#ifdef NEW_GENERIC\nimport qualified       Control.Par.Class as PN\nimport qualified       Control.Par.Class.Unsafe as PU\n#endif\n\n-- -----------------------------------------------------------------------------\n\n-- Not in 6.12: {- INLINABLE fork -}\n{-# INLINE fork #-}\nfork :: Par () -> Par ()\nfork p = Par $ \\c -> Fork (runCont p (\\_ -> Done)) (c ())\n\n-- --------------------------------------------------------------------------------\n-- -- Standard instances:\n\n-- <boilerplate>\nspawn :: NFData a => Par a -> Par (IVar a)\nspawn p  = do r <- new;  fork (p >>= put r);   return r\nspawn_ :: Par a -> Par (IVar a)\nspawn_ p = do r <- new;  fork (p >>= put_ r);  return r\n-- </boilerplate>>\n\nspawnP :: NFData a => a -> Par (IVar a)\nspawnP a = spawn (return a)\n\ninstance PC.ParFuture IVar Par  where\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance PC.ParIVar IVar Par  where\n  fork = fork\n  new  = new\n  put  = put\n  put_ = put_\n  newFull  = newFull\n  newFull_ = newFull_\n--  yield = yield\n\n#ifdef NEW_GENERIC\ninstance PU.ParMonad Par where\n  fork = fork  \n  internalLiftIO io = Par (LiftIO io)\n\ninstance PU.ParThreadSafe Par where\n  unsafeParIO io = Par (LiftIO io)  \n    \ninstance PN.ParFuture Par where\n  type Future Par = IVar\n  type FutContents Par a = ()\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n  \ninstance PN.ParIVar Par  where\n  new  = new\n  put_ = put_\n  newFull = newFull\n  newFull_ = newFull_\n#endif\n\n'