b'-- Deals with adding private caches to netrc\nmodule Cachix.Client.NetRc\n  ( add,\n  )\nwhere\n\nimport Cachix.API.Error (escalateAs)\nimport Cachix.Client.Exception (CachixException (NetRcParseError))\nimport qualified Cachix.Types.BinaryCache as BinaryCache\nimport qualified Data.ByteString as BS\nimport Data.List (nubBy)\nimport qualified Data.Text as T\nimport Network.NetRc\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport Servant.Auth.Client (Token, getToken)\nimport System.Directory (createDirectoryIfMissing, doesFileExist)\nimport System.FilePath (takeDirectory)\n\n-- | Add a list of binary caches to netrc under `filename`.\n--   Makes sure there are no duplicate entries (using domain as a key).\n--   If file under filename doesn\'t exist it\'s created.\nadd ::\n  Token ->\n  [BinaryCache.BinaryCache] ->\n  FilePath ->\n  IO ()\nadd cachixAuthToken binarycaches filename = do\n  doesExist <- doesFileExist filename\n  netrc <-\n    if doesExist\n      then BS.readFile filename >>= parse\n      else return $ NetRc [] []\n  createDirectoryIfMissing True (takeDirectory filename)\n  BS.writeFile filename $ netRcToByteString $ uniqueAppend netrc\n  where\n    parse :: ByteString -> IO NetRc\n    parse contents = escalateAs (NetRcParseError . show) $ parseNetRc filename contents\n    -- O(n^2) but who cares?\n    uniqueAppend :: NetRc -> NetRc\n    uniqueAppend (NetRc hosts macdefs) =\n      let f :: NetRcHost -> NetRcHost -> Bool\n          f x y = nrhName x == nrhName y\n       in NetRc (nubBy f (new ++ hosts)) macdefs\n    new :: [NetRcHost]\n    new = map mkHost $ filter (not . BinaryCache.isPublic) binarycaches\n    mkHost :: BinaryCache.BinaryCache -> NetRcHost\n    mkHost bc =\n      NetRcHost\n        { nrhName = toS $ stripPrefix "http://" $ stripPrefix "https://" (BinaryCache.uri bc),\n          nrhLogin = "",\n          nrhPassword = getToken cachixAuthToken,\n          nrhAccount = "",\n          nrhMacros = []\n        }\n      where\n        -- stripPrefix that either strips or returns the same string\n        stripPrefix :: Text -> Text -> Text\n        stripPrefix prefix str =\n          maybe str identity $ T.stripPrefix prefix str\n'