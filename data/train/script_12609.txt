b'{-# LANGUAGE\n    CPP\n  , DataKinds\n  , FlexibleContexts\n  , GADTs\n  , GeneralizedNewtypeDeriving\n  , KindSignatures\n  , ScopedTypeVariables\n  , StandaloneDeriving\n  , TemplateHaskell\n  , TypeFamilies\n  , TypeOperators\n  , UndecidableInstances\n  #-}\nmodule Rest.Dictionary.Types\n  (\n  -- * Possible I/O formats.\n\n    Format (..)\n\n  -- * The dictionary type.\n\n  , Dict\n  , headers\n  , params\n  , inputs\n  , outputs\n  , errors\n\n  , empty\n  , Modifier\n\n  -- * Dictionary aspects.\n\n  , Ident (..)\n  , Header (..)\n  , Param (..)\n  , Input (..)\n  , Output (..)\n  , Error (..)\n  , Xml (..)\n  , Json (..)\n\n  -- * Plural dictionaries.\n\n  , Dicts (..)\n  , dicts\n  , getDicts\n  , getDicts_\n  , modDicts\n  , Inputs\n  , Outputs\n  , Errors\n  , SomeError (..)\n\n  , FromMaybe\n\n  )\n\nwhere\n\nimport Data.Aeson\nimport Data.ByteString.Lazy (ByteString)\nimport Data.JSON.Schema\nimport Data.Label ((:->), lens)\nimport Data.Label.Derive\nimport Data.Text.Lazy (Text)\nimport Data.Typeable\nimport Network.Multipart (BodyPart)\nimport Text.XML.HXT.Arrow.Pickle\n\nimport Rest.Error\nimport Rest.Info\nimport Rest.Types.Void\n\n-- | The `Format` datatype enumerates all input and output formats we might recognize.\n\ndata Format\n  = XmlFormat\n  | JsonFormat\n  | StringFormat\n  | FileFormat\n  | MultipartFormat\n  | NoFormat\n  deriving (Eq, Ord, Enum, Bounded, Show)\n\n-- | The explicit dictionary `Ident` describes how to translate a resource\n-- identifier (originating from a request URI) to a Haskell value. We allow\n-- plain `String` identifiers or all Haskell types that have a `Read` instance.\n\ndata Ident id where\n  ReadId   :: (Info id, Read id) => Ident id\n  StringId ::                       Ident String\n\nderiving instance Show (Ident id)\n\n-- | The explicit dictionary `Header` describes how to translate HTTP request\n-- headers to some Haskell value. The first field in the `Header` constructor\n-- is a white list of headers we can recognize, used in generic validation and\n-- for generating documentation. The second field is a custom parser that can\n-- fail with a `DataError` or can produce a some value. When explicitly not\n-- interested in the headers we can use `NoHeader`.\n\ndata Header h where\n  NoHeader    ::                                                       Header ()\n  Header      :: [String] -> ([Maybe String] -> Either DataError h) -> Header h\n  TwoHeaders  :: Header h -> Header k                               -> Header (h,k)\n\ninstance Show (Header h) where\n  showsPrec _ NoHeader         = showString "NoHeader"\n  showsPrec n (Header hs _)    = showParen (n > 9) (showString "Header " . showsPrec 10 hs)\n  showsPrec n (TwoHeaders h k) = showParen (n > 9) ( showString "TwoHeaders "\n                                                   . showsPrec 10 h\n                                                   . showString " "\n                                                   . showsPrec 10 k\n                                                   )\n\n-- | The explicit dictionary `Param` describes how to translate the request\n-- parameters to some Haskell value. The first field in the `Param`\n-- constructor is a white list of paramters we can recognize, used in generic\n-- validation and for generating documentation. The second field is a custom\n-- parser that can fail with a `DataError` or can produce a some value. When\n-- explicitly not interested in the parameters we can use `NoParam`.\n\ndata Param p where\n  NoParam   ::                                                       Param ()\n  Param     :: [String] -> ([Maybe String] -> Either DataError p) -> Param p\n  TwoParams :: Param p -> Param q                                 -> Param (p, q)\n\ninstance Show (Param p) where\n  showsPrec _ NoParam         = showString "NoParam"\n  showsPrec n (Param ns _)    = showParen (n > 9) (showString "Param " . showsPrec 10 ns)\n  showsPrec n (TwoParams p q) = showParen (n > 9) ( showString "TwoParams "\n                                                  . showsPrec 10 p\n                                                  . showString " "\n                                                  . showsPrec 10 q\n                                                  )\n\n-- | The explicit dictionary `Input` describes how to translate the request\n-- body into some Haskell value. We currently use a constructor for every\n-- combination of input type to output type. For example, we can use XML input\n-- in multiple ways, parsed, as plain/text or as raw bytes, depending on the\n-- needs of the backend resource.\n\ndata Input i where\n  JsonI          :: (Typeable i, FromJSON i, JSONSchema i) => Input i\n  ReadI          :: (Info i, Read i, Show i)               => Input i\n  StringI        ::                                           Input String\n  FileI          ::                                           Input ByteString\n  XmlI           :: (Typeable i, XmlPickler i)             => Input i\n  XmlTextI       ::                                           Input Text\n  RawJsonI       ::                                           Input ByteString\n  RawXmlI        ::                                           Input ByteString\n  RawJsonAndXmlI ::                                           Input (Either Json Xml)\n\nderiving instance Show (Input i)\nderiving instance Eq   (Input i)\nderiving instance Ord  (Input i)\n\n-- | The explicit dictionary `Output` describes how to translate some Haskell\n-- value to a response body. We currently use a constructor for every\n-- combination of input type to output type.\n\ndata Output o where\n  FileO          ::                                         Output (ByteString, String, Bool)\n  RawJsonO       ::                                         Output ByteString\n  RawXmlO        ::                                         Output ByteString\n  JsonO          :: (Typeable o, ToJSON o, JSONSchema o) => Output o\n  XmlO           :: (Typeable o, XmlPickler o)           => Output o\n  StringO        ::                                         Output String\n  RawJsonAndXmlO ::                                         Output ByteString\n  MultipartO     ::                                         Output [BodyPart]\n\nderiving instance Show (Output o)\nderiving instance Eq   (Output o)\nderiving instance Ord  (Output o)\n\n-- | Newtype around ByteStrings used in `RawJsonAndXmlI` to add some\n-- protection from parsing the input incorrectly.\nnewtype Xml = Xml { unXml :: ByteString }\n  deriving (Eq, Show)\n\n-- | Newtype around ByteStrings used in `RawJsonAndXmlI` to add some\n-- protection from parsing the input incorrectly.\nnewtype Json = Json { unJson :: ByteString }\n  deriving (Eq, Show)\n\n-- | The explicit dictionary `Error` describes how to translate some Haskell\n-- error value to a response body.\n\ndata Error e where\n  JsonE   :: (ToResponseCode e, Typeable e, ToJSON e, JSONSchema e) => Error e\n  XmlE    :: (ToResponseCode e, Typeable e, XmlPickler e)           => Error e\n\nderiving instance Show (Error e)\nderiving instance Eq   (Error e)\nderiving instance Ord  (Error e)\n\ntype Inputs  i = Dicts Input  i\ntype Outputs o = Dicts Output o\ntype Errors  e = Dicts Error  e\n\ndata Dicts f a where\n  None  :: Dicts f \'Nothing\n  Dicts :: [f a] -> Dicts f (\'Just a)\n\n-- Needs UndecidableInstances\nderiving instance Show (f (FromMaybe Void a)) => Show (Dicts f a)\n\n#if GLASGOW_HASKELL < 708\ntype family FromMaybe d (m :: Maybe *) :: *\ntype instance FromMaybe b \'Nothing  = b\ntype instance FromMaybe b (\'Just a) = a\n#else\ntype family FromMaybe d (m :: Maybe *) :: * where\n  FromMaybe b Nothing  = b\n  FromMaybe b (Just a) = a\n#endif\n\n{-# DEPRECATED dicts "The modifier for this lens doesn\'t do anything when Dicts is None. Use getDicts and modDicts instead." #-}\ndicts :: forall a o f. o ~ FromMaybe o a => Dicts f a :-> [f o]\ndicts = lens get modify\n  where\n    get :: Dicts f a -> [f o]\n    get None       = []\n    get (Dicts ds) = ds\n    modify :: ([f o] -> [f o]) -> Dicts f a -> Dicts f a\n    modify _ None       = None\n    modify f (Dicts ds) = Dicts (f ds)\n\n-- | Get the list of dictionaries. If there are none, you get a [o].\n-- If this is too polymorphic, try `getDicts_`.\n\ngetDicts :: o ~ FromMaybe o a => Dicts f a -> [f o]\ngetDicts None       = []\ngetDicts (Dicts ds) = ds\n\n-- | Get the list of dictionaries. If there are none, you get a [()].\n-- Sometimes useful to constraint the types if the element type of the\n-- list isn\'t clear from the context.\n\ngetDicts_ :: o ~ FromMaybe () a => Dicts f a -> [f o]\ngetDicts_ None = []\ngetDicts_ (Dicts ds) = ds\n\nmodDicts :: (FromMaybe o i ~ o) => ([f o] -> [f o]) -> Dicts f i -> Dicts f (\'Just o)\nmodDicts f None       = Dicts (f [])\nmodDicts f (Dicts ds) = Dicts (f ds)\n\n-- | The `Dict` datatype containing sub-dictionaries for translation of\n-- identifiers (i), headers (h), parameters (p), inputs (i), outputs (o), and\n-- errors (e). Inputs, outputs and errors can have multiple associated\n-- dictionaries.\n\nfclabels [d|\n  data Dict h p i o e = Dict\n    { headers :: Header  h\n    , params  :: Param   p\n    , inputs  :: Inputs  i\n    , outputs :: Outputs o\n    , errors  :: Errors  e\n    } deriving Show\n  |]\n\n-- | The empty dictionary, recognizing no types.\n\nempty :: Dict () () \'Nothing \'Nothing \'Nothing\nempty = Dict NoHeader NoParam None None None\n\n-- | Custom existential packing an error together with a Reason.\n\ndata SomeError where\n  SomeError :: Errors e -> Reason (FromMaybe Void e) -> SomeError\n\n-- | Type synonym for dictionary modification.\n\ntype Modifier h p i o e = Dict () () \'Nothing \'Nothing \'Nothing -> Dict h p i o e\n'