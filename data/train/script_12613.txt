b'{-# LANGUAGE CPP #-}\n\nimport Data.Tree as T\n\nimport Control.Applicative (Const(Const, getConst), pure, (<$>), (<*>), liftA2)\n\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck\nimport Test.QuickCheck.Function (apply)\nimport Test.QuickCheck.Poly (A, B, C, OrdA)\nimport Control.Monad.Fix (MonadFix (..))\nimport Control.Monad (ap)\nimport Data.Foldable (foldl\', toList)\nimport Data.Traversable (foldMapDefault)\n#if MIN_VERSION_base(4,18,0)\nimport qualified Data.List.NonEmpty as NE\nimport qualified Data.Foldable1 as Foldable1\n#endif\n\ndefault (Int)\n\nmain :: IO ()\nmain = defaultMain $ testGroup "tree-properties"\n         [\n           testCase     "foldr"                    test_foldr\n         , testProperty "monad_id1"                prop_monad_id1\n         , testProperty "monad_id2"                prop_monad_id2\n         , testProperty "monad_assoc"              prop_monad_assoc\n         , testProperty "ap_ap"                    prop_ap_ap\n         , testProperty "ap_liftA2"                prop_ap_liftA2\n         , testProperty "monadFix_ls"              prop_monadFix_ls\n         , testProperty "toList"                   prop_toList\n         , testProperty "foldMap"                  prop_foldMap\n         , testProperty "foldl\'"                   prop_foldl\'\n         , testProperty "foldr1"                   prop_foldr1\n         , testProperty "foldl1"                   prop_foldl1\n         , testProperty "foldr_infinite"           prop_foldr_infinite\n         , testProperty "maximum"                  prop_maximum\n         , testProperty "minimum"                  prop_minimum\n         , testProperty "sum"                      prop_sum\n         , testProperty "product"                  prop_product\n#if MIN_VERSION_base(4,18,0)\n         , testProperty "toNonEmpty"               prop_toNonEmpty\n         , testProperty "last"                     prop_last\n         , testProperty "foldrMap1"                prop_foldrMap1\n         , testProperty "foldlMap1\'"               prop_foldlMap1\'\n         , testProperty "foldlMap1"                prop_foldlMap1\n#endif\n         ]\n\n{--------------------------------------------------------------------\n  Arbitrary trees\n--------------------------------------------------------------------}\n\n\n-- This instance isn\'t balanced very well; the trees will probably tend\n-- to lean left. But it\'s better than nothing and we can fix it later.\ninstance Arbitrary a => Arbitrary (Tree a) where\n  arbitrary = sized (fmap snd . arbtree)\n    where\n      arbtree :: Arbitrary a => Int -> Gen (Int, Tree a)\n      arbtree 0 = fmap ((,) 1) $ Node <$> arbitrary <*> pure []\n      arbtree n = do\n        root <- arbitrary\n        num_children <- choose (0, n - 1)\n        (st, tl) <- go num_children\n        return (1+st, Node root tl)\n\n      go 0 = pure (0, [])\n      go n = do\n        (sh, hd) <- arbtree n\n        (st, tl) <- go (n - sh)\n        pure (sh + st, hd : tl)\n\n#if defined(__GLASGOW_HASKELL__)\n  shrink = genericShrink\n#endif\n\n----------------------------------------------------------------\n-- Utilities\n----------------------------------------------------------------\n\ndata Magma a\n  = Inj a\n  | Magma a :* Magma a\n  deriving (Eq, Show)\n\n----------------------------------------------------------------\n-- Unit tests\n----------------------------------------------------------------\n\ntest_foldr :: Assertion\ntest_foldr = do\n  foldr (:) [] (Node 1 []) @?= [1]\n  foldr (:) [] (Node 1 [Node 2 [Node 3 []]]) @?= [1..3]\n  foldr (:) [] (Node 1 [Node 2 [Node 3 [], Node 4 []], Node 5 [Node 6 [], Node 7 []]]) @?= [1..7]\n\n----------------------------------------------------------------\n-- QuickCheck\n----------------------------------------------------------------\n\napply2 :: Fun (a, b) c -> a -> b -> c\napply2 f a b = apply f (a, b)\n\nprop_ap_ap :: Tree (Fun A B) -> Tree A -> Property\nprop_ap_ap fs xs = (apply <$> fs <*> xs) === ((apply <$> fs) `ap` xs)\n\nprop_ap_liftA2 :: Fun (A, B) C -> Tree A -> Tree B -> Property\nprop_ap_liftA2 f as bs = (apply2 f <$> as <*> bs) === liftA2 (apply2 f) as bs\n\nprop_monad_id1 :: Tree A -> Property\nprop_monad_id1 t = (t >>= pure) === t\n\nprop_monad_id2 :: A -> Fun A (Tree B) -> Property\nprop_monad_id2 a f = (pure a >>= apply f) === apply f a\n\nprop_monad_assoc :: Tree A -> Fun A (Tree B) -> Fun B (Tree C) -> Property\nprop_monad_assoc ta atb btc =\n  ((ta >>= apply atb) >>= apply btc)\n  ===\n  (ta >>= \\a -> apply atb a >>= apply btc)\n\n-- The left shrinking law\n--\n-- This test is kind of wonky and unprincipled, because it\'s\n-- rather tricky to construct test cases!\n-- This is the most important MonadFix law to test because it\'s the\n-- least intuitive by far, and because it\'s the only one that\'s\n-- sensitive to the Monad instance.\nprop_monadFix_ls :: Int -> Tree Int -> Fun Int (Tree Int) -> Property\nprop_monadFix_ls val ta ti =\n  fmap ($ val) (mfix (\\x -> ta >>= \\y -> f x y))\n  ===\n  fmap ($ val) (ta >>= \\y -> mfix (\\x -> f x y))\n  where\n    fact :: Int -> (Int -> Int) -> Int -> Int\n    fact x _ 0 = x + 1\n    fact x f n = x + n * f ((n - 1) `mod` 23)\n\n    f :: (Int -> Int) -> Int -> Tree (Int -> Int)\n    f q y = let t = apply ti y\n            in fmap (\\w -> fact w q) t\n\nprop_toList :: Tree A -> Property\nprop_toList t = toList t === foldr (:) [] t\n\nprop_foldMap :: Tree A -> Property\nprop_foldMap t =\n  foldMap (:[]) t === toList t .&&.\n  foldMap (:[]) t === foldMapDefault (:[]) t\n\nprop_foldl\' :: Tree A -> Property\nprop_foldl\' t = foldl\' (flip (:)) [] t === reverse (toList t)\n\nprop_foldr1 :: Tree A -> Property\nprop_foldr1 t = foldr1 (:*) (fmap Inj t) === foldr1 (:*) (map Inj (toList t))\n\nprop_foldl1 :: Tree A -> Property\nprop_foldl1 t = foldl1 (:*) (fmap Inj t) === foldl1 (:*) (map Inj (toList t))\n\nprop_foldr_infinite :: NonNegative Int -> Property\nprop_foldr_infinite (NonNegative n) =\n    forAllShow genInf (const "<possibly infinite tree>") $\n        \\t -> length (take n (foldr (:) [] t)) <= n\n  where\n    genInf = Node () <$> oneof [listOf genInf, infiniteListOf genInf]\n\nprop_maximum :: Tree OrdA -> Property\nprop_maximum t = maximum t === maximum (toList t)\n\nprop_minimum :: Tree OrdA -> Property\nprop_minimum t = minimum t === minimum (toList t)\n\nprop_sum :: Tree OrdA -> Property\nprop_sum t = sum t === sum (toList t)\n\nprop_product :: Tree OrdA -> Property\nprop_product t = product t === product (toList t)\n\n#if MIN_VERSION_base(4,18,0)\nprop_toNonEmpty :: Tree A -> Property\nprop_toNonEmpty t = Foldable1.toNonEmpty t === NE.fromList (toList t)\n\nprop_last :: Tree A -> Property\nprop_last t = Foldable1.last t === NE.last (Foldable1.toNonEmpty t)\n\nprop_foldrMap1 :: Tree A -> Property\nprop_foldrMap1 t =\n    Foldable1.foldrMap1 Inj f t === Foldable1.foldrMap1 Inj f (Foldable1.toNonEmpty t)\n  where\n    f x z = Inj x :* z\n\nprop_foldlMap1\' :: Tree A -> Property\nprop_foldlMap1\' t =\n    Foldable1.foldlMap1\' Inj f t === Foldable1.foldlMap1\' Inj f (Foldable1.toNonEmpty t)\n  where\n    f z x = z :* Inj x\n\nprop_foldlMap1 :: Tree A -> Property\nprop_foldlMap1 t =\n    Foldable1.foldlMap1 Inj f t === Foldable1.foldlMap1 Inj f (Foldable1.toNonEmpty t)\n  where\n    f z x = z :* Inj x\n#endif\n'