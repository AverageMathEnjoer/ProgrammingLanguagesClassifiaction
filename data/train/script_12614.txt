b"{-# LANGUAGE CPP  #-}\n\n-- This is a simplistic benchmark but is included just for comparison with Haskell CnC\n\n-- Author: Ryan Newton \n\nimport System.Environment\nimport qualified Control.Monad.Par.AList as A\n\n#ifdef NEW_GENERIC\nimport qualified Data.Par as C\n#else\nimport qualified Control.Monad.Par.Combinator as C\n#endif\nimport Debug.Trace\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\n-- First a naive serial test for primality:\nisPrime :: Int -> Bool\nisPrime 2 = True\nisPrime n = (prmlp 3 == n)\n    where prmlp :: Int -> Int\n  \t  prmlp i = if (rem n i) == 0\n \t\t    then i else prmlp (i + 2)\n\n----------------------------------------\n\n-- Next, a CnC program that calls the serial test in parallel.\n\nprimes :: Int -> Int -> Par (A.AList Int)\nprimes start end = \n-- parMapReduceRange (InclusiveRange start end)\n C.parMapReduceRangeThresh 100 (C.InclusiveRange start end)\n\t\t   (\\n -> if \n\t\t            -- TEMP: Need a strided range here:\n                            (rem n 2 /= 0) && isPrime n \n\t\t          then return$ A.singleton n\n\t\t          else return$ A.empty)\n\t\t   (\\ a b -> return (A.append a b))\n\t\t   A.empty\n\n-- This version never builds up the list, it simply counts:\n-- countprimes :: Int -> Int -> Par Int\n-- countprimes start end = \n\t\t   \nmain :: IO ()\nmain = do args <- getArgs \n\t  let size = case args of \n\t\t      []  -> 1000 -- Should output 168\n\t\t      [n] -> (read n)\n\n              ls = runPar $ primes 3 size\n\t      \n--\t  putStrLn (show ls)\n\t  putStrLn (show (1 + A.length ls)) -- Add one to include '2'.\n          return ()\n"