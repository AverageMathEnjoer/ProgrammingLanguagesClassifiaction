b'{-# LANGUAGE ForeignFunctionInterface #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Test1 where\n\nimport           Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport qualified Data.MessagePack as MSG\n\nimport Foreign.C\n\n-- import FFI.Anything.TH (deriveCallable)\nimport FFI.Anything.TypeUncurry.Msgpack\n\n\n\n-- | Example function to be called from Python.\nf1 :: Int -> Double -> String\nf1 i f = "Called with params: " ++ show i ++ ", " ++ show f\n\n\n-- To be translated to:\nf1\' :: ByteString -> ByteString\nf1\' bs = BSL.toStrict $ MSG.pack (uncurry f1 $ msg)\n  where\n    msg = case MSG.unpack (BSL.fromStrict bs) of\n      Nothing -> error "could not unpack"\n      Just r -> r\n\n\n-- TODO check who deallocs - it seems to work magically!\nforeign export ccall f1_hs :: CString -> IO CString\nf1_hs :: CString -> IO CString\nf1_hs cs = do\n    cs_bs <- BS.packCString cs\n    let res_bs = f1\' cs_bs\n    res_cs <- BS.useAsCString res_bs return\n    return res_cs\n\n\nf1_t :: ByteString -> ByteString\nf1_t = uncurryMsgpack f1\n\nforeign export ccall f1_t_export :: CString -> IO CString\nf1_t_export :: CString -> IO CString\nf1_t_export = byteStringToCStringFun f1_t\n\n\n\nfib :: Int -> Int\nfib 0 = 1\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\n\n\nfib_print :: Int -> IO Int\nfib_print x = putStrLn ("fib_print: " ++ show f) >> return f\n  where\n    f = fib x\n\n\nforeign export ccall fib_export :: CString -> IO CString\nfib_export :: CString -> IO CString\nfib_export = export fib\n\n\n-- TODO the sole *presence* of this function seems to make the calls in Python slower\n-- foreign export ccall fib_print_export :: CString -> IO CString\n-- fib_print_export :: CString -> IO CString\n-- fib_print_export = exportIO fib_print\n\n-- -- TODO the sole *presence* of this function seems to make the calls in Python slower\n-- foreign export ccall fib_print_export2 :: CString -> IO CString\n-- fib_print_export2 :: CString -> IO CString\n-- fib_print_export2 = exportIO fib_print\n\n\n-- $(deriveCallable \'f1 "f1_hs")\n\n\nforeign export ccall fib_export_ffi :: CInt -> CInt\nfib_export_ffi :: CInt -> CInt\nfib_export_ffi = fromIntegral . fib . fromIntegral\n'