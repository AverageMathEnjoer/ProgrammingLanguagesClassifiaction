b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2004 April 13\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains routines used to translate between UTF-8,\n    ** UTF-16, UTF-16BE, and UTF-16LE.\n    **\n    ** $Id: utf.c,v 1.73 2009/04/01 18:40:32 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    **\n    ** Notes on UTF-8:\n    **\n    **   Byte-0    Byte-1    Byte-2    Byte-3    Value\n    **  0xxxxxxx                                 00000000 00000000 0xxxxxxx\n    **  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx\n    **  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx\n    **  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx\n    **\n    **\n    ** Notes on UTF-16:  (with wwww+1==uuuuu)\n    **\n    **      Word-0               Word-1          Value\n    **  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxx\n    **  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx\n    **\n    **\n    ** BOM or Byte Order Mark:\n    **     0xff 0xfe   little-endian utf-16 follows\n    **     0xfe 0xff   big-endian utf-16 follows\n    **\n    */\n    //#include "sqliteInt.h"\n    //#include <assert.h>\n    //#include "vdbeInt.h"\n\n#if !SQLITE_AMALGAMATION\n    /*\n** The following constant value is used by the SQLITE_BIGENDIAN and\n** SQLITE_LITTLEENDIAN macros.\n*/\n    //const int sqlite3one = 1;\n#endif //* SQLITE_AMALGAMATION */\n\n    /*\n** This lookup table is used to help decode the first byte of\n** a multi-byte UTF8 character.\n*/\n    static byte[] sqlite3Utf8Trans1 = new byte[]  {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,\n};\n\n\n    //#define WRITE_UTF8(zOut, c) {                          \\\n    //  if( c<0x00080 ){                                     \\\n    //    *zOut++ = (u8)(c&0xFF);                            \\\n    //  }                                                    \\\n    //  else if( c<0x00800 ){                                \\\n    //    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \\\n    //    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n    //  }                                                    \\\n    //  else if( c<0x10000 ){                                \\\n    //    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \\\n    //    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \\\n    //    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n    //  }else{                                               \\\n    //    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \\\n    //    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \\\n    //    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \\\n    //    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n    //  }                                                    \\\n    //}\n\n    //#define WRITE_UTF16LE(zOut, c) {                                    \\\n    //  if( c<=0xFFFF ){                                                  \\\n    //    *zOut++ = (u8)(c&0x00FF);                                       \\\n    //    *zOut++ = (u8)((c>>8)&0x00FF);                                  \\\n    //  }else{                                                            \\\n    //    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \\\n    //    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \\\n    //    *zOut++ = (u8)(c&0x00FF);                                       \\\n    //    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \\\n    //  }                                                                 \\\n    //}\n\n    //#define WRITE_UTF16BE(zOut, c) {                                    \\\n    //  if( c<=0xFFFF ){                                                  \\\n    //    *zOut++ = (u8)((c>>8)&0x00FF);                                  \\\n    //    *zOut++ = (u8)(c&0x00FF);                                       \\\n    //  }else{                                                            \\\n    //    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \\\n    //    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \\\n    //    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \\\n    //    *zOut++ = (u8)(c&0x00FF);                                       \\\n    //  }                                                                 \\\n    //}\n\n    //#define READ_UTF16LE(zIn, c){                                         \\\n    //  c = (*zIn++);                                                       \\\n    //  c += ((*zIn++)<<8);                                                 \\\n    //  if( c>=0xD800 && c<0xE000 ){                                       \\\n    //    int c2 = (*zIn++);                                                \\\n    //    c2 += ((*zIn++)<<8);                                              \\\n    //    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \\\n    //  }                                                                   \\\n    //}\n\n    //#define READ_UTF16BE(zIn, c){                                         \\\n    //  c = ((*zIn++)<<8);                                                  \\\n    //  c += (*zIn++);                                                      \\\n    //  if( c>=0xD800 && c<0xE000 ){                                       \\\n    //    int c2 = ((*zIn++)<<8);                                           \\\n    //    c2 += (*zIn++);                                                   \\\n    //    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \\\n    //  }                                                                   \\\n    //}\n\n    /*\n    ** Translate a single UTF-8 character.  Return the unicode value.\n    **\n    ** During translation, assume that the byte that zTerm points\n    ** is a 0x00.\n    **\n    ** Write a pointer to the next unread byte back into pzNext.\n    **\n    ** Notes On Invalid UTF-8:\n    **\n    **  *  This routine never allows a 7-bit character (0x00 through 0x7f) to\n    **     be encoded as a multi-byte character.  Any multi-byte character that\n    **     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.\n    **\n    **  *  This routine never allows a UTF16 surrogate value to be encoded.\n    **     If a multi-byte character attempts to encode a value between\n    **     0xd800 and 0xe000 then it is rendered as 0xfffd.\n    **\n    **  *  Bytes in the range of 0x80 through 0xbf which occur as the first\n    **     byte of a character are interpreted as single-byte characters\n    **     and rendered as themselves even though they are technically\n    **     invalid characters.\n    **\n    **  *  This routine accepts an infinite number of different UTF8 encodings\n    **     for unicode values 0x80 and greater.  It do not change over-length\n    **     encodings to 0xfffd as some systems recommend.\n    */\n    //#define READ_UTF8(zIn, zTerm, c)                           \\\n    //  c = *(zIn++);                                            \\\n    //  if( c>=0xc0 ){                                           \\\n    //    c = sqlite3Utf8Trans1[c-0xc0];                          \\\n    //    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \\\n    //      c = (c<<6) + (0x3f & *(zIn++));                      \\\n    //    }                                                      \\\n    //    if( c<0x80                                             \\\n    //        || (c&0xFFFFF800)==0xD800                          \\\n    //        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \\\n    //  }\n    static int sqlite3Utf8Read(\n    string zIn,          /* First byte of UTF-8 character */\n    ref string pzNext   /* Write first byte past UTF-8 char here */\n    )\n    {\n      //int c;\n      /* Same as READ_UTF8() above but without the zTerm parameter.\n      ** For this routine, we assume the UTF8 string is always zero-terminated.\n      */\n      if ( zIn == null || zIn.Length == 0 ) return 0;\n      //c = *( zIn++ );\n      //if ( c >= 0xc0 )\n      //{\n      //  c = sqlite3Utf8Trans1[c - 0xc0];\n      //  while ( ( *zIn & 0xc0 ) == 0x80 )\n      //  {\n      //    c = ( c << 6 ) + ( 0x3f & *( zIn++ ) );\n      //  }\n      //  if ( c < 0x80\n      //      || ( c & 0xFFFFF800 ) == 0xD800\n      //      || ( c & 0xFFFFFFFE ) == 0xFFFE ) { c = 0xFFFD; }\n      //}\n      //*pzNext = zIn;\n      int zIndex = 0;\n      int c = zIn[zIndex++];\n      if ( c >= 0xc0 )\n      {\n        if ( c > 0xff ) c = 0;\n        else\n        {\n          c = sqlite3Utf8Trans1[c - 0xc0];\n          while ( zIndex != zIn.Length && ( zIn[zIndex] & 0xc0 ) == 0x80 )\n          {\n            c = ( c << 6 ) + ( 0x3f & zIn[zIndex++] );\n          }\n          if ( c < 0x80\n          || ( c & 0xFFFFF800 ) == 0xD800\n          || ( c & 0xFFFFFFFE ) == 0xFFFE ) { c = 0xFFFD; }\n        }\n      } pzNext = zIn.Substring( zIndex );\n      return c;\n    }\n\n\n\n    /*\n    ** If the TRANSLATE_TRACE macro is defined, the value of each Mem is\n    ** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().\n    */\n    /* #define TRANSLATE_TRACE 1 */\n\n#if ! SQLITE_OMIT_UTF16\n\n/*\n** This routine transforms the internal text encoding used by pMem to\n** desiredEnc. It is an error if the string is already of the desired\n** encoding, or if pMem does not contain a string value.\n*/\nstatic int sqlite3VdbeMemTranslate(Mem pMem, int desiredEnc){\nint len;                    /* Maximum length of output string in bytes */\nDebugger.Break (); // TODO -\n//unsigned char *zOut;                  /* Output buffer */\n//unsigned char *zIn;                   /* Input iterator */\n//unsigned char *zTerm;                 /* End of input */\n//unsigned char *z;                     /* Output iterator */\n//unsigned int c;\n\nDebug.Assert( pMem.db==null || sqlite3_mutex_held(pMem.db.mutex) );\nDebug.Assert( (pMem.flags&MEM_Str )!=0);\nDebug.Assert( pMem.enc!=desiredEnc );\nDebug.Assert( pMem.enc!=0 );\nDebug.Assert( pMem.n>=0 );\n\n#if TRANSLATE_TRACE && SQLITE_DEBUG\n{\nchar zBuf[100];\nsqlite3VdbeMemPrettyPrint(pMem, zBuf);\nfprintf(stderr, "INPUT:  %s\\n", zBuf);\n}\n#endif\n\n/* If the translation is between UTF-16 little and big endian, then\n** all that is required is to swap the byte order. This case is handled\n** differently from the others.\n*/\nDebugger.Break (); // TODO -\n//if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){\n//  u8 temp;\n//  int rc;\n//  rc = sqlite3VdbeMemMakeWriteable(pMem);\n//  if( rc!=SQLITE_OK ){\n//    Debug.Assert( rc==SQLITE_NOMEM );\n//    return SQLITE_NOMEM;\n//  }\n//  zIn = (u8*)pMem.z;\n//  zTerm = &zIn[pMem->n&~1];\n//  while( zIn<zTerm ){\n//    temp = *zIn;\n//    *zIn = *(zIn+1);\n//    zIn++;\n//    *zIn++ = temp;\n//  }\n//  pMem->enc = desiredEnc;\n//  goto translate_out;\n//}\n\n/* Set len to the maximum number of bytes required in the output buffer. */\nif( desiredEnc==SQLITE_UTF8 ){\n/* When converting from UTF-16, the maximum growth results from\n** translating a 2-byte character to a 4-byte UTF-8 character.\n** A single byte is required for the output string\n** nul-terminator.\n*/\npMem->n &= ~1;\nlen = pMem.n * 2 + 1;\n}else{\n/* When converting from UTF-8 to UTF-16 the maximum growth is caused\n** when a 1-byte UTF-8 character is translated into a 2-byte UTF-16\n** character. Two bytes are required in the output buffer for the\n** nul-terminator.\n*/\nlen = pMem.n * 2 + 2;\n}\n\n/* Set zIn to point at the start of the input buffer and zTerm to point 1\n** byte past the end.\n**\n** Variable zOut is set to point at the output buffer, space obtained\n** from sqlite3Malloc().\n*/\nDebugger.Break (); // TODO -\n//zIn = (u8*)pMem.z;\n//zTerm = &zIn[pMem->n];\n//zOut = sqlite3DbMallocRaw(pMem->db, len);\n//if( !zOut ){\n//  return SQLITE_NOMEM;\n//}\n//z = zOut;\n\n//if( pMem->enc==SQLITE_UTF8 ){\n//  if( desiredEnc==SQLITE_UTF16LE ){\n//    /* UTF-8 -> UTF-16 Little-endian */\n//    while( zIn<zTerm ){\n///* c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn); */\n//READ_UTF8(zIn, zTerm, c);\n//      WRITE_UTF16LE(z, c);\n//    }\n//  }else{\n//    Debug.Assert( desiredEnc==SQLITE_UTF16BE );\n//    /* UTF-8 -> UTF-16 Big-endian */\n//    while( zIn<zTerm ){\n///* c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn); */\n//READ_UTF8(zIn, zTerm, c);\n//      WRITE_UTF16BE(z, c);\n//    }\n//  }\n//  pMem->n = (int)(z - zOut);\n//  *z++ = 0;\n//}else{\n//  Debug.Assert( desiredEnc==SQLITE_UTF8 );\n//  if( pMem->enc==SQLITE_UTF16LE ){\n//    /* UTF-16 Little-endian -> UTF-8 */\n//    while( zIn<zTerm ){\n//      READ_UTF16LE(zIn, c);\n//      WRITE_UTF8(z, c);\n//    }\n//  }else{\n//    /* UTF-16 Big-endian -> UTF-8 */\n//    while( zIn<zTerm ){\n//      READ_UTF16BE(zIn, c);\n//      WRITE_UTF8(z, c);\n//    }\n//  }\n//  pMem->n = (int)(z - zOut);\n//}\n//*z = 0;\n//Debug.Assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len );\n\n//sqlite3VdbeMemRelease(pMem);\n//pMem->flags &= ~(MEM_Static|MEM_Dyn|MEM_Ephem);\n//pMem->enc = desiredEnc;\n//pMem->flags |= (MEM_Term|MEM_Dyn);\n//pMem.z = (char*)zOut;\n//pMem.zMalloc = pMem.z;\n\ntranslate_out:\n#if TRANSLATE_TRACE && SQLITE_DEBUG\n{\nchar zBuf[100];\nsqlite3VdbeMemPrettyPrint(pMem, zBuf);\nfprintf(stderr, "OUTPUT: %s\\n", zBuf);\n}\n#endif\nreturn SQLITE_OK;\n}\n\n/*\n** This routine checks for a byte-order mark at the beginning of the\n** UTF-16 string stored in pMem. If one is present, it is removed and\n** the encoding of the Mem adjusted. This routine does not do any\n** byte-swapping, it just sets Mem.enc appropriately.\n**\n** The allocation (static, dynamic etc.) and encoding of the Mem may be\n** changed by this function.\n*/\nstatic int sqlite3VdbeMemHandleBom(Mem pMem){\nint rc = SQLITE_OK;\nint bom = 0;\nbyte[] b01 = new byte[2];\nEncoding.Unicode.GetBytes( pMem.z, 0, 1,b01,0 );\nassert( pMem->n>=0 );\nif( pMem->n>1 ){\n//  u8 b1 = *(u8 *)pMem.z;\n//  u8 b2 = *(((u8 *)pMem.z) + 1);\nif( b01[0]==0xFE && b01[1]==0xFF ){//  if( b1==0xFE && b2==0xFF ){\nbom = SQLITE_UTF16BE;\n}\nif( b01[0]==0xFF && b01[1]==0xFE ){  //  if( b1==0xFF && b2==0xFE ){\nbom = SQLITE_UTF16LE;\n}\n}\n\nif( bom!=0 ){\nrc = sqlite3VdbeMemMakeWriteable(pMem);\nif( rc==SQLITE_OK ){\npMem.n -= 2;\nDebugger.Break (); // TODO -\n//memmove(pMem.z, pMem.z[2], pMem.n);\n//pMem.z[pMem.n] = \'\\0\';\n//pMem.z[pMem.n+1] = \'\\0\';\npMem.flags |= MEM_Term;\npMem.enc = bom;\n}\n}\nreturn rc;\n}\n#endif // * SQLITE_OMIT_UTF16 */\n\n    /*\n** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,\n** return the number of unicode characters in pZ up to (but not including)\n** the first 0x00 byte. If nByte is not less than zero, return the\n** number of unicode characters in the first nByte of pZ (or up to\n** the first 0x00, whichever comes first).\n*/\n    static int sqlite3Utf8CharLen( string zIn, int nByte )\n    {\n      //int r = 0;\n      //string z = zIn;\n      if ( zIn.Length == 0 ) return 0;\n      int zInLength = zIn.Length;\n      int zTerm = ( nByte >= 0 && nByte <= zInLength ) ? nByte : zInLength;\n      ////Debug.Assert( z<=zTerm );\n      //for ( int i = 0 ; i < zTerm ; i++ )      //while( *z!=0 && z<zTerm ){\n      //{\n      //  SQLITE_SKIP_UTF8( ref z);//  SQLITE_SKIP_UTF8(z);\n      //  r++;\n      //}\n      //return r;\n      if ( zTerm == zInLength )\n        return zInLength - ( zIn[zTerm - 1] == 0 ? 1 : 0 );\n      else\n        return nByte;\n    }\n\n    /* This test function is not currently used by the automated test-suite.\n    ** Hence it is only available in debug builds.\n    */\n#if SQLITE_TEST && SQLITE_DEBUG\n    /*\n** Translate UTF-8 to UTF-8.\n**\n** This has the effect of making sure that the string is well-formed\n** UTF-8.  Miscoded characters are removed.\n**\n** The translation is done in-place (since it is impossible for the\n** correct UTF-8 encoding to be longer than a malformed encoding).\n*/\n    //int sqlite3Utf8To8(unsigned char *zIn){\n    //  unsigned char *zOut = zIn;\n    //  unsigned char *zStart = zIn;\n    //  u32 c;\n\n    //  while( zIn[0] ){\n    //    c = sqlite3Utf8Read(zIn, (const u8**)&zIn);\n    //    if( c!=0xfffd ){\n    //      WRITE_UTF8(zOut, c);\n    //    }\n    //  }\n    //  *zOut = 0;\n    //  return (int)(zOut - zStart);\n    //}\n#endif\n\n#if ! SQLITE_OMIT_UTF16\n/*\n** Convert a UTF-16 string in the native encoding into a UTF-8 string.\n** Memory to hold the UTF-8 string is obtained from sqlite3Malloc and must\n** be freed by the calling function.\n**\n** NULL is returned if there is an allocation error.\n*/\nstatic string sqlite3Utf16to8(sqlite3 db, string z, int nByte){\nDebugger.Break (); // TODO -\nMem m = new Mem();\n//  memset(&m, 0, sizeof(m));\n//  m.db = db;\n//  sqlite3VdbeMemSetStr(&m, z, nByte, SQLITE_UTF16NATIVE, SQLITE_STATIC);\n//  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);\n//  if( db.mallocFailed !=0{\n//    sqlite3VdbeMemRelease(&m);\n//    m.z = 0;\n//  }\n//  Debug.Assert( (m.flags & MEM_Term)!=0 || db.mallocFailed !=0);\n//  Debug.Assert( (m.flags & MEM_Str)!=0 || db.mallocFailed !=0);\nreturn m.z;// ( m.flags & MEM_Dyn ) != 0 ? m.z : sqlite3DbStrDup( db, m.z );\n}\n\n/*\n** pZ is a UTF-16 encoded unicode string. If nChar is less than zero,\n** return the number of bytes up to (but not including), the first pair\n** of consecutive 0x00 bytes in pZ. If nChar is not less than zero,\n** then return the number of bytes in the first nChar unicode characters\n** in pZ (or up until the first pair of 0x00 bytes, whichever comes first).\n*/\nint sqlite3Utf16ByteLen(const void *zIn, int nChar){\nint c;\nunsigned char const *z = zIn;\nint n = 0;\nif( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){\n/* Using an "if (SQLITE_UTF16NATIVE==SQLITE_UTF16BE)" construct here\n** and in other parts of this file means that at one branch will\n** not be covered by coverage testing on any single host. But coverage\n** will be complete if the tests are run on both a little-endian and\n** big-endian host. Because both the UTF16NATIVE and SQLITE_UTF16BE\n** macros are constant at compile time the compiler can determine\n** which branch will be followed. It is therefore assumed that no runtime\n** penalty is paid for this "if" statement.\n*/\nwhile( n<nChar ){\nREAD_UTF16BE(z, c);\nn++;\n}\n}else{\nwhile( n<nChar ){\nREAD_UTF16LE(z, c);\nn++;\n}\n}\nreturn (int)(z-(unsigned char const *)zIn);\n}\n\n#if SQLITE_TEST\n/*\n** This routine is called from the TCL test function "translate_selftest".\n** It checks that the primitives for serializing and deserializing\n** characters in each encoding are inverses of each other.\n*/\n/*\n** This routine is called from the TCL test function "translate_selftest".\n** It checks that the primitives for serializing and deserializing\n** characters in each encoding are inverses of each other.\n*/\nvoid sqlite3UtfSelfTest(void){\nunsigned int i, t;\nunsigned char zBuf[20];\nunsigned char *z;\nint n;\nunsigned int c;\n\nfor(i=0; i<0x00110000; i++){\nz = zBuf;\nWRITE_UTF8(z, i);\nn = (int)(z-zBuf);\nassert( n>0 && n<=4 );\nz[0] = 0;\nz = zBuf;\nc = sqlite3Utf8Read(z, (const u8**)&z);\nt = i;\nif( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;\nif( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;\nassert( c==t );\nassert( (z-zBuf)==n );\n}\nfor(i=0; i<0x00110000; i++){\nif( i>=0xD800 && i<0xE000 ) continue;\nz = zBuf;\nWRITE_UTF16LE(z, i);\nn = (int)(z-zBuf);\nassert( n>0 && n<=4 );\nz[0] = 0;\nz = zBuf;\nREAD_UTF16LE(z, c);\nassert( c==i );\nassert( (z-zBuf)==n );\n}\nfor(i=0; i<0x00110000; i++){\nif( i>=0xD800 && i<0xE000 ) continue;\nz = zBuf;\nWRITE_UTF16BE(z, i);\nn = (int)(z-zBuf);\nassert( n>0 && n<=4 );\nz[0] = 0;\nz = zBuf;\nREAD_UTF16BE(z, c);\nassert( c==i );\nassert( (z-zBuf)==n );\n}\n}\n#endif // * SQLITE_TEST */\n#endif // * SQLITE_OMIT_UTF16 */\n  }\n}\n'