b'//Z-Algorithm\n//z[i] is length of prefix starting from i\n\n// always pass stirng by reference, weird how it got me SIGSEGV in a Codechef problem\n// https://codeforces.com/blog/entry/77906 \nvector<int> go(const string &s){\n\tvector<int> z(s.size(), 0);\n\tint i, n = s.size(), L = 0, R = 0;\n\tz[0] = 0;\n\tFo(i, 1, n){\n\t\tif (i > R){\n\t\t\tL = R = i;\n\t\t\twhile(R<n and s[R] == s[R-L]) R++;\n\t\t\tR--;\n\t\t\tz[i] = R-L+1;\n\t\t}\n\t\telse{\n\t\t\tint k = i-L;\n\t\t\tif (z[k] < R-i+1) z[i] = z[k];\n\t\t\telse{\n\t\t\t\tL = i;\n\t\t\t\twhile(R<n and s[R] == s[R-L]) R++;\n\t\t\t\tR--;\n\t\t\t\tz[i] = R-L+1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn z;\n}\n\n\n// another implementation\ntemplate <typename T>\nvector<int> z_function(int n, const T &s) {\n  vector<int> z(n, n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; i++) {\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\n\ntemplate <typename T>\nvector<int> z_function(const T &s) {\n  return z_function((int) s.size(), s);\n}\n\n'