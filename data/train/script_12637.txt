b'{-# LANGUAGE RankNTypes, ViewPatterns #-}\n-- | @since 1.0\nmodule Test.Tasty.Patterns.Eval (Path, eval, withFields, asB) where\n\nimport Prelude hiding (Ordering(..))\nimport Control.Monad ((<=<))\nimport Control.Monad.Trans.Class (lift)\nimport Control.Monad.Trans.Reader (ReaderT, runReaderT, ask)\nimport qualified Data.Sequence as Seq\nimport Data.Foldable\nimport Data.List (findIndex, intercalate, isInfixOf, isPrefixOf, tails)\nimport Data.Maybe\nimport Data.Char\nimport Test.Tasty.Patterns.Types\n#if !MIN_VERSION_base(4,9,0)\nimport Control.Applicative\nimport Data.Traversable\n#endif\n\n-- | @since 1.2\ntype Path = Seq.Seq String\n\ndata Value\n  = VN !Int\n  | VS !Bool String\n    -- ^ The \'Bool\' is \'True\' if the source of the string\n    -- allows it to be numeric\n  | Uninitialized\n  deriving Show\n\ntype M = ReaderT Path (Either String)\n\nthrowError :: String -> M a\nthrowError s = lift $ Left s\n\nasS :: Value -> M String\nasS v = return $\n  case v of\n    VN n -> show n\n    VS _ s -> s\n    Uninitialized -> ""\n\n-- readMaybe was not in base-4.3 yet\nparseN :: String -> Maybe Int\nparseN s =\n  case read s of\n    [(n, "")] -> Just n\n    _ -> Nothing\n\nasN :: Value -> M Int\nasN v =\n  case v of\n    VN n -> return n\n    VS True s ->\n      case parseN s of\n        Just n -> return n\n        Nothing -> throwError $ "Not a number: " ++ show s\n    VS False s -> throwError $ "String is not numeric: " ++ show s\n    Uninitialized -> return 0\n\nisN :: Value -> Bool\nisN v =\n  case v of\n    VN _ -> True\n    _ -> False\n\nisNumeric :: Value -> Bool\nisNumeric v =\n  case v of\n    VS b s -> b && isJust (parseN s)\n    _ -> True\n\n-- | @since 1.0\nasB :: Value -> M Bool\nasB v = return $\n  case v of\n    VN 0 -> False\n    VS _ "" -> False\n    _ -> True\n\nfromB :: Bool -> Value\nfromB = VN . fromEnum\n\n-- | Evaluate an awk expression.\n--\n-- @since 1.0\neval :: Expr -> M Value\neval e0 =\n  case e0 of\n    IntLit n -> return $ VN n\n    StringLit s -> return $ VS False s\n    NF -> VN . subtract 1 . Seq.length <$> ask\n    Add e1 e2 -> binNumOp (+) e1 e2\n    Sub e1 e2 -> binNumOp (-) e1 e2\n    Neg e1 -> VN . negate <$> (asN =<< eval e1)\n    Not e1 -> fromB . not <$> (asB =<< eval e1)\n    And e1 e2 -> binLglOp (&&) e1 e2\n    Or e1 e2  -> binLglOp (||) e1 e2\n    LT e1 e2 -> binCmpOp (<)  e1 e2\n    LE e1 e2 -> binCmpOp (<=) e1 e2\n    GT e1 e2 -> binCmpOp (>)  e1 e2\n    GE e1 e2 -> binCmpOp (>=) e1 e2\n    EQ e1 e2 -> binCmpOp (==) e1 e2\n    NE e1 e2 -> binCmpOp (/=) e1 e2\n    Concat e1 e2 -> VS False <$> ((++) <$> (asS =<< eval e1) <*> (asS =<< eval e2))\n    If cond e1 e2 -> do\n      condV <- asB =<< eval cond\n      if condV then eval e1 else eval e2\n    Field e1 -> do\n      n <- asN =<< eval e1\n      fields <- ask\n      return $ if n > Seq.length fields - 1\n        then Uninitialized\n        else VS True $ Seq.index fields n\n    ERE pat -> do\n      str <- Seq.index <$> ask <*> pure 0\n      return . fromB $ match pat str\n    Match e1 pat -> do\n      str <- asS =<< eval e1\n      return . fromB $ match pat str\n    NoMatch e1 pat -> do\n      str <- asS =<< eval e1\n      return . fromB . not $ match pat str\n    ToUpperFn e1 ->\n      VS True . map toUpper <$> (asS =<< eval e1)\n    ToLowerFn e1 ->\n      VS True . map toLower <$> (asS =<< eval e1)\n    SubstrFn e1 e2 mb_e3 -> do\n      s <- asS =<< eval e1\n      m <- asN =<< eval e2\n      mb_n <- traverse (asN <=< eval) mb_e3\n      return $ VS True $\n        maybe id take mb_n . drop (m-1) $ s\n    LengthFn (fromMaybe (Field (IntLit 0)) ->  e1) ->\n      VN . length <$> (asS =<< eval e1)\n    MatchFn e1 pat -> do\n      s <- asS =<< eval e1\n      return . VN . maybe 0 (+1) . findIndex (pat `isPrefixOf`) $ tails s\n\n  where\n    binNumOp op e1 e2 = VN <$> (op <$> (asN =<< eval e1) <*> (asN =<< eval e2))\n    binLglOp op e1 e2 = fromB <$> (op <$> (asB =<< eval e1) <*> (asB =<< eval e2))\n    binCmpOp :: (forall a . Ord a => a -> a -> Bool) -> Expr -> Expr -> M Value\n    binCmpOp op e1 e2 = do\n      v1 <- eval e1\n      v2 <- eval e2\n      let\n        compareAsNumbers =\n          isN v1 && isNumeric v2 ||\n          isN v2 && isNumeric v1\n      if compareAsNumbers\n        then fromB <$> (op <$> asN v1 <*> asN v2)\n        else fromB <$> (op <$> asS v1 <*> asS v2)\n\nmatch\n  :: String -- ^ pattern\n  -> String -- ^ string\n  -> Bool\nmatch pat str = pat `isInfixOf` str\n\n-- | Run the @M@ monad with a given list of fields\n--\n-- The field list should not include @$0@; it\'s calculated automatically.\n--\n-- @since 1.0\nwithFields :: Seq.Seq String -> M a -> Either String a\nwithFields fields a = runReaderT a (whole Seq.<| fields)\n  where whole = intercalate "." $ toList fields\n'