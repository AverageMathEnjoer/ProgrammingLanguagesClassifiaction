b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Coroutine.Window where\n\nimport Control.Lens (over, set, view, (.~), (^.), _2)\nimport Control.Monad (when)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.State (get, gets, modify, put)\nimport Data.Hoodle.Generic (gdimension)\nimport Data.Hoodle.Simple (Dimension (..))\nimport qualified Data.IntMap as M\nimport qualified Data.List as L\nimport Data.UUID (UUID)\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( getCurrentPageCvsId,\n    pureUpdateUhdl,\n    updateUhdl,\n  )\nimport Hoodle.Coroutine.Draw\n  ( doIOaction_,\n    invalidateAll,\n    invalidateInBBox,\n    nextevent,\n  )\nimport Hoodle.Coroutine.File (getFileContent)\nimport Hoodle.Coroutine.Mode (sing2ContPage)\nimport Hoodle.Coroutine.Page\n  ( canvasZoomUpdateAll,\n    canvasZoomUpdateBufAll,\n    pageZoomChange,\n  )\nimport Hoodle.GUI.Reflect\n  ( blockWhile,\n    changeCurrentCanvasId,\n    reflectCursor,\n    reflectPenModeUI,\n    reflectUIToggle,\n  )\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.ModelAction.Window\n  ( constructFrame,\n    constructFrame\',\n    createTab,\n    eventConnect,\n    newCanvasId,\n    registerFrameToContainer,\n  )\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo (_canvasId),\n    CanvasInfoBox (CanvasContPage, CanvasSinglePage),\n    defaultCvsInfoSinglePage,\n    unboxBiAct,\n    updateCanvasDimForContSingle,\n    updateCanvasDimForSingle,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine, maybeError)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event\n  ( UserEvent (CanvasConfigure, PaneMoveEnd, UpdateCanvas),\n  )\nimport Hoodle.Type.HoodleState\n  ( FileStore,\n    callBack,\n    currentCanvasInfo,\n    currentUnit,\n    cvsInfoMap,\n    emptyUnitHoodle,\n    frameState,\n    getCanvasInfo,\n    getCurrentCanvasId,\n    gtkUIManager,\n    hoodleFileControl,\n    hoodleFileName,\n    hoodleModeState,\n    isFullScreen,\n    isSaved,\n    rootContainer,\n    rootNotebook,\n    rootOfRootWindow,\n    rootWindow,\n    setCanvasInfo,\n    setCanvasInfoMap,\n    switchTabSignal,\n    uiComponentSignalHandler,\n    undoTable,\n    unitButton,\n    unitHoodles,\n    unitKey,\n    unitUUID,\n    updateFromCanvasInfoAsCurrentCanvas,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasDimension (..),\n    PageDimension (..),\n    ZoomMode (FitWidth),\n  )\nimport Hoodle.Type.Undo (emptyUndo)\nimport Hoodle.Type.Window\n  ( SplitType,\n    WindowConfig (Node),\n    removeWindow,\n    splitWindow,\n  )\nimport Hoodle.Util (fromJustError, msgShout)\n\n-- | canvas configure with general zoom update func\ncanvasConfigureGenUpdate ::\n  MainCoroutine () ->\n  CanvasId ->\n  CanvasDimension ->\n  MainCoroutine ()\ncanvasConfigureGenUpdate updatefunc cid cdim =\n  updateUhdl (\\uhdl -> unboxBiAct (fsingle uhdl) (fcont uhdl) (getCanvasInfo cid uhdl)) >> updatefunc\n  where\n    fsingle uhdl cinfo = do\n      cinfo\' <- liftIO $ updateCanvasDimForSingle cdim cinfo\n      return $ setCanvasInfo (cid, CanvasSinglePage cinfo\') uhdl\n    fcont uhdl cinfo = do\n      page <- getCurrentPageCvsId cid\n      let pdim = PageDimension (view gdimension page)\n      cinfo\' <- liftIO $ updateCanvasDimForContSingle pdim cdim cinfo\n      return $ setCanvasInfo (cid, CanvasContPage cinfo\') uhdl\n\n-- |\ndoCanvasConfigure :: CanvasId -> CanvasDimension -> MainCoroutine ()\ndoCanvasConfigure = canvasConfigureGenUpdate canvasZoomUpdateAll\n\n-- |\neitherSplit :: SplitType -> MainCoroutine ()\neitherSplit stype = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  let cmap = view cvsInfoMap uhdl\n      currcid = getCurrentCanvasId uhdl\n      newcid = newCanvasId cmap\n      fstate = view frameState uhdl\n      enewfstate = splitWindow currcid (newcid, stype) fstate\n  case enewfstate of\n    Left _ -> return ()\n    Right fstate\' -> do\n      cinfobox <- maybeError "eitherSplit" . M.lookup currcid $ cmap\n      let callback = view callBack xst\n          rtwin = view rootWindow uhdl\n          rtcntr = view rootContainer uhdl\n          rtrwin = view rootOfRootWindow xst\n      liftIO $ Gtk.containerRemove rtcntr rtwin\n      (uhdl\', win, fstate\'\') <- liftIO $ constructFrame\' callback cinfobox uhdl fstate\'\n      let uhdl\'\' = ((frameState .~ fstate\'\') . (rootWindow .~ win)) uhdl\'\n      let xst3 = (unitHoodles . currentUnit .~ uhdl\'\') xst\n      put xst3\n      liftIO $ registerFrameToContainer rtrwin rtcntr win\n      (uhdl3, _wconf) <- liftIO $ eventConnect xst3 uhdl\'\' (view frameState uhdl\'\')\n      updateUhdl $ const (liftIO $ updatePageAll (view hoodleModeState uhdl3) uhdl3)\n      canvasZoomUpdateAll\n      invalidateAll\n\n-- |\ndeleteCanvas :: MainCoroutine ()\ndeleteCanvas = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cmap = view cvsInfoMap uhdl\n      currcid = getCurrentCanvasId uhdl\n      fstate = view frameState uhdl\n      enewfstate = removeWindow currcid fstate\n  case enewfstate of\n    Left _ -> return ()\n    Right Nothing -> return ()\n    Right (Just fstate\') -> do\n      let cmap\' = M.delete currcid cmap\n          newcurrcid = maximum (M.keys cmap\')\n      updateUhdl $ \\_uhdl -> do\n        uhdl\' <- changeCurrentCanvasId newcurrcid\n        maybe (return uhdl\') return $ setCanvasInfoMap cmap\' uhdl\'\n      xst1 <- get\n      let uhdl1 = view (unitHoodles . currentUnit) xst1\n      let rtwin = view rootWindow uhdl1\n          rtcntr = view rootContainer uhdl1\n          rtrwin = view rootOfRootWindow xst1\n      liftIO $ Gtk.containerRemove rtcntr rtwin\n      (uhdl2, win, fstate\'\') <- liftIO $ constructFrame xst1 uhdl1 fstate\'\n      pureUpdateUhdl (const (((frameState .~ fstate\'\') . (rootWindow .~ win)) uhdl2))\n      xst3 <- get\n      liftIO $ registerFrameToContainer rtrwin rtcntr win\n      updateUhdl $ \\uhdl\' -> do\n        (uhdl\'\', _wconf) <- liftIO $ eventConnect xst3 uhdl\' (view frameState uhdl\')\n        liftIO $ updatePageAll (view hoodleModeState uhdl\'\') uhdl\'\'\n      canvasZoomUpdateAll\n      invalidateAll\n\n-- |\npaneMoveStart :: MainCoroutine ()\npaneMoveStart = do\n  ev <- nextevent\n  case ev of\n    UpdateCanvas cid -> invalidateInBBox Nothing Efficient cid >> paneMoveStart\n    PaneMoveEnd -> return ()\n    CanvasConfigure cid w\' h\' ->\n      canvasConfigureGenUpdate canvasZoomUpdateBufAll cid (CanvasDimension (Dim w\' h\')) >> paneMoveStart\n    _ -> paneMoveStart\n\n-- | not yet implemented?\npaneMoved :: MainCoroutine ()\npaneMoved = msgShout "paneMoved: not implemented"\n\n-- | start full screen mode\nfullScreen :: MainCoroutine ()\nfullScreen = do\n  xst <- get\n  let rwin = view rootOfRootWindow xst\n  if view isFullScreen xst\n    then liftIO (Gtk.windowUnfullscreen rwin) >> modify (over isFullScreen (const False))\n    else liftIO (Gtk.windowFullscreen rwin) >> modify (over isFullScreen (const True))\n\n-- |\naddTab :: FileStore -> MainCoroutine ()\naddTab filestore = do\n  xst <- get\n  let notebook = xst ^. rootNotebook\n      callback = xst ^. callBack\n      btnold = xst ^. (unitHoodles . currentUnit . unitButton)\n  liftIO $ Gtk.widgetSetSensitive btnold False\n  vboxcvs <- liftIO $ Gtk.vBoxNew False 0\n  (tabnum, uuid, btn) <- liftIO $ createTab callback notebook vboxcvs\n  let wconf = Node 1\n      initcvs = defaultCvsInfoSinglePage {_canvasId = 1}\n      initcvsbox = CanvasSinglePage initcvs\n  -- mfp = fileStore2Maybe filestore\n  uhdl\' <-\n    (undoTable .~ emptyUndo 50) -- (undo = 50 for the time being)\n      . (frameState .~ wconf)\n      . updateFromCanvasInfoAsCurrentCanvas initcvsbox\n      . (cvsInfoMap .~ M.empty)\n      . (isSaved .~ True)\n      . (hoodleFileControl . hoodleFileName .~ filestore)\n      . (unitKey .~ tabnum)\n      . (unitUUID .~ uuid)\n      . (unitButton .~ btn)\n      <$> liftIO emptyUnitHoodle\n  modify . set (unitHoodles . currentUnit)\n    =<< liftIO\n      ( do\n          (uhdl\'\', wdgt, _) <- constructFrame xst uhdl\' wconf\n          let uhdl3 = (rootWindow .~ wdgt) . (rootContainer .~ Gtk.castToBox vboxcvs) $ uhdl\'\'\n          (uhdl4, _wconf) <- eventConnect xst uhdl3 (view frameState uhdl3)\n          registerFrameToContainer (xst ^. rootOfRootWindow) (Gtk.castToBox vboxcvs) wdgt\n          Gtk.widgetShowAll notebook\n          return uhdl4\n      )\n\n  doIOaction_ $\n    blockWhile (view (uiComponentSignalHandler . switchTabSignal) xst) $\n      Gtk.set notebook [Gtk.notebookPage Gtk.:= tabnum]\n  getFileContent filestore\n  updateUhdl $ \\uhdl -> do\n    _ <- liftIO (updatePageAll (view hoodleModeState uhdl) uhdl)\n    unboxBiAct (sing2ContPage uhdl) (const (return uhdl)) . view currentCanvasInfo $ uhdl\n  pageZoomChange FitWidth\n  canvasZoomUpdateAll\n  invalidateAll\n  reflectCursor True\n\n-- |\nfindTab :: UUID -> MainCoroutine (Maybe Int)\nfindTab uuid = do\n  uhdlmap <- gets (view (unitHoodles . _2))\n  let assoc = (map (\\x -> (view unitUUID x, view unitKey x)) . M.elems) uhdlmap\n  return (L.lookup uuid assoc)\n\n-- |\nswitchTab :: Int -> MainCoroutine ()\nswitchTab tabnum = do\n  xst <- get\n  let notebook = view rootNotebook xst\n  doIOaction_ $ Gtk.set notebook [Gtk.notebookPage Gtk.:= tabnum]\n  uhdls <- gets (view unitHoodles)\n\n  let current = fst uhdls\n  when (tabnum /= current) $ do\n    let uhdl = fromJustError "switchTab" (M.lookup tabnum (snd uhdls))\n    liftIO $ Gtk.widgetSetSensitive (uhdls ^. (currentUnit . unitButton)) False\n    liftIO $ Gtk.widgetSetSensitive (uhdl ^. unitButton) True\n    modify (unitHoodles . currentUnit .~ uhdl)\n    updateUhdl $ \\uhdl\' -> liftIO (updatePageAll (view hoodleModeState uhdl\') uhdl\')\n    invalidateAll\n    liftIO $ reflectUIToggle (xst ^. gtkUIManager) "SAVEA" (not (uhdl ^. isSaved))\n    reflectPenModeUI\n    reflectCursor True\n\n-- |\ncloseTab :: MainCoroutine ()\ncloseTab = do\n  xst <- get\n  let (currk, uhdlmap) = xst ^. unitHoodles\n      uhdlmap\' = M.delete currk uhdlmap\n      uhdllst\'\' = zipWith (\\x y -> (x, (unitKey .~ x) y)) [0 ..] (M.elems uhdlmap\')\n      uhdlmap\'\' = M.fromList uhdllst\'\'\n      sz = M.size uhdlmap\n  if sz > 1\n    then do\n      let notebook = xst ^. rootNotebook\n      doIOaction_ $ Gtk.notebookRemovePage notebook currk\n      modify (unitHoodles .~ (0, uhdlmap\'\'))\n      canvasZoomUpdateAll\n      switchTab 0\n    else liftIO Gtk.mainQuit\n'