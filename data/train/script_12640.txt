b'{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE PartialTypeSignatures #-}\n{-# OPTIONS_GHC -fglasgow-exts #-}\nmodule Main where\n\nimport Pagila.Schema\n\nimport Database.Beam\nimport Database.Beam.Postgres\nimport Database.Beam.Postgres (PgSyntax(..))\nimport Database.Beam.Postgres.Migrate\nimport Database.Beam.Migrate.Types hiding (migrateScript)\nimport Database.Beam.Migrate.SQL.Tables\nimport Database.Beam.Migrate.SQL.Types\n\nimport qualified Database.PostgreSQL.Simple as Pg\n\nimport qualified Control.Exception as E\n\nimport Data.Text (Text)\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Time.LocalTime (LocalTime)\n\nimport Data.Conduit ((=$=), runConduit)\nimport qualified Data.Conduit.List as CL (mapM_)\n\ntestQuery conn q = runConduit (runSelect conn (select q) =$= CL.mapM_ (putStrLn . show))\n\nmain :: IO ()\nmain = pure ()\n  -- E.bracket (Pg.connectPostgreSQL "dbname=pagila") Pg.close $ \\conn ->\n  -- do let q = do AddressT { .. } <- all_ (addresses db)\n  --               CityT { .. } <- related_ (cities db) addressCity\n  --               CountryT { .. } <- related_ (countries db) cityCountryId\n  --               guard_ (isJust_ addressAddress2)\n  --               pure (addressAddress1, addressDistrict, cityName, addressPostalCode, countryName, addressPhone, addressLastUpdate)\n  --    runConduit (runSelect conn (select q) =$= CL.mapM_ (putStrLn . show))\n\n  --    let q = do store@StoreT { .. } <- all_ (stores db)\n  --               manager <- related_ (staff db) storeManager\n  --               pure (store, manager)\n  --    runConduit (runSelect conn (select q) =$= CL.mapM_ (putStrLn . show))\n\n  --    BL.putStrLn . BL.concat . migrateScript $ migration\n'