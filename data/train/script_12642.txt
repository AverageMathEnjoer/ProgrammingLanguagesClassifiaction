b'/*\n    SPDX-FileCopyrightText: 2016-2019 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "callercalleemodel.h"\n\n#include <KLocalizedString>\n\nCallerCalleeModel::CallerCalleeModel(QObject* parent)\n    : HashModel(parent)\n{\n    qRegisterMetaType<CallerCalleeResults>();\n}\n\nCallerCalleeModel::~CallerCalleeModel() = default;\n\nvoid CallerCalleeModel::setResults(const CallerCalleeResults& results)\n{\n    Q_ASSERT(results.resultData);\n    m_results = results;\n    setRows(results.entries);\n}\n\nvoid CallerCalleeModel::clearData()\n{\n    m_results = {};\n    setRows({});\n}\n\nQVariant CallerCalleeModel::headerCell(int column, int role) const\n{\n    if (role == Qt::InitialSortOrderRole) {\n        return (column > LocationColumn) ? Qt::DescendingOrder : Qt::AscendingOrder;\n    }\n    if (role == Qt::DisplayRole) {\n        switch (static_cast<Columns>(column)) {\n        case LocationColumn:\n            return i18n("Location");\n        case SelfAllocationsColumn:\n            return i18n("Allocations (Self)");\n        case SelfTemporaryColumn:\n            return i18n("Temporary (Self)");\n        case SelfPeakColumn:\n            return i18n("Peak (Self)");\n        case SelfLeakedColumn:\n            return i18n("Leaked (Self)");\n        case InclusiveAllocationsColumn:\n            return i18n("Allocations (Incl.)");\n        case InclusiveTemporaryColumn:\n            return i18n("Temporary (Incl.)");\n        case InclusivePeakColumn:\n            return i18n("Peak (Incl.)");\n        case InclusiveLeakedColumn:\n            return i18n("Leaked (Incl.)");\n        case NUM_COLUMNS:\n            break;\n        }\n    } else if (role == Qt::ToolTipRole) {\n        switch (static_cast<Columns>(column)) {\n        case LocationColumn:\n            return i18n("<qt>The parent symbol that called an allocation function. "\n                        "The function name may be unresolved when debug information is missing.</qt>");\n        case SelfAllocationsColumn:\n            return i18n("<qt>The number of times an allocation function was directly "\n                        "called from this location.</qt>");\n        case SelfTemporaryColumn:\n            return i18n("<qt>The number of direct temporary allocations. These "\n                        "allocations are directly followed by a "\n                        "free without any other allocations in-between.</qt>");\n        case SelfPeakColumn:\n            return i18n("<qt>The maximum heap memory in bytes consumed from "\n                        "allocations originating directly at "\n                        "this location. "\n                        "This takes deallocations into account.</qt>");\n        case SelfLeakedColumn:\n            return i18n("<qt>The bytes allocated directly at this location that have "\n                        "not been deallocated.</qt>");\n        case InclusiveAllocationsColumn:\n            return i18n("<qt>The inclusive number of times an allocation function "\n                        "was called from this location or any "\n                        "functions called from here.</qt>");\n        case InclusiveTemporaryColumn:\n            return i18n("<qt>The number of inclusive temporary allocations. These "\n                        "allocations are directly followed by "\n                        "a free without any other allocations in-between.</qt>");\n        case InclusivePeakColumn:\n            return i18n("<qt>The inclusive maximum heap memory in bytes consumed "\n                        "from allocations originating at this "\n                        "location or from functions called from here. "\n                        "This takes deallocations into account.</qt>");\n        case InclusiveLeakedColumn:\n            return i18n("<qt>The bytes allocated at this location that have not been "\n                        "deallocated.</qt>");\n        case NUM_COLUMNS:\n            break;\n        }\n    }\n    return {};\n}\n\nQVariant CallerCalleeModel::cell(int column, int role, const Symbol& symbol, const CallerCalleeEntry& entry) const\n{\n    if (role == SymbolRole) {\n        return QVariant::fromValue(symbol);\n    } else if (role == SortRole) {\n        switch (static_cast<Columns>(column)) {\n        case LocationColumn:\n            return Util::toString(symbol, *m_results.resultData, Util::Short);\n        case SelfAllocationsColumn:\n            // NOTE: we sort by unsigned absolute value\n            return QVariant::fromValue<quint64>(std::abs(entry.selfCost.allocations));\n        case SelfTemporaryColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.selfCost.temporary));\n        case SelfPeakColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.selfCost.peak));\n        case SelfLeakedColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.selfCost.leaked));\n        case InclusiveAllocationsColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.inclusiveCost.allocations));\n        case InclusiveTemporaryColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.inclusiveCost.temporary));\n        case InclusivePeakColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.inclusiveCost.peak));\n        case InclusiveLeakedColumn:\n            return QVariant::fromValue<quint64>(std::abs(entry.inclusiveCost.leaked));\n        case NUM_COLUMNS:\n            break;\n        }\n    } else if (role == TotalCostRole) {\n        const auto& totalCosts = m_results.resultData->totalCosts();\n        switch (static_cast<Columns>(column)) {\n        case SelfAllocationsColumn:\n        case InclusiveAllocationsColumn:\n            return QVariant::fromValue<qint64>(totalCosts.allocations);\n        case SelfTemporaryColumn:\n        case InclusiveTemporaryColumn:\n            return QVariant::fromValue<qint64>(totalCosts.temporary);\n        case SelfPeakColumn:\n        case InclusivePeakColumn:\n            return QVariant::fromValue<qint64>(totalCosts.peak);\n        case SelfLeakedColumn:\n        case InclusiveLeakedColumn:\n            return QVariant::fromValue<qint64>(totalCosts.leaked);\n        case LocationColumn:\n        case NUM_COLUMNS:\n            break;\n        }\n    } else if (role == Qt::DisplayRole) {\n        switch (static_cast<Columns>(column)) {\n        case LocationColumn:\n            return Util::toString(symbol, *m_results.resultData, Util::Short);\n        case SelfAllocationsColumn:\n            return QVariant::fromValue<qint64>(entry.selfCost.allocations);\n        case SelfTemporaryColumn:\n            return QVariant::fromValue<qint64>(entry.selfCost.temporary);\n        case SelfPeakColumn:\n            return Util::formatBytes(entry.selfCost.peak);\n        case SelfLeakedColumn:\n            return Util::formatBytes(entry.selfCost.leaked);\n        case InclusiveAllocationsColumn:\n            return QVariant::fromValue<qint64>(entry.inclusiveCost.allocations);\n        case InclusiveTemporaryColumn:\n            return QVariant::fromValue<qint64>(entry.inclusiveCost.temporary);\n        case InclusivePeakColumn:\n            return Util::formatBytes(entry.inclusiveCost.peak);\n        case InclusiveLeakedColumn:\n            return Util::formatBytes(entry.inclusiveCost.leaked);\n        case NUM_COLUMNS:\n            break;\n        }\n    } else if (role == CalleesRole) {\n        return QVariant::fromValue(entry.callees);\n    } else if (role == CallersRole) {\n        return QVariant::fromValue(entry.callers);\n    } else if (role == SourceMapRole) {\n        return QVariant::fromValue(entry.sourceMap);\n    } else if (role == Qt::ToolTipRole) {\n        return Util::formatTooltip(symbol, entry.selfCost, entry.inclusiveCost, *m_results.resultData);\n    } else if (role == ResultDataRole) {\n        return QVariant::fromValue(m_results.resultData.get());\n    }\n\n    return {};\n}\n\nQModelIndex CallerCalleeModel::indexForSymbol(const Symbol& symbol) const\n{\n    return indexForKey(symbol);\n}\n\nCallerModel::CallerModel(QObject* parent)\n    : SymbolCostModelImpl(parent)\n{\n}\n\nCallerModel::~CallerModel() = default;\n\nQString CallerModel::symbolHeader() const\n{\n    return i18n("Caller");\n}\n\nCalleeModel::CalleeModel(QObject* parent)\n    : SymbolCostModelImpl(parent)\n{\n}\n\nCalleeModel::~CalleeModel() = default;\n\nQString CalleeModel::symbolHeader() const\n{\n    return i18n("Callee");\n}\n\nSourceMapModel::SourceMapModel(QObject* parent)\n    : LocationCostModelImpl(parent)\n{\n}\n\nSourceMapModel::~SourceMapModel() = default;\n\nint CallerCalleeModel::numColumns() const\n{\n    return NUM_COLUMNS;\n}\n'