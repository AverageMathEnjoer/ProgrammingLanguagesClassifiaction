b'#include "stdafx.h"\n#include "InstallerDataFormat.h"\n#include <InternalBundleReplacer.h>\n#include <cassert>\n\nMODINSTALLER_API InstallerPackageFile::InstallerPackageFile()\n{\n}\nMODINSTALLER_API InstallerPackageFile::~InstallerPackageFile()\n{\n}\n\nbool InstallerPackageFile::Read(QWORD& pos, IAssetsReader *pReader, std::shared_ptr<IAssetsReader> ref_pReader, bool prefReplacersInMemory = false)\n{\n\tDWORD assetsCount = 0;\n\tuint8_t version = 1;\n\t//opCount = 0;\n\t*(DWORD*)(&magic[0]) = 0;\n\taffectedAssets.clear();\n\tmodName.clear();\n\tmodCreators.clear();\n\tmodDescription.clear();\n\n\tpos += pReader->Read(pos, 4, &magic[0]);\n\tif (*(DWORD*)(&magic[0]) != 0x50494D45)\n\t\treturn false;\n\t\n\tpos += pReader->Read(pos, 1, &version);\n\tif (version > 2)\n\t\treturn false;\n\n\tuint16_t nameLen = 0;\n\tpos += pReader->Read(pos, 2, &nameLen);\n\tstd::vector<char> modNameBuf(nameLen);\n\tpos += pReader->Read(pos, nameLen, modNameBuf.data());\n\tmodName.assign(modNameBuf.begin(), modNameBuf.end());\n\t\n\tuint16_t creatorsLen = 0;\n\tpos += pReader->Read(pos, 2, &creatorsLen);\n\tstd::vector<char> modCreatorsBuf(creatorsLen);\n\tpos += pReader->Read(pos, creatorsLen, modCreatorsBuf.data());\n\tmodCreators.assign(modCreatorsBuf.begin(), modCreatorsBuf.end());\n\t\n\tuint16_t descriptionLen = 0;\n\tpos += pReader->Read(pos, 2, &descriptionLen);\n\tstd::vector<char> modDescriptionBuf(descriptionLen);\n\tpos += pReader->Read(pos, descriptionLen, modDescriptionBuf.data());\n\tmodDescription.assign(modDescriptionBuf.begin(), modDescriptionBuf.end());\n\n\tif (version >= 1)\n\t{\n\t\tpos = addedTypes.Read(pReader, pos);\n\t}\n\n\tpos += pReader->Read(pos, 4, &assetsCount);\n\taffectedAssets.reserve(assetsCount);\n\tfor (DWORD i = 0; i < assetsCount; i++)\n\t{\n\t\taffectedAssets.push_back(InstallerPackageAssetsDesc());\n\t\tInstallerPackageAssetsDesc *pDesc = &affectedAssets[i];\n\t\tuint8_t typeVal = 0;\n\t\tpos += pReader->Read(pos, 1, &typeVal);\n\t\tif (typeVal > 2)\n\t\t\treturn false;\n\t\tpDesc->type = static_cast<InstallerPackageAssetsType>((int)typeVal);\n\t\tuint16_t pathLen = 0;\n\t\tpos += pReader->Read(pos, 2, &pathLen);\n\t\tstd::vector<char> pathBuf(pathLen);\n\t\tpos += pReader->Read(pos, pathLen, pathBuf.data());\n\t\tpDesc->path.assign(pathBuf.begin(), pathBuf.end());\n\t\tDWORD replacerCount = 0;\n\t\tpos += pReader->Read(pos, 4, &replacerCount);\n\t\tswitch (pDesc->type)\n\t\t{\n\t\tcase InstallerPackageAssetsType::Assets:\n\t\t\tfor (DWORD k = 0; k < replacerCount; k++)\n\t\t\t{\n\t\t\t\tpDesc->replacers.emplace_back(ref_pReader\n\t\t\t\t\t? ReadAssetsReplacer(pos, ref_pReader, prefReplacersInMemory)\n\t\t\t\t\t: ReadAssetsReplacer(pos, pReader, prefReplacersInMemory));\n\t\t\t\tif (pDesc->replacers.back().get() == nullptr)\n\t\t\t\t{\n\t\t\t\t\tpDesc->replacers.clear();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Bundle:\n\t\t\tfor (DWORD k = 0; k < replacerCount; k++)\n\t\t\t{\n\t\t\t\tpDesc->replacers.emplace_back(ref_pReader\n\t\t\t\t\t? ReadBundleReplacer(pos, ref_pReader, prefReplacersInMemory)\n\t\t\t\t\t: ReadBundleReplacer(pos, pReader, prefReplacersInMemory));\n\t\t\t\tif (pDesc->replacers.back().get() == nullptr)\n\t\t\t\t{\n\t\t\t\t\tpDesc->replacers.clear();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Resources:\n\t\t\tif (replacerCount != 1)\n\t\t\t\treturn false;\n\t\t\tpDesc->replacers.emplace_back(ref_pReader\n\t\t\t\t? ReadBundleReplacer(pos, ref_pReader, prefReplacersInMemory)\n\t\t\t\t: ReadBundleReplacer(pos, pReader, prefReplacersInMemory));\n\t\t\tif (dynamic_cast<BundleEntryModifierByResources*>(pDesc->replacers.back().get()) == nullptr)\n\t\t\t{\n\t\t\t\tpDesc->replacers.clear();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\nMODINSTALLER_API bool InstallerPackageFile::Read(QWORD& pos, IAssetsReader *pReader, bool prefReplacersInMemory)\n{\n\treturn Read(pos, pReader, nullptr, prefReplacersInMemory);\n}\nMODINSTALLER_API bool InstallerPackageFile::Read(QWORD& pos, std::shared_ptr<IAssetsReader> pReader, bool prefReplacersInMemory)\n{\n\tIAssetsReader *_pReader = pReader.get();\n\treturn Read(pos, _pReader, std::move(pReader), prefReplacersInMemory);\n}\nMODINSTALLER_API InstallerPackageAssetsDesc::InstallerPackageAssetsDesc() : type(InstallerPackageAssetsType::Assets){}\nMODINSTALLER_API InstallerPackageAssetsDesc::InstallerPackageAssetsDesc(const InstallerPackageAssetsDesc &src)\n{\n\ttype = src.type;\n\treplacers = src.replacers;\n\tpath = src.path;\n}\nMODINSTALLER_API InstallerPackageAssetsDesc::~InstallerPackageAssetsDesc(){}\nMODINSTALLER_API bool InstallerPackageFile::Write(QWORD& pos, IAssetsWriter *pWriter)\n{\n\t*(DWORD*)(&magic[0]) = 0x50494D45;\n\tpos += pWriter->Write(pos, 4, &magic[0]);\n\n\tuint8_t version = 2;\n\tpos += pWriter->Write(pos, 1, &version);\n\n\tuint16_t nameLen = (uint16_t)modName.size();\n\tpos += pWriter->Write(pos, 2, &nameLen);\n\tpos += pWriter->Write(pos, nameLen, modName.c_str());\n\t\n\tuint16_t creatorsLen = (uint16_t)modCreators.size();\n\tpos += pWriter->Write(pos, 2, &creatorsLen);\n\tpos += pWriter->Write(pos, creatorsLen, modCreators.c_str());\n\t\n\tuint16_t descriptionLen = (uint16_t)modDescription.size();\n\tpos += pWriter->Write(pos, 2, &descriptionLen);\n\tpos += pWriter->Write(pos, descriptionLen, modDescription.c_str());\n\t\n\tif (version >= 1)\n\t{\n\t\tpos = addedTypes.Write(pWriter, pos);\n\t}\n\n\tDWORD assetsCount = (DWORD)affectedAssets.size();\n\tpos += pWriter->Write(pos, 4, &assetsCount);\n\tfor (DWORD i = 0; i < assetsCount; i++)\n\t{\n\t\tInstallerPackageAssetsDesc *pDesc = &affectedAssets[i];\n\t\tuint8_t typeVal = (uint8_t)(uint32_t)pDesc->type;\n\t\tpos += pWriter->Write(pos, 1, &typeVal);\n\n\t\tuint16_t pathLen = (uint16_t)pDesc->path.size();\n\t\tpos += pWriter->Write(pos, 2, &pathLen);\n\t\tpos += pWriter->Write(pos, pathLen, pDesc->path.c_str());\n\n\t\tDWORD replacerCount = (DWORD)pDesc->replacers.size();\n\t\tpos += pWriter->Write(pos, 4, &replacerCount);\n\t\tswitch (pDesc->type)\n\t\t{\n\t\tcase InstallerPackageAssetsType::Assets:\n\t\t\tfor (DWORD k = 0; k < replacerCount; k++)\n\t\t\t\tpos = ((AssetsReplacer*)pDesc->replacers[k].get())->WriteReplacer(pos, pWriter);\n\t\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Bundle:\n\t\t\tfor (DWORD k = 0; k < replacerCount; k++)\n\t\t\t\tpos = ((BundleReplacer*)pDesc->replacers[k].get())->WriteReplacer(pos, pWriter);\n\t\t\tbreak;\n\t\tcase InstallerPackageAssetsType::Resources:\n\t\t\tassert(replacerCount == 1);\n\t\t\tif (replacerCount != 1 || dynamic_cast<BundleEntryModifierByResources*>(pDesc->replacers[0].get()) == nullptr)\n\t\t\t\treturn false;\n\t\t\tpos = ((BundleReplacer*)pDesc->replacers[0].get())->WriteReplacer(pos, pWriter);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n'