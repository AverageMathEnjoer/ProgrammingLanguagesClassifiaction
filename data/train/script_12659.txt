b'{-# LANGUAGE BangPatterns #-}\n\n{-# OPTIONS_HADDOCK not-home #-}\n\n-- |\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- This module provides the various sorting implementations for\n-- "Data.Sequence". Further notes are available in the file sorting.md\n-- (in this directory).\n\nmodule Data.Sequence.Internal.Sorting\n  (\n   -- * Sort Functions\n   sort\n  ,sortBy\n  ,sortOn\n  ,unstableSort\n  ,unstableSortBy\n  ,unstableSortOn\n  ,\n   -- * Heaps\n   -- $heaps\n   Queue(..)\n  ,QList(..)\n  ,IndexedQueue(..)\n  ,IQList(..)\n  ,TaggedQueue(..)\n  ,TQList(..)\n  ,IndexedTaggedQueue(..)\n  ,ITQList(..)\n  ,\n   -- * Merges\n   -- $merges\n   mergeQ\n  ,mergeIQ\n  ,mergeTQ\n  ,mergeITQ\n  ,\n   -- * popMin\n   -- $popMin\n   popMinQ\n  ,popMinIQ\n  ,popMinTQ\n  ,popMinITQ\n  ,\n   -- * Building\n   -- $building\n   buildQ\n  ,buildIQ\n  ,buildTQ\n  ,buildITQ\n  ,\n   -- * Special folds\n   -- $folds\n   foldToMaybeTree\n  ,foldToMaybeWithIndexTree)\n  where\n\nimport Data.Sequence.Internal\n       (Elem(..), Seq(..), Node(..), Digit(..), Sized(..), FingerTree(..),\n        replicateA, foldDigit, foldNode, foldWithIndexDigit,\n        foldWithIndexNode)\nimport Utils.Containers.Internal.State (State(..), execState)\n-- | \\( O(n \\log n) \\).  \'sort\' sorts the specified \'Seq\' by the natural\n-- ordering of its elements.  The sort is stable.  If stability is not\n-- required, \'unstableSort\' can be slightly faster.\n--\n-- @since 0.3.0\nsort :: Ord a => Seq a -> Seq a\nsort = sortBy compare\n\n-- | \\( O(n \\log n) \\).  \'sortBy\' sorts the specified \'Seq\' according to the\n-- specified comparator.  The sort is stable.  If stability is not required,\n-- \'unstableSortBy\' can be slightly faster.\n--\n-- @since 0.3.0\nsortBy :: (a -> a -> Ordering) -> Seq a -> Seq a\nsortBy cmp (Seq xs) =\n    maybe\n        (Seq EmptyT)\n        (execState (replicateA (size xs) (State (popMinIQ cmp))))\n        (buildIQ cmp (\\s (Elem x) -> IQ s x IQNil) 0 xs)\n\n-- | \\( O(n \\log n) \\). \'sortOn\' sorts the specified \'Seq\' by comparing\n-- the results of a key function applied to each element. @\'sortOn\' f@ is\n-- equivalent to @\'sortBy\' (\'compare\' ``Data.Function.on`` f)@, but has the\n-- performance advantage of only evaluating @f@ once for each element in the\n-- input list. This is called the decorate-sort-undecorate paradigm, or\n-- Schwartzian transform.\n--\n-- An example of using \'sortOn\' might be to sort a \'Seq\' of strings\n-- according to their length:\n--\n-- > sortOn length (fromList ["alligator", "monkey", "zebra"]) == fromList ["zebra", "monkey", "alligator"]\n--\n-- If, instead, \'sortBy\' had been used, \'length\' would be evaluated on\n-- every comparison, giving \\( O(n \\log n) \\) evaluations, rather than\n-- \\( O(n) \\).\n--\n-- If @f@ is very cheap (for example a record selector, or \'fst\'),\n-- @\'sortBy\' (\'compare\' ``Data.Function.on`` f)@ will be faster than\n-- @\'sortOn\' f@.\n--\n-- @since 0.5.11\nsortOn :: Ord b => (a -> b) -> Seq a -> Seq a\nsortOn f (Seq xs) =\n    maybe\n       (Seq EmptyT)\n       (execState (replicateA (size xs) (State (popMinITQ compare))))\n       (buildITQ compare (\\s (Elem x) -> ITQ s (f x) x ITQNil) 0 xs)\n\n-- | \\( O(n \\log n) \\).  \'unstableSort\' sorts the specified \'Seq\' by\n-- the natural ordering of its elements, but the sort is not stable.\n-- This algorithm is frequently faster and uses less memory than \'sort\'.\n\n-- Notes on the implementation and choice of heap are available in\n-- the file sorting.md (in this directory).\n--\n-- @since 0.3.0\nunstableSort :: Ord a => Seq a -> Seq a\nunstableSort = unstableSortBy compare\n\n-- | \\( O(n \\log n) \\).  A generalization of \'unstableSort\', \'unstableSortBy\'\n-- takes an arbitrary comparator and sorts the specified sequence.\n-- The sort is not stable.  This algorithm is frequently faster and\n-- uses less memory than \'sortBy\'.\n--\n-- @since 0.3.0\nunstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a\nunstableSortBy cmp (Seq xs) =\n    maybe\n        (Seq EmptyT)\n        (execState (replicateA (size xs) (State (popMinQ cmp))))\n        (buildQ cmp (\\(Elem x) -> Q x Nil) xs)\n\n-- | \\( O(n \\log n) \\). \'unstableSortOn\' sorts the specified \'Seq\' by\n-- comparing the results of a key function applied to each element.\n-- @\'unstableSortOn\' f@ is equivalent to @\'unstableSortBy\' (\'compare\' ``Data.Function.on`` f)@,\n-- but has the performance advantage of only evaluating @f@ once for each\n-- element in the input list. This is called the\n-- decorate-sort-undecorate paradigm, or Schwartzian transform.\n--\n-- An example of using \'unstableSortOn\' might be to sort a \'Seq\' of strings\n-- according to their length:\n--\n-- > unstableSortOn length (fromList ["alligator", "monkey", "zebra"]) == fromList ["zebra", "monkey", "alligator"]\n--\n-- If, instead, \'unstableSortBy\' had been used, \'length\' would be evaluated on\n-- every comparison, giving \\( O(n \\log n) \\) evaluations, rather than\n-- \\( O(n) \\).\n--\n-- If @f@ is very cheap (for example a record selector, or \'fst\'),\n-- @\'unstableSortBy\' (\'compare\' ``Data.Function.on`` f)@ will be faster than\n-- @\'unstableSortOn\' f@.\n--\n-- @since 0.5.11\nunstableSortOn :: Ord b => (a -> b) -> Seq a -> Seq a\nunstableSortOn f (Seq xs) =\n    maybe\n       (Seq EmptyT)\n       (execState (replicateA (size xs) (State (popMinTQ compare))))\n       (buildTQ compare (\\(Elem x) -> TQ (f x) x TQNil) xs)\n\n------------------------------------------------------------------------\n-- $heaps\n--\n-- The following are definitions for various specialized pairing heaps.\n--\n-- All of the heaps are defined to be non-empty, which speeds up the\n-- merge functions.\n------------------------------------------------------------------------\n\n-- | A simple pairing heap.\ndata Queue e = Q !e (QList e)\ndata QList e\n    = Nil\n    | QCons {-# UNPACK #-} !(Queue e)\n            (QList e)\n\n-- | A pairing heap tagged with the original position of elements,\n-- to allow for stable sorting.\ndata IndexedQueue e =\n    IQ {-# UNPACK #-} !Int !e (IQList e)\ndata IQList e\n    = IQNil\n    | IQCons {-# UNPACK #-} !(IndexedQueue e)\n             (IQList e)\n\n-- | A pairing heap tagged with some key for sorting elements, for use\n-- in \'unstableSortOn\'.\ndata TaggedQueue a b =\n    TQ !a b (TQList a b)\ndata TQList a b\n    = TQNil\n    | TQCons {-# UNPACK #-} !(TaggedQueue a b)\n             (TQList a b)\n\n-- | A pairing heap tagged with both a key and the original position\n-- of its elements, for use in \'sortOn\'.\ndata IndexedTaggedQueue e a =\n    ITQ {-# UNPACK #-} !Int !e a (ITQList e a)\ndata ITQList e a\n    = ITQNil\n    | ITQCons {-# UNPACK #-} !(IndexedTaggedQueue e a)\n              (ITQList e a)\n\ninfixr 8 `ITQCons`, `TQCons`, `QCons`, `IQCons`\n\n------------------------------------------------------------------------\n-- $merges\n--\n-- The following are definitions for "merge" for each of the heaps\n-- above. Each takes a comparison function which is used to order the\n-- elements.\n------------------------------------------------------------------------\n\n-- | \'mergeQ\' merges two \'Queue\'s.\nmergeQ :: (a -> a -> Ordering) -> Queue a -> Queue a -> Queue a\nmergeQ cmp q1@(Q x1 ts1) q2@(Q x2 ts2)\n  | cmp x1 x2 == GT = Q x2 (q1 `QCons` ts2)\n  | otherwise       = Q x1 (q2 `QCons` ts1)\n\n-- | \'mergeTQ\' merges two \'TaggedQueue\'s, based on the tag value.\nmergeTQ :: (a -> a -> Ordering)\n        -> TaggedQueue a b\n        -> TaggedQueue a b\n        -> TaggedQueue a b\nmergeTQ cmp q1@(TQ x1 y1 ts1) q2@(TQ x2 y2 ts2)\n  | cmp x1 x2 == GT = TQ x2 y2 (q1 `TQCons` ts2)\n  | otherwise       = TQ x1 y1 (q2 `TQCons` ts1)\n\n-- | \'mergeIQ\' merges two \'IndexedQueue\'s, taking into account the\n-- original position of the elements.\nmergeIQ :: (a -> a -> Ordering)\n        -> IndexedQueue a\n        -> IndexedQueue a\n        -> IndexedQueue a\nmergeIQ cmp q1@(IQ i1 x1 ts1) q2@(IQ i2 x2 ts2) =\n    case cmp x1 x2 of\n        LT -> IQ i1 x1 (q2 `IQCons` ts1)\n        EQ | i1 <= i2 -> IQ i1 x1 (q2 `IQCons` ts1)\n        _ -> IQ i2 x2 (q1 `IQCons` ts2)\n\n-- | \'mergeITQ\' merges two \'IndexedTaggedQueue\'s, based on the tag\n-- value, taking into account the original position of the elements.\nmergeITQ\n    :: (a -> a -> Ordering)\n    -> IndexedTaggedQueue a b\n    -> IndexedTaggedQueue a b\n    -> IndexedTaggedQueue a b\nmergeITQ cmp q1@(ITQ i1 x1 y1 ts1) q2@(ITQ i2 x2 y2 ts2) =\n    case cmp x1 x2 of\n        LT -> ITQ i1 x1 y1 (q2 `ITQCons` ts1)\n        EQ | i1 <= i2 -> ITQ i1 x1 y1 (q2 `ITQCons` ts1)\n        _ -> ITQ i2 x2 y2 (q1 `ITQCons` ts2)\n\n------------------------------------------------------------------------\n-- $popMin\n--\n-- The following are definitions for @popMin@, a function which\n-- constructs a stateful action which pops the smallest element from the\n-- queue, where "smallest" is according to the supplied comparison\n-- function.\n--\n-- All of the functions fail on an empty queue.\n--\n-- Each of these functions is structured something like this:\n--\n-- @popMinQ cmp (Q x ts) = (mergeQs ts, x)@\n--\n-- The reason the call to @mergeQs@ is lazy is that it will be bottom\n-- for the last element in the queue, preventing us from evaluating the\n-- fully sorted sequence.\n------------------------------------------------------------------------\n\n-- | Pop the smallest element from the queue, using the supplied\n-- comparator.\npopMinQ :: (e -> e -> Ordering) -> Queue e -> (Queue e, e)\npopMinQ cmp (Q x xs) = (mergeQs xs, x)\n  where\n    mergeQs (t `QCons` Nil) = t\n    mergeQs (t1 `QCons` t2 `QCons` Nil) = t1 <+> t2\n    mergeQs (t1 `QCons` t2 `QCons` ts) = (t1 <+> t2) <+> mergeQs ts\n    mergeQs Nil = error "popMinQ: tried to pop from empty queue"\n    (<+>) = mergeQ cmp\n\n-- | Pop the smallest element from the queue, using the supplied\n-- comparator, deferring to the item\'s original position when the\n-- comparator returns \'EQ\'.\npopMinIQ :: (e -> e -> Ordering) -> IndexedQueue e -> (IndexedQueue e, e)\npopMinIQ cmp (IQ _ x xs) = (mergeQs xs, x)\n  where\n    mergeQs (t `IQCons` IQNil) = t\n    mergeQs (t1 `IQCons` t2 `IQCons` IQNil) = t1 <+> t2\n    mergeQs (t1 `IQCons` t2 `IQCons` ts) = (t1 <+> t2) <+> mergeQs ts\n    mergeQs IQNil = error "popMinQ: tried to pop from empty queue"\n    (<+>) = mergeIQ cmp\n\n-- | Pop the smallest element from the queue, using the supplied\n-- comparator on the tag.\npopMinTQ :: (a -> a -> Ordering) -> TaggedQueue a b -> (TaggedQueue a b, b)\npopMinTQ cmp (TQ _ x xs) = (mergeQs xs, x)\n  where\n    mergeQs (t `TQCons` TQNil) = t\n    mergeQs (t1 `TQCons` t2 `TQCons` TQNil) = t1 <+> t2\n    mergeQs (t1 `TQCons` t2 `TQCons` ts) = (t1 <+> t2) <+> mergeQs ts\n    mergeQs TQNil = error "popMinQ: tried to pop from empty queue"\n    (<+>) = mergeTQ cmp\n\n-- | Pop the smallest element from the queue, using the supplied\n-- comparator on the tag, deferring to the item\'s original position\n-- when the comparator returns \'EQ\'.\npopMinITQ :: (e -> e -> Ordering)\n          -> IndexedTaggedQueue e b\n          -> (IndexedTaggedQueue e b, b)\npopMinITQ cmp (ITQ _ _ x xs) = (mergeQs xs, x)\n  where\n    mergeQs (t `ITQCons` ITQNil) = t\n    mergeQs (t1 `ITQCons` t2 `ITQCons` ITQNil) = t1 <+> t2\n    mergeQs (t1 `ITQCons` t2 `ITQCons` ts) = (t1 <+> t2) <+> mergeQs ts\n    mergeQs ITQNil = error "popMinQ: tried to pop from empty queue"\n    (<+>) = mergeITQ cmp\n\n------------------------------------------------------------------------\n-- $building\n--\n-- The following are definitions for functions to build queues, given a\n-- comparison function.\n------------------------------------------------------------------------\n\nbuildQ :: (b -> b -> Ordering) -> (a -> Queue b) -> FingerTree a -> Maybe (Queue b)\nbuildQ cmp = foldToMaybeTree (mergeQ cmp)\n\nbuildIQ\n    :: (b -> b -> Ordering)\n    -> (Int -> Elem y -> IndexedQueue b)\n    -> Int\n    -> FingerTree (Elem y)\n    -> Maybe (IndexedQueue b)\nbuildIQ cmp = foldToMaybeWithIndexTree (mergeIQ cmp)\n\nbuildTQ\n    :: (b -> b -> Ordering)\n    -> (a -> TaggedQueue b c)\n    -> FingerTree a\n    -> Maybe (TaggedQueue b c)\nbuildTQ cmp = foldToMaybeTree (mergeTQ cmp)\n\nbuildITQ\n    :: (b -> b -> Ordering)\n    -> (Int -> Elem y -> IndexedTaggedQueue b c)\n    -> Int\n    -> FingerTree (Elem y)\n    -> Maybe (IndexedTaggedQueue b c)\nbuildITQ cmp = foldToMaybeWithIndexTree (mergeITQ cmp)\n\n------------------------------------------------------------------------\n-- $folds\n--\n-- A big part of what makes the heaps fast is that they\'re non empty,\n-- so the merge function can avoid an extra case match. To take\n-- advantage of this, though, we need specialized versions of \'foldMap\'\n-- and \'Data.Sequence.foldMapWithIndex\', which can alternate between\n-- calling the faster semigroup-like merge when folding over non empty\n-- structures (like \'Node\' and \'Digit\'), and the\n-- \'Data.Semirgroup.Option\'-like mappend, when folding over structures\n-- which can be empty (like \'FingerTree\').\n------------------------------------------------------------------------\n\n-- | A \'foldMap\'-like function, specialized to the\n-- \'Data.Semigroup.Option\' monoid, which takes advantage of the\n-- internal structure of \'Seq\' to avoid wrapping in \'Maybe\' at certain\n-- points.\nfoldToMaybeTree :: (b -> b -> b) -> (a -> b) -> FingerTree a -> Maybe b\nfoldToMaybeTree _ _ EmptyT = Nothing\nfoldToMaybeTree _ f (Single xs) = Just (f xs)\nfoldToMaybeTree (<+>) f (Deep _ pr m sf) =\n    Just (maybe (pr\' <+> sf\') ((pr\' <+> sf\') <+>) m\')\n  where\n    pr\' = foldDigit (<+>) f pr\n    sf\' = foldDigit (<+>) f sf\n    m\' = foldToMaybeTree (<+>) (foldNode (<+>) f) m\n\n-- | A \'Data.Sequence.foldMapWithIndex\'-like function, specialized to the\n-- \'Data.Semigroup.Option\' monoid, which takes advantage of the\n-- internal structure of \'Seq\' to avoid wrapping in \'Maybe\' at certain\n-- points.\nfoldToMaybeWithIndexTree :: (b -> b -> b)\n                         -> (Int -> Elem y -> b)\n                         -> Int\n                         -> FingerTree (Elem y)\n                         -> Maybe b\nfoldToMaybeWithIndexTree = foldToMaybeWithIndexTree\'\n  where\n    {-# SPECIALISE foldToMaybeWithIndexTree\' :: (b -> b -> b) -> (Int -> Elem y -> b) -> Int -> FingerTree (Elem y) -> Maybe b #-}\n    {-# SPECIALISE foldToMaybeWithIndexTree\' :: (b -> b -> b) -> (Int -> Node y -> b) -> Int -> FingerTree (Node y) -> Maybe b #-}\n    foldToMaybeWithIndexTree\'\n        :: Sized a\n        => (b -> b -> b) -> (Int -> a -> b) -> Int -> FingerTree a -> Maybe b\n    foldToMaybeWithIndexTree\' _ _ !_s EmptyT = Nothing\n    foldToMaybeWithIndexTree\' _ f s (Single xs) = Just (f s xs)\n    foldToMaybeWithIndexTree\' (<+>) f s (Deep _ pr m sf) =\n        Just (maybe (pr\' <+> sf\') ((pr\' <+> sf\') <+>) m\')\n      where\n        pr\' = digit (<+>) f s pr\n        sf\' = digit (<+>) f sPsprm sf\n        m\' = foldToMaybeWithIndexTree\' (<+>) (node (<+>) f) sPspr m\n        !sPspr = s + size pr\n        !sPsprm = sPspr + size m\n    {-# SPECIALISE digit :: (b -> b -> b) -> (Int -> Elem y -> b) -> Int -> Digit (Elem y) -> b #-}\n    {-# SPECIALISE digit :: (b -> b -> b) -> (Int -> Node y -> b) -> Int -> Digit (Node y) -> b #-}\n    digit\n        :: Sized a\n        => (b -> b -> b) -> (Int -> a -> b) -> Int -> Digit a -> b\n    digit = foldWithIndexDigit\n    {-# SPECIALISE node :: (b -> b -> b) -> (Int -> Elem y -> b) -> Int -> Node (Elem y) -> b #-}\n    {-# SPECIALISE node :: (b -> b -> b) -> (Int -> Node y -> b) -> Int -> Node (Node y) -> b #-}\n    node\n        :: Sized a\n        => (b -> b -> b) -> (Int -> a -> b) -> Int -> Node a -> b\n    node = foldWithIndexNode\n{-# INLINE foldToMaybeWithIndexTree #-}\n'