b'// UVa11584 Partitioning by Palindromes\n// Rujia Liu\n// This code is slightly different from the book.\n// It uses memoization to judge whether s[i..j] is a palindrome.\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 1000 + 5;\nint n, kase, vis[maxn][maxn], p[maxn][maxn], d[maxn];\nchar s[maxn];\n\nint is_palindrome(int i, int j) {\n  if(i >= j) return 1;\n  if(s[i] != s[j]) return 0;\n\n  if(vis[i][j] == kase) return p[i][j];\n  vis[i][j] = kase;\n  p[i][j] = is_palindrome(i+1, j-1);\n  return p[i][j];\n}\n\nint main() {\n  int T;\n  scanf("%d", &T);\n  memset(vis, 0, sizeof(vis));\n  for(kase = 1; kase <= T; kase++) {\n    scanf("%s", s+1);\n    n = strlen(s+1);\n    d[0] = 0;\n    for(int i = 1; i <= n; i++) {\n      d[i] = i+1;\n      for(int j = 0; j < i; j++)\n        if(is_palindrome(j+1, i)) d[i] = min(d[i], d[j] + 1);\n    }\n    printf("%d\\n", d[n]);\n  }\n  return 0;\n}\n'