b'/*\n * Copyright (C) 2015 tyrantgit\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n package tyrantgit.explosionfield;\n\nimport android.animation.ValueAnimator;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.view.View;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.Interpolator;\n\nimport java.util.Random;\n\npublic class ExplosionAnimator extends ValueAnimator {\n\n    static long DEFAULT_DURATION = 0x400;\n    private static final Interpolator DEFAULT_INTERPOLATOR = new AccelerateInterpolator(0.6f);\n    private static final float END_VALUE = 1.4f;\n    private static final float X = Utils.dp2Px(5);\n    private static final float Y = Utils.dp2Px(20);\n    private static final float V = Utils.dp2Px(2);\n    private static final float W = Utils.dp2Px(1);\n    private Paint mPaint;\n    private Particle[] mParticles;\n    private Rect mBound;\n    private View mContainer;\n\n    public ExplosionAnimator(View container, Bitmap bitmap, Rect bound) {\n        mPaint = new Paint();\n        mBound = new Rect(bound);\n        int partLen = 15;\n        mParticles = new Particle[partLen * partLen];\n        Random random = new Random(System.currentTimeMillis());\n        int w = bitmap.getWidth() / (partLen + 2);\n        int h = bitmap.getHeight() / (partLen + 2);\n        for (int i = 0; i < partLen; i++) {\n            for (int j = 0; j < partLen; j++) {\n                mParticles[(i * partLen) + j] = generateParticle(bitmap.getPixel((j + 1) * w, (i + 1) * h), random);\n            }\n        }\n        mContainer = container;\n        setFloatValues(0f, END_VALUE);\n        setInterpolator(DEFAULT_INTERPOLATOR);\n        setDuration(DEFAULT_DURATION);\n    }\n\n    private Particle generateParticle(int color, Random random) {\n        Particle particle = new Particle();\n        particle.color = color;\n        particle.radius = V;\n        if (random.nextFloat() < 0.2f) {\n            particle.baseRadius = V + ((X - V) * random.nextFloat());\n        } else {\n            particle.baseRadius = W + ((V - W) * random.nextFloat());\n        }\n        float nextFloat = random.nextFloat();\n        particle.top = mBound.height() * ((0.18f * random.nextFloat()) + 0.2f);\n        particle.top = nextFloat < 0.2f ? particle.top : particle.top + ((particle.top * 0.2f) * random.nextFloat());\n        particle.bottom = (mBound.height() * (random.nextFloat() - 0.5f)) * 1.8f;\n        float f = nextFloat < 0.2f ? particle.bottom : nextFloat < 0.8f ? particle.bottom * 0.6f : particle.bottom * 0.3f;\n        particle.bottom = f;\n        particle.mag = 4.0f * particle.top / particle.bottom;\n        particle.neg = (-particle.mag) / particle.bottom;\n        f = mBound.centerX() + (Y * (random.nextFloat() - 0.5f));\n        particle.baseCx = f;\n        particle.cx = f;\n        f = mBound.centerY() + (Y * (random.nextFloat() - 0.5f));\n        particle.baseCy = f;\n        particle.cy = f;\n        particle.life = END_VALUE / 10 * random.nextFloat();\n        particle.overflow = 0.4f * random.nextFloat();\n        particle.alpha = 1f;\n        return particle;\n    }\n\n    public boolean draw(Canvas canvas) {\n        if (!isStarted()) {\n            return false;\n        }\n        for (Particle particle : mParticles) {\n            particle.advance((float) getAnimatedValue());\n            if (particle.alpha > 0f) {\n                mPaint.setColor(particle.color);\n                mPaint.setAlpha((int) (Color.alpha(particle.color) * particle.alpha));\n                canvas.drawCircle(particle.cx, particle.cy, particle.radius, mPaint);\n            }\n        }\n        mContainer.invalidate();\n        return true;\n    }\n\n    @Override\n    public void start() {\n        super.start();\n        mContainer.invalidate(mBound);\n    }\n\n    private class Particle {\n        float alpha;\n        int color;\n        float cx;\n        float cy;\n        float radius;\n        float baseCx;\n        float baseCy;\n        float baseRadius;\n        float top;\n        float bottom;\n        float mag;\n        float neg;\n        float life;\n        float overflow;\n\n\n        public void advance(float factor) {\n            float f = 0f;\n            float normalization = factor / END_VALUE;\n            if (normalization < life || normalization > 1f - overflow) {\n                alpha = 0f;\n                return;\n            }\n            normalization = (normalization - life) / (1f - life - overflow);\n            float f2 = normalization * END_VALUE;\n            if (normalization >= 0.7f) {\n                f = (normalization - 0.7f) / 0.3f;\n            }\n            alpha = 1f - f;\n            f = bottom * f2;\n            cx = baseCx + f;\n            cy = (float) (baseCy - this.neg * Math.pow(f, 2.0)) - f * mag;\n            radius = V + (baseRadius - V) * f2;\n        }\n    }\n}\n'