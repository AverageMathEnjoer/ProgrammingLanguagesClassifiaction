b'{-# LANGUAGE ScopedTypeVariables, FlexibleInstances,\n             MultiParamTypeClasses, UndecidableInstances, CPP #-}\n\n-- | This module provides a notion of (Splittable) State that is\n--   compatible with any Par monad.\n--\n--   This module provides instances that make StateT-transformed\n--   monads into valid Par monads.\n\nmodule Control.Monad.Par.State\n  (\n   SplittableState(..)\n  )\n  where\n\nimport qualified Control.Monad.Par.Class as PC\nimport Control.Monad.Trans\nimport qualified Control.Monad.Trans.State.Strict as S\nimport qualified Control.Monad.Trans.State.Lazy as SL\n\n---------------------------------------------------------------------------------\n--- Make Par computations with state work.\n--- (TODO: move these instances to a different module.)\n\n-- | A type in `SplittableState` is meant to be added to a Par monad\n--   using StateT.  It works like any other state except at `fork`\n--   points, where the runtime system splits the state using `splitState`.\n--\n--   Common examples for applications of `SplittableState` would\n--   include (1) routing a splittable random number generator through\n--   a parallel computation, and (2) keeping a tree-index that locates\n--   the current computation within the binary tree of `fork`s.\n--   Also, it is possible to simply duplicate the state at all fork points,\n--   enabling "thread local" copies of the state.\n--\n--   The limitation of this approach is that the splitting method is\n--   fixed, and the same at all `fork` points.\nclass SplittableState a where\n  splitState :: a -> (a,a)\n\n----------------------------------------------------------------------------------------------------\n-- Strict State:\n\n-- | Adding State to a `ParFuture` monad yields another `ParFuture` monad.\ninstance (SplittableState s, PC.ParFuture fut p)\n      =>  PC.ParFuture fut (S.StateT s p)\n where\n  get = lift . PC.get\n  spawn_ (task :: S.StateT s p ans) =\n    do s <- S.get\n       let (s1,s2) = splitState s\n       S.put s2                               -- Parent comp. gets one branch.\n       lift$ PC.spawn_ $ S.evalStateT task s1   -- Child the other.\n\n-- | Likewise, adding State to a `ParIVar` monad yield s another `ParIVar` monad.\ninstance (SplittableState s, PC.ParIVar iv p)\n      =>  PC.ParIVar iv (S.StateT s p)\n where\n  fork (task :: S.StateT s p ()) =\n              do s <- S.get\n                 let (s1,s2) = splitState s\n                 S.put s2\n                 lift$ PC.fork $ do _ <- S.runStateT task s1; return ()\n\n  new      = lift PC.new\n  put_ v x = lift$ PC.put_ v x\n  newFull_ = lift . PC.newFull_\n\n-- ParChan not released yet:\n#if 0\n-- | Likewise, adding State to a `ParChan` monad yield s another `ParChan` monad.\ninstance (SplittableState s, PC.ParChan snd rcv p)\n      =>  PC.ParChan snd rcv (S.StateT s p)\n where\n   newChan  = lift   PC.newChan\n   recv   r = lift $ PC.recv r\n   send s x = lift $ PC.send s x\n#endif\n\n\n----------------------------------------------------------------------------------------------------\n-- Lazy State:\n\n-- <DUPLICATE_CODE>\n\n-- | Adding State to a `ParFuture` monad yield s another `ParFuture` monad.\ninstance (SplittableState s, PC.ParFuture fut p)\n      =>  PC.ParFuture fut (SL.StateT s p)\n where\n  get = lift . PC.get\n  spawn_ (task :: SL.StateT s p ans) =\n    do s <- SL.get\n       let (s1,s2) = splitState s\n       SL.put s2                               -- Parent comp. gets one branch.\n       lift$ PC.spawn_ $ SL.evalStateT task s1   -- Child the other.\n\n-- | Likewise, adding State to a `ParIVar` monad yield s another `ParIVar` monad.\ninstance (SplittableState s, PC.ParIVar iv p)\n      =>  PC.ParIVar iv (SL.StateT s p)\n where\n  fork (task :: SL.StateT s p ()) =\n              do s <- SL.get\n                 let (s1,s2) = splitState s\n                 SL.put s2\n                 lift$ PC.fork $ do _ <- SL.runStateT task s1; return ()\n\n  new      = lift PC.new\n  put_ v x = lift$ PC.put_ v x\n  newFull_ = lift . PC.newFull_\n\n#if 0\n-- | Likewise, adding State to a `ParChan` monad yield s another `ParChan` monad.\ninstance (SplittableState s, PC.ParChan snd rcv p)\n      =>  PC.ParChan snd rcv (SL.StateT s p)\n where\n   newChan  = lift   PC.newChan\n   recv   r = lift $ PC.recv r\n   send s x = lift $ PC.send s x\n#endif\n\n-- </DUPLICATE_CODE>\n'