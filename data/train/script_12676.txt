b'{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\n-- | Defines common \'DatabasePredicate\'s that are shared among backends\nmodule Database.Beam.Migrate.Checks where\n\nimport Database.Beam.Backend.SQL.SQL92\nimport Database.Beam.Migrate.SQL.SQL92\nimport Database.Beam.Migrate.SQL.Types\nimport Database.Beam.Migrate.Serialization\nimport Database.Beam.Migrate.Types.Predicates\n\nimport Data.Aeson ((.:), (.=), withObject, object)\nimport Data.Aeson.Types (Parser, Value)\nimport Data.Hashable (Hashable(..))\nimport Data.Text (Text)\nimport Data.Typeable (Typeable, cast)\n#if !MIN_VERSION_base(4, 11, 0)\nimport Data.Semigroup\n#endif\n\nimport GHC.Generics (Generic)\n\n-- * Table checks\n\n-- | Asserts that a table with the given name exists in a database\ndata TableExistsPredicate = TableExistsPredicate QualifiedName {-^ Table name -}\n  deriving (Show, Eq, Ord, Typeable, Generic)\ninstance Hashable TableExistsPredicate\ninstance DatabasePredicate TableExistsPredicate where\n  englishDescription (TableExistsPredicate t) =\n    "Table " <> show t <> " must exist"\n\n  serializePredicate (TableExistsPredicate t) =\n    object [ "table-exists" .= t ]\n\n  predicateSpecificity _ = PredicateSpecificityAllBackends\n\n-- | A class that can check whether a particular data type is present\n-- in a set of preconditions.\nclass HasDataTypeCreatedCheck dataType where\n  dataTypeHasBeenCreated :: dataType -> (forall preCondition. Typeable preCondition => [ preCondition ]) -> Bool\n\n-- | Asserts that the table specified has a column with the given data type. The\n-- type paramater @syntax@ should be an instance of \'IsSql92ColumnSchemaSyntax\'.\ndata TableHasColumn be where\n  TableHasColumn\n    :: ( HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be) )\n    => { hasColumn_table  :: QualifiedName {-^ Table name -}\n       , hasColumn_column :: Text {-^ Column name -}\n       , hasColumn_type   :: BeamMigrateSqlBackendDataTypeSyntax be {-^ Data type -}\n       }\n    -> TableHasColumn be\ninstance Hashable (BeamMigrateSqlBackendDataTypeSyntax be) => Hashable (TableHasColumn be) where\n  hashWithSalt salt (TableHasColumn t c s) = hashWithSalt salt (t, c, s)\ninstance Eq (BeamMigrateSqlBackendDataTypeSyntax be) => Eq (TableHasColumn be) where\n  TableHasColumn aTbl aCol aDt == TableHasColumn bTbl bCol bDt =\n    aTbl == bTbl && aCol == bCol && aDt == bDt\ninstance ( Typeable be\n         , BeamMigrateOnlySqlBackend be\n         , Hashable (BeamMigrateSqlBackendDataTypeSyntax be) ) =>\n  DatabasePredicate (TableHasColumn be) where\n  englishDescription (TableHasColumn tbl col type_) =\n    "Table " <> show tbl <> " must have a column " <> show col <> " of " <> displaySyntax type_\n\n  predicateSpecificity _ = PredicateSpecificityAllBackends\n\n  serializePredicate (TableHasColumn tbl col type_) =\n    object [ "has-column" .= object [ "table" .= tbl, "column" .= col\n                                    , "type" .= serializeDataType type_ ]]\n\n  predicateCascadesDropOn (TableHasColumn tblNm _ _) p\'\n    | Just (TableExistsPredicate tblNm\') <- cast p\' = tblNm\' == tblNm\n    | otherwise = False\n\n-- | Asserts that a particular column of a table has a given constraint. The\n-- @syntax@ type parameter should be an instance of \'IsSql92ColumnSchemaSyntax\'\ndata TableColumnHasConstraint be\n  = TableColumnHasConstraint\n  { hasConstraint_table  :: QualifiedName {-^ Table name -}\n  , hasConstraint_column :: Text {-^ Column name -}\n  , hasConstraint_defn   :: BeamSqlBackendColumnConstraintDefinitionSyntax be {-^ Constraint definition -}\n  } deriving Generic\ninstance Hashable (BeamSqlBackendColumnConstraintDefinitionSyntax be) => Hashable (TableColumnHasConstraint be)\nderiving instance Eq (BeamSqlBackendColumnConstraintDefinitionSyntax be) => Eq (TableColumnHasConstraint be)\ninstance ( Typeable be, BeamMigrateOnlySqlBackend be\n         , Hashable (BeamSqlBackendColumnConstraintDefinitionSyntax be) ) =>\n         DatabasePredicate (TableColumnHasConstraint be) where\n  englishDescription (TableColumnHasConstraint tbl col cns) =\n    "Column " <> show tbl <> "." <> show col <> " has constraint " <> displaySyntax cns\n\n  predicateSpecificity _ = PredicateSpecificityAllBackends\n  serializePredicate (TableColumnHasConstraint tbl col cns) =\n    object [ "has-column-constraint" .= object [ "table" .= tbl, "column" .= col\n                                               , "constraint" .= serializeConstraint cns ] ]\n\n  predicateCascadesDropOn (TableColumnHasConstraint tblNm colNm _) p\'\n    | Just (TableExistsPredicate tblNm\') <- cast p\' = tblNm\' == tblNm\n    | Just (TableHasColumn tblNm\' colNm\' _ :: TableHasColumn be) <- cast p\' = tblNm\' == tblNm && colNm\' == colNm\n    | otherwise = False\n\n-- | Asserts that the given table has a primary key made of the given columns.\n-- The order of the columns is significant.\ndata TableHasPrimaryKey\n  = TableHasPrimaryKey\n  { hasPrimaryKey_table :: QualifiedName   {-^ Table name -}\n  , hasPrimaryKey_cols  :: [Text] {-^ Column names -}\n  } deriving (Show, Eq, Generic)\ninstance Hashable TableHasPrimaryKey\ninstance DatabasePredicate TableHasPrimaryKey where\n  englishDescription (TableHasPrimaryKey tblName colNames) =\n    "Table " <> show tblName <> " has primary key " <> show colNames\n\n  predicateSpecificity _ = PredicateSpecificityAllBackends\n\n  serializePredicate (TableHasPrimaryKey tbl cols) =\n    object [ "has-primary-key" .= object [ "table" .= tbl\n                                         , "columns" .= cols ] ]\n\n  predicateCascadesDropOn (TableHasPrimaryKey tblNm _) p\'\n    | Just (TableExistsPredicate tblNm\') <- cast p\' = tblNm\' == tblNm\n    | otherwise = False\n\n-- * Deserialization\n\n-- | \'BeamDeserializers\' for all the predicates defined in this module\nbeamCheckDeserializers\n  :: forall be\n   . ( Typeable be, BeamMigrateOnlySqlBackend be\n     , HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be) )\n  => BeamDeserializers be\nbeamCheckDeserializers = mconcat\n  [ beamDeserializer (const deserializeTableExistsPredicate)\n  , beamDeserializer (const deserializeTableHasPrimaryKeyPredicate)\n  , beamDeserializer deserializeTableHasColumnPredicate\n  , beamDeserializer deserializeTableColumnHasConstraintPredicate\n  ]\n  where\n    deserializeTableExistsPredicate :: Value -> Parser SomeDatabasePredicate\n    deserializeTableExistsPredicate =\n      withObject "TableExistPredicate" $ \\v ->\n      SomeDatabasePredicate <$> (TableExistsPredicate <$> v .: "table-exists")\n\n    deserializeTableHasPrimaryKeyPredicate :: Value -> Parser SomeDatabasePredicate\n    deserializeTableHasPrimaryKeyPredicate =\n      withObject "TableHasPrimaryKey" $ \\v ->\n      v .: "has-primary-key" >>=\n      (withObject "TableHasPrimaryKey" $ \\v\' ->\n       SomeDatabasePredicate <$> (TableHasPrimaryKey <$> v\' .: "table" <*> v\' .: "columns"))\n\n    deserializeTableHasColumnPredicate :: BeamDeserializers be\'\n                                       -> Value -> Parser SomeDatabasePredicate\n    deserializeTableHasColumnPredicate d =\n      withObject "TableHasColumn" $ \\v ->\n      v .: "has-column" >>=\n      (withObject "TableHasColumn" $ \\v\' ->\n       SomeDatabasePredicate <$>\n       fmap (id @(TableHasColumn be))\n         (TableHasColumn <$> v\' .: "table" <*> v\' .: "column"\n                         <*> (beamDeserialize d =<< v\' .: "type")))\n\n    deserializeTableColumnHasConstraintPredicate :: BeamDeserializers be\'\n                                                 -> Value -> Parser SomeDatabasePredicate\n    deserializeTableColumnHasConstraintPredicate d =\n      withObject "TableColumnHasConstraint" $ \\v ->\n      v .: "has-column-constraint" >>=\n      (withObject "TableColumnHasConstraint" $ \\v\' ->\n       SomeDatabasePredicate <$>\n       fmap (id @(TableColumnHasConstraint be))\n         (TableColumnHasConstraint <$> v\' .: "table" <*> v\' .: "column"\n                                   <*> (beamDeserialize d =<< v\' .: "constraint")))\n'