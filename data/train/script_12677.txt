b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2003 April 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains code used to implement the ATTACH and DETACH commands.\n    **\n    ** $Id: attach.c,v 1.93 2009/05/31 21:21:41 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n#if !SQLITE_OMIT_ATTACH\n    /*\n** Resolve an expression that was part of an ATTACH or DETACH statement. This\n** is slightly different from resolving a normal SQL expression, because simple\n** identifiers are treated as strings, not possible column names or aliases.\n**\n** i.e. if the parser sees:\n**\n**     ATTACH DATABASE abc AS def\n**\n** it treats the two expressions as literal strings \'abc\' and \'def\' instead of\n** looking for columns of the same name.\n**\n** This only applies to the root node of pExpr, so the statement:\n**\n**     ATTACH DATABASE abc||def AS \'db2\'\n**\n** will fail because neither abc or def can be resolved.\n*/\n    static int resolveAttachExpr( NameContext pName, Expr pExpr )\n    {\n      int rc = SQLITE_OK;\n      if ( pExpr != null )\n      {\n        if ( pExpr.op != TK_ID )\n        {\n          rc = sqlite3ResolveExprNames( pName, ref pExpr );\n          if ( rc == SQLITE_OK && sqlite3ExprIsConstant( pExpr ) == 0 )\n          {\n            sqlite3ErrorMsg( pName.pParse, "invalid name: \\"%s\\"", pExpr.u.zToken );\n            return SQLITE_ERROR;\n          }\n        }\n        else\n        {\n          pExpr.op = TK_STRING;\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** An SQL user-function registered to do the work of an ATTACH statement. The\n    ** three arguments to the function come directly from an attach statement:\n    **\n    **     ATTACH DATABASE x AS y KEY z\n    **\n    **     SELECT sqlite_attach(x, y, z)\n    **\n    ** If the optional "KEY z" syntax is omitted, an SQL NULL is passed as the\n    ** third argument.\n    */\n    static void attachFunc(\n    sqlite3_context context,\n    int NotUsed,\n    sqlite3_value[] argv\n    )\n    {\n      int i;\n      int rc = 0;\n      sqlite3 db = sqlite3_context_db_handle( context );\n      string zName;\n      string zFile;\n      Db aNew = null;\n      string zErrDyn = "";\n\n      UNUSED_PARAMETER( NotUsed );\n\n      zFile = argv[0].z != null && ( argv[0].z.Length > 0 ) ? sqlite3_value_text( argv[0] ) : "";\n      zName = argv[1].z != null && ( argv[1].z.Length > 0 ) ? sqlite3_value_text( argv[1] ) : "";\n      //if( zFile==null ) zFile = "";\n      //if ( zName == null ) zName = "";\n\n\n      /* Check for the following errors:\n      **\n      **     * Too many attached databases,\n      **     * Transaction currently open\n      **     * Specified database name already being used.\n      */\n      if ( db.nDb >= db.aLimit[SQLITE_LIMIT_ATTACHED] + 2 )\n      {\n        zErrDyn = sqlite3MPrintf( db, "too many attached databases - max %d",\n        db.aLimit[SQLITE_LIMIT_ATTACHED]\n        );\n        goto attach_error;\n      }\n      if ( 0 == db.autoCommit )\n      {\n        zErrDyn = sqlite3MPrintf( db, "cannot ATTACH database within transaction" );\n        goto attach_error;\n      }\n      for ( i = 0 ; i < db.nDb ; i++ )\n      {\n        string z = db.aDb[i].zName;\n        Debug.Assert( z != null && zName != null );\n        if ( sqlite3StrICmp( z, zName ) == 0 )\n        {\n          zErrDyn = sqlite3MPrintf( db, "database %s is already in use", zName );\n          goto attach_error;\n        }\n      }\n\n      /* Allocate the new entry in the db.aDb[] array and initialise the schema\n      ** hash tables.\n      */\n      /* Allocate the new entry in the db.aDb[] array and initialise the schema\n      ** hash tables.\n      */\n      //if( db.aDb==db.aDbStatic ){\n      //  aNew = sqlite3DbMallocRaw(db, sizeof(db.aDb[0])*3 );\n      //  if( aNew==0 ) return;\n      //  memcpy(aNew, db.aDb, sizeof(db.aDb[0])*2);\n      //}else {\n      if ( db.aDb.Length <= db.nDb ) Array.Resize( ref db.aDb, db.nDb + 1 );//aNew = sqlite3DbRealloc(db, db.aDb, sizeof(db.aDb[0])*(db.nDb+1) );\n      if ( db.aDb == null ) return;   // if( aNew==0 ) return;\n      //}\n      db.aDb[db.nDb] = new Db();//db.aDb = aNew;\n      aNew = db.aDb[db.nDb];//memset(aNew, 0, sizeof(*aNew));\n      //  memset(aNew, 0, sizeof(*aNew));\n\n      /* Open the database file. If the btree is successfully opened, use\n      ** it to obtain the database schema. At this point the schema may\n      ** or may not be initialised.\n      */\n      rc = sqlite3BtreeFactory( db, zFile, false, SQLITE_DEFAULT_CACHE_SIZE,\n      db.openFlags | SQLITE_OPEN_MAIN_DB,\n      ref aNew.pBt );\n      db.nDb++;\n      if ( rc == SQLITE_CONSTRAINT )\n      {\n        rc = SQLITE_ERROR;\n        zErrDyn = sqlite3MPrintf( db, "database is already attached" );\n      }\n      else if ( rc == SQLITE_OK )\n      {\n        Pager pPager;\n        aNew.pSchema = sqlite3SchemaGet( db, aNew.pBt );\n        if ( aNew.pSchema == null )\n        {\n          rc = SQLITE_NOMEM;\n        }\n        else if ( aNew.pSchema.file_format != 0 && aNew.pSchema.enc != ENC( db ) )\n        {\n          zErrDyn = sqlite3MPrintf( db,\n          "attached databases must use the same text encoding as main database" );\n          rc = SQLITE_ERROR;\n        }\n        pPager = sqlite3BtreePager( aNew.pBt );\n        sqlite3PagerLockingMode( pPager, db.dfltLockMode );\n        sqlite3PagerJournalMode( pPager, db.dfltJournalMode );\n      }\n      aNew.zName = zName;// sqlite3DbStrDup( db, zName );\n      aNew.safety_level = 3;\n\n#if SQLITE_HAS_CODEC\n{\nextern int sqlite3CodecAttach(sqlite3*, int, const void*, int);\nextern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);\nint nKey;\nchar *zKey;\nint t = sqlite3_value_type(argv[2]);\nswitch( t ){\ncase SQLITE_INTEGER:\ncase SQLITE_FLOAT:\nzErrDyn = sqlite3DbStrDup(db, "Invalid key value");\nrc = SQLITE_ERROR;\nbreak;\n\ncase SQLITE_TEXT:\ncase SQLITE_BLOB:\nnKey = sqlite3_value_bytes(argv[2]);\nzKey = (char *)sqlite3_value_blob(argv[2]);\nsqlite3CodecAttach(db, db.nDb-1, zKey, nKey);\nbreak;\n\ncase SQLITE_NULL:\n/* No key specified.  Use the key from the main database */\nsqlite3CodecGetKey(db, 0, (void**)&zKey, nKey);\nsqlite3CodecAttach(db, db.nDb-1, zKey, nKey);\nbreak;\n}\n}\n#endif\n\n      /* If the file was opened successfully, read the schema for the new database.\n** If this fails, or if opening the file failed, then close the file and\n** remove the entry from the db.aDb[] array. i.e. put everything back the way\n** we found it.\n*/\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3SafetyOn( db );\n        sqlite3BtreeEnterAll( db );\n        rc = sqlite3Init( db, ref zErrDyn );\n        sqlite3BtreeLeaveAll( db );\n        sqlite3SafetyOff( db );\n      }\n      if ( rc != 0 )\n      {\n        int iDb = db.nDb - 1;\n        Debug.Assert( iDb >= 2 );\n        if ( db.aDb[iDb].pBt != null )\n        {\n          sqlite3BtreeClose( ref db.aDb[iDb].pBt );\n          db.aDb[iDb].pBt = null;\n          db.aDb[iDb].pSchema = null;\n        }\n        sqlite3ResetInternalSchema( db, 0 );\n        db.nDb = iDb;\n        if ( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM )\n        {\n  ////        db.mallocFailed = 1;\n          //sqlite3DbFree( db, zErrDyn );\n          zErrDyn = sqlite3MPrintf( db, "out of memory" );\n        }\n        else if ( zErrDyn == "" )\n        {\n          zErrDyn = sqlite3MPrintf( db, "unable to open database: %s", zFile );\n        }\n        goto attach_error;\n      }\n\n      return;\n\nattach_error:\n      /* Return an error if we get here */\n      if ( zErrDyn != "" )\n      {\n        sqlite3_result_error( context, zErrDyn, -1 );\n        //sqlite3DbFree( db, ref zErrDyn );\n      }\n      if ( rc != 0 ) sqlite3_result_error_code( context, rc );\n    }\n\n    /*\n    ** An SQL user-function registered to do the work of an DETACH statement. The\n    ** three arguments to the function come directly from a detach statement:\n    **\n    **     DETACH DATABASE x\n    **\n    **     SELECT sqlite_detach(x)\n    */\n    static void detachFunc(\n    sqlite3_context context,\n    int NotUsed,\n    sqlite3_value[] argv\n    )\n    {\n      string zName = zName = argv[0].z != null && ( argv[0].z.Length > 0 ) ? sqlite3_value_text( argv[0] ) : "";//(sqlite3_value_text(argv[0]);\n      sqlite3 db = sqlite3_context_db_handle( context );\n      int i;\n      Db pDb = null;\n      string zErr = "";\n\n      UNUSED_PARAMETER( NotUsed );\n\n      if ( zName == null ) zName = "";\n      for ( i = 0 ; i < db.nDb ; i++ )\n      {\n        pDb = db.aDb[i];\n        if ( pDb.pBt == null ) continue;\n        if ( sqlite3StrICmp( pDb.zName, zName ) == 0 ) break;\n      }\n\n      if ( i >= db.nDb )\n      {\n        sqlite3_snprintf( 200, ref zErr, "no such database: %s", zName );\n        goto detach_error;\n      }\n      if ( i < 2 )\n      {\n        sqlite3_snprintf( 200, ref zErr, "cannot detach database %s", zName );\n        goto detach_error;\n      }\n      if ( 0 == db.autoCommit )\n      {\n        sqlite3_snprintf( 200, ref zErr,\n        "cannot DETACH database within transaction" );\n        goto detach_error;\n      }\n      if ( sqlite3BtreeIsInReadTrans( pDb.pBt ) || sqlite3BtreeIsInBackup( pDb.pBt ) )\n      {\n        sqlite3_snprintf( 200, ref zErr, "database %s is locked", zName );\n        goto detach_error;\n      }\n\n      sqlite3BtreeClose( ref pDb.pBt );\n      pDb.pBt = null;\n      pDb.pSchema = null;\n      sqlite3ResetInternalSchema( db, 0 );\n      return;\n\ndetach_error:\n      sqlite3_result_error( context, zErr, -1 );\n    }\n\n    /*\n    ** This procedure generates VDBE code for a single invocation of either the\n    ** sqlite_detach() or sqlite_attach() SQL user functions.\n    */\n    static void codeAttach(\n    Parse pParse,       /* The parser context */\n    int type,           /* Either SQLITE_ATTACH or SQLITE_DETACH */\n    FuncDef pFunc,      /* FuncDef wrapper for detachFunc() or attachFunc() */\n    Expr pAuthArg,      /* Expression to pass to authorization callback */\n    Expr pFilename,     /* Name of database file */\n    Expr pDbname,       /* Name of the database to use internally */\n    Expr pKey           /* Database key for encryption extension */\n    )\n    {\n      int rc;\n      NameContext sName;\n      Vdbe v;\n      sqlite3 db = pParse.db;\n      int regArgs;\n\n      sName = new NameContext();// memset( &sName, 0, sizeof(NameContext));\n      sName.pParse = pParse;\n\n      if (\n      SQLITE_OK != ( rc = resolveAttachExpr( sName, pFilename ) ) ||\n      SQLITE_OK != ( rc = resolveAttachExpr( sName, pDbname ) ) ||\n      SQLITE_OK != ( rc = resolveAttachExpr( sName, pKey ) )\n      )\n      {\n        pParse.nErr++;\n        goto attach_end;\n      }\n\n#if !SQLITE_OMIT_AUTHORIZATION\nif( pAuthArg ){\nchar *zAuthArg = pAuthArg->u.zToken;\nif( NEVER(zAuthArg==0) ){\ngoto attach_end;\n}\nrc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\nif(rc!=SQLITE_OK ){\ngoto attach_end;\n}\n}\n#endif //* SQLITE_OMIT_AUTHORIZATION */\n\n      v = sqlite3GetVdbe( pParse );\n      regArgs = sqlite3GetTempRange( pParse, 4 );\n      sqlite3ExprCode( pParse, pFilename, regArgs );\n      sqlite3ExprCode( pParse, pDbname, regArgs + 1 );\n      sqlite3ExprCode( pParse, pKey, regArgs + 2 );\n\n      Debug.Assert( v != null /*|| db.mallocFailed != 0 */ );\n      if ( v != null )\n      {\n        sqlite3VdbeAddOp3( v, OP_Function, 0, regArgs + 3 - pFunc.nArg, regArgs + 3 );\n        Debug.Assert( pFunc.nArg == -1 || ( pFunc.nArg & 0xff ) == pFunc.nArg );\n        sqlite3VdbeChangeP5( v, (u8)( pFunc.nArg ) );\n        sqlite3VdbeChangeP4( v, -1, pFunc, P4_FUNCDEF );\n\n        /* Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this\n        ** statement only). For DETACH, set it to false (expire all existing\n        ** statements).\n        */\n        sqlite3VdbeAddOp1( v, OP_Expire, ( type == SQLITE_ATTACH ) ? 1 : 0 );\n      }\n\nattach_end:\n      sqlite3ExprDelete( db, ref pFilename );\n      sqlite3ExprDelete( db, ref pDbname );\n      sqlite3ExprDelete( db, ref pKey );\n    }\n\n    /*\n    ** Called by the parser to compile a DETACH statement.\n    **\n    **     DETACH pDbname\n    */\n    static void sqlite3Detach( Parse pParse, Expr pDbname )\n    {\n      FuncDef detach_func = new FuncDef(\n      1,                   /* nArg */\n      SQLITE_UTF8,         /* iPrefEnc */\n      0,                   /* flags */\n      null,                /* pUserData */\n      null,                /* pNext */\n      detachFunc,          /* xFunc */\n      null,                /* xStep */\n      null,                /* xFinalize */\n      "sqlite_detach",     /* zName */\n      null                 /* pHash */\n      );\n      codeAttach( pParse, SQLITE_DETACH, detach_func, pDbname, null, null, pDbname );\n    }\n\n    /*\n    ** Called by the parser to compile an ATTACH statement.\n    **\n    **     ATTACH p AS pDbname KEY pKey\n    */\n    static void sqlite3Attach( Parse pParse, Expr p, Expr pDbname, Expr pKey )\n    {\n      FuncDef attach_func = new FuncDef(\n      3,                /* nArg */\n      SQLITE_UTF8,      /* iPrefEnc */\n      0,                /* flags */\n      null,             /* pUserData */\n      null,             /* pNext */\n      attachFunc,       /* xFunc */\n      null,             /* xStep */\n      null,             /* xFinalize */\n      "sqlite_attach",  /* zName */\n      null              /* pHash */\n      );\n      codeAttach( pParse, SQLITE_ATTACH, attach_func, p, p, pDbname, pKey );\n    }\n#endif // * SQLITE_OMIT_ATTACH */\n\n    /*\n** Initialize a DbFixer structure.  This routine must be called prior\n** to passing the structure to one of the sqliteFixAAAA() routines below.\n**\n** The return value indicates whether or not fixation is required.  TRUE\n** means we do need to fix the database references, FALSE means we do not.\n*/\n    static int sqlite3FixInit(\n    DbFixer pFix,       /* The fixer to be initialized */\n    Parse pParse,       /* Error messages will be written here */\n    int iDb,            /* This is the database that must be used */\n    string zType,       /* "view", "trigger", or "index" */\n    Token pName         /* Name of the view, trigger, or index */\n    )\n    {\n      sqlite3 db;\n\n      if ( NEVER( iDb < 0 ) || iDb == 1 ) return 0;\n      db = pParse.db;\n      Debug.Assert( db.nDb > iDb );\n      pFix.pParse = pParse;\n      pFix.zDb = db.aDb[iDb].zName;\n      pFix.zType = zType;\n      pFix.pName = pName;\n      return 1;\n    }\n\n    /*\n    ** The following set of routines walk through the parse tree and assign\n    ** a specific database to all table references where the database name\n    ** was left unspecified in the original SQL statement.  The pFix structure\n    ** must have been initialized by a prior call to sqlite3FixInit().\n    **\n    ** These routines are used to make sure that an index, trigger, or\n    ** view in one database does not refer to objects in a different database.\n    ** (Exception: indices, triggers, and views in the TEMP database are\n    ** allowed to refer to anything.)  If a reference is explicitly made\n    ** to an object in a different database, an error message is added to\n    ** pParse.zErrMsg and these routines return non-zero.  If everything\n    ** checks out, these routines return 0.\n    */\n    static int sqlite3FixSrcList(\n    DbFixer pFix,       /* Context of the fixation */\n    SrcList pList       /* The Source list to check and modify */\n    )\n    {\n      int i;\n      string zDb;\n      SrcList_item pItem;\n\n      if ( NEVER( pList == null ) ) return 0;\n      zDb = pFix.zDb;\n      for ( i = 0 ; i < pList.nSrc ; i++ )\n      {//, pItem++){\n        pItem = pList.a[i];\n        if ( pItem.zDatabase == null )\n        {\n          pItem.zDatabase = zDb;// sqlite3DbStrDup( pFix.pParse.db, zDb );\n        }\n        else if ( sqlite3StrICmp( pItem.zDatabase, zDb ) != 0 )\n        {\n          sqlite3ErrorMsg( pFix.pParse,\n          "%s %T cannot reference objects in database %s",\n          pFix.zType, pFix.pName, pItem.zDatabase );\n          return 1;\n        }\n#if !SQLITE_OMIT_VIEW || !SQLITE_OMIT_TRIGGER\n        if ( sqlite3FixSelect( pFix, pItem.pSelect ) != 0 ) return 1;\n        if ( sqlite3FixExpr( pFix, pItem.pOn ) != 0 ) return 1;\n#endif\n      }\n      return 0;\n    }\n#if !SQLITE_OMIT_VIEW || !SQLITE_OMIT_TRIGGER\n    static int sqlite3FixSelect(\n    DbFixer pFix,       /* Context of the fixation */\n    Select pSelect      /* The SELECT statement to be fixed to one database */\n    )\n    {\n      while ( pSelect != null )\n      {\n        if ( sqlite3FixExprList( pFix, pSelect.pEList ) != 0 )\n        {\n          return 1;\n        }\n        if ( sqlite3FixSrcList( pFix, pSelect.pSrc ) != 0 )\n        {\n          return 1;\n        }\n        if ( sqlite3FixExpr( pFix, pSelect.pWhere ) != 0 )\n        {\n          return 1;\n        }\n        if ( sqlite3FixExpr( pFix, pSelect.pHaving ) != 0 )\n        {\n          return 1;\n        }\n        pSelect = pSelect.pPrior;\n      }\n      return 0;\n    }\n    static int sqlite3FixExpr(\n    DbFixer pFix,     /* Context of the fixation */\n    Expr pExpr        /* The expression to be fixed to one database */\n    )\n    {\n      while ( pExpr != null )\n      {\n        if ( ExprHasAnyProperty( pExpr, EP_TokenOnly ) ) break;\n        if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n        {\n          if ( sqlite3FixSelect( pFix, pExpr.x.pSelect ) != 0 ) return 1;\n        }\n        else\n        {\n          if ( sqlite3FixExprList( pFix, pExpr.x.pList ) != 0 ) return 1;\n        }\n        if ( sqlite3FixExpr( pFix, pExpr.pRight ) != 0 )\n        {\n          return 1;\n        }\n        pExpr = pExpr.pLeft;\n      }\n      return 0;\n    }\n    static int sqlite3FixExprList(\n    DbFixer pFix,     /* Context of the fixation */\n    ExprList pList    /* The expression to be fixed to one database */\n    )\n    {\n      int i;\n      ExprList_item pItem;\n      if ( pList == null ) return 0;\n      for ( i = 0 ; i < pList.nExpr ; i++ )//, pItem++ )\n      {\n        pItem = pList.a[i];\n        if ( sqlite3FixExpr( pFix, pItem.pExpr ) != 0 )\n        {\n          return 1;\n        }\n      }\n      return 0;\n    }\n#endif\n\n#if !SQLITE_OMIT_TRIGGER\n    static int sqlite3FixTriggerStep(\n    DbFixer pFix,     /* Context of the fixation */\n    TriggerStep pStep /* The trigger step be fixed to one database */\n    )\n    {\n      while ( pStep != null )\n      {\n        if ( sqlite3FixSelect( pFix, pStep.pSelect ) != 0 )\n        {\n          return 1;\n        }\n        if ( sqlite3FixExpr( pFix, pStep.pWhere ) != 0 )\n        {\n          return 1;\n        }\n        if ( sqlite3FixExprList( pFix, pStep.pExprList ) != 0 )\n        {\n          return 1;\n        }\n        pStep = pStep.pNext;\n      }\n      return 0;\n    }\n#endif\n\n  }\n}\n'