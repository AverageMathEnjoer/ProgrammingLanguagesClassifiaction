b'{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\n-- | A high-level, multiple reader, single writer interface for Websocket clients.\nmodule Cachix.Deploy.Websocket where\n\nimport qualified Cachix.Client.Retry as Retry\nimport qualified Cachix.Client.URI as URI\nimport Cachix.Client.Version (versionNumber)\nimport qualified Cachix.Deploy.Log as Log\nimport qualified Cachix.Deploy.WebsocketPong as WebsocketPong\nimport qualified Control.Concurrent.Async as Async\nimport qualified Control.Concurrent.MVar as MVar\nimport qualified Control.Concurrent.STM.TBMQueue as TBMQueue\nimport qualified Control.Concurrent.STM.TMChan as TMChan\nimport Control.Exception.Safe (Handler (..), MonadMask, isSyncException)\nimport qualified Control.Exception.Safe as Safe\nimport qualified Control.Retry as Retry\nimport qualified Data.Aeson as Aeson\nimport qualified Data.ByteString as BS\nimport Data.Conduit ((.|))\nimport qualified Data.Conduit as Conduit\nimport qualified Data.Conduit.Combinators as Conduit\nimport qualified Data.Conduit.TQueue as Conduit\nimport qualified Data.IORef as IORef\nimport Data.String (String)\nimport Data.String.Here (iTrim)\nimport qualified Data.Text as Text\nimport qualified Data.Time.Clock as Time\nimport qualified Katip as K\nimport qualified Network.HTTP.Simple as HTTP\nimport qualified Network.WebSockets as WS\nimport qualified Network.WebSockets.Connection as WS.Connection\nimport Protolude hiding (Handler, toS)\nimport Protolude.Conv\nimport qualified System.Info\nimport qualified System.Timeout as Timeout\nimport qualified Wuss\n\n-- | A reliable WebSocket connection that can be run ergonomically in a\n-- separate thread.\n--\n-- Maintains the connection by periodically sending pings.\ndata WebSocket tx rx = WebSocket\n  { -- | The active WebSocket connection, if available\n    connection :: MVar.MVar WS.Connection,\n    -- | The connection options\n    options :: Options,\n    -- | A timestamp of the last pong message received\n    lastPong :: WebsocketPong.LastPongState,\n    -- | See \'Transmit\'\n    tx :: Transmit tx,\n    -- | See \'Receive\'\n    rx :: Receive rx,\n    withLog :: Log.WithLog\n  }\n\ndata Options = Options\n  { host :: URI.Host,\n    port :: URI.Port,\n    path :: Text,\n    useSSL :: Bool,\n    headers :: HTTP.RequestHeaders,\n    -- | The identifier used when logging. Usually a combination of the agent\n    -- name and the CLI version.\n    identifier :: Text\n  }\n  deriving (Show)\n\n-- | A more ergonomic version of the Websocket \'Message\' data type\ndata Message msg\n  = ControlMessage WS.ControlMessage\n  | DataMessage msg\n\n-- | A bounded queue of outbound messages.\ntype Transmit msg = TBMQueue.TBMQueue (Message msg)\n\n-- | A broadcast channel for incoming messages.\ntype Receive msg = TMChan.TMChan (Message msg)\n\n-- | Send messages over the socket.\nsend :: WebSocket tx rx -> Message tx -> IO ()\nsend WebSocket {tx} = atomically . TBMQueue.writeTBMQueue tx\n\n-- | Open a new receiving channel.\nreceive :: WebSocket tx rx -> IO (Receive rx)\nreceive WebSocket {rx} = atomically $ TMChan.dupTMChan rx\n\n-- | Read incoming messages on a channel opened with \'receive\'.\nread :: Receive rx -> IO (Maybe (Message rx))\nread = atomically . TMChan.readTMChan\n\n-- | Read incoming data messages, ignoring everything else.\nreadDataMessages :: Receive rx -> (rx -> IO ()) -> IO ()\nreadDataMessages channel action = loop\n  where\n    loop =\n      read channel >>= \\case\n        Just (DataMessage message) -> action message *> loop\n        Just (ControlMessage _) -> loop\n        Nothing -> pure ()\n\n-- | Close the outgoing queue.\ndrainQueue :: WebSocket tx rx -> Async () -> IO ()\ndrainQueue WebSocket {tx} outgoingThread = do\n  atomically $ TBMQueue.closeTBMQueue tx\n  Async.wait outgoingThread\n\ncloseGracefully :: WebSocket tx rx -> Async () -> IO ()\ncloseGracefully websocket incomingThread = do\n  repsonseToCloseRequest <- startGracePeriod $ do\n    MVar.tryReadMVar (connection websocket) >>= \\case\n      Just activeConnection -> do\n        WS.sendClose activeConnection ("Peer initiated a close request" :: ByteString)\n        Async.wait incomingThread\n      Nothing -> pure ()\n\n  when (isNothing repsonseToCloseRequest) throwNoResponseToCloseRequest\n\n-- | Run an app inside a new WebSocket connection.\nwithConnection :: Log.WithLog -> Options -> (WebSocket tx rx -> IO ()) -> IO ()\nwithConnection withLog options app = do\n  websocket <- new withLog options\n  runConnection websocket (app websocket)\n\n-- | Set up state for a new WebSocket connection. Use \'runConnection\' to then\n-- open the connection.\n--\n-- This is useful for setting up message processing using the tx/rx channels\n-- before the connection is established. For example, you might want to use\n-- \'receive\' to open a receiving channel and capture incoming messages.\nnew :: Log.WithLog -> Options -> IO (WebSocket tx rx)\nnew withLog options = do\n  connection <- MVar.newEmptyMVar\n  tx <- TBMQueue.newTBMQueueIO 100\n  rx <- TMChan.newBroadcastTMChanIO\n  lastPong <- WebsocketPong.newState\n  pure $ WebSocket {connection, options, tx, rx, lastPong, withLog}\n\nrunConnection :: WebSocket tx rx -> IO () -> IO ()\nrunConnection websocket@WebSocket {connection, options, tx, rx, withLog, lastPong} app = do\n  threadId <- myThreadId\n\n  -- TODO: store this in the WebSocket record\n  let pingEvery = 30\n  let pongTimeout = pingEvery * 2\n  let onPing = do\n        last <- WebsocketPong.secondsSinceLastPong lastPong\n        withLog $ K.logLocM K.DebugS $ K.ls $ "Sending WebSocket keep-alive ping, last pong was " <> (show last :: Text) <> " seconds ago"\n        WebsocketPong.pingHandler lastPong threadId pongTimeout\n  let connectionOptions = WebsocketPong.installPongHandler lastPong WS.defaultConnectionOptions\n\n  let dropConnection = void $ MVar.tryTakeMVar connection\n  let closeChannels = atomically $ do\n        TBMQueue.closeTBMQueue tx\n        TMChan.closeTMChan rx\n\n  flip Safe.finally closeChannels $\n    reconnectWithLog withLog $ do\n      withLog $ K.logLocM K.InfoS $ K.ls (logOnMessage options)\n\n      -- TODO: https://github.com/jaspervdj/websockets/issues/229\n      runClientWith options connectionOptions $\n        \\newConnection -> flip Safe.finally dropConnection $ do\n          withLog $ K.logLocM K.InfoS "Connected to Cachix Deploy service"\n\n          -- Reset the pong state in case we\'re reconnecting\n          WebsocketPong.pongHandler lastPong\n\n          -- Update the connection\n          MVar.putMVar connection newConnection\n\n          Async.concurrently_ (sendPingEvery pingEvery onPing websocket) app\n\nrunClientWith :: Options -> WS.Connection.ConnectionOptions -> WS.ClientApp a -> IO a\nrunClientWith Options {host, port, path, headers, useSSL} connectionOptions app =\n  if useSSL\n    then Wuss.runSecureClientWith hostS (fromIntegral (URI.portNumber port)) (toS path) connectionOptions headers app\n    else WS.runClientWith hostS (URI.portNumber port) (toS path) connectionOptions headers app\n  where\n    hostS = toS (URI.hostBS host)\n\n-- Handle JSON messages\n\n-- | Start processing incoming and outgoing JSON messages.\n--\n-- Make sure to open an incoming channel with [receive] beforehand to avoid\n-- dropping messages.\nhandleJSONMessages :: (Aeson.ToJSON tx, Aeson.FromJSON rx) => WebSocket tx rx -> IO () -> IO ()\nhandleJSONMessages websocket app =\n  handleJust unwrapThreadExceptions throwIO $\n    mask $ \\restore -> do\n      incomingThread <- Async.async (handleIncomingJSON websocket)\n      outgoingThread <- Async.async (handleOutgoingJSON websocket)\n\n      let threads = [incomingThread, outgoingThread]\n          cancelThreads = mapM_ Async.uninterruptibleCancel threads\n      mapM_ Async.link threads\n\n      let runApp = do\n            app\n            drainQueue websocket outgoingThread\n            closeGracefully websocket incomingThread\n      restore (runApp `Safe.finally` cancelThreads)\n  where\n    unwrapThreadExceptions :: SomeException -> Maybe SomeException\n    unwrapThreadExceptions e\n      | Just (Async.ExceptionInLinkedThread _ e\') <- fromException e = Just e\'\n      | otherwise = Nothing\n\nhandleIncomingJSON :: (Aeson.FromJSON rx) => WebSocket tx rx -> IO ()\nhandleIncomingJSON websocket@WebSocket {connection, rx, withLog} = do\n  activeConnection <- MVar.readMVar connection\n  let broadcast = atomically . TMChan.writeTMChan rx\n\n  forever $ do\n    msg <- WS.receive activeConnection\n    case msg of\n      WS.DataMessage _ _ _ am ->\n        case Aeson.eitherDecodeStrict\' (WS.fromDataMessage am :: ByteString) of\n          Left e -> withLog $ K.logLocM K.DebugS . K.ls $ "Cannot parse websocket payload: " <> e\n          Right pMsg -> broadcast (DataMessage pMsg)\n      WS.ControlMessage controlMsg -> do\n        case controlMsg of\n          WS.Ping pl ->\n            send websocket (ControlMessage (WS.Pong pl))\n          WS.Pong _ ->\n            WS.connectionOnPong (WS.Connection.connectionOptions activeConnection)\n          WS.Close code closeMsg -> do\n            hasSentClose <- IORef.readIORef $ WS.Connection.connectionSentClose activeConnection\n            unless hasSentClose $ WS.send activeConnection msg\n            throwIO $ WS.CloseRequest code closeMsg\n\n        broadcast (ControlMessage controlMsg)\n\nhandleOutgoingJSON :: forall tx rx. Aeson.ToJSON tx => WebSocket tx rx -> IO ()\nhandleOutgoingJSON WebSocket {connection, tx} = do\n  activeConnection <- MVar.readMVar connection\n  Conduit.runConduit $\n    Conduit.sourceTBMQueue tx\n      .| Conduit.mapM_ (sendJSONMessage activeConnection)\n  where\n    sendJSONMessage :: WS.Connection -> Message tx -> IO ()\n    sendJSONMessage conn (ControlMessage msg) = WS.send conn (WS.ControlMessage msg)\n    sendJSONMessage conn (DataMessage msg) = WS.sendTextData conn (Aeson.encode msg)\n\n-- | Log exceptions and retry, specialized for reconnecting WebSockets.\n--\n-- Close requests should be retried unless the status code is 1000, which\n-- indicates that both the client and server have acknowledged the close\n-- request and are ready to terminate the connection.\n--\n-- Other status codes typically indicate some sort of error. For example,\n-- Cloudflare periodically restarts WebSockets and sends a pre-defined\n-- status code in the 1xxx range.\n--\n-- Defined status codes:\n-- https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n--\n-- TODO: use exponential retry with reset: https://github.com/Soostone/retry/issues/25\n-- TODO: clients should be able to decide which errors to recover from.\nreconnectWithLog :: (MonadMask m, MonadIO m) => Log.WithLog -> m () -> m ()\nreconnectWithLog withLog app =\n  Safe.handle closeRequest $\n    Retry.recovering Retry.endlessConstantRetryPolicy handlers (const app)\n  where\n    handlers = Retry.skipAsyncExceptions ++ [exitOnSuccess, exitOnCloseRequest, logSyncExceptions]\n\n    closeRequest (WS.CloseRequest 1000 _) = return ()\n    closeRequest e = Safe.throwM e\n\n    exitOnSuccess _ = Handler $ \\(_ :: ExitCode) -> return False\n\n    exitOnCloseRequest _ = Handler $ \\(e :: WS.ConnectionException) ->\n      case e of\n        WS.CloseRequest code msg -> do\n          liftIO . withLog $\n            K.logLocM K.DebugS . K.ls $\n              "Received close request from peer (code: " <> show code <> ", message: " <> msg <> ")"\n\n          -- Retry on any code other than 1000\n          pure (code /= 1000)\n        _ -> return True\n\n    logSyncExceptions = Retry.logRetries (return . isSyncException) logRetries\n\n    logRetries :: (MonadIO m) => Bool -> SomeException -> Retry.RetryStatus -> m ()\n    logRetries _ exception retryStatus =\n      liftIO . withLog $\n        K.logLocM K.ErrorS . K.ls $\n          "Retrying in " <> delay (Retry.rsPreviousDelay retryStatus) <> " due to an exception: " <> displayException exception\n\n    delay :: Maybe Int -> String\n    delay Nothing = "0 seconds"\n    delay (Just t) = show (toSeconds t) <> " seconds"\n\n    toSeconds :: Int -> Int\n    toSeconds t =\n      floor $ (fromIntegral t :: Double) / 1000 / 1000\n\nwaitForPong :: Int -> WebSocket tx rx -> IO (Maybe Time.UTCTime)\nwaitForPong seconds websocket = do\n  channel <- receive websocket\n  Async.withAsync (sendPingEvery 1 pass websocket) $ \\_ ->\n    Timeout.timeout (seconds * 1000 * 1000) $\n      fix $ \\waitForNextMsg -> do\n        read channel >>= \\case\n          Just (ControlMessage (WS.Pong _)) -> Time.getCurrentTime\n          _ -> waitForNextMsg\n\nsendPingEvery :: Int -> IO () -> WebSocket tx rx -> IO ()\nsendPingEvery seconds onPing WebSocket {connection} = forever $ do\n  onPing\n  activeConnection <- MVar.readMVar connection\n  WS.sendPing activeConnection BS.empty\n  threadDelay (seconds * 1000 * 1000)\n\nstartGracePeriod :: IO a -> IO (Maybe a)\nstartGracePeriod = Timeout.timeout (3 * 1000 * 1000)\n\n-- | Try to gracefully close the WebSocket.\n--\n-- Do not run with asynchronous exceptions masked, ie. Control.Exception.Safe.finally.\n--\n-- We send a close request to the peer and continue processing\n-- any incoming messages until the server replies with its own\n-- close control message.\nwaitForGracefulShutdown :: WS.Connection -> IO ()\nwaitForGracefulShutdown connection = do\n  WS.sendClose connection ("Closing." :: ByteString)\n\n  -- Grace period\n  response <- startGracePeriod $ forever (WS.receiveDataMessage connection)\n\n  when (isNothing response) throwNoResponseToCloseRequest\n\nthrowNoResponseToCloseRequest :: IO a\nthrowNoResponseToCloseRequest = throwIO $ WS.CloseRequest 1000 "No response to close request"\n\n-- Authorization headers for Cachix Deploy\n\nsystem :: String\nsystem = System.Info.arch <> "-" <> System.Info.os\n\ncreateHeaders ::\n  -- | Agent name\n  Text ->\n  -- | Agent Token\n  Text ->\n  HTTP.RequestHeaders\ncreateHeaders agentName agentToken =\n  [ ("Authorization", "Bearer " <> toS agentToken),\n    ("name", toS agentName),\n    ("version", toS versionNumber),\n    ("system", toS system)\n  ]\n\nlogOnMessage :: Options -> Text\nlogOnMessage Options {host, identifier, path, useSSL} =\n  [iTrim|\n    ${Text.toTitle identifier} connecting to ${uri} over ${protocol}\n  |]\n  where\n    uri = decodeUtf8 (URI.hostBS host) <> path\n\n    protocol :: Text\n    protocol = if useSSL then "HTTPS" else "HTTP"\n'