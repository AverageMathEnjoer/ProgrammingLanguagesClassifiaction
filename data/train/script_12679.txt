b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Basic support for encrypted PDF files\n\nmodule Pdf.Core.Encryption\n( Decryptor\n, DecryptorScope(..)\n, defaultUserPassword\n, mkStandardDecryptor\n, decryptObject\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Util\n\nimport qualified Data.Traversable as Traversable\nimport Data.Bits (xor)\nimport Data.IORef\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.ByteString.Builder\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\nimport qualified Crypto.Cipher.RC4 as RC4\nimport qualified Crypto.Cipher.AES as AES\nimport qualified Crypto.Hash.MD5 as MD5\nimport qualified Crypto.Padding as Padding\n\n-- | Encryption handler may specify different encryption keys for strings\n-- and streams\ndata DecryptorScope\n  = DecryptString\n  | DecryptStream\n\n-- | Decrypt input stream\ntype Decryptor\n  =  Ref\n  -> DecryptorScope\n  -> InputStream ByteString\n  -> IO (InputStream ByteString)\n\n-- | Decrypt object with the decryptor\ndecryptObject :: Decryptor -> Ref -> Object -> IO Object\ndecryptObject decryptor ref (String str)\n  = String <$> decryptStr decryptor ref str\ndecryptObject decryptor ref (Dict dict)\n  = Dict <$> decryptDict decryptor ref dict\ndecryptObject decryptor ref (Array arr)\n  = Array <$> decryptArray decryptor ref arr\ndecryptObject _ _ o = return o\n\ndecryptStr :: Decryptor -> Ref -> ByteString -> IO ByteString\ndecryptStr decryptor ref str = do\n  is <- Streams.fromList [str]\n  res <- decryptor ref DecryptString is >>= Streams.toList\n  return $ BS.concat res\n\ndecryptDict :: Decryptor -> Ref -> Dict -> IO Dict\ndecryptDict decryptor ref vals = Traversable.forM vals $\n  decryptObject decryptor ref\n\ndecryptArray :: Decryptor -> Ref -> Array -> IO Array\ndecryptArray decryptor ref vals = Vector.forM vals decr\n  where\n  decr = decryptObject decryptor ref\n\n-- | The default user password\ndefaultUserPassword :: ByteString\ndefaultUserPassword = BS.pack [\n  0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E,\n  0x56, 0xFF, 0xFA, 0x01, 0x08, 0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68,\n  0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A\n  ]\n\n-- | Standard decryptor, RC4\nmkStandardDecryptor :: Dict\n                    -- ^ document trailer\n                    -> Dict\n                    -- ^ encryption dictionary\n                    -> ByteString\n                    -- ^ user password (32 bytes exactly,\n                    -- see 7.6.3.3 Encryption Key Algorithm)\n                    -> Either String (Maybe Decryptor)\nmkStandardDecryptor tr enc pass = do\n  filterType <-\n    case HashMap.lookup "Filter" enc of\n      Just o -> nameValue o `notice` "Filter should be a name"\n      _ -> Left "Filter missing"\n  unless (filterType == "Standard") $\n    Left ("Unsupported encryption handler: " ++ show filterType)\n\n  v <-\n    case HashMap.lookup "V" enc of\n      Just n -> intValue n `notice` "V should be an integer"\n      _ -> Left "V is missing"\n\n  if v == 4\n    then mk4\n    else mk12 v\n\n  where\n  mk12 v = do\n    n <-\n      case v of\n        1 -> Right 5\n        2 -> do\n          case HashMap.lookup "Length" enc of\n            Just o -> fmap (`div` 8) (intValue o\n                        `notice` "Length should be an integer")\n            Nothing -> Left "Length is missing"\n        _ -> Left ("Unsuported encryption handler version: " ++ show v)\n\n    ekey <- mkKey tr enc pass n\n    ok <- verifyKey tr enc ekey\n    return $\n      if not ok\n        then Nothing\n        else Just $ \\ref _ is -> mkDecryptor V2 ekey n ref is\n\n  mk4 = do\n    cryptoFilters <-\n      case HashMap.lookup "CF" enc of\n        Nothing -> Left "CF is missing in crypt handler V4"\n        Just o -> dictValue o `notice` "CF should be a dictionary"\n    keysMap <- Traversable.forM cryptoFilters $ \\obj -> do\n      dict <- dictValue obj `notice` "Crypto filter should be a dictionary"\n      n <-\n        case HashMap.lookup "Length" dict of\n          Nothing -> Left "Crypto filter without Length"\n          Just o -> intValue o `notice` "Crypto filter length should be int"\n      algName <-\n        case HashMap.lookup "CFM" dict of\n          Nothing -> Left "CFM is missing"\n          Just o -> nameValue o `notice` "CFM should be a name"\n      alg <-\n        case algName of\n          "V2" -> return V2\n          "AESV2" -> return AESV2\n          _ -> Left $ "Unknown crypto method: " ++ show algName\n      ekey <- mkKey tr enc pass n\n      return (ekey, n, alg)\n\n    (stdCfKey, _, _) <- HashMap.lookup "StdCF" keysMap\n      `notice` "StdCF is missing"\n    ok <- verifyKey tr enc stdCfKey\n    if not ok\n      then return Nothing\n\n      else do\n        strFName <- (HashMap.lookup "StrF" enc >>= nameValue)\n          `notice` "StrF is missing"\n        (strFKey, strFN, strFAlg) <- HashMap.lookup strFName keysMap\n          `notice` ("Crypto filter not found: " ++ show strFName)\n\n        stmFName <- (HashMap.lookup "StmF" enc >>= nameValue)\n          `notice` "StmF is missing"\n        (stmFKey, stmFN, stmFAlg) <- HashMap.lookup stmFName keysMap\n          `notice` ("Crypto filter not found: " ++ show stmFName)\n\n        return $ Just $ \\ref scope is ->\n          case scope of\n            DecryptString -> mkDecryptor strFAlg strFKey strFN ref is\n            DecryptStream -> mkDecryptor stmFAlg stmFKey stmFN ref is\n\nmkKey :: Dict -> Dict -> ByteString -> Int -> Either String ByteString\nmkKey tr enc pass n = do\n  oVal <- do\n    o <- HashMap.lookup "O" enc `notice` "O is missing"\n    stringValue o `notice` "o should be a string"\n\n  pVal <- do\n    o <- HashMap.lookup "P" enc `notice` "P is missing"\n    i <- intValue o `notice` "P should be an integer"\n    Right . BS.pack . BSL.unpack . toLazyByteString\n          . word32LE . fromIntegral $ i\n\n  idVal <- do\n    ids <- (HashMap.lookup "ID" tr >>= arrayValue)\n        `notice` "ID should be an array"\n    case (Vector.toList ids) of\n      [] -> Left "ID array is empty"\n      (x:_) -> stringValue x\n                  `notice` "The first element if ID should be a string"\n\n  rVal <- (HashMap.lookup "R" enc >>= intValue)\n      `notice` "R should be an integer"\n\n  encMD <-\n    case HashMap.lookup "EncryptMetadata" enc of\n      Nothing -> return True\n      Just o -> boolValue o `notice` "EncryptMetadata should be a bool"\n\n  let ekey\' = BS.take n $ MD5.hash $ BS.concat [pass, oVal, pVal, idVal, pad]\n      pad =\n        if rVal < 4 || encMD\n          then BS.empty\n          else BS.pack (replicate 4 255)\n      ekey =\n        if rVal < 3\n           then ekey\'\n           else foldl (\\bs _ -> BS.take n $ MD5.hash bs)\n                      ekey\'\n                      [1 :: Int .. 50]\n\n  return ekey\n\nverifyKey :: Dict -> Dict -> ByteString -> Either String Bool\nverifyKey tr enc ekey = do\n  rVal <- (HashMap.lookup "R" enc >>= intValue)\n      `notice` "R should be an integer"\n\n  idVal <- do\n    ids <- (HashMap.lookup "ID" tr >>= arrayValue)\n        `notice` "ID should be an array"\n    case (Vector.toList ids) of\n      [] -> Left "ID array is empty"\n      (x:_) -> stringValue x\n                  `notice` "The first element if ID should be a string"\n\n  uVal <- (HashMap.lookup "U" enc >>= stringValue)\n      `notice` "U should be a string"\n\n  return $\n    case rVal of\n      2 ->\n        let uVal\' = snd $ RC4.combine (RC4.initCtx ekey)\n                                      defaultUserPassword\n        in uVal == uVal\'\n      _ ->\n        let pass1 = snd $ RC4.combine (RC4.initCtx ekey)\n                        $ BS.take 16 $ MD5.hash\n                        $ BS.concat [defaultUserPassword, idVal]\n            uVal\' = loop 1 pass1\n            loop 20 input = input\n            loop i input = loop (i + 1) $ snd $ RC4.combine (RC4.initCtx\n                                        $ BS.map (`xor` i) ekey) input\n        in BS.take 16 uVal == BS.take 16 uVal\'\n\ndata Algorithm\n  = V2\n  | AESV2\n  deriving (Show)\n\nmkDecryptor\n  :: Algorithm\n  -> ByteString\n  -> Int\n  -> Ref\n  -> InputStream ByteString\n  -> IO (InputStream ByteString)\nmkDecryptor alg ekey n (R index gen) is = do\n  let key = BS.take (16 `min` n + 5) $ MD5.hash $ BS.concat\n        [ ekey\n        , BS.pack $ take 3 $ BSL.unpack $ toLazyByteString\n                  $ int32LE $ fromIntegral index\n        , BS.pack $ take 2 $ BSL.unpack $ toLazyByteString\n                  $ int32LE $ fromIntegral gen\n        , salt alg\n        ]\n      salt V2 = ""\n      salt AESV2 = "sAlT"\n\n  case alg of\n    V2 -> do\n      ioRef <- newIORef $ RC4.initCtx key\n      let readNext = do\n            chunk <- Streams.read is\n            case chunk of\n              Nothing -> return Nothing\n              Just c -> do\n                ctx\' <- readIORef ioRef\n                let (ctx\'\', res) = RC4.combine ctx\' c\n                writeIORef ioRef ctx\'\'\n                return (Just res)\n      Streams.makeInputStream readNext\n\n    AESV2 -> do\n      content <- BS.concat <$> Streams.toList is\n      let initV = BS.take 16 content\n          aes = AES.initAES key\n          decrypted = AES.decryptCBC aes initV $ BS.drop 16 content\n      Streams.fromByteString $ Padding.unpadPKCS5 decrypted\n'