b'#include <bits/stdc++.h>\nusing namespace std;\n#define gc getchar_unlocked\n#define fo(i,n) for(i=0;i<n;i++)\n#define Fo(i,k,n) for(i=k;i<n;i++)\n#define ll long long\n#define si(x)\tscanf("%d",&x)\n#define sl(x)\tscanf("%I64d",&x)\n#define ss(s)\tscanf("%s",s)\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define clr(x) memset(x, 0, sizeof(x))\n#define sortall(x) sort(all(x))\n#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)\n#define PI 3.1415926535897932384626\ntypedef pair<int, int>\tpii;\ntypedef pair<ll, ll>\tpll;\ntypedef vector<int>\t\tvi;\ntypedef vector<ll>\t\tvl;\ntypedef vector<pii>\t\tvpii;\ntypedef vector<pll>\t\tvpll;\ntypedef vector<vi>\t\tvvi;\ntypedef vector<vl>\t\tvvl;\nconst int mod = 2e5;\nconst int N = 3e5;\nvi g[N];\nint a[N];\nvoid dfs(int u, int par);\n//http://codeforces.com/contest/600/problem/E\nstatic int t = 0;\nint BLOCK = sqrt(mod);\nbool f(pair<int, pii> a, pair<int, pii> b){\n    if (a.S.F / BLOCK != b.S.F / BLOCK) return a.S.F < b.S.F;\n    return a.S.S < b.S.S;\n}\n\nll sum = 0, occ = 0;\nll ans[N], val[N];\nint cnt[N], col[N], rep[N], in[N], out[N], agla[N], pre[N];\nset<int> dom;\nset<pii> mx;\n//ADD , DEL a number and store the sum of max occuring nos in \'sum\'\nvoid add(int pos){\n    //c is the variable that we are adding here\n    int c = rep[pos];\n    val[cnt[c]] -= c;\n    int pr = pre[cnt[c]];\n    int nxt = agla[cnt[c]];\n    if (val[cnt[c]] == 0) {\n        if (nxt == cnt[c]){\n            //this is highest\n            occ = pr;\n            agla[pr] = pr;\n        }\n        else{\n            pre[nxt] = pr;\n            agla[pr] = nxt;\n        }\n        agla[cnt[c]] = pre[cnt[c]] = -1;\n    }\n    cnt[c]++;\n    val[cnt[c]] += c;\n\n    if (cnt[c] > occ){\n        agla[occ] = cnt[c];\n        pre[cnt[c]] = occ;\n        occ = cnt[c];\n    }\n    else if (cnt[c] < nxt){\n        agla[pr] = cnt[c];\n        pre[cnt[c]] = pr;\n        agla[cnt[c]] = nxt;\n        pre[nxt] = cnt[c];\n    }\n    agla[occ] = occ;\n    sum = val[occ];\n}\nvoid del(int pos){\n    int c = rep[pos];\n    val[cnt[c]] -= c;\n    int pr = pre[cnt[c]];\n    int nxt = agla[cnt[c]];\n    if (val[cnt[c]] == 0) {\n        if (nxt == cnt[c]){\n            //this is highest\n            occ = pr;\n            agla[pr] = pr;\n        }\n        else{\n            pre[nxt] = pr;\n            agla[pr] = nxt;\n        }\n        agla[cnt[c]] = pre[cnt[c]] = -1;\n    }\n    cnt[c]--;\n    val[cnt[c]] += c;\n    if (cnt[c] > occ){\n        agla[occ] = cnt[c];\n        pre[cnt[c]] = occ;\n        occ = cnt[c];\n    }\n    else if (cnt[c] > pr){\n        agla[pr] = cnt[c];\n        pre[cnt[c]] = pr;\n        agla[cnt[c]] = nxt;\n        pre[nxt] = cnt[c];\n    }\n    agla[occ] = occ;\n    sum = val[occ];\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n, i;\n\tsi(n);\n\tset<int> dis_col;\n\tfo (i, n) si(col[i+1]), dis_col.insert(col[i+1]);\n\ttr(it, dis_col) val[0] += *it;\n\n\tfo(i, n-1){\n        int u, v;\n        si(u); si(v);\n        g[u].pb(v);\n        g[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tvector< pair<int, pii> > Q;\n\tFo(i, 1, n+1) Q.pb( { i, {in[i], out[i]} } );\n    sort(Q.begin(), Q.end(), f);\n    int L , R, curl, curr;\n    curl = curr = 0;\n    fo(i, n){\n        pair<int, pii> q = Q[i];\n        L = q.S.F, R = q.S.S;\n\n        while( curl > L){\n            add(curl-1);\n            curl--;\n        }\n        while( curr < R){\n            add(curr+1);\n            curr++;\n        }\n        while( curl < L){\n            del(curl);\n            curl++;\n        }\n        while( curr > R){\n            del(curr);\n            curr--;\n        }\n        ans[q.F] = sum;\n    }\n    Fo(i, 1, n+1) printf("%I64d ",ans[i]);\n\treturn 0;\n}\n\nvoid dfs(int u, int par){\n    in[u] = ++t;\n    rep[t] = col[u];\n    for(int v:g[u]){\n        if (v == par) continue;\n        dfs(v, u);\n    }\n    out[u] = ++t;\n    rep[t] = col[u];\n}\n'