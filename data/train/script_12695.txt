b'//#load "../Excel VM/Project.fs"\n#load "./unused modules/UnusedModule1.fsx"\n#load "../Excel VM/Parser.Definition.fs"\n#load "../Excel VM/Parser.Lexer.fs"\n#load "../Excel VM/Parser.StringFormatting.fs"\n#load "./unused modules/UnusedModule2.fsx"\n#load "../Excel VM/Parser.CParser.fs"\n#load "../Excel VM/Parser.TypeValidation.fs"\n#load "../Excel VM/Parser.Implementation.fs"\n#load "../Excel VM/AST.Definition.fs"\n#load "../Excel VM/AST.Compile.fs"\n#load "../Excel VM/AST.Optimize.fs"\n#load "../Excel VM/AST.Implementation.fs"\n#load "../Excel VM/PseudoASM.Definition.fs"\n#load "../Excel VM/PseudoASM.Compile.fs"\n#load "../Excel VM/PseudoASM.Implementation.fs"\n\nmodule Interpreter =\n  open System\n  open Parser.Definition\n  open AST.Definition\n  open PseudoASM.Definition\n  [<AbstractClass>]\n  type Op(x:PseudoASM) =\n    inherit Comb2("", (x.CommandInfo :?> Comb2).Symbol)\n    abstract member Apply: string -> string -> string\n  let implementForType<\'T> (cast:string -> \'T) (f:\'T -> \'T -> string) a b = f (cast a) (cast b)\n  let k f a b = (f a b).ToString()\n  let castToIntThen = implementForType<int> int\n  let checkIntFirst fint fstr a b =\n    if fst (Int32.TryParse a) && fst (Int32.TryParse b)\n     then castToIntThen fint a b\n     else fstr a b\n  let castToBoolThen = implementForType<bool> (fun s ->\n    match s.ToLower() with\n    |"true" -> true\n    |"false" -> false\n    |_ -> failwith "not a bool"\n   )\n  let allCombinators = [  //[Add; Sub; Mul; Div; Mod; Less; LEq; Equals; NotEq; Greater; GEq; And; Or]\n    {new Op(Add) with override x.Apply a b = castToIntThen (k (+)) a b}\n    {new Op(Sub) with override x.Apply a b = castToIntThen (k (-)) a b}\n    {new Op(Mul) with override x.Apply a b = castToIntThen (k (*)) a b}\n    {new Op(Div) with override x.Apply a b = castToIntThen (k (/)) a b}\n    {new Op(Mod) with override x.Apply a b = castToIntThen (k (%)) a b}\n    {new Op(Less) with override x.Apply a b = checkIntFirst (k (<)) (k (<)) a b}\n    {new Op(LEq) with override x.Apply a b = checkIntFirst (k (<=)) (k (<=)) a b}\n    {new Op(Equals) with override x.Apply a b = checkIntFirst (k (=)) (k (=)) a b}\n    {new Op(NotEq) with override x.Apply a b = checkIntFirst (k (<>)) (k (<>)) a b}\n    {new Op(Greater) with override x.Apply a b = checkIntFirst (k (>)) (k (>)) a b}\n    {new Op(GEq) with override x.Apply a b = checkIntFirst (k (>=)) (k (>=)) a b}\n    {new Op(And) with override x.Apply a b = castToBoolThen (k (&&)) a b}\n    {new Op(Or) with override x.Apply a b = castToBoolThen (k (||)) a b}\n   ]\n  let interpretPAsm act getInput sendOutput cmds =\n    let pushstack stack v = stack := v :: !stack\n    let popstack stack = stack := match !stack with _ :: tl -> tl | [] -> []\n    let topstack stack = match !stack with hd :: _ -> hd | [] -> failwith "took top of an empty stack"\n    let stacks =\n      let x =\n        Array.append (Array.map string [|\'A\'..\'E\'|])\n         <| Array.choose (function Store e | Load e -> Some e | _ -> None) cmds\n         |> Set.ofArray |> Set.toArray\n      printfn "%A" x\n      (x, Array.init x.Length (fun _ -> ref ["0"]))\n       ||> Array.zip\n       |> dict\n    let push name = pushstack stacks.[name]\n    let pop name = popstack stacks.[name]\n    let top name = topstack stacks.[name]\n    let instr, value, _, _, output = "A", "B", "C", "D", "E"\n    pop instr; pop value; pop output\n    let heap = ResizeArray()\n    let interpretCmd i =\n      let fwd = (+) (i-1) >> string     // i-1 because +1 to instrPt gets appended to the end of every cmd\n      let fwd2 = (+) i >> string\n      function\n      |Push s -> push value s\n      |PushFwdShift ii -> push value (fwd2 ii)\n      |Pop -> pop value\n      |Store var -> pop var; push var (top value); pop value\n      |Load var -> push value (top var)\n      |GotoFwdShift ii -> pop instr; push instr (fwd ii)\n      |GotoIfTrueFwdShift ii -> (if (top value).ToLower() = "true" || top value = "1" then pop instr; push instr (fwd ii)); pop value  //not perfect\n      |Call -> let newInstr = string(int(top value) - 1) in pop value; push value (string(int(top instr) + 1)); pop instr; push instr newInstr\n      |Return -> pop instr; push instr (string(int(top value) - 1)); pop value\n      |GetHeap -> let yld = heap.[int(top value)] in pop value; push value yld\n      |NewHeap -> heap.Add ""; push value (string(heap.Count-1))\n      |WriteHeap -> let v = top value in pop value; let i = top value in pop value; heap.[int i] <- v\n      |Input fmt -> push value (getInput fmt)\n      |Output _ -> sendOutput (top value); push output (top value); pop value\n      |Combinator_2(_, _) as c ->\n        let a = top value in pop value\n        let b = top value in pop value\n        let op = List.find (fun (e:Op) -> (c.CommandInfo :?> Comb2).Symbol = e.Symbol) allCombinators\n        push value (op.Apply a b)\n    push instr "0"\n    while int(top instr) < Array.length cmds && List.length !stacks.[output] < 50 do\n      let i = int(top instr)\n      try\n        interpretCmd i cmds.[i]\n      with\n      |ex ->\n        printfn "%A" ex\n        printfn "stack %A" !stacks.[value]\n        printfn "heap [%s]" (String.concat "; " (Seq.map (sprintf "%A") heap))\n        printfn "%A" cmds.[i]\n        failwith "failed"\n      act stacks heap cmds.[i]\n      let pt = int(top instr)\n      pop instr; push instr (string(pt+1))\n\n\nlet compileAndRun act getInput sendOutput txt =\n  Parser.Implementation.fromString (txt, Map ["language", "C"])\n   |> AST.Implementation.fromToken\n   |> PseudoASM.Implementation.fromAST\n   |> fst\n   |> Array.ofSeq\n   |> Interpreter.interpretPAsm act getInput sendOutput\n\n\n//compileAndRun (ignore >> stdin.ReadLine) stdout.WriteLine "int main(){printf(\\"%i\\", 45);}"'