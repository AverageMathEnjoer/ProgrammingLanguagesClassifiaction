b'#include "stdafx.h"\n#include "../AssetsTools/AssetsFileFormat.h"\n#include "../AssetsTools/ResourceManagerFile.h"\n\n#define fwwrite(source,count) {if (pWriter->Write(count, source) != count) return false; filePos += count;}\n#define fwalign() {uint32_t zero = 0; uint32_t nAlign = _fmalign(filePos) - filePos; if (nAlign != 0 && pWriter->Write(nAlign, &zero) != nAlign) return false; filePos += nAlign;}\n#define _fmalign(fpos) (fpos + 3) & ~3\n#define fmalign() {*filePos = _fmalign(*filePos);}\n\nASSETSTOOLS_API bool ResourceManagerFile::Write(IAssetsWriter *pWriter, size_t *size)\n{\n\tif (!isRead)\n\t\treturn false;\n\tsize_t filePos = 0;\n\tint iTmp;\n\n\tuint32_t containerArrayLen = (uint32_t)containers.size();\n\tfwwrite(&containerArrayLen, 4);\n\tfor (size_t i = 0; i < containerArrayLen; i++)\n\t{\n\t\tResourceManager_ContainerData &cd = containers[i];\n\n\t\tiTmp = cd.name.size();\n\t\tif (iTmp < 0) iTmp = 0;\n\t\tfwwrite(&iTmp, 4);\n\t\tfwwrite(cd.name.c_str(), iTmp);\n\t\tfwalign();\n\n\t\tfwwrite(&cd.ids.fileId, 4);\n\t\tfwwrite(&cd.ids.pathId, ((unityVersion>=0x0E)?8:4));\n\t}\n\t\n\tuint32_t dependenciesArrayLen = (uint32_t)dependencyLists.size();\n\tfwwrite(&dependenciesArrayLen, 4);\n\tfor (size_t i = 0; i < dependenciesArrayLen; i++)\n\t{\n\t\tResourceManager_AssetDependencies &dependencyList = dependencyLists[i];\n\t\tfwwrite(&dependencyList.asset.fileId, 4);\n\t\tfwwrite(&dependencyList.asset.pathId, ((unityVersion>=0x0E)?8:4));\n\n\t\tuint32_t dependencyCount = dependencyList.dependencies.size();\n\t\tfwwrite(&dependencyCount, 4);\n\t\tfor (int k = 0; k < dependencyCount; k++)\n\t\t{\n\t\t\tResourceManager_PPtr &pptr = dependencyList.dependencies[k];\n\t\t\tfwwrite(&pptr.fileId, 4);\n\t\t\tfwwrite(&pptr.pathId, ((unityVersion>=0x0E)?8:4));\n\t\t}\n\t}\n\n\tif (size)\n\t\t*size = filePos;\n\treturn true;\n}\n\nASSETSTOOLS_API size_t ResourceManagerFile::GetFileSize()\n{\n\tif (!isRead)\n\t\treturn -1;\n\tint ret = 0;\n\n\tret += 4; //containerArrayLen\n\tfor (size_t i = 0; i < containers.size(); i++)\n\t\tret += _fmalign(containers[i].name.size()); //strlen(containerArray::name)\n\tret += (4 + ((unityVersion>=0x0E)?12:8)) * containers.size(); //sizeof(containerArray::ids)\n\t\n\tret += 4; //dependenciesArrayLen\n\tret += dependencyLists.size() * (4 + ((unityVersion>=0x0E)?12:8)); //sizeof(assetDependency::asset)\n\tfor (size_t i = 0; i < dependencyLists.size(); i++)\n\t\tret += (dependencyLists[i].dependencies.size() * ((unityVersion>=0x0E)?12:8)); //assetDependency::dependencies\n\t\n\treturn ret;\n}\n\nASSETSTOOLS_API ResourceManagerFile::ResourceManagerFile()\n{\n\tisModified = false;\n\tisRead = false;\n\tunityVersion = 0;\n}\n\nASSETSTOOLS_API void ResourceManagerFile::Clear()\n{\n\tisRead = false;\n\tcontainers.clear();\n\tdependencyLists.clear();\n}\n\nASSETSTOOLS_API ResourceManagerFile::~ResourceManagerFile()\n{\n\tthis->Clear();\n}\n\n//#define fmxread(target,count,onerr) {if ((*filePos + count) > dataLen) {memset(target, 0, count);onerr;} else {memcpy(target, &((uint8_t*)data)[*filePos], count); *filePos = *filePos + count;}}\n//#define fmread(target,count) fmxread(target,count,0)\ninline bool fmread(void *target, size_t count, void *data, size_t dataLen, size_t &dataPos)\n{\n\tif ((dataPos + count) > dataLen)\n\t{\n\t\tmemset(target, 0, count);\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tmemcpy(target, &((uint8_t*)data)[dataPos], count);\n\t\tdataPos += count;\n\t\treturn true;\n\t}\n}\n#include "AssetTypeClass.h"\nASSETSTOOLS_API bool ResourceManagerFile::Read(AssetTypeValueField *pBase)\n{\n\t/*\n      ResourceManager Base\n        map m_Container\n         Array Array (IsArray)\n          int size\n          pair data\n           string first\n            Array Array (IsArray)\n             int size\n             char data\n           PPtr<Object> second\n            int m_FileID\n            SInt64 m_PathID\n        vector m_DependentAssets\n         Array Array (IsArray)\n          int size\n          ResourceManager_Dependency data\n           PPtr<Object> m_Object\n            int m_FileID\n            SInt64 m_PathID\n           vector m_Dependencies\n            Array Array (IsArray)\n             int size\n             PPtr<Object> data\n              int m_FileID\n              SInt64 m_PathID\n\t*/\n\tClear();\n\tunityVersion = -1;\n\tisModified = false;\n\tAssetTypeValueField *pContainers = pBase->Get("m_Container")->Get("Array");\n\n\tuint32_t containerArrayLen;\n\tif (pContainers->IsDummy())\n\t{\n\t\tcontainerArrayLen = 0;\n\t\tClear();\n\t\treturn false;\n\t}\n\telse\n\t\tcontainerArrayLen = pContainers->GetChildrenCount();\n\tcontainers.resize(containerArrayLen);\n\tfor (uint32_t i = 0; i < containerArrayLen; i++)\n\t{\n\t\tAssetTypeValueField *pContainerItem = pContainers->Get(i);\n\t\tAssetTypeValue *nameValue = pContainerItem->Get(0U)->GetValue(); //"first"\n\t\tif (nameValue && nameValue->AsString())\n\t\t\tcontainers[i].name.assign(nameValue->AsString());\n\t\telse\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t\tAssetTypeValueField *pContainerPPtr = pContainerItem->Get(1U); //"second"\n\t\tAssetTypeValueField *pContainerPPtr_FileID = pContainerPPtr->Get(0U); //"m_FileID"\n\t\tAssetTypeValueField *pContainerPPtr_PathID = pContainerPPtr->Get(1U); //"m_PathID"\n\t\tif (pContainerPPtr_FileID->GetValue() && pContainerPPtr_FileID->GetValue()->GetType() == ValueType_Int32\n\t\t\t&& pContainerPPtr_PathID->GetValue() && (pContainerPPtr_PathID->GetValue()->GetType() == ValueType_Int32 || pContainerPPtr_PathID->GetValue()->GetType() == ValueType_Int64))\n\t\t{\n\t\t\tcontainers[i].ids.fileId = pContainerPPtr_FileID->GetValue()->AsInt();\n\t\t\tcontainers[i].ids.pathId = pContainerPPtr_PathID->GetValue()->AsInt64();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tAssetTypeValueField *pDependencyLists = pBase->Get("m_DependentAssets")->Get("Array");\n\tuint32_t dependencyListCount;\n\tif (pDependencyLists->IsDummy() || !pDependencyLists->GetValue() || !pDependencyLists->GetValue()->AsArray())\n\t{\n\t\tClear();\n\t\treturn false;\n\t}\n\telse\n\t\tdependencyListCount = pDependencyLists->GetChildrenCount();\n\n\tdependencyLists.resize(dependencyListCount);\n\tfor (uint32_t i = 0; i < dependencyListCount; i++)\n\t{\n\t\tAssetTypeValueField *pDependencyList = pDependencyLists->Get(i);\n\t\tResourceManager_AssetDependencies &dependencyList = dependencyLists[i];\n\t\tAssetTypeValueField *pObjectFileID = pDependencyList->Get(0U)->Get(0U);\n\t\tAssetTypeValueField *pObjectPathID = pDependencyList->Get(0U)->Get(1U);\n\t\tif (pObjectFileID->GetValue() && pObjectFileID->GetValue()->GetType() == ValueType_Int32\n\t\t\t&& pObjectPathID->GetValue() && (pObjectPathID->GetValue()->GetType() == ValueType_Int32 || pObjectPathID->GetValue()->GetType() == ValueType_Int64))\n\t\t{\n\t\t\tdependencyList.asset.fileId = pObjectFileID->GetValue()->AsInt();\n\t\t\tdependencyList.asset.pathId = pObjectPathID->GetValue()->AsInt64();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t\tAssetTypeValueField *pDependencies = pDependencyList->Get(1U)->Get(0U);\n\t\tif (pDependencies->GetValue() && pDependencies->GetValue()->AsArray())\n\t\t{\n\t\t\tuint32_t dependencyCount = pDependencies->GetChildrenCount();\n\t\t\tdependencyList.dependencies.resize(dependencyCount);\n\t\t\tfor (uint32_t k = 0; k < dependencyCount; k++)\n\t\t\t{\n\t\t\t\tAssetTypeValueField *pDependency = pDependencies->Get(k);\n\t\t\t\tResourceManager_PPtr &dependency = dependencyList.dependencies[k];\n\n\t\t\t\tAssetTypeValueField *pDependencyFileID = pDependency->Get(0U);\n\t\t\t\tAssetTypeValueField *pDependencyPathID = pDependency->Get(1U);\n\t\t\t\tif (pDependencyFileID->GetValue() && pDependencyFileID->GetValue()->GetType() == ValueType_Int32\n\t\t\t\t\t&& pDependencyPathID->GetValue() && (pDependencyPathID->GetValue()->GetType() == ValueType_Int32 || pDependencyPathID->GetValue()->GetType() == ValueType_Int64))\n\t\t\t\t{\n\t\t\t\t\tdependency.fileId = pDependencyFileID->GetValue()->AsInt();\n\t\t\t\t\tdependency.pathId = pDependencyPathID->GetValue()->AsInt64();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClear();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tisRead = true;\n\treturn true;\n\n}\nASSETSTOOLS_API void ResourceManagerFile::Read(void *data, size_t dataLen, size_t *filePos, int assetsVersion, bool bigEndian)\n{\n\tClear();\n\tunityVersion = assetsVersion;\n\tisModified = false;\n\n\tbool readErr = false;\n\tuint32_t containerArrayLen = 0;\n\treadErr |= !fmread(&containerArrayLen, 4, data, dataLen, *filePos);\n\tif (bigEndian)\n\t\tSwapEndians_(containerArrayLen);\n\tif (readErr)\n\t{\n\t\tClear();\n\t\treturn;\n\t}\n\tcontainers.resize(containerArrayLen);\n\tfor (size_t i = 0; i < containerArrayLen; i++)\n\t{\n\t\tsize_t assetNameSize = 0; readErr |= !fmread(&assetNameSize, 4, data, dataLen, *filePos);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(assetNameSize);\n\t\tif ((*filePos + assetNameSize) > dataLen)\n\t\t{\n\t\t\tClear();\n\t\t\treturn;\n\t\t}\n\t\tstd::unique_ptr<char[]> assetName(new char[assetNameSize+1]);\n\t\treadErr |= !fmread(assetName.get(), assetNameSize, data, dataLen, *filePos); assetName[assetNameSize] = 0;\n\t\tcontainers[i].name.assign(assetName.get());\n\t\tfmalign();\n\n\t\treadErr |= !fmread(&containers[i].ids.fileId, 4, data, dataLen, *filePos);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(containers[i].ids.fileId);\n\t\tcontainers[i].ids.pathId = 0;\n\t\tif (assetsVersion>=0x0E)\n\t\t{\n\t\t\treadErr |= !fmread(&containers[i].ids.pathId, 8, data, dataLen, *filePos);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(containers[i].ids.pathId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treadErr |= !fmread(&containers[i].ids.pathId, 4, data, dataLen, *filePos);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(*(uint32_t*)&containers[i].ids.pathId);\n\t\t}\n\t\tif (readErr)\n\t\t{\n\t\t\tClear();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tuint32_t dependenciesArrayLen = 0;\n\treadErr |= !fmread(&dependenciesArrayLen, 4, data, dataLen, *filePos);\n\tif (bigEndian)\n\t\tSwapEndians_(dependenciesArrayLen);\n\tif (readErr)\n\t{\n\t\tClear();\n\t\treturn;\n\t}\n\tdependencyLists.resize(dependenciesArrayLen);\n\tfor (size_t i = 0; i < dependenciesArrayLen; i++)\n\t{\n\t\tResourceManager_AssetDependencies &dependencyList = dependencyLists[i];\n\t\treadErr |= !fmread(&dependencyList.asset.fileId, 4, data, dataLen, *filePos);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(dependencyList.asset.fileId);\n\t\tdependencyList.asset.pathId = 0;\n\t\tif (assetsVersion>=0x0E)\n\t\t{\n\t\t\treadErr |= !fmread(&dependencyList.asset.pathId, 8, data, dataLen, *filePos);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(dependencyList.asset.pathId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treadErr |= !fmread(&dependencyList.asset.pathId, 4, data, dataLen, *filePos);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(*(uint32_t*)&dependencyList.asset.pathId);\n\t\t}\n\t\t\n\t\tuint32_t dependencyCount = 0;\n\t\treadErr |= !fmread(&dependencyCount, 4, data, dataLen, *filePos);\n\t\tif (bigEndian)\n\t\t\tSwapEndians_(dependencyCount);\n\t\tif (readErr || (*filePos + ((size_t)dependencyCount) * (assetsVersion>=0x0E ? 8 : 4)) > dataLen)\n\t\t{\n\t\t\tClear();\n\t\t\treturn;\n\t\t}\n\t\tdependencyList.dependencies.resize(dependencyCount);\n\t\tfor (size_t k = 0; k < dependencyCount; k++)\n\t\t{\n\t\t\tResourceManager_PPtr &pptr = dependencyList.dependencies[k];\n\t\t\treadErr |= !fmread(&pptr.fileId, 4, data, dataLen, *filePos);\n\t\t\tif (bigEndian)\n\t\t\t\tSwapEndians_(pptr.fileId);\n\t\t\tpptr.pathId = 0;\n\t\t\tif (assetsVersion>=0x0E)\n\t\t\t{\n\t\t\t\treadErr |= !fmread(&pptr.pathId, 8, data, dataLen, *filePos);\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(pptr.pathId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treadErr |= !fmread(&pptr.pathId, 4, data, dataLen, *filePos);\n\t\t\t\tif (bigEndian)\n\t\t\t\t\tSwapEndians_(*(uint32_t*)&pptr.pathId);\n\t\t\t}\n\t\t}\n\t\tif (readErr)\n\t\t{\n\t\t\tClear();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tisRead = true;\n}'