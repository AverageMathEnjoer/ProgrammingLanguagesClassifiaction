b'package com.iammert.library\n\nimport android.animation.AnimatorSet\nimport android.animation.ArgbEvaluator\nimport android.animation.ValueAnimator\nimport android.content.Context\nimport android.graphics.*\nimport android.graphics.drawable.Drawable\nimport android.os.Build\nimport android.util.AttributeSet\nimport android.view.Gravity\nimport android.view.animation.DecelerateInterpolator\nimport android.widget.ImageView\nimport android.widget.LinearLayout\nimport androidx.core.content.ContextCompat\n\nclass AnimatedTabItemView : LinearLayout {\n\n    enum class State {\n        COLLAPSED, EXPANDED\n    }\n\n    private var mSize: Float = 0.0f\n\n    private var fromColor: Int = 0\n    private var toColor: Int = 0\n\n    private val iconFromColor: Int = ContextCompat.getColor(context, R.color.atl_icon_from_color)\n    private val iconToColor: Int = ContextCompat.getColor(context, R.color.atl_icon_to_color)\n\n    private var path: Path? = null\n    private var rectF: RectF? = null\n    private var maskPaint: Paint? = null\n    private var state: State = State.COLLAPSED\n\n    private var sizeAnimator: ValueAnimator? = null\n    private var layoutColorAnimator: ValueAnimator? = null\n    private var iconColorAnimator: ValueAnimator? = null\n    private var animatorSet: AnimatorSet? = null\n\n    private var mWidth: Float = 0.0f\n    private var mHeight: Float = 0.0f\n    private var radius: Float = 0.0f\n\n    private var imageView: ImageView? = null\n\n    constructor(context: Context) : super(context) {\n        init(context, null)\n    }\n\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {\n        init(context, attrs)\n    }\n\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {\n        init(context, attrs)\n    }\n\n    private fun init(context: Context, attrs: AttributeSet?) {\n        path = Path()\n        rectF = RectF(0f, 0f, 0f, 0f)\n        maskPaint = Paint(Paint.ANTI_ALIAS_FLAG)\n        maskPaint?.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_IN)\n\n        layoutParams = LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)\n        gravity = Gravity.CENTER\n\n        val imageViewLayoutParams = LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)\n        imageView = ImageView(context)\n        imageView?.layoutParams = imageViewLayoutParams\n        addView(imageView)\n\n        setLayerType(LAYER_TYPE_HARDWARE, null)\n        setBackgroundColor(fromColor)\n        requestLayout()\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n        setMeasuredDimension(mWidth.toInt(), mHeight.toInt())\n    }\n\n    override fun dispatchDraw(canvas: Canvas?) {\n        val save = canvas!!.save()\n        super.dispatchDraw(canvas)\n        canvas.restoreToCount(save)\n        path?.let {\n            canvas.drawPath(it, maskPaint!!)\n        }\n    }\n\n    override fun draw(canvas: Canvas?) {\n        path?.let {\n            canvas?.clipPath(it)\n        }\n        super.draw(canvas)\n    }\n\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        path?.reset()\n        path?.addRoundRect(rectF, radius, radius, Path.Direction.CCW)\n    }\n\n    fun setFromColor(fromColor: Int) {\n        this.fromColor = fromColor\n        setBackgroundColor(fromColor)\n        requestLayout()\n    }\n\n    fun setToColor(toColor: Int) {\n        this.toColor = toColor\n        requestLayout()\n    }\n\n    fun setDrawable(drawable: Drawable?) {\n        drawable?.colorFilter = PorterDuffColorFilter(iconFromColor, PorterDuff.Mode.SRC_IN)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n            imageView?.background = drawable\n        } else {\n            imageView?.setBackgroundDrawable(drawable)\n        }\n    }\n\n    fun setItemSize(mSize: Float) {\n        initializeSize(mSize)\n        initializeAnimators()\n        requestLayout()\n    }\n\n    fun expand() {\n        if (state == State.EXPANDED) {\n            return\n        }\n\n        state = State.EXPANDED\n        sizeAnimator?.setFloatValues(mSize, mSize * 2)\n        layoutColorAnimator?.setObjectValues(fromColor, toColor)\n        iconColorAnimator?.setObjectValues(iconFromColor, iconToColor)\n        animatorSet?.start()\n    }\n\n    fun collapse() {\n        if (state == State.COLLAPSED) {\n            return\n        }\n\n        state = State.COLLAPSED\n        sizeAnimator?.setFloatValues(mSize * 2, mSize)\n        layoutColorAnimator?.setObjectValues(toColor, fromColor)\n        iconColorAnimator?.setObjectValues(iconToColor, iconFromColor)\n        animatorSet?.start()\n    }\n\n    private fun initializeAnimators() {\n        createSizeAnimator()\n        createColorAnimator()\n        createAnimatorSet()\n    }\n\n    private fun initializeSize(mSize: Float) {\n        this.mSize = mSize\n        mWidth = mSize\n        mHeight = mSize\n        radius = mSize / 2\n        rectF?.set(0f, 0f, mWidth, mHeight)\n    }\n\n    private fun createSizeAnimator() {\n        sizeAnimator = ValueAnimator.ofFloat(0f, 0f)\n                .also {\n                    it?.apply {\n                        duration = animDuration\n                        interpolator = DecelerateInterpolator()\n                        addUpdateListener { animation -> calculateBorders(animation.animatedValue as Float) }\n                    }\n                }\n    }\n\n    private fun createColorAnimator() {\n        layoutColorAnimator = ValueAnimator.ofObject(ArgbEvaluator(), fromColor, toColor)\n                .also {\n                    it?.apply {\n                        duration = animDuration\n                        interpolator = DecelerateInterpolator()\n                        addUpdateListener { animation ->\n                            setBackgroundColor(animation.animatedValue as Int)\n                            postInvalidate()\n                        }\n                    }\n                }\n\n        iconColorAnimator = ValueAnimator.ofObject(ArgbEvaluator(), iconFromColor, iconToColor)\n                .also {\n                    it?.apply {\n                        duration = animDuration\n                        interpolator = DecelerateInterpolator()\n                        addUpdateListener { animation ->\n                            val drawable = imageView?.background\n                            drawable?.colorFilter = PorterDuffColorFilter(animation.animatedValue as Int, PorterDuff.Mode.SRC_IN)\n                            postInvalidate()\n                        }\n                    }\n                }\n    }\n\n    private fun createAnimatorSet() {\n        animatorSet = AnimatorSet().apply { playTogether(sizeAnimator, layoutColorAnimator, iconColorAnimator) }\n    }\n\n    private fun calculateBorders(value: Float) {\n        val params = layoutParams\n        params.width = value.toInt()\n        layoutParams = params\n        mWidth = value\n        mHeight = (mSize + ((value - mSize) * multiplier)).toFloat()\n        radius = mHeight / 2\n        rectF?.set(0f, 0f, mWidth, mHeight)\n        postInvalidate()\n    }\n\n    companion object {\n        //constants\n        const val animDuration: Long = 300\n        const val multiplier: Double = 0.15\n    }\n}'