b'{-# LANGUAGE CPP #-}\n-- Time-stamp: <2011-02-12 21:11:31 simonmar>\n-----------------------------------------------------------------------------\n\nmodule Game where\n\nimport Board\nimport Tree\n\nimport Control.Parallel\nimport Debug.Trace\n#ifdef NEW_GENERIC\nimport qualified Data.Par as C\n#else\nimport qualified Control.Monad.Par.Combinator as C\n#endif\n#ifdef PARSCHED\nimport PARSCHED\n#else\nimport Control.Monad.Par (runPar, Par)\n#endif\n\ntype Player = Evaluation -> Evaluation -> Evaluation\ntype Move = (Board,Evaluation)\n\nalternate :: Int -> Piece -> Player -> Player -> Board -> [Move]\nalternate _ _ _ _ b | fullBoard b = []\nalternate _ _ _ _ b | static b == XWin = []\nalternate _ _ _ _ b | static b == OWin = []\nalternate depth player f g board = move : alternate depth opponent g f board\'\n  where\n    move@(board\',eval) = best f possibles scores\n    scores = runPar $ C.parMapM (bestMove depth opponent g f) possibles\n    possibles = newPositions player board\n    opponent = opposite player\n\nalternateNested :: Int -> Piece -> Player -> Player -> Board -> [Move]\nalternateNested _ _ _ _ b | fullBoard b = []\nalternateNested _ _ _ _ b | static b == XWin = []\nalternateNested _ _ _ _ b | static b == OWin = []\nalternateNested depth player f g board = move : alternateNested depth opponent g f board\'\n  where\n    move@(board\',eval) = best f possibles scores\n    scores = runPar $ C.parMap (bestMoveNested depth opponent g f) possibles\n    possibles = newPositions player board\n    opponent = opposite player\n\nopposite :: Piece -> Piece\nopposite X = O\nopposite O = X\n\n\nbest :: Player -> [Board] -> [Evaluation] -> Move\nbest f (b:bs) (s:ss) = best\' b s bs ss\n\twhere\n\tbest\' b s [] [] = (b,s)\n\tbest\' b s (b\':bs) (s\':ss) | s==(f s s\') = best\' b s bs ss\n\t\t\t\t  | otherwise \t= best\' b\' s\' bs ss\n\nshowMove :: Move -> String\nshowMove (b,e) = show e ++ "\\n" ++ showBoard b\n\nbestMove :: Int -> Piece -> Player -> Player -> Board -> Par Evaluation\nbestMove depth p f g board\n  = do\n    let tree = cropTree $ mapTree static $ prune depth $ searchTree p $ board\n    parMise 2 f g tree\n\nbestMoveNested :: Int -> Piece -> Player -> Player -> Board -> Evaluation\nbestMoveNested depth p f g board\n  = let tree = cropTree $ mapTree static $ prune depth $ searchTree p $ board\n    in runPar $ parMise 2 f g tree\n\ncropTree :: (Tree Evaluation) -> (Tree Evaluation)\ncropTree (Branch a []) = (Branch a [])\ncropTree (Branch (Score x) l) = Branch (Score x) (map cropTree l)\ncropTree (Branch x l) = Branch x []\n\nsearchTree :: Piece -> Board -> (Tree Board)\nsearchTree p board = repTree (newPositions p) (newPositions (opposite p)) board\n\nmise :: Player -> Player -> (Tree Evaluation) -> Evaluation\nmise f g (Branch a []) = a\nmise f g (Branch _ l) = foldr f (g OWin XWin) (map (mise g f) l)\n\nparMise :: Int -> Player -> Player -> (Tree Evaluation) -> Par Evaluation\nparMise 0 f g t = return (mise f g t)\nparMise n f g (Branch a []) = return a\nparMise n f g (Branch _ l) = do\n  es <- C.parMapM (parMise (n-1) g f) l\n  return (foldr f (g OWin XWin) es)\n'