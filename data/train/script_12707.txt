b'{-# LANGUAGE ApplicativeDo #-}\n\nmodule Cachix.Client.OptionsParser\n  ( CachixCommand (..),\n    PushArguments (..),\n    PushOptions (..),\n    PinOptions (..),\n    BinaryCacheName,\n    getOpts,\n    Flags (..),\n  )\nwhere\n\nimport qualified Cachix.Client.Config as Config\nimport qualified Cachix.Client.InstallationMode as InstallationMode\nimport Cachix.Client.URI (URI)\nimport qualified Cachix.Client.URI as URI\nimport qualified Cachix.Deploy.OptionsParser as DeployOptions\nimport qualified Cachix.Types.BinaryCache as BinaryCache\nimport Cachix.Types.PinCreate (Keep (..))\nimport qualified Data.Text as T\nimport Options.Applicative\nimport Protolude hiding (toS)\nimport Protolude.Conv\nimport qualified Prelude\n\ndata Flags = Flags\n  { configPath :: Config.ConfigPath,\n    hostname :: Maybe URI,\n    verbose :: Bool\n  }\n\nflagParser :: Config.ConfigPath -> Parser Flags\nflagParser defaultConfigPath = do\n  hostname <-\n    optional $\n      option\n        uriOption\n        ( mconcat\n            [ long "hostname",\n              metavar "URI",\n              help ("Host to connect to (default: " <> defaultHostname <> ")")\n            ]\n        )\n        -- Accept `host` for backwards compatibility\n        <|> option uriOption (long "host" <> hidden)\n\n  configPath <-\n    strOption $\n      mconcat\n        [ long "config",\n          short \'c\',\n          value defaultConfigPath,\n          metavar "CONFIGPATH",\n          showDefault,\n          help "Cachix configuration file"\n        ]\n\n  verbose <-\n    switch $\n      mconcat\n        [ long "verbose",\n          short \'v\',\n          help "Verbose mode"\n        ]\n\n  pure Flags {hostname, configPath, verbose}\n  where\n    defaultHostname = URI.serialize URI.defaultCachixURI\n\nuriOption :: ReadM URI\nuriOption = eitherReader $ \\s ->\n  first show $ URI.parseURI (toS s)\n\ntype BinaryCacheName = Text\n\ndata CachixCommand\n  = AuthToken (Maybe Text)\n  | Config Config.Command\n  | GenerateKeypair BinaryCacheName\n  | Push PushArguments\n  | Pin PinOptions\n  | WatchStore PushOptions Text\n  | WatchExec PushOptions Text Text [Text]\n  | Use BinaryCacheName InstallationMode.UseOptions\n  | DeployCommand DeployOptions.DeployCommand\n  | Version\n  deriving (Show)\n\ndata PushArguments\n  = PushPaths PushOptions Text [Text]\n  | PushWatchStore PushOptions Text\n  deriving (Show)\n\ndata PinOptions = PinOptions\n  { pinCacheName :: BinaryCacheName,\n    pinName :: Text,\n    pinStorePath :: Text,\n    pinArtifacts :: [Text],\n    pinKeep :: Maybe Keep\n  }\n  deriving (Show)\n\ndata PushOptions = PushOptions\n  { compressionLevel :: Int,\n    compressionMethod :: Maybe BinaryCache.CompressionMethod,\n    numJobs :: Int,\n    omitDeriver :: Bool\n  }\n  deriving (Show)\n\ncommandParser :: Parser CachixCommand\ncommandParser =\n  subparser $\n    command "authtoken" (infoH authtoken (progDesc "Configure authentication token for communication to HTTP API"))\n      <> command "config" (Config <$> Config.parser)\n      <> command "generate-keypair" (infoH generateKeypair (progDesc "Generate signing key pair for a binary cache"))\n      <> command "push" (infoH push (progDesc "Upload Nix store paths to a binary cache"))\n      <> command "pin" (infoH pin (progDesc "Pin a store path to prevent it from being garbage collected"))\n      <> command "watch-exec" (infoH watchExec (progDesc "Run a command while it\'s running watch /nix/store for newly added store paths and upload them to a binary cache"))\n      <> command "watch-store" (infoH watchStore (progDesc "Indefinitely watch /nix/store for newly added store paths and upload them to a binary cache"))\n      <> command "use" (infoH use (progDesc "Configure a binary cache by writing nix.conf and netrc files"))\n      <> command "deploy" (infoH (DeployCommand <$> DeployOptions.parser) (progDesc "Cachix Deploy commands"))\n  where\n    nameArg = strArgument (metavar "CACHE-NAME")\n    authtoken = AuthToken <$> (stdinFlag <|> (Just <$> authTokenArg))\n      where\n        stdinFlag = flag\' Nothing (long "stdin" <> help "Read the token from stdin rather than accepting it as an argument.")\n        authTokenArg = strArgument (metavar "AUTH-TOKEN")\n    generateKeypair = GenerateKeypair <$> nameArg\n    validatedLevel l =\n      l <$ unless (l `elem` [0 .. 16]) (readerError $ "value " <> show l <> " not in expected range: [0..16]")\n    validatedMethod :: Prelude.String -> Either Prelude.String (Maybe BinaryCache.CompressionMethod)\n    validatedMethod method =\n      if method `elem` ["xz", "zstd"]\n        then case readEither (T.toUpper (toS method)) of\n          Right a -> Right $ Just a\n          Left b -> Left $ toS b\n        else Left $ "Compression method " <> show method <> " not expected. Use xz or zstd."\n    pushOptions :: Parser PushOptions\n    pushOptions =\n      PushOptions\n        <$> option\n          (auto >>= validatedLevel)\n          ( long "compression-level"\n              <> short \'c\'\n              <> metavar "[0..16]"\n              <> help\n                "The compression level for XZ compression between 0-9 and ZSTD 0-16."\n              <> showDefault\n              <> value 2\n          )\n        <*> option\n          (eitherReader validatedMethod)\n          ( long "compression-method"\n              <> short \'m\'\n              <> metavar "xz | zstd"\n              <> help\n                "The compression method, either xz or zstd. Defaults to zstd."\n              <> value Nothing\n          )\n        <*> option\n          auto\n          ( long "jobs"\n              <> short \'j\'\n              <> help "Number of threads used for pushing store paths."\n              <> showDefault\n              <> value 8\n          )\n        <*> switch (long "omit-deriver" <> help "Do not publish which derivations built the store paths.")\n    push = (\\opts cache f -> Push $ f opts cache) <$> pushOptions <*> nameArg <*> (pushPaths <|> pushWatchStore)\n    pushPaths =\n      (\\paths opts cache -> PushPaths opts cache paths)\n        <$> many (strArgument (metavar "PATHS..."))\n    keepParser = daysParser <|> revisionsParser <|> foreverParser <|> pure Nothing\n    -- these three flag are mutually exclusive\n    daysParser = Just . Days <$> option auto (long "keep-days" <> metavar "INT")\n    revisionsParser = Just . Revisions <$> option auto (long "keep-revisions" <> metavar "INT")\n    foreverParser = flag\' (Just Forever) (long "keep-forever")\n    pinOptions =\n      PinOptions\n        <$> nameArg\n        <*> strArgument (metavar "PIN-NAME")\n        <*> strArgument (metavar "STORE-PATH")\n        <*> many (strOption (metavar "ARTIFACTS..." <> long "artifact" <> short \'a\'))\n        <*> keepParser\n    pin = Pin <$> pinOptions\n    watchExec = WatchExec <$> pushOptions <*> nameArg <*> strArgument (metavar "CMD") <*> many (strArgument (metavar "-- ARGS"))\n    watchStore = WatchStore <$> pushOptions <*> nameArg\n    pushWatchStore =\n      (\\() opts cache -> PushWatchStore opts cache)\n        <$> flag\'\n          ()\n          ( long "watch-store"\n              <> short \'w\'\n              <> help "DEPRECATED: use watch-store command instead."\n          )\n    use =\n      Use\n        <$> nameArg\n        <*> ( InstallationMode.UseOptions\n                <$> optional\n                  ( option\n                      (maybeReader InstallationMode.fromString)\n                      ( long "mode"\n                          <> short \'m\'\n                          <> help "Mode in which to configure binary caches for Nix. Supported values: nixos, root-nixconf, user-nixconf"\n                      )\n                  )\n                <*> strOption\n                  ( long "nixos-folder"\n                      <> short \'d\'\n                      <> help "Base directory for NixOS configuration generation"\n                      <> value "/etc/nixos/"\n                      <> showDefault\n                  )\n                <*> optional\n                  ( strOption\n                      ( long "output-directory"\n                          <> short \'O\'\n                          <> help "Output directory where nix.conf and netrc will be updated."\n                      )\n                  )\n            )\n\ngetOpts :: IO (Flags, CachixCommand)\ngetOpts = do\n  configpath <- Config.getDefaultFilename\n  customExecParser (prefs showHelpOnEmpty) (optsInfo configpath)\n\noptsInfo :: Config.ConfigPath -> ParserInfo (Flags, CachixCommand)\noptsInfo configpath = infoH parser desc\n  where\n    parser = (,) <$> flagParser configpath <*> (commandParser <|> versionParser)\n    versionParser :: Parser CachixCommand\n    versionParser =\n      flag\'\n        Version\n        ( long "version"\n            <> short \'V\'\n            <> help "Show cachix version"\n        )\n\ndesc :: InfoMod a\ndesc =\n  fullDesc\n    <> progDesc "To get started log in to https://app.cachix.org"\n    <> header "https://cachix.org command line interface"\n\n-- TODO: usage footer\ninfoH :: Parser a -> InfoMod a -> ParserInfo a\ninfoH a = info (helper <*> a)\n'