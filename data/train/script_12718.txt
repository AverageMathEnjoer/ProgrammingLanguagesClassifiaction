b'{-# LANGUAGE TypeSynonymInstances, CPP, FlexibleInstances, BangPatterns #-}\n\n-- | This module extends a Par monad with /pedigree/.  That is, it\n--   allows a running computation to look up its position in the\n--   dynamic binary tree of `fork` calls ("ancestry").\n\nmodule Control.Monad.Par.Pedigree\n (\n   pedigree, ParPedigreeT\n , unpack, runParPedigree\n )\n where\n\nimport Control.Monad.Par.Class\nimport Control.Monad.Par.State\nimport Control.Monad.Trans.State.Strict as S\n\n-- It\'s running slightly better with normal lists for parfib:\n#if 0\nimport Data.BitList\ntype BList = BitList\n#else\ntype BList = [Bool]\nunpack :: Pedigree -> BList\nunpack (Pedigree _ x) = x\ncons :: x -> [x] -> [x]\ncons = (:)\nempty :: [x]\nempty = []\n#endif\n\ntype ParPedigreeT p a = S.StateT Pedigree p a\n\n-- type Pedigree = BList\n-- -- | Trivial instance.\n-- instance SplittableState Pedigree where\n--   splitState bl = (cons False bl, cons True bl)\n\ndata Pedigree =\n      Pedigree { _ivarCounter :: {-# UNPACK #-} !Int,\n                 _treePath    :: !BList }\n\ninstance SplittableState Pedigree where\n  splitState (Pedigree cnt bl) =\n    (Pedigree cnt (cons False bl),\n     Pedigree cnt (cons True bl))\n\npedigree :: ParFuture iv p => S.StateT Pedigree p Pedigree\npedigree = S.get\n\nrunParPedigree :: Monad p => ParPedigreeT p a -> p a\nrunParPedigree m = S.evalStateT m (Pedigree 0 empty)\n'