b'package id.zelory.compressor\n\nimport android.content.Context\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.graphics.Matrix\nimport android.media.ExifInterface\nimport java.io.File\nimport java.io.FileOutputStream\n\n/**\n * Created on : January 24, 2020\n * Author     : zetbaitsu\n * Name       : Zetra\n * GitHub     : https://github.com/zetbaitsu\n */\nprivate val separator = File.separator\n\nprivate fun cachePath(context: Context) = "${context.cacheDir.path}${separator}compressor$separator"\n\nfun File.compressFormat() = when (extension.toLowerCase()) {\n    "png" -> Bitmap.CompressFormat.PNG\n    "webp" -> Bitmap.CompressFormat.WEBP\n    else -> Bitmap.CompressFormat.JPEG\n}\n\nfun Bitmap.CompressFormat.extension() = when (this) {\n    Bitmap.CompressFormat.PNG -> "png"\n    Bitmap.CompressFormat.WEBP -> "webp"\n    else -> "jpg"\n}\n\nfun loadBitmap(imageFile: File) = BitmapFactory.decodeFile(imageFile.absolutePath).run {\n    determineImageRotation(imageFile, this)\n}\n\nfun decodeSampledBitmapFromFile(imageFile: File, reqWidth: Int, reqHeight: Int): Bitmap {\n    return BitmapFactory.Options().run {\n        inJustDecodeBounds = true\n        BitmapFactory.decodeFile(imageFile.absolutePath, this)\n\n        inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)\n\n        inJustDecodeBounds = false\n        BitmapFactory.decodeFile(imageFile.absolutePath, this)\n    }\n}\n\nfun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {\n    // Raw height and width of image\n    val (height: Int, width: Int) = options.run { outHeight to outWidth }\n    var inSampleSize = 1\n\n    if (height > reqHeight || width > reqWidth) {\n\n        val halfHeight: Int = height / 2\n        val halfWidth: Int = width / 2\n\n        // Calculate the largest inSampleSize value that is a power of 2 and keeps both\n        // height and width larger than the requested height and width.\n        while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {\n            inSampleSize *= 2\n        }\n    }\n\n    return inSampleSize\n}\n\nfun determineImageRotation(imageFile: File, bitmap: Bitmap): Bitmap {\n    val exif = ExifInterface(imageFile.absolutePath)\n    val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 0)\n    val matrix = Matrix()\n    when (orientation) {\n        6 -> matrix.postRotate(90f)\n        3 -> matrix.postRotate(180f)\n        8 -> matrix.postRotate(270f)\n    }\n    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)\n}\n\ninternal fun copyToCache(context: Context, imageFile: File): File {\n    return imageFile.copyTo(File("${cachePath(context)}${imageFile.name}"), true)\n}\n\nfun overWrite(imageFile: File, bitmap: Bitmap, format: Bitmap.CompressFormat = imageFile.compressFormat(), quality: Int = 100): File {\n    val result = if (format == imageFile.compressFormat()) {\n        imageFile\n    } else {\n        File("${imageFile.absolutePath.substringBeforeLast(".")}.${format.extension()}")\n    }\n    imageFile.delete()\n    saveBitmap(bitmap, result, format, quality)\n    return result\n}\n\nfun saveBitmap(bitmap: Bitmap, destination: File, format: Bitmap.CompressFormat = destination.compressFormat(), quality: Int = 100) {\n    destination.parentFile?.mkdirs()\n    var fileOutputStream: FileOutputStream? = null\n    try {\n        fileOutputStream = FileOutputStream(destination.absolutePath)\n        bitmap.compress(format, quality, fileOutputStream)\n    } finally {\n        fileOutputStream?.run {\n            flush()\n            close()\n        }\n    }\n}'