b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i64 = System.Int64;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\n\nusing Pgno = System.UInt32;\n\n\nnamespace CS_SQLite3\n{\n  using sqlite_int64 = System.Int64;\n  using System.Globalization;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** Utility functions used throughout sqlite.\n    **\n    ** This file contains functions for allocating memory, comparing\n    ** strings, and stuff like that.\n    **\n    ** $Id: util.c,v 1.262 2009/07/28 16:44:26 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <stdarg.h>\n#if SQLITE_HAVE_ISNAN\n//# include <math.h>\n#endif\n\n\n    /*\n** Routine needed to support the testcase() macro.\n*/\n#if SQLITE_COVERAGE_TEST\nvoid sqlite3Coverage(int x){\nstatic int dummy = 0;\ndummy += x;\n}\n#endif\n\n    /*\n** Return true if the floating point value is Not a Number (NaN).\n**\n** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.\n** Otherwise, we have our own implementation that works on most systems.\n*/\n    static bool sqlite3IsNaN( double x )\n    {\n      bool rc;   /* The value return */\n#if !(SQLITE_HAVE_ISNAN)\n      /*\n** Systems that support the isnan() library function should probably\n** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we have\n** found that many systems do not have a working isnan() function so\n** this implementation is provided as an alternative.\n**\n** This NaN test sometimes fails if compiled on GCC with -ffast-math.\n** On the other hand, the use of -ffast-math comes with the following\n** warning:\n**\n**      This option [-ffast-math] should never be turned on by any\n**      -O option since it can result in incorrect output for programs\n**      which depend on an exact implementation of IEEE or ISO\n**      rules/specifications for math functions.\n**\n** Under MSVC, this NaN test may fail if compiled with a floating-\n** point precision mode other than /fp:precise.  From the MSDN\n** documentation:\n**\n**      The compiler [with /fp:precise] will properly handle comparisons\n**      involving NaN. For example, x != x evaluates to true if x is NaN\n**      ...\n*/\n#if __FAST_MATH__\n# error SQLite will not work correctly with the -ffast-math option of GCC.\n#endif\n      double y = x;\n      double z = y;\n      rc = ( y != z );\n#else  //* if defined(SQLITE_HAVE_ISNAN) */\nrc = isnan(x);\n#endif //* SQLITE_HAVE_ISNAN */\n      testcase( rc );\n      return rc;\n    }\n\n\n    /*\n    ** Compute a string length that is limited to what can be stored in\n    ** lower 30 bits of a 32-bit signed integer.\n    **\n    ** The value returned will never be negative.  Nor will it ever be greater\n    ** than the actual length of the string.  For very long strings (greater\n    ** than 1GiB) the value returned might be less than the true string length.\n    */\n    static int sqlite3Strlen30( int z )\n    {\n      return 0x3fffffff & z;\n    }\n    static int sqlite3Strlen30( StringBuilder z )\n    {\n      //const char *z2 = z;\n      if ( z == null ) return 0;\n      //while( *z2 ){ z2++; }\n      //return 0x3fffffff & (int)(z2 - z);\n      return 0x3fffffff & z.Length;\n    }\n    static int sqlite3Strlen30( string z )\n    {\n      //const char *z2 = z;\n      if ( z == null ) return 0;\n      //while( *z2 ){ z2++; }\n      //return 0x3fffffff & (int)(z2 - z);\n      return 0x3fffffff & z.Length;\n    }\n\n\n    /*\n    ** Set the most recent error code and error string for the sqlite\n    ** handle "db". The error code is set to "err_code".\n    **\n    ** If it is not NULL, string zFormat specifies the format of the\n    ** error string in the style of the printf functions: The following\n    ** format characters are allowed:\n    **\n    **      %s      Insert a string\n    **      %z      A string that should be freed after use\n    **      %d      Insert an integer\n    **      %T      Insert a token\n    **      %S      Insert the first element of a SrcList\n    **\n    ** zFormat and any string tokens that follow it are assumed to be\n    ** encoded in UTF-8.\n    **\n    ** To clear the most recent error for sqlite handle "db", sqlite3Error\n    ** should be called with err_code set to SQLITE_OK and zFormat set\n    ** to NULL.\n    */\n    //Overloads\n    static void sqlite3Error( sqlite3 db, int err_code, int noString )\n    { sqlite3Error( db, err_code, err_code == 0 ?null :""); }\n\n    static void sqlite3Error( sqlite3 db, int err_code, string zFormat, params object[] ap )\n    {\n      if ( db != null && ( db.pErr != null || ( db.pErr = sqlite3ValueNew( db ) ) != null ) )\n      {\n        db.errCode = err_code;\n        if ( zFormat != null )\n        {\n          string z;\n          va_start( ap, zFormat );\n          z = sqlite3VMPrintf( db, zFormat, ap );\n          va_end( ap );\n          sqlite3ValueSetStr( db.pErr, -1, z, SQLITE_UTF8, (dxDel)SQLITE_DYNAMIC );\n        }\n        else\n        {\n          sqlite3ValueSetStr( db.pErr, 0, null, SQLITE_UTF8, SQLITE_STATIC );\n        }\n      }\n    }\n\n    /*\n    ** Add an error message to pParse.zErrMsg and increment pParse.nErr.\n    ** The following formatting characters are allowed:\n    **\n    **      %s      Insert a string\n    **      %z      A string that should be freed after use\n    **      %d      Insert an integer\n    **      %T      Insert a token\n    **      %S      Insert the first element of a SrcList\n    **\n    ** This function should be used to report any error that occurs whilst\n    ** compiling an SQL statement (i.e. within sqlite3_prepare()). The\n    ** last thing the sqlite3_prepare() function does is copy the error\n    ** stored by this function into the database handle using sqlite3Error().\n    ** Function sqlite3Error() should be used during statement execution\n    ** (sqlite3_step() etc.).\n    */\n    static void sqlite3ErrorMsg( Parse pParse, string zFormat, params object[] ap )\n    {\n      //va_list ap;\n      sqlite3 db = pParse.db;\n      pParse.nErr++;\n      //sqlite3DbFree( db, ref pParse.zErrMsg );\n      va_start( ap, zFormat );\n      pParse.zErrMsg = sqlite3VMPrintf( db, zFormat, ap );\n      va_end( ap );\n      pParse.rc = SQLITE_ERROR;\n    }\n\n    /*\n    ** Clear the error message in pParse, if any\n    */\n    static void sqlite3ErrorClear( Parse pParse )\n    {\n      //sqlite3DbFree( pParse.db, ref  pParse.zErrMsg );\n      pParse.nErr = 0;\n    }\n\n    /*\n    ** Convert an SQL-style quoted string into a normal string by removing\n    ** the quote characters.  The conversion is done in-place.  If the\n    ** input does not begin with a quote character, then this routine\n    ** is a no-op.\n    **\n    ** The input string must be zero-terminated.  A new zero-terminator\n    ** is added to the dequoted string.\n    **\n    ** The return value is -1 if no dequoting occurs or the length of the\n    ** dequoted string, exclusive of the zero terminator, if dequoting does\n    ** occur.\n    **\n    ** 2002-Feb-14: This routine is extended to remove MS-Access style\n    ** brackets from around identifers.  For example:  "[a-b-c]" becomes\n    ** "a-b-c".\n    */\n    static int sqlite3Dequote( ref string z )\n    {\n      char quote;\n      int i;\n      if ( z == null || z == "" ) return -1;\n      quote = z[0];\n      switch ( quote )\n      {\n        case \'\\\'\': break;\n        case \'"\': break;\n        case \'`\': break;                /* For MySQL compatibility */\n        case \'[\': quote = \']\'; break;  /* For MS SqlServer compatibility */\n        default: return -1;\n      }\n      StringBuilder sbZ = new StringBuilder( z.Length );\n      for ( i = 1 ; i < z.Length ; i++ ) //z[i] != 0; i++)\n      {\n        if ( z[i] == quote )\n        {\n          if ( i < z.Length - 1 && ( z[i + 1] == quote ) )\n          {\n            sbZ.Append( quote );\n            i++;\n          }\n          else\n          {\n            break;\n          }\n        }\n        else\n        {\n          sbZ.Append( z[i] );\n        }\n      }\n      z = sbZ.ToString();\n      return sbZ.Length;\n    }\n\n    /* Convenient short-hand */\n    //#define UpperToLower sqlite3UpperToLower\n    static int[] UpperToLower;\n\n    /*\n    ** Some systems have stricmp().  Others have strcasecmp().  Because\n    ** there is no consistency, we will define our own.\n    */\n\n    static int sqlite3StrICmp( string zLeft, string zRight )\n    {\n      //register unsigned char *a, *b;\n      //a = (unsigned char *)zLeft;\n      //b = (unsigned char *)zRight;\n      //while( *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }\n      //return UpperToLower[*a] - UpperToLower[*b];\n      int a = 0, b = 0;\n      while ( a < zLeft.Length && b < zRight.Length && UpperToLower[zLeft[a]] == UpperToLower[zRight[b]] ) { a++; b++; }\n      if ( a == zLeft.Length && b == zRight.Length ) return 0;\n      else\n      {\n        if ( a == zLeft.Length ) return -UpperToLower[zRight[b]];\n        if ( b == zRight.Length ) return UpperToLower[zLeft[a]];\n        return UpperToLower[zLeft[a]] - UpperToLower[zRight[b]];\n      }\n    }\n\n    static int sqlite3_strnicmp( string zLeft, int offsetLeft, string zRight, int N )\n    { return sqlite3StrNICmp(  zLeft,  offsetLeft,  zRight,  N );}\n\n    static int sqlite3StrNICmp( string zLeft, int offsetLeft, string zRight, int N )\n    {\n      //register unsigned char *a, *b;\n      //a = (unsigned char *)zLeft;\n      //b = (unsigned char *)zRight;\n      int a = 0, b = 0;\n      while ( N-- > 0 && zLeft[a + offsetLeft] != 0 && UpperToLower[zLeft[a + offsetLeft]] == UpperToLower[zRight[b]] ) { a++; b++; }\n      return N < 0 ? 0 : UpperToLower[zLeft[a + offsetLeft]] - UpperToLower[zRight[b]];\n    }\n\n    static int sqlite3StrNICmp( string zLeft, string zRight, int N )\n    {\n      //register unsigned char *a, *b;\n      //a = (unsigned char *)zLeft;\n      //b = (unsigned char *)zRight;\n      int a = 0, b = 0;\n      while ( N-- > 0 && ( zLeft[a] == zRight[b] || ( zLeft[a] != 0 && zLeft[a] < 256 && zRight[b] < 256 && UpperToLower[zLeft[a]] == UpperToLower[zRight[b]] ) ) ) { a++; b++; }\n      if ( N < 0 ) return 0;\n      else if ( zLeft[a] < 256 && zRight[b] < 256 ) return UpperToLower[zLeft[a]] - UpperToLower[zRight[b]];\n      else return zLeft[a] - zRight[b];\n    }\n\n    /*\n    ** Return TRUE if z is a pure numeric string.  Return FALSE and leave\n    ** *realnum unchanged if the string contains any character which is not\n    ** part of a number.\n    **\n    ** If the string is pure numeric, set *realnum to TRUE if the string\n    ** contains the \'.\' character or an "E+000" style exponentiation suffix.\n    ** Otherwise set *realnum to FALSE.  Note that just becaue *realnum is\n    ** false does not mean that the number can be successfully converted into\n    ** an integer - it might be too big.\n    **\n    ** An empty string is considered non-numeric.\n    */\n    static int sqlite3IsNumber( string z, ref int realnum, int enc )\n    {\n      if ( String.IsNullOrEmpty( z ) ) return 0;\n      int incr = ( enc == SQLITE_UTF8 ? 1 : 2 );\n      int zIndex = 0;\n      if ( enc == SQLITE_UTF16BE ) zIndex++;// z++;\n      if ( z[zIndex] == \'-\' || z[zIndex] == \'+\' ) zIndex += incr;//z += incr;\n      if ( zIndex == z.Length || !sqlite3Isdigit( z[zIndex] ) )\n      {\n        return 0;\n      }\n      zIndex += incr;//z += incr;\n      realnum = 0;\n      while ( zIndex < z.Length && sqlite3Isdigit( z[zIndex] ) ) { zIndex += incr; }//z += incr; }\n      if ( zIndex < z.Length && z[zIndex] == \'.\' )\n      {\n        zIndex += incr;//z += incr;\n        if ( !sqlite3Isdigit( z[zIndex] ) ) return 0;\n        while ( zIndex < z.Length && sqlite3Isdigit( z[zIndex] ) ) { zIndex += incr; }//z += incr; }\n        realnum = 1;\n      }\n      if ( zIndex < z.Length && ( z[zIndex] == \'e\' || z[zIndex] == \'E\' ) )\n      {\n        zIndex += incr;//z += incr;\n        if ( zIndex < z.Length && ( z[zIndex] == \'+\' || z[zIndex] == \'-\' ) ) zIndex += incr;//z += incr;\n        if ( zIndex == z.Length || !sqlite3Isdigit( z[zIndex] ) ) return 0;\n        while ( zIndex < z.Length && sqlite3Isdigit( z[zIndex] ) ) { zIndex += incr; }//z += incr; }\n        realnum = 1;\n      }\n      return zIndex == z.Length ? 1 : 0;// z[zIndex] == 0;\n    }\n\n    /*\n    ** The string z[] is an ascii representation of a real number.\n    ** Convert this string to a double.\n    **\n    ** This routine assumes that z[] really is a valid number.  If it\n    ** is not, the result is undefined.\n    **\n    ** This routine is used instead of the library atof() function because\n    ** the library atof() might want to use "," as the decimal point instead\n    ** of "." depending on how locale is set.  But that would cause problems\n    ** for SQL.  So this routine always uses "." regardless of locale.\n    */\n    static int sqlite3AtoF( string z, ref double pResult )\n    {\n#if !SQLITE_OMIT_FLOATING_POINT\n      z = z.Trim() + " ";\n      int zDx = 0;\n      int sign = 1;\n      double v1 = 0.0;\n      int nSignificant = 0;\n      if ( z.Length > 1 )\n      {\n        while ( sqlite3Isspace( z[zDx] ) ) zDx++;\n        if ( z[zDx] == \'-\' )\n        {\n          sign = -1;\n          zDx++;\n        }\n        else if ( z[zDx] == \'+\' )\n        {\n          zDx++;\n        }\n        while ( z[zDx] == \'0\' )\n        {\n          zDx++;\n        }\n        while ( sqlite3Isdigit( z[zDx] ) )\n        {\n          v1 = v1 * 10.0 + ( z[zDx] - \'0\' );\n          zDx++;\n          nSignificant++;\n        }\n        if ( z[zDx] == \'.\' )\n        {\n          double divisor = 1.0;\n          zDx++;\n          if ( nSignificant == 0 )\n          {\n            while ( z[zDx] == \'0\' )\n            {\n              divisor *= 10.0;\n              zDx++;\n            }\n          }\n          while ( sqlite3Isdigit( z[zDx] ) )\n          {\n            if ( nSignificant < 18 )\n            {\n              v1 = v1 * 10.0 + ( z[zDx] - \'0\' );\n              divisor *= 10.0;\n              nSignificant++;\n            }\n            zDx++;\n          }\n          if ( Double.IsInfinity( divisor ) )\n          { if ( !Double.TryParse( z.Substring( 0, zDx ), out v1 ) ) v1 = 0; }\n          else v1 /= divisor;\n        }\n        if ( z[zDx] == \'e\' || z[zDx] == \'E\' )\n        {\n          int esign = 1;\n          int eval = 0;\n          double scale = 1.0;\n          zDx++;\n          if ( z[zDx] == \'-\' )\n          {\n            esign = -1;\n            zDx++;\n          }\n          else if ( z[zDx] == \'+\' )\n          {\n            zDx++;\n          }\n          while ( sqlite3Isdigit( z[zDx] ) )\n          {\n            eval = eval * 10 + z[zDx] - \'0\';\n            zDx++;\n          }\n          while ( eval >= 64 ) { scale *= 1.0e+64; eval -= 64; }\n          while ( eval >= 16 ) { scale *= 1.0e+16; eval -= 16; }\n          while ( eval >= 4 ) { scale *= 1.0e+4; eval -= 4; }\n          while ( eval >= 1 ) { scale *= 1.0e+1; eval -= 1; }\n          if ( esign < 0 )\n          {\n            v1 /= scale;\n          }\n          else\n          {\n            v1 *= scale;\n          }\n        }\n      }\n      pResult = (double)( sign < 0 ? -v1 : v1 );\n      return (int)( zDx );\n#else\nreturn sqlite3Atoi64(z, pResult);\n#endif //* SQLITE_OMIT_FLOATING_POINT */\n    }\n\n    /*\n    ** Compare the 19-character string zNum against the text representation\n    ** value 2^63:  9223372036854775808.  Return negative, zero, or positive\n    ** if zNum is less than, equal to, or greater than the string.\n    **\n    ** Unlike memcmp() this routine is guaranteed to return the difference\n    ** in the values of the last digit if the only difference is in the\n    ** last digit.  So, for example,\n    **\n    **      compare2pow63("9223372036854775800")\n    **\n    ** will return -8.\n    */\n    static int compare2pow63( string zNum )\n    {\n      int c;\n      if ( zNum.Length <= 18 )\n        c = string.Compare( zNum, "922337203685477580" );\n      else\n      {\n        c = ( string.Compare( zNum.Substring( 0, 18 ), "922337203685477580" ) == 1 ) ? 10 : 0;\n        if ( c == 0 )\n        {\n          c = zNum[18] - \'8\';\n        }\n      }\n      return c;\n    }\n\n\n    /*\n    ** Return TRUE if zNum is a 64-bit signed integer and write\n    ** the value of the integer into pNum.  If zNum is not an integer\n    ** or is an integer that is too large to be expressed with 64 bits,\n    ** then return false.\n    **\n    ** When this routine was originally written it dealt with only\n    ** 32-bit numbers.  At that time, it was much faster than the\n    ** atoi() library routine in RedHat 7.2.\n    */\n    static bool sqlite3Atoi64( string zNum, ref i64 pNum )\n    {\n      zNum = zNum.Trim() + " ";\n      int i;\n      for ( i = 1 ; i < zNum.Length ; i++ ) if ( !sqlite3Isdigit( zNum[i] ) ) break;\n      return Int64.TryParse( zNum.Substring( 0, i ), out pNum\n      );\n      //i64 v = 0;\n      //int neg;\n      //int i, c;\n      //const char *zStart;\n      //while( sqlite3Isspace(*(u8*)zNum) ) zNum++;\n      //if( *zNum==\'-\' ){\n      //  neg = 1;\n      //  zNum++;\n      //}else if( *zNum==\'+\' ){\n      //  neg = 0;\n      //  zNum++;\n      //}else{\n      //  neg = 0;\n      //}\n      //zStart = zNum;\n      //while( zNum[0]==\'0\' ){ zNum++; } /* Skip over leading zeros. Ticket #2454 */\n      //for(i=0; (c=zNum[i])>=\'0\' && c<=\'9\'; i++){\n      //  v = v*10 + c - \'0\';\n      //}\n      //*pNum = neg ? -v : v;\n      //if( c!=0 || (i==0 && zStart==zNum) || i>19 ){\n      //  /* zNum is empty or contains non-numeric text or is longer\n      //  ** than 19 digits (thus guaranting that it is too large) */\n      //  return 0;\n      //}else if( i<19 ){\n      //  /* Less than 19 digits, so we know that it fits in 64 bits */\n      //  return 1;\n      //}else{\n      //  /* 19-digit numbers must be no larger than 9223372036854775807 if positive\n      //  ** or 9223372036854775808 if negative.  Note that 9223372036854665808\n      //  ** is 2^63. */\n      //  return compare2pow63(zNum)<neg;\n      //}\n    }\n\n    /*\n    ** The string zNum represents an unsigned integer.  The zNum string\n    ** consists of one or more digit characters and is terminated by\n    ** a zero character.  Any stray characters in zNum result in undefined\n    ** behavior.\n    **\n    ** If the unsigned integer that zNum represents will fit in a\n    ** 64-bit signed integer, return TRUE.  Otherwise return FALSE.\n    **\n    ** If the negFlag parameter is true, that means that zNum really represents\n    ** a negative number.  (The leading "-" is omitted from zNum.)  This\n    ** parameter is needed to determine a boundary case.  A string\n    ** of "9223373036854775808" returns false if negFlag is false or true\n    ** if negFlag is true.\n    **\n    ** Leading zeros are ignored.\n    */\n    static bool sqlite3FitsIn64Bits( string zNum, bool negFlag )\n    {\n      Int64 pNum;\n      Debug.Assert( zNum[0] >= \'0\' && zNum[0] <= \'9\' ); /* zNum is an unsigned number */\n      bool result = negFlag ? Int64.TryParse( "-" + zNum, out pNum ) : Int64.TryParse( zNum, out pNum );\n      // if ( result && negFlag && pNum == Int64.MaxValue  ) result = false;\n      return result;\n      //int i;\n      //int neg = 0;\n      //if (negFlag != 0) neg = 1 - neg;\n      //while (*zNum == \'0\')\n      //{\n      //  zNum++;   /* Skip leading zeros.  Ticket #2454 */\n      //}\n      //for (i = 0;  zNum[i]; i++){ assert( zNum[i]>=\'0\' && zNum[i]<=\'9\' ); }\n      //if (i < 19)\n      //{\n      /* Guaranteed to fit if less than 19 digits */\n      //  return 1;\n      //}\n      //else if (i > 19)\n      //{\n      /* Guaranteed to be too big if greater than 19 digits */\n      //  return 0;\n      //}\n      //else\n      //{\n      /* Compare against 2^63. */\n      //  if (compare2pow63(new string(zNum)) < neg) return 1; else return 0;\n      //}\n    }\n\n    /*\n    ** If zNum represents an integer that will fit in 32-bits, then set\n    ** pValue to that integer and return true.  Otherwise return false.\n    **\n    ** Any non-numeric characters that following zNum are ignored.\n    ** This is different from sqlite3Atoi64() which requires the\n    ** input number to be zero-terminated.\n    */\n    static bool sqlite3GetInt32( string zNum, ref int pValue )\n    {\n      sqlite_int64 v = 0;\n      int iZnum = 0;\n      int i, c;\n      int neg = 0;\n      if ( zNum[iZnum] == \'-\' )\n      {\n        neg = 1;\n        iZnum++;\n      }\n      else if ( zNum[iZnum] == \'+\' )\n      {\n        iZnum++;\n      }\n      while ( iZnum < zNum.Length && zNum[iZnum] == \'0\' ) iZnum++;\n      for ( i = 0 ; i < 11 && i + iZnum < zNum.Length && ( c = zNum[iZnum + i] - \'0\' ) >= 0 && c <= 9 ; i++ )\n      {\n        v = v * 10 + c;\n      }\n\n      /* The longest decimal representation of a 32 bit integer is 10 digits:\n      **\n      **             1234567890\n      **     2^31 . 2147483648\n      */\n      if ( i > 10 )\n      {\n        return false;\n      }\n      if ( v - neg > 2147483647 )\n      {\n        return false;\n      }\n      if ( neg != 0 )\n      {\n        v = -v;\n      }\n      pValue = (int)v;\n      return true;\n    }\n\n    /*\n    ** The variable-length integer encoding is as follows:\n    **\n    ** KEY:\n    **         A = 0xxxxxxx    7 bits of data and one flag bit\n    **         B = 1xxxxxxx    7 bits of data and one flag bit\n    **         C = xxxxxxxx    8 bits of data\n    **\n    **  7 bits - A\n    ** 14 bits - BA\n    ** 21 bits - BBA\n    ** 28 bits - BBBA\n    ** 35 bits - BBBBA\n    ** 42 bits - BBBBBA\n    ** 49 bits - BBBBBBA\n    ** 56 bits - BBBBBBBA\n    ** 64 bits - BBBBBBBBC\n    */\n\n    /*\n    ** Write a 64-bit variable-length integer to memory starting at p[0].\n    ** The length of data write will be between 1 and 9 bytes.  The number\n    ** of bytes written is returned.\n    **\n    ** A variable-length integer consists of the lower 7 bits of each byte\n    ** for all bytes that have the 8th bit set and one byte with the 8th\n    ** bit clear.  Except, if we get to the 9th byte, it stores the full\n    ** 8 bits and is the last byte.\n    */\n    static int getVarint( byte[] p, ref u32 v )\n    {\n      v = p[0];\n      if ( v <= 0x7F ) return 1;\n      u64 u64_v = 0;\n      int result = sqlite3GetVarint( p, 0, ref u64_v );\n      v = (u32)u64_v;\n      return result;\n    }\n    static int getVarint( byte[] p, int offset, ref u32 v )\n    {\n      v = p[offset + 0];\n      if ( v <= 0x7F ) return 1;\n      u64 u64_v = 0;\n      int result = sqlite3GetVarint( p, offset, ref u64_v );\n      v = (u32)u64_v;\n      return result;\n    }\n    static int getVarint( byte[] p, int offset, ref int v )\n    {\n      v = p[offset + 0];\n      if ( v <= 0x7F ) return 1;\n      u64 u64_v = 0;\n      int result = sqlite3GetVarint( p, offset, ref u64_v );\n      v = (int)u64_v;\n      return result;\n    }\n    static int getVarint( byte[] p, int offset, ref i64 v )\n    {\n      v = p[offset + 0];\n      if ( v <= 0x7F ) return 1;\n      u64 u64_v = 0;\n      int result = sqlite3GetVarint( p, offset, ref u64_v );\n      v = (i64)u64_v;\n      return result;\n    }\n    static int getVarint( byte[] p, int offset, ref u64 v )\n    {\n      v = p[offset + 0];\n      if ( v <= 0x7F ) return 1;\n      int result = sqlite3GetVarint( p, offset, ref v );\n      return result;\n    }\n    static int getVarint32( byte[] p, ref u32 v )\n    { //(*B=*(A))<=0x7f?1:sqlite3GetVarint32(A,B))\n      v = p[0];\n      if ( v <= 0x7F ) return 1;\n      return sqlite3GetVarint32( p, 0, ref v );\n    }\n    static int getVarint32( string s, u32 offset, ref int v )\n    { //(*B=*(A))<=0x7f?1:sqlite3GetVarint32(A,B))\n      v = s[(int)offset];\n      if ( v <= 0x7F ) return 1;\n      byte[] p = new byte[4];\n      p[0] = (u8)s[(int)offset + 0];\n      p[1] = (u8)s[(int)offset + 1];\n      p[2] = (u8)s[(int)offset + 2];\n      p[3] = (u8)s[(int)offset + 3];\n      u32 u32_v = 0;\n      int result = sqlite3GetVarint32( p, 0, ref u32_v );\n      v = (int)u32_v;\n      return sqlite3GetVarint32( p, 0, ref v );\n    }\n    static int getVarint32( string s, u32 offset, ref u32 v )\n    { //(*B=*(A))<=0x7f?1:sqlite3GetVarint32(A,B))\n      v = s[(int)offset];\n      if ( v <= 0x7F ) return 1;\n      byte[] p = new byte[4];\n      p[0] = (u8)s[(int)offset + 0];\n      p[1] = (u8)s[(int)offset + 1];\n      p[2] = (u8)s[(int)offset + 2];\n      p[3] = (u8)s[(int)offset + 3];\n      return sqlite3GetVarint32( p, 0, ref v );\n    }\n    static int getVarint32( byte[] p, u32 offset, ref u32 v )\n    { //(*B=*(A))<=0x7f?1:sqlite3GetVarint32(A,B))\n      v = p[offset];\n      if ( v <= 0x7F ) return 1;\n      return sqlite3GetVarint32( p, (int)offset, ref v );\n    }\n    static int getVarint32( byte[] p, int offset, ref u32 v )\n    { //(*B=*(A))<=0x7f?1:sqlite3GetVarint32(A,B))\n      v = p[offset];\n      if ( v <= 0x7F ) return 1;\n      return sqlite3GetVarint32( p, offset, ref v );\n    }\n    static int getVarint32( byte[] p, int offset, ref int v )\n    { //(*B=*(A))<=0x7f?1:sqlite3GetVarint32(A,B))\n      v = p[offset + 0];\n      if ( v <= 0x7F ) return 1;\n      u32 u32_v = 0;\n      int result = sqlite3GetVarint32( p, offset, ref u32_v );\n      v = (int)u32_v;\n      return result;\n    }\n    static int putVarint( byte[] p, int offset, int v )\n    { return putVarint( p, offset, (u64)v ); }\n    static int putVarint( byte[] p, int offset, u64 v )\n    {\n      return sqlite3PutVarint( p, offset, v );\n    }\n    static int sqlite3PutVarint( byte[] p, int offset, int v )\n    { return sqlite3PutVarint( p, offset, (u64)v ); }\n    static int sqlite3PutVarint( byte[] p, int offset, u64 v )\n    {\n      int i, j, n;\n      u8[] buf = new u8[10];\n      if ( ( v & ( ( (u64)0xff000000 ) << 32 ) ) != 0 )\n      {\n        p[offset + 8] = (byte)v;\n        v >>= 8;\n        for ( i = 7 ; i >= 0 ; i-- )\n        {\n          p[offset + i] = (byte)( ( v & 0x7f ) | 0x80 );\n          v >>= 7;\n        }\n        return 9;\n      }\n      n = 0;\n      do\n      {\n        buf[n++] = (byte)( ( v & 0x7f ) | 0x80 );\n        v >>= 7;\n      } while ( v != 0 );\n      buf[0] &= 0x7f;\n      Debug.Assert( n <= 9 );\n      for ( i = 0, j = n - 1 ; j >= 0 ; j--, i++ )\n      {\n        p[offset + i] = buf[j];\n      }\n      return n;\n    }\n\n    /*\n    ** This routine is a faster version of sqlite3PutVarint() that only\n    ** works for 32-bit positive integers and which is optimized for\n    ** the common case of small integers.\n    */\n    static int putVarint32( byte[] p, int offset, int v )\n    {\n#if !putVarint32\n      if ( ( v & ~0x7f ) == 0 )\n      {\n        p[offset] = (byte)v;\n        return 1;\n      }\n#endif\n      if ( ( v & ~0x3fff ) == 0 )\n      {\n        p[offset] = (byte)( ( v >> 7 ) | 0x80 );\n        p[offset + 1] = (byte)( v & 0x7f );\n        return 2;\n      }\n      return sqlite3PutVarint( p, offset, v );\n    }\n\n    static int putVarint32( byte[] p, int v )\n    {\n      if ( ( v & ~0x7f ) == 0 )\n      {\n        p[0] = (byte)v;\n        return 1;\n      }\n      else if ( ( v & ~0x3fff ) == 0 )\n      {\n        p[0] = (byte)( ( v >> 7 ) | 0x80 );\n        p[1] = (byte)( v & 0x7f );\n        return 2;\n      }\n      else\n      {\n        return sqlite3PutVarint( p, 0, v );\n      }\n    }\n\n    /*\n    ** Read a 64-bit variable-length integer from memory starting at p[0].\n    ** Return the number of bytes read.  The value is stored in *v.\n    */\n    static u8 sqlite3GetVarint( byte[] p, int offset, ref u64 v )\n    {\n      u32 a, b, s;\n\n      a = p[offset + 0];\n      /* a: p0 (unmasked) */\n      if ( 0 == ( a & 0x80 ) )\n      {\n        v = a;\n        return 1;\n      }\n\n      //p++;\n      b = p[offset + 1];\n      /* b: p1 (unmasked) */\n      if ( 0 == ( b & 0x80 ) )\n      {\n        a &= 0x7f;\n        a = a << 7;\n        a |= b;\n        v = a;\n        return 2;\n      }\n\n      //p++;\n      a = a << 14;\n      a |= p[offset + 2];\n      /* a: p0<<14 | p2 (unmasked) */\n      if ( 0 == ( a & 0x80 ) )\n      {\n        a &= ( 0x7f << 14 ) | ( 0x7f );\n        b &= 0x7f;\n        b = b << 7;\n        a |= b;\n        v = a;\n        return 3;\n      }\n\n      /* CSE1 from below */\n      a &= ( 0x7f << 14 ) | ( 0x7f );\n      //p++;\n      b = b << 14;\n      b |= p[offset + 3];\n      /* b: p1<<14 | p3 (unmasked) */\n      if ( 0 == ( b & 0x80 ) )\n      {\n        b &= ( 0x7f << 14 ) | ( 0x7f );\n        /* moved CSE1 up */\n        /* a &= (0x7f<<14)|(0x7f); */\n        a = a << 7;\n        a |= b;\n        v = a;\n        return 4;\n      }\n\n      /* a: p0<<14 | p2 (masked) */\n      /* b: p1<<14 | p3 (unmasked) */\n      /* 1:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */\n      /* moved CSE1 up */\n      /* a &= (0x7f<<14)|(0x7f); */\n      b &= ( 0x7f << 14 ) | ( 0x7f );\n      s = a;\n      /* s: p0<<14 | p2 (masked) */\n\n      //p++;\n      a = a << 14;\n      a |= p[offset + 4];\n      /* a: p0<<28 | p2<<14 | p4 (unmasked) */\n      if ( 0 == ( a & 0x80 ) )\n      {\n        /* we can skip these cause they were (effectively) done above in calc\'ing s */\n        /* a &= (0x1f<<28)|(0x7f<<14)|(0x7f); */\n        /* b &= (0x7f<<14)|(0x7f); */\n        b = b << 7;\n        a |= b;\n        s = s >> 18;\n        v = ( (u64)s ) << 32 | a;\n        return 5;\n      }\n\n      /* 2:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */\n      s = s << 7;\n      s |= b;\n      /* s: p0<<21 | p1<<14 | p2<<7 | p3 (masked) */\n\n      //p++;\n      b = b << 14;\n      b |= p[offset + 5];\n      /* b: p1<<28 | p3<<14 | p5 (unmasked) */\n      if ( 0 == ( b & 0x80 ) )\n      {\n        /* we can skip this cause it was (effectively) done above in calc\'ing s */\n        /* b &= (0x1f<<28)|(0x7f<<14)|(0x7f); */\n        a &= ( 0x7f << 14 ) | ( 0x7f );\n        a = a << 7;\n        a |= b;\n        s = s >> 18;\n        v = ( (u64)s ) << 32 | a;\n        return 6;\n      }\n\n      //p++;\n      a = a << 14;\n      a |= p[offset + 6];\n      /* a: p2<<28 | p4<<14 | p6 (unmasked) */\n      if ( 0 == ( a & 0x80 ) )\n      {\n        a &= ( (u32)0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f );\n        b &= ( 0x7f << 14 ) | ( 0x7f );\n        b = b << 7;\n        a |= b;\n        s = s >> 11;\n        v = ( (u64)s ) << 32 | a;\n        return 7;\n      }\n\n      /* CSE2 from below */\n      a &= ( 0x7f << 14 ) | ( 0x7f );\n      //p++;\n      b = b << 14;\n      b |= p[offset + 7];\n      /* b: p3<<28 | p5<<14 | p7 (unmasked) */\n      if ( 0 == ( b & 0x80 ) )\n      {\n        b &= ( (u32)0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f );\n        /* moved CSE2 up */\n        /* a &= (0x7f<<14)|(0x7f); */\n        a = a << 7;\n        a |= b;\n        s = s >> 4;\n        v = ( (u64)s ) << 32 | a;\n        return 8;\n      }\n\n      //p++;\n      a = a << 15;\n      a |= p[offset + 8];\n      /* a: p4<<29 | p6<<15 | p8 (unmasked) */\n\n      /* moved CSE2 up */\n      /* a &= (0x7f<<29)|(0x7f<<15)|(0xff); */\n      b &= ( 0x7f << 14 ) | ( 0x7f );\n      b = b << 8;\n      a |= b;\n\n      s = s << 4;\n      b = p[offset + 4];\n      b &= 0x7f;\n      b = b >> 3;\n      s |= b;\n\n      v = ( (u64)s ) << 32 | a;\n\n      return 9;\n    }\n\n\n    /*\n    ** Read a 32-bit variable-length integer from memory starting at p[0].\n    ** Return the number of bytes read.  The value is stored in *v.\n    **\n    ** If the varint stored in p[0] is larger than can fit in a 32-bit unsigned\n    ** integer, then set *v to 0xffffffff.\n    **\n    ** A MACRO version, getVarint32, is provided which inlines the\n    ** single-byte case.  All code should use the MACRO version as\n    ** this function assumes the single-byte case has already been handled.\n    */\n    static u8 sqlite3GetVarint32( byte[] p, ref int v )\n    {\n      u32 u32_v = 0;\n      u8 result = sqlite3GetVarint32( p, 0, ref u32_v );\n      v = (int)u32_v;\n      return result;\n    }\n    static u8 sqlite3GetVarint32( byte[] p, int offset, ref int v )\n    {\n      u32 u32_v = 0;\n      u8 result = sqlite3GetVarint32( p, offset, ref u32_v );\n      v = (int)u32_v;\n      return result;\n    }\n    static u8 sqlite3GetVarint32( byte[] p, ref u32 v )\n    { return sqlite3GetVarint32( p, 0, ref v ); }\n    static u8 sqlite3GetVarint32( byte[] p, int offset, ref u32 v )\n    {\n      u32 a, b;\n\n      /* The 1-byte case.  Overwhelmingly the most common.  Handled inline\n      ** by the getVarin32() macro */\n      a = p[offset + 0];\n      /* a: p0 (unmasked) */\n      //#if getVarint32\n      //  if ( 0==( a&0x80))\n      //  {\n      /* Values between 0 and 127 */\n      //    v = a;\n      //    return 1;\n      //  }\n      //#endif\n\n      /* The 2-byte case */\n      //p++;\n      b = p[offset + 1];\n      /* b: p1 (unmasked) */\n      if ( 0 == ( b & 0x80 ) )\n      {\n        /* Values between 128 and 16383 */\n        a &= 0x7f;\n        a = a << 7;\n        v = a | b;\n        return 2;\n      }\n\n      /* The 3-byte case */\n      //p++;\n      a = a << 14;\n      a |= p[offset + 2];\n      /* a: p0<<14 | p2 (unmasked) */\n      if ( 0 == ( a & 0x80 ) )\n      {\n        /* Values between 16384 and 2097151 */\n        a &= ( 0x7f << 14 ) | ( 0x7f );\n        b &= 0x7f;\n        b = b << 7;\n        v = a | b;\n        return 3;\n      }\n\n      /* A 32-bit varint is used to store size information in btrees.\n      ** Objects are rarely larger than 2MiB limit of a 3-byte varint.\n      ** A 3-byte varint is sufficient, for example, to record the size\n      ** of a 1048569-byte BLOB or string.\n      **\n      ** We only unroll the first 1-, 2-, and 3- byte cases.  The very\n      ** rare larger cases can be handled by the slower 64-bit varint\n      ** routine.\n      */\n#if TRUE\n      {\n        u64 v64 = 0;\n        u8 n;\n\n        //p -= 2;\n        n = sqlite3GetVarint( p, offset, ref v64 );\n        Debug.Assert( n > 3 && n <= 9 );\n        if ( ( v64 & SQLITE_MAX_U32 ) != v64 )\n        {\n          v = 0xffffffff;\n        }\n        else\n        {\n          v = (u32)v64;\n        } return n;\n      }\n#else\n/* For following code (kept for historical record only) shows an\n** unrolling for the 3- and 4-byte varint cases.  This code is\n** slightly faster, but it is also larger and much harder to test.\n*/\n//p++;\nb = b << 14;\nb |= p[offset + 3];\n/* b: p1<<14 | p3 (unmasked) */\nif ( 0 == ( b & 0x80 ) )\n{\n/* Values between 2097152 and 268435455 */\nb &= ( 0x7f << 14 ) | ( 0x7f );\na &= ( 0x7f << 14 ) | ( 0x7f );\na = a << 7;\nv = a | b;\nreturn 4;\n}\n\n//p++;\na = a << 14;\na |= p[offset + 4];\n/* a: p0<<28 | p2<<14 | p4 (unmasked) */\nif ( 0 == ( a & 0x80 ) )\n{\n/* Values  between 268435456 and 34359738367 */\na &= ( (u32)0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f );\nb &= ( (u32)0x1f << 28 ) | ( 0x7f << 14 ) | ( 0x7f );\nb = b << 7;\nv = a | b;\nreturn 5;\n}\n\n/* We can only reach this point when reading a corrupt database\n** file.  In that case we are not in any hurry.  Use the (relatively\n** slow) general-purpose sqlite3GetVarint() routine to extract the\n** value. */\n{\nu64 v64 = 0;\nint n;\n\n//p -= 4;\nn = sqlite3GetVarint( p, offset, ref v64 );\nDebug.Assert( n > 5 && n <= 9 );\nv = (u32)v64;\nreturn n;\n}\n#endif\n    }\n\n\n    /*\n    ** Return the number of bytes that will be needed to store the given\n    ** 64-bit integer.\n    */\n    static int sqlite3VarintLen( u64 v )\n    {\n      int i = 0;\n      do\n      {\n        i++;\n        v >>= 7;\n      } while ( v != 0 && ALWAYS( i < 9 ) );\n      return i;\n    }\n\n\n    /*\n    ** Read or write a four-byte big-endian integer value.\n    */\n    static u32 sqlite3Get4byte( u8[] p, int p_offset, int offset )\n    {\n      offset += p_offset;\n      return (u32)( ( p[0 + offset] << 24 ) | ( p[1 + offset] << 16 ) | ( p[2 + offset] << 8 ) | p[3 + offset] );\n    }\n    static u32 sqlite3Get4byte( u8[] p, int offset )\n    {\n      return (u32)( ( p[0 + offset] << 24 ) | ( p[1 + offset] << 16 ) | ( p[2 + offset] << 8 ) | p[3 + offset] );\n    }\n    static u32 sqlite3Get4byte( u8[] p, u32 offset )\n    {\n      return (u32)( ( p[0 + offset] << 24 ) | ( p[1 + offset] << 16 ) | ( p[2 + offset] << 8 ) | p[3 + offset] );\n    }\n    static u32 sqlite3Get4byte( u8[] p )\n    {\n      return (u32)( ( p[0] << 24 ) | ( p[1] << 16 ) | ( p[2] << 8 ) | p[3] );\n    }\n    static void sqlite3Put4byte( byte[] p, int v )\n    {\n      p[0] = (byte)( v >> 24 & 0xFF );\n      p[1] = (byte)( v >> 16 & 0xFF );\n      p[2] = (byte)( v >> 8 & 0xFF );\n      p[3] = (byte)( v & 0xFF );\n    }\n    static void sqlite3Put4byte( byte[] p, int offset, int v )\n    {\n      p[0 + offset] = (byte)( v >> 24 & 0xFF );\n      p[1 + offset] = (byte)( v >> 16 & 0xFF );\n      p[2 + offset] = (byte)( v >> 8 & 0xFF );\n      p[3 + offset] = (byte)( v & 0xFF );\n    }\n    static void sqlite3Put4byte( byte[] p, u32 offset, u32 v )\n    {\n      p[0 + offset] = (byte)( v >> 24 & 0xFF );\n      p[1 + offset] = (byte)( v >> 16 & 0xFF );\n      p[2 + offset] = (byte)( v >> 8 & 0xFF );\n      p[3 + offset] = (byte)( v & 0xFF );\n    }\n    static void sqlite3Put4byte( byte[] p, int offset, u64 v )\n    {\n      p[0 + offset] = (byte)( v >> 24 & 0xFF );\n      p[1 + offset] = (byte)( v >> 16 & 0xFF );\n      p[2 + offset] = (byte)( v >> 8 & 0xFF );\n      p[3 + offset] = (byte)( v & 0xFF );\n    }\n    static void sqlite3Put4byte( byte[] p, u64 v )\n    {\n      p[0] = (byte)( v >> 24 & 0xFF );\n      p[1] = (byte)( v >> 16 & 0xFF );\n      p[2] = (byte)( v >> 8 & 0xFF );\n      p[3] = (byte)( v & 0xFF );\n    }\n\n\n\n#if !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC\n    /*\n** Translate a single byte of Hex into an integer.\n** This routinen only works if h really is a valid hexadecimal\n** character:  0..9a..fA..F\n*/\n    static int hexToInt( int h )\n    {\n      Debug.Assert( ( h >= \'0\' && h <= \'9\' ) || ( h >= \'a\' && h <= \'f\' ) || ( h >= \'A\' && h <= \'F\' ) );\n#if SQLITE_ASCII\n      h += 9 * ( 1 & ( h >> 6 ) );\n#endif\n#if SQLITE_EBCDIC\nh += 9*(1&~(h>>4));\n#endif\n      return h & 0xf;\n    }\n#endif // * !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */\n\n#if !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC\n    /*\n** Convert a BLOB literal of the form "x\'hhhhhh\'" into its binary\n** value.  Return a pointer to its binary value.  Space to hold the\n** binary value has been obtained from malloc and must be freed by\n** the calling routine.\n*/\n    static byte[] sqlite3HexToBlob( sqlite3 db, string z, int n )\n    {\n      StringBuilder zBlob;\n      int i;\n\n      zBlob = new StringBuilder( n / 2 + 1 );// (char*)sqlite3DbMallocRaw(db, n / 2 + 1);\n      n--;\n      if ( zBlob != null )\n      {\n        for ( i = 0 ; i < n ; i += 2 )\n        {\n          zBlob.Append( Convert.ToChar( ( hexToInt( z[i] ) << 4 ) | hexToInt( z[i + 1] ) ) );\n        }\n        //zBlob[i / 2] = \'\\0\'; ;\n      }\n      return Encoding.UTF8.GetBytes( zBlob.ToString() );\n    }\n#endif // * !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */\n\n\n\n    /*\n** Change the sqlite.magic from SQLITE_MAGIC_OPEN to SQLITE_MAGIC_BUSY.\n** Return an error (non-zero) if the magic was not SQLITE_MAGIC_OPEN\n** when this routine is called.\n**\n** This routine is called when entering an SQLite API.  The SQLITE_MAGIC_OPEN\n** value indicates that the database connection passed into the API is\n** open and is not being used by another thread.  By changing the value\n** to SQLITE_MAGIC_BUSY we indicate that the connection is in use.\n** sqlite3SafetyOff() below will change the value back to SQLITE_MAGIC_OPEN\n** when the API exits.\n**\n** This routine is a attempt to detect if two threads use the\n** same sqlite* pointer at the same time.  There is a race\n** condition so it is possible that the error is not detected.\n** But usually the problem will be seen.  The result will be an\n** error which can be used to debug the application that is\n** using SQLite incorrectly.\n**\n** Ticket #202:  If db.magic is not a valid open value, take care not\n** to modify the db structure at all.  It could be that db is a stale\n** pointer.  In other words, it could be that there has been a prior\n** call to sqlite3_close(db) and db has been deallocated.  And we do\n** not want to write into deallocated memory.\n*/\n#if SQLITE_DEBUG\n    static bool sqlite3SafetyOn( sqlite3 db )\n    {\n      if ( db.magic == SQLITE_MAGIC_OPEN )\n      {\n        db.magic = SQLITE_MAGIC_BUSY;\n        Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n        return false;\n      }\n      else if ( db.magic == SQLITE_MAGIC_BUSY )\n      {\n        db.magic = SQLITE_MAGIC_ERROR;\n        db.u1.isInterrupted = true;\n      }\n      return true;\n    }\n#else\nstatic bool sqlite3SafetyOn( sqlite3 db ) {return false;}\n#endif\n\n    /*\n** Change the magic from SQLITE_MAGIC_BUSY to SQLITE_MAGIC_OPEN.\n** Return an error (non-zero) if the magic was not SQLITE_MAGIC_BUSY\n** when this routine is called.\n*/\n#if SQLITE_DEBUG\n    static bool sqlite3SafetyOff( sqlite3 db )\n    {\n      if ( db.magic == SQLITE_MAGIC_BUSY )\n      {\n        db.magic = SQLITE_MAGIC_OPEN;\n        Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n        return false;\n      }\n      else\n      {\n        db.magic = SQLITE_MAGIC_ERROR;\n        db.u1.isInterrupted = true;\n        return true;\n      }\n    }\n#else\nstatic bool sqlite3SafetyOff( sqlite3 db ) { return false; }\n#endif\n\n    /*\n** Check to make sure we have a valid db pointer.  This test is not\n** foolproof but it does provide some measure of protection against\n** misuse of the interface such as passing in db pointers that are\n** NULL or which have been previously closed.  If this routine returns\n** 1 it means that the db pointer is valid and 0 if it should not be\n** dereferenced for any reason.  The calling function should invoke\n** SQLITE_MISUSE immediately.\n**\n** sqlite3SafetyCheckOk() requires that the db pointer be valid for\n** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to\n** open properly and is not fit for general use but which can be\n** used as an argument to sqlite3_errmsg() or sqlite3_close().\n*/\n    static bool sqlite3SafetyCheckOk( sqlite3 db )\n    {\n      u32 magic;\n      if ( db == null ) return false;\n      magic = db.magic;\n      if ( magic != SQLITE_MAGIC_OPEN\n#if SQLITE_DEBUG\n && magic != SQLITE_MAGIC_BUSY\n#endif\n )\n      {\n        return false;\n      }\n      else\n      {\n        return true;\n      }\n    }\n\n    static bool sqlite3SafetyCheckSickOrOk( sqlite3 db )\n    {\n      u32 magic;\n      magic = db.magic;\n      if ( magic != SQLITE_MAGIC_SICK &&\n      magic != SQLITE_MAGIC_OPEN &&\n      magic != SQLITE_MAGIC_BUSY ) return false;\n      return true;\n    }\n  }\n}\n'