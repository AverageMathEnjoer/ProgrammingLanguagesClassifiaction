b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.tries\n\nimport org.funktionale.either.Disjunction\nimport org.funktionale.either.Either\nimport org.funktionale.option.Option\nimport org.funktionale.option.Option.None\nimport org.funktionale.option.Option.Some\nimport org.funktionale.utils.Predicate\nimport java.util.*\n\n/**\n * Try Computation\n */\nsealed class Try<T> {\n\n    abstract fun isFailure(): Boolean\n\n    abstract fun isSuccess(): Boolean\n\n    abstract fun get(): T\n\n    operator fun invoke() = get()\n\n    fun getOrElse(f: () -> T): T = when (this) {\n        is Success -> get()\n        is Failure -> f()\n    }\n\n    fun orElse(f: () -> Try<T>): Try<T> = when (this) {\n        is Success -> this\n        is Failure -> f()\n    }\n\n    fun foreach(f: (T) -> Unit) {\n        if (isSuccess()) f(get())\n    }\n\n    fun onEach(f: (T) -> Unit): Try<T> = map {\n        f(it)\n        it\n    }\n\n    fun <X> flatMap(f: (T) -> Try<X>): Try<X> = when (this) {\n        is Success -> try {\n            f(get())\n        } catch (t: Throwable) {\n            Failure<X>(t)\n        }\n        is Failure -> Failure<X>(throwable)\n    }\n\n    fun <X> map(f: (T) -> X): Try<X> = flatMap { Success(f(it)) }\n\n    fun exists(predicate: Predicate<T>): Boolean = when (this) {\n        is Success -> predicate(get())\n        is Failure -> false\n    }\n\n    fun filter(predicate: Predicate<T>): Try<T> = when (this) {\n        is Success -> try {\n            val value = get()\n            if (predicate(value)) {\n                this\n            } else {\n                Failure<T>(NoSuchElementException("Predicate does not hold for $value"))\n            }\n        } catch (t: Throwable) {\n            Failure<T>(t)\n        }\n        is Failure -> this\n    }\n\n\n    fun rescue(f: (Throwable) -> Try<T>): Try<T> = when (this) {\n        is Success -> this\n        is Failure -> try {\n            f(throwable)\n        } catch (t: Throwable) {\n            Failure<T>(t)\n        }\n    }\n\n    fun handle(f: (Throwable) -> T): Try<T> = rescue { Success(f(it)) }\n\n    fun onSuccess(body: (T) -> Unit): Try<T> {\n        foreach(body)\n        return this\n    }\n\n    fun onFailure(body: (Throwable) -> Unit): Try<T> = when (this) {\n        is Success -> this\n        is Failure -> {\n            body(throwable)\n            this\n        }\n    }\n\n    fun toOption(): Option<T> = when (this) {\n        is Success -> Some(get())\n        is Failure -> None\n    }\n\n    fun toEither(): Either<Throwable, T> = when (this) {\n        is Success -> Either.right(get())\n        is Failure -> Either.left(throwable)\n    }\n\n    fun toDisjunction(): Disjunction<Throwable, T> = toEither().toDisjunction()\n\n    fun failed(): Try<Throwable> = when (this) {\n        is Success -> Failure(UnsupportedOperationException("Success"))\n        is Failure -> Success(throwable)\n    }\n\n    fun <X> transform(s: (T) -> Try<X>, f: (Throwable) -> Try<X>): Try<X> = when (this) {\n        is Success -> flatMap(s)\n        is Failure -> try {\n            f(throwable)\n        } catch (t: Throwable) {\n            Failure<X>(t)\n        }\n    }\n\n    fun <X> fold(s: (T) -> X, f: (Throwable) -> X): X = when (this) {\n        is Success -> try {\n            s(get())\n        } catch (t: Throwable) {\n            f(t)\n        }\n        is Failure -> f(throwable)\n    }\n\n\n    class Success<T>(private val t: T) : Try<T>() {\n        override fun get(): T = t\n\n        override fun isFailure() = false\n\n        override fun isSuccess() = true\n\n        override fun toString(): String {\n            return "Success($t)"\n        }\n\n        override fun equals(other: Any?): Boolean {\n            if (this === other) return true\n            if (other !is Success<*>) return false\n\n            if (t != other.t) return false\n\n            return true\n        }\n\n        override fun hashCode(): Int {\n            return t?.hashCode() ?: 0\n        }\n\n\n    }\n\n    class Failure<T>(val throwable: Throwable) : Try<T>() {\n        override fun get(): T {\n            throw throwable\n        }\n\n        override fun isFailure() = true\n\n        override fun isSuccess() = false\n\n        override fun toString(): String {\n            return "Failure($throwable)"\n        }\n\n        override fun equals(other: Any?): Boolean {\n            if (this === other) return true\n            if (other !is Failure<*>) return false\n\n            if (throwable != other.throwable) return false\n\n            return true\n        }\n\n        override fun hashCode(): Int {\n            return throwable.hashCode()\n        }\n\n\n    }\n\n    /*companion object {\n        operator fun <T> invoke(body: () -> T): Try<T> = try {\n            Success(body())\n        } catch (t: Throwable) {\n            Failure(t)\n        }\n    }*/\n}\n\nfun <T> Try(body: () -> T): Try<T> = try {\n    Try.Success(body())\n} catch (t: Throwable) {\n    Try.Failure(t)\n}\n\nfun <T> Try<Try<T>>.flatten(): Try<T> = when (this) {\n    is Try.Success -> get()\n    is Try.Failure -> Try.Failure<T>(throwable)\n}'