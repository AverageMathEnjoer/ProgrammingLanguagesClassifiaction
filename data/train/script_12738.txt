b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Change PDF document title\n--\n-- The example shows how to use incremental updates to change PDF file\n\nmodule Main\n(\n  main\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.XRef\nimport Pdf.Core.Stream (knownFilters)\nimport Pdf.Core.Util\nimport Pdf.Core.Exception\nimport qualified Pdf.Core.IO.Buffer as Buffer\nimport qualified Pdf.Core.File as File\nimport Pdf.Core.Writer\nimport Pdf.Document\n\n-- Using the internals to switch from \'pdf-toolbox-document\' level\n-- to \'pdf-toolbox-core\'\nimport Pdf.Document.Internal.Types\n\nimport Data.String\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport System.IO\nimport qualified System.IO.Streams as Streams\nimport System.Environment\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  unless (length args == 3) $ do\n    mapM_ putStrLn [\n      "Usage:",\n      "\\t./change-document-title input.pdf \\"New Title\\" output.pdf"\n      ]\n    error "Please supply 3 arguments"\n  let (input, title, output) = case args of\n        [a, b, c] -> (a, b, c)\n        _ -> error "expected 3 arbuments"\n\n  withBinaryFile input ReadMode $ \\h -> do\n    buf <- Buffer.fromHandle h\n    file <- File.fromBuffer knownFilters buf\n    pdf <- fromFile file\n    doc <- document pdf\n\n    infoDict <- do\n      i <- documentInfo doc\n      case i of\n        Just info -> return info\n        Nothing -> error "Unimplemented: PDF document without Info dictionary"\n\n    let Document _ tr = doc\n        Info _ infoRef info = infoDict\n\n    fileSize <- Buffer.size buf\n    xref <- lastXRef buf\n\n    nextFree <- sure $ (HashMap.lookup "Size" tr >>= intValue)\n      `notice` "Trailer Size should be an integer"\n\n    let hasTable = case xref of\n          XRefTable{} -> True\n          XRefStream{} -> False\n\n    let startxref =\n          case xref of\n            XRefTable off -> off\n            XRefStream off _ -> off\n        newInfo = HashMap.insert "Title" (String $ fromString title) info\n        newTr\n          = HashMap.insert "Prev" (Number $ fromIntegral startxref)\n          . HashMap.insert "Size" (Number (fromIntegral size))\n          $ tr\n        size = if hasTable then nextFree else succ nextFree\n\n    Buffer.seek buf 0\n    let is = Buffer.toInputStream buf\n\n    Streams.withFileAsOutput output $ \\ostream -> do\n      Streams.supply is ostream\n      writer <- makeWriter ostream\n      writeObject writer infoRef (Dict newInfo)\n      if hasTable\n        then writeXRefTable writer fileSize newTr\n        else writeXRefStream writer fileSize (R nextFree 0) newTr\n'