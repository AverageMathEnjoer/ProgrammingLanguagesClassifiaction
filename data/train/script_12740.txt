b'using System;\nusing System.Diagnostics;\n\nusing i16 = System.Int16;\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\n\nusing sqlite3_int64 = System.Int64;\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using DbPage = CSSQLite.PgHdr;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2004 April 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** $Id: btreeInt.h,v 1.52 2009/07/15 17:25:46 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    **\n    ** This file implements a external (disk-based) database using BTrees.\n    ** For a detailed discussion of BTrees, refer to\n    **\n    **     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:\n    **     "Sorting And Searching", pages 473-480. Addison-Wesley\n    **     Publishing Company, Reading, Massachusetts.\n    **\n    ** The basic idea is that each page of the file contains N database\n    ** entries and N+1 pointers to subpages.\n    **\n    **   ----------------------------------------------------------------\n    **   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |\n    **   ----------------------------------------------------------------\n    **\n    ** All of the keys on the page that Ptr(0) points to have values less\n    ** than Key(0).  All of the keys on page Ptr(1) and its subpages have\n    ** values greater than Key(0) and less than Key(1).  All of the keys\n    ** on Ptr(N) and its subpages have values greater than Key(N-1).  And\n    ** so forth.\n    **\n    ** Finding a particular key requires reading O(log(M)) pages from the\n    ** disk where M is the number of entries in the tree.\n    **\n    ** In this implementation, a single file can hold one or more separate\n    ** BTrees.  Each BTree is identified by the index of its root page.  The\n    ** key and data for any entry are combined to form the "payload".  A\n    ** fixed amount of payload can be carried directly on the database\n    ** page.  If the payload is larger than the preset amount then surplus\n    ** bytes are stored on overflow pages.  The payload for an entry\n    ** and the preceding pointer are combined to form a "Cell".  Each\n    ** page has a small header which contains the Ptr(N) pointer and other\n    ** information such as the size of key and data.\n    **\n    ** FORMAT DETAILS\n    **\n    ** The file is divided into pages.  The first page is called page 1,\n    ** the second is page 2, and so forth.  A page number of zero indicates\n    ** "no such page".  The page size can be anything between 512 and 65536.\n    ** Each page can be either a btree page, a freelist page or an overflow\n    ** page.\n    **\n    ** The first page is always a btree page.  The first 100 bytes of the first\n    ** page contain a special header (the "file header") that describes the file.\n    ** The format of the file header is as follows:\n    **\n    **   OFFSET   SIZE    DESCRIPTION\n    **      0      16     Header string: "SQLite format 3\\000"\n    **     16       2     Page size in bytes.\n    **     18       1     File format write version\n    **     19       1     File format read version\n    **     20       1     Bytes of unused space at the end of each page\n    **     21       1     Max embedded payload fraction\n    **     22       1     Min embedded payload fraction\n    **     23       1     Min leaf payload fraction\n    **     24       4     File change counter\n    **     28       4     Reserved for future use\n    **     32       4     First freelist page\n    **     36       4     Number of freelist pages in the file\n    **     40      60     15 4-byte meta values passed to higher layers\n    **\n    **     40       4     Schema cookie\n    **     44       4     File format of schema layer\n    **     48       4     Size of page cache\n    **     52       4     Largest root-page (auto/incr_vacuum)\n    **     56       4     1=UTF-8 2=UTF16le 3=UTF16be\n    **     60       4     User version\n    **     64       4     Incremental vacuum mode\n    **     68       4     unused\n    **     72       4     unused\n    **     76       4     unused\n    **\n    ** All of the integer values are big-endian (most significant byte first).\n    **\n    ** The file change counter is incremented when the database is changed\n    ** This counter allows other processes to know when the file has changed\n    ** and thus when they need to flush their cache.\n    **\n    ** The max embedded payload fraction is the amount of the total usable\n    ** space in a page that can be consumed by a single cell for standard\n    ** B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default\n    ** is to limit the maximum cell size so that at least 4 cells will fit\n    ** on one page.  Thus the default max embedded payload fraction is 64.\n    **\n    ** If the payload for a cell is larger than the max payload, then extra\n    ** payload is spilled to overflow pages.  Once an overflow page is allocated,\n    ** as many bytes as possible are moved into the overflow pages without letting\n    ** the cell size drop below the min embedded payload fraction.\n    **\n    ** The min leaf payload fraction is like the min embedded payload fraction\n    ** except that it applies to leaf nodes in a LEAFDATA tree.  The maximum\n    ** payload fraction for a LEAFDATA tree is always 100% (or 255) and it\n    ** not specified in the header.\n    **\n    ** Each btree pages is divided into three sections:  The header, the\n    ** cell pointer array, and the cell content area.  Page 1 also has a 100-byte\n    ** file header that occurs before the page header.\n    **\n    **      |----------------|\n    **      | file header    |   100 bytes.  Page 1 only.\n    **      |----------------|\n    **      | page header    |   8 bytes for leaves.  12 bytes for interior nodes\n    **      |----------------|\n    **      | cell pointer   |   |  2 bytes per cell.  Sorted order.\n    **      | array          |   |  Grows downward\n    **      |                |   v\n    **      |----------------|\n    **      | unallocated    |\n    **      | space          |\n    **      |----------------|   ^  Grows upwards\n    **      | cell content   |   |  Arbitrary order interspersed with freeblocks.\n    **      | area           |   |  and free space fragments.\n    **      |----------------|\n    **\n    ** The page headers looks like this:\n    **\n    **   OFFSET   SIZE     DESCRIPTION\n    **      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf\n    **      1       2      byte offset to the first freeblock\n    **      3       2      number of cells on this page\n    **      5       2      first byte of the cell content area\n    **      7       1      number of fragmented free bytes\n    **      8       4      Right child (the Ptr(N) value).  Omitted on leaves.\n    **\n    ** The flags define the format of this btree page.  The leaf flag means that\n    ** this page has no children.  The zerodata flag means that this page carries\n    ** only keys and no data.  The intkey flag means that the key is a integer\n    ** which is stored in the key size entry of the cell header rather than in\n    ** the payload area.\n    **\n    ** The cell pointer array begins on the first byte after the page header.\n    ** The cell pointer array contains zero or more 2-byte numbers which are\n    ** offsets from the beginning of the page to the cell content in the cell\n    ** content area.  The cell pointers occur in sorted order.  The system strives\n    ** to keep free space after the last cell pointer so that new cells can\n    ** be easily added without having to defragment the page.\n    **\n    ** Cell content is stored at the very end of the page and grows toward the\n    ** beginning of the page.\n    **\n    ** Unused space within the cell content area is collected into a linked list of\n    ** freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset\n    ** to the first freeblock is given in the header.  Freeblocks occur in\n    ** increasing order.  Because a freeblock must be at least 4 bytes in size,\n    ** any group of 3 or fewer unused bytes in the cell content area cannot\n    ** exist on the freeblock chain.  A group of 3 or fewer free bytes is called\n    ** a fragment.  The total number of bytes in all fragments is recorded.\n    ** in the page header at offset 7.\n    **\n    **    SIZE    DESCRIPTION\n    **      2     Byte offset of the next freeblock\n    **      2     Bytes in this freeblock\n    **\n    ** Cells are of variable length.  Cells are stored in the cell content area at\n    ** the end of the page.  Pointers to the cells are in the cell pointer array\n    ** that immediately follows the page header.  Cells is not necessarily\n    ** contiguous or in order, but cell pointers are contiguous and in order.\n    **\n    ** Cell content makes use of variable length integers.  A variable\n    ** length integer is 1 to 9 bytes where the lower 7 bits of each\n    ** byte are used.  The integer consists of all bytes that have bit 8 set and\n    ** the first byte with bit 8 clear.  The most significant byte of the integer\n    ** appears first.  A variable-length integer may not be more than 9 bytes long.\n    ** As a special case, all 8 bytes of the 9th byte are used as data.  This\n    ** allows a 64-bit integer to be encoded in 9 bytes.\n    **\n    **    0x00                      becomes  0x00000000\n    **    0x7f                      becomes  0x0000007f\n    **    0x81 0x00                 becomes  0x00000080\n    **    0x82 0x00                 becomes  0x00000100\n    **    0x80 0x7f                 becomes  0x0000007f\n    **    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678\n    **    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081\n    **\n    ** Variable length integers are used for rowids and to hold the number of\n    ** bytes of key and data in a btree cell.\n    **\n    ** The content of a cell looks like this:\n    **\n    **    SIZE    DESCRIPTION\n    **      4     Page number of the left child. Omitted if leaf flag is set.\n    **     var    Number of bytes of data. Omitted if the zerodata flag is set.\n    **     var    Number of bytes of key. Or the key itself if intkey flag is set.\n    **      *     Payload\n    **      4     First page of the overflow chain.  Omitted if no overflow\n    **\n    ** Overflow pages form a linked list.  Each page except the last is completely\n    ** filled with data (pagesize - 4 bytes).  The last page can have as little\n    ** as 1 byte of data.\n    **\n    **    SIZE    DESCRIPTION\n    **      4     Page number of next overflow page\n    **      *     Data\n    **\n    ** Freelist pages come in two subtypes: trunk pages and leaf pages.  The\n    ** file header points to the first in a linked list of trunk page.  Each trunk\n    ** page points to multiple leaf pages.  The content of a leaf page is\n    ** unspecified.  A trunk page looks like this:\n    **\n    **    SIZE    DESCRIPTION\n    **      4     Page number of next trunk page\n    **      4     Number of leaf pointers on this page\n    **      *     zero or more pages numbers of leaves\n    */\n    //#include "sqliteInt.h"\n\n    /* The following value is the maximum cell size assuming a maximum page\n    ** size give above.\n    */\n    //#define MX_CELL_SIZE(pBt)  (pBt.pageSize-8)\n    static int MX_CELL_SIZE( BtShared pBt ) { return ( pBt.pageSize - 8 ); }\n\n    /* The maximum number of cells on a single page of the database.  This\n    ** assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself\n    ** plus 2 bytes for the index to the cell in the page header).  Such\n    ** small cells will be rare, but they are possible.\n    */\n    //#define MX_CELL(pBt) ((pBt.pageSize-8)/6)\n    static int MX_CELL( BtShared pBt ) { return ( ( pBt.pageSize - 8 ) / 6 ); }\n\n    /* Forward declarations */\n    //typedef struct MemPage MemPage;\n    //typedef struct BtLock BtLock;\n\n    /*\n    ** This is a magic string that appears at the beginning of every\n    ** SQLite database in order to identify the file as a real database.\n    **\n    ** You can change this value at compile-time by specifying a\n    ** -DSQLITE_FILE_HEADER="..." on the compiler command-line.  The\n    ** header must be exactly 16 bytes including the zero-terminator so\n    ** the string itself should be 15 characters long.  If you change\n    ** the header, then your custom library will not be able to read\n    ** databases generated by the standard tools and the standard tools\n    ** will not be able to read databases created by your custom library.\n    */\n#if !SQLITE_FILE_HEADER //* 123456789 123456 */\n    const string SQLITE_FILE_HEADER = "SQLite format 3\\0";\n#endif\n\n    /*\n** Page type flags.  An ORed combination of these flags appear as the\n** first byte of on-disk image of every BTree page.\n*/\n    const byte PTF_INTKEY = 0x01;\n    const byte PTF_ZERODATA = 0x02;\n    const byte PTF_LEAFDATA = 0x04;\n    const byte PTF_LEAF = 0x08;\n\n    /*\n    ** As each page of the file is loaded into memory, an instance of the following\n    ** structure is appended and initialized to zero.  This structure stores\n    ** information about the page that is decoded from the raw file page.\n    **\n    ** The pParent field points back to the parent page.  This allows us to\n    ** walk up the BTree from any leaf to the root.  Care must be taken to\n    ** unref() the parent page pointer when this page is no longer referenced.\n    ** The pageDestructor() routine handles that chore.\n    **\n    ** Access to all fields of this structure is controlled by the mutex\n    ** stored in MemPage.pBt.mutex.\n    */\n    public struct _OvflCell\n    {   /* Cells that will not fit on aData[] */\n      public u8[] pCell;       /* Pointers to the body of the overflow cell */\n      public u16 idx;            /* Insert this cell before idx-th non-overflow cell */\n      public _OvflCell Copy()\n      {\n        _OvflCell cp = new _OvflCell();\n        if ( pCell != null )\n        {\n          cp.pCell = new byte[pCell.Length];\n          Buffer.BlockCopy( pCell, 0, cp.pCell, 0, pCell.Length );\n        }\n        cp.idx = idx;\n        return cp;\n      }\n    };\n    public class MemPage\n    {\n      public u8 isInit;           /* True if previously initialized. MUST BE FIRST! */\n      public u8 nOverflow;        /* Number of overflow cell bodies in aCell[] */\n      public u8 intKey;           /* True if u8key flag is set */\n      public u8 leaf;             /* 1 if leaf flag is set */\n      public u8 hasData;          /* True if this page stores data */\n      public u8 hdrOffset;        /* 100 for page 1.  0 otherwise */\n      public u8 childPtrSize;     /* 0 if leaf==1.  4 if leaf==0 */\n      public u16 maxLocal;        /* Copy of BtShared.maxLocal or BtShared.maxLeaf */\n      public u16 minLocal;        /* Copy of BtShared.minLocal or BtShared.minLeaf */\n      public u16 cellOffset;      /* Index in aData of first cell pou16er */\n      public u16 nFree;           /* Number of free bytes on the page */\n      public u16 nCell;           /* Number of cells on this page, local and ovfl */\n      public u16 maskPage;        /* Mask for page offset */\n      public _OvflCell[] aOvfl = new _OvflCell[5];\n      public BtShared pBt;        /* Pointer to BtShared that this page is part of */\n      public byte[] aData;        /* Pointer to disk image of the page data */\n      public DbPage pDbPage;      /* Pager page handle */\n      public Pgno pgno;           /* Page number for this page */\n\n      public MemPage Copy()\n      {\n        MemPage cp = (MemPage)MemberwiseClone();\n        if ( aOvfl != null )\n        {\n          cp.aOvfl = new _OvflCell[aOvfl.Length];\n          for ( int i = 0 ; i < aOvfl.Length ; i++ ) cp.aOvfl[i] = aOvfl[i].Copy();\n        }\n        if ( aData != null )\n        {\n          cp.aData = new byte[aData.Length];\n          Buffer.BlockCopy( aData, 0, cp.aData, 0, aData.Length );\n        }\n        return cp;\n      }\n    };\n\n    /*\n    ** The in-memory image of a disk page has the auxiliary information appended\n    ** to the end.  EXTRA_SIZE is the number of bytes of space needed to hold\n    ** that extra information.\n    */\n    const int EXTRA_SIZE = 0;// No used in C#, since we use create a class; was MemPage.Length;\n\n    /*\n    ** A linked list of the following structures is stored at BtShared.pLock.\n    ** Locks are added (or upgraded from READ_LOCK to WRITE_LOCK) when a cursor \n    ** is opened on the table with root page BtShared.iTable. Locks are removed\n    ** from this list when a transaction is committed or rolled back, or when\n    ** a btree handle is closed.\n    */\n    public class BtLock {\n      Btree pBtree;         /* Btree handle holding this lock */\n      Pgno iTable;          /* Root page of table */\n      u8 eLock;             /* READ_LOCK or WRITE_LOCK */\n      BtLock pNext;         /* Next in BtShared.pLock list */\n    };\n\n    /* Candidate values for BtLock.eLock */\n    //#define READ_LOCK     1\n    //#define WRITE_LOCK    2\n    const int READ_LOCK = 1;\n    const int WRITE_LOCK = 2;\n\n    /* A Btree handle\n    **\n    ** A database connection contains a pointer to an instance of\n    ** this object for every database file that it has open.  This structure\n    ** is opaque to the database connection.  The database connection cannot\n    ** see the internals of this structure and only deals with pointers to\n    ** this structure.\n    **\n    ** For some database files, the same underlying database cache might be\n    ** shared between multiple connections.  In that case, each contection\n    ** has it own pointer to this object.  But each instance of this object\n    ** points to the same BtShared object.  The database cache and the\n    ** schema associated with the database file are all contained within\n    ** the BtShared object.\n    **\n    ** All fields in this structure are accessed under sqlite3.mutex.\n    ** The pBt pointer itself may not be changed while there exists cursors\n    ** in the referenced BtShared that point back to this Btree since those\n    ** cursors have to do go through this Btree to find their BtShared and\n    ** they often do so without holding sqlite3.mutex.\n    */\n    public class Btree\n    {\n      public sqlite3 db;        /* The database connection holding this Btree */\n      public BtShared pBt;      /* Sharable content of this Btree */\n      public u8 inTrans;        /* TRANS_NONE, TRANS_READ or TRANS_WRITE */\n      public bool sharable;     /* True if we can share pBt with another db */\n      public bool locked;       /* True if db currently has pBt locked */\n      public int wantToLock;    /* Number of nested calls to sqlite3BtreeEnter() */\n      public int nBackup;       /* Number of backup operations reading this btree */\n      public Btree pNext;       /* List of other sharable Btrees from the same db */\n      public Btree pPrev;       /* Back pointer of the same list */\n#if !SQLITE_OMIT_SHARED_CACHE\n      BtLock lock;              /* Object used to lock page 1 */\n#endif\n    };\n\n    /*\n    ** Btree.inTrans may take one of the following values.\n    **\n    ** If the shared-data extension is enabled, there may be multiple users\n    ** of the Btree structure. At most one of these may open a write transaction,\n    ** but any number may have active read transactions.\n    */\n    const byte TRANS_NONE = 0;\n    const byte TRANS_READ = 1;\n    const byte TRANS_WRITE = 2;\n\n    /*\n    ** An instance of this object represents a single database file.\n    **\n    ** A single database file can be in use as the same time by two\n    ** or more database connections.  When two or more connections are\n    ** sharing the same database file, each connection has it own\n    ** private Btree object for the file and each of those Btrees points\n    ** to this one BtShared object.  BtShared.nRef is the number of\n    ** connections currently sharing this database file.\n    **\n    ** Fields in this structure are accessed under the BtShared.mutex\n    ** mutex, except for nRef and pNext which are accessed under the\n    ** global SQLITE_MUTEX_STATIC_MASTER mutex.  The pPager field\n    ** may not be modified once it is initially set as long as nRef>0.\n    ** The pSchema field may be set once under BtShared.mutex and\n    ** thereafter is unchanged as long as nRef>0.\n    **\n    ** isPending:\n    **\n    **   If a BtShared client fails to obtain a write-lock on a database\n    **   table (because there exists one or more read-locks on the table),\n    **   the shared-cache enters \'pending-lock\' state and isPending is\n    **   set to true.\n    **\n    **   The shared-cache leaves the \'pending lock\' state when either of\n    **   the following occur:\n    **\n    **     1) The current writer (BtShared.pWriter) concludes its transaction, OR\n    **     2) The number of locks held by other connections drops to zero.\n    **\n    **   while in the \'pending-lock\' state, no connection may start a new\n    **   transaction.\n    **\n    **   This feature is included to help prevent writer-starvation.\n    */\n    public class BtShared\n    {\n      public Pager pPager;           /* The page cache */\n      public sqlite3 db;             /* Database connection currently using this Btree */\n      public BtCursor pCursor;       /* A list of all open cursors */\n      public MemPage pPage1;         /* First page of the database */\n      public bool readOnly;          /* True if the underlying file is readonly */\n      public bool pageSizeFixed;     /* True if the page size can no longer be changed */\n#if !SQLITE_OMIT_AUTOVACUUM\n      public bool autoVacuum;         /* True if auto-vacuum is enabled */\n      public bool incrVacuum;         /* True if incr-vacuum is enabled */\n#endif\n      public u16 pageSize;            /* Total number of bytes on a page */\n      public u16 usableSize;          /* Number of usable bytes on each page */\n      public u16 maxLocal;            /* Maximum local payload in non-LEAFDATA tables */\n      public u16 minLocal;            /* Minimum local payload in non-LEAFDATA tables */\n      public u16 maxLeaf;             /* Maximum local payload in a LEAFDATA table */\n      public u16 minLeaf;             /* Minimum local payload in a LEAFDATA table */\n      public u8 inTransaction;        /* Transaction state */\n      public int nTransaction;        /* Number of open transactions (read + write) */\n      public Schema pSchema;          /* Pointer to space allocated by sqlite3BtreeSchema() */\n      public dxFreeSchema xFreeSchema;/* Destructor for BtShared.pSchema */\n      public sqlite3_mutex mutex;     /* Non-recursive mutex required to access this struct */\n      public Bitvec pHasContent;      /* Set of pages moved to free-list this transaction */\n#if !SQLITE_OMIT_SHARED_CACHE\npublic int nRef;                /* Number of references to this structure */\npublic BtShared pNext;          /* Next on a list of sharable BtShared structs */\npublic BtLock pLock;            /* List of locks held on this shared-btree struct */\npublic Btree pWriter;           /* Btree with currently open write transaction */\npublic u8 isExclusive;          /* True if pWriter has an EXCLUSIVE lock on the db */\npublic u8 isPending;            /* If waiting for read-locks to clear */\n#endif\n      public byte[] pTmpSpace;        /* BtShared.pageSize bytes of space for tmp use */\n    };\n\n    /*\n    ** An instance of the following structure is used to hold information\n    ** about a cell.  The parseCellPtr() function fills in this structure\n    ** based on information extract from the raw disk page.\n    */\n    //typedef struct CellInfo CellInfo;\n    public struct CellInfo\n    {\n      public byte[] pCell;  /* Pointer to the start of cell content */\n      public int iCell;     /* Offset to start of cell content -- Needed for C# */\n      public i64 nKey;      /* The key for INTKEY tables, or number of bytes in key */\n      public u32 nData;     /* Number of bytes of data */\n      public u32 nPayload;  /* Total amount of payload */\n      public u16 nHeader;   /* Size of the cell content header in bytes */\n      public u16 nLocal;    /* Amount of payload held locally */\n      public u16 iOverflow; /* Offset to overflow page number.  Zero if no overflow */\n      public u16 nSize;     /* Size of the cell content on the main b-tree page */\n      public bool Equals( CellInfo ci )\n      {\n        if ( ci.pCell[ci.iCell] != this.pCell[iCell] ) return false;\n        if ( ci.nKey != this.nKey || ci.nData != this.nData || ci.nPayload != this.nPayload ) return false;\n        if ( ci.nHeader != this.nHeader || ci.nLocal != this.nLocal ) return false;\n        if ( ci.iOverflow != this.iOverflow || ci.nSize != this.nSize ) return false;\n        return true;\n      }\n    };\n\n    /*\n    ** Maximum depth of an SQLite B-Tree structure. Any B-Tree deeper than\n    ** this will be declared corrupt. This value is calculated based on a\n    ** maximum database size of 2^31 pages a minimum fanout of 2 for a\n    ** root-node and 3 for all other internal nodes.\n    **\n    ** If a tree that appears to be taller than this is encountered, it is\n    ** assumed that the database is corrupt.\n    */\n    //#define BTCURSOR_MAX_DEPTH 20\n    const int BTCURSOR_MAX_DEPTH = 20;\n\n    /*\n    ** A cursor is a pointer to a particular entry within a particular\n    ** b-tree within a database file.\n    **\n    ** The entry is identified by its MemPage and the index in\n    ** MemPage.aCell[] of the entry.\n    **\n    ** When a single database file can shared by two more database connections,\n    ** but cursors cannot be shared.  Each cursor is associated with a\n    ** particular database connection identified BtCursor.pBtree.db.\n    **\n    ** Fields in this structure are accessed under the BtShared.mutex\n    ** found at self.pBt.mutex.\n    */\n    public class BtCursor\n    {\n      public Btree pBtree;            /* The Btree to which this cursor belongs */\n      public BtShared pBt;            /* The BtShared this cursor points to */\n      public BtCursor pNext;\n      public BtCursor pPrev;          /* Forms a linked list of all cursors */\n      public KeyInfo pKeyInfo;        /* Argument passed to comparison function */\n      public Pgno pgnoRoot;            /* The root page of this tree */\n      public sqlite3_int64 cachedRowid; /* Next rowid cache.  0 means not valid */\n      public CellInfo info = new CellInfo();           /* A parse of the cell we are pointing at */\n      public u8 wrFlag;               /* True if writable */\n      public u8 atLast;               /* VdbeCursor pointing to the last entry */\n      public bool validNKey;          /* True if info.nKey is valid */\n      public int eState;              /* One of the CURSOR_XXX constants (see below) */\n      public byte[] pKey;             /* Saved key that was cursor\'s last known position */\n      public i64 nKey;                /* Size of pKey, or last integer key */\n      public int skipNext;            /* Prev() is noop if negative. Next() is noop if positive */\n#if !SQLITE_OMIT_INCRBLOB\npublic bool isIncrblobHandle;   /* True if this cursor is an incr. io handle */\npublic Pgno[] aOverflow;         /* Cache of overflow page locations */\n#endif\n      public i16 iPage;                                          /* Index of current page in apPage */\n      public MemPage[] apPage = new MemPage[BTCURSOR_MAX_DEPTH]; /* Pages from root to current page */\n      public u16[] aiIdx = new u16[BTCURSOR_MAX_DEPTH];           /* Current index in apPage[i] */\n\n      public BtCursor Copy()\n      {\n        BtCursor cp = (BtCursor)MemberwiseClone();\n        return cp;\n      }\n    };\n\n    /*\n    ** Potential values for BtCursor.eState.\n    **\n    ** CURSOR_VALID:\n    **   VdbeCursor points to a valid entry. getPayload() etc. may be called.\n    **\n    ** CURSOR_INVALID:\n    **   VdbeCursor does not point to a valid entry. This can happen (for example)\n    **   because the table is empty or because BtreeCursorFirst() has not been\n    **   called.\n    **\n    ** CURSOR_REQUIRESEEK:\n    **   The table that this cursor was opened on still exists, but has been\n    **   modified since the cursor was last used. The cursor position is saved\n    **   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in\n    **   this state, restoreCursorPosition() can be called to attempt to\n    **   seek the cursor to the saved position.\n    **\n    ** CURSOR_FAULT:\n    **   A unrecoverable error (an I/O error or a malloc failure) has occurred\n    **   on a different connection that shares the BtShared cache with this\n    **   cursor.  The error has left the cache in an inconsistent state.\n    **   Do nothing else with this cursor.  Any attempt to use the cursor\n    **   should return the error code stored in BtCursor.skip\n    */\n    const int CURSOR_INVALID = 0;\n    const int CURSOR_VALID = 1;\n    const int CURSOR_REQUIRESEEK = 2;\n    const int CURSOR_FAULT = 3;\n\n    /*\n    ** The database page the PENDING_BYTE occupies. This page is never used.\n    */\n    //# define PENDING_BYTE_PAGE(pBt) PAGER_MJ_PGNO(pBt)\n    // TODO -- Convert PENDING_BYTE_PAGE to inline\n    static u32 PENDING_BYTE_PAGE( BtShared pBt ) { return (u32)PAGER_MJ_PGNO( pBt.pPager ); }\n\n    /*\n    ** These macros define the location of the pointer-map entry for a\n    ** database page. The first argument to each is the number of usable\n    ** bytes on each page of the database (often 1024). The second is the\n    ** page number to look up in the pointer map.\n    **\n    ** PTRMAP_PAGENO returns the database page number of the pointer-map\n    ** page that stores the required pointer. PTRMAP_PTROFFSET returns\n    ** the offset of the requested map entry.\n    **\n    ** If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,\n    ** then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be\n    ** used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements\n    ** this test.\n    */\n    //#define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno)\n    static Pgno PTRMAP_PAGENO( BtShared pBt, Pgno pgno ) { return ptrmapPageno( pBt, pgno ); }\n    //#define PTRMAP_PTROFFSET(pgptrmap, pgno) (5*(pgno-pgptrmap-1))\n    static u32 PTRMAP_PTROFFSET( u32 pgptrmap, u32 pgno ) { return ( 5 * ( pgno - pgptrmap - 1 ) ); }\n    //#define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))\n    static bool PTRMAP_ISPAGE( BtShared pBt, u32 pgno ) { return ( PTRMAP_PAGENO( ( pBt ), ( pgno ) ) == ( pgno ) ); }\n    /*\n    ** The pointer map is a lookup table that identifies the parent page for\n    ** each child page in the database file.  The parent page is the page that\n    ** contains a pointer to the child.  Every page in the database contains\n    ** 0 or 1 parent pages.  (In this context \'database page\' refers\n    ** to any page that is not part of the pointer map itself.)  Each pointer map\n    ** entry consists of a single byte \'type\' and a 4 byte parent page number.\n    ** The PTRMAP_XXX identifiers below are the valid types.\n    **\n    ** The purpose of the pointer map is to facility moving pages from one\n    ** position in the file to another as part of autovacuum.  When a page\n    ** is moved, the pointer in its parent must be updated to point to the\n    ** new location.  The pointer map is used to locate the parent page quickly.\n    **\n    ** PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not\n    **                  used in this case.\n    **\n    ** PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number\n    **                  is not used in this case.\n    **\n    ** PTRMAP_OVERFLOW1: The database page is the first page in a list of\n    **                   overflow pages. The page number identifies the page that\n    **                   contains the cell with a pointer to this overflow page.\n    **\n    ** PTRMAP_OVERFLOW2: The database page is the second or later page in a list of\n    **                   overflow pages. The page-number identifies the previous\n    **                   page in the overflow page list.\n    **\n    ** PTRMAP_BTREE: The database page is a non-root btree page. The page number\n    **               identifies the parent page in the btree.\n    */\n    //#define PTRMAP_ROOTPAGE 1\n    //#define PTRMAP_FREEPAGE 2\n    //#define PTRMAP_OVERFLOW1 3\n    //#define PTRMAP_OVERFLOW2 4\n    //#define PTRMAP_BTREE 5\n    const int PTRMAP_ROOTPAGE = 1;\n    const int PTRMAP_FREEPAGE = 2;\n    const int PTRMAP_OVERFLOW1 = 3;\n    const int PTRMAP_OVERFLOW2 = 4;\n    const int PTRMAP_BTREE = 5;\n\n    /* A bunch of Debug.Assert() statements to check the transaction state variables\n    ** of handle p (type Btree*) are internally consistent.\n    */\n#if DEBUG\n    //#define btreeIntegrity(p) \\\n    //  Debug.Assert( p.pBt.inTransaction!=TRANS_NONE || p.pBt.nTransaction==0 ); \\\n    //  Debug.Assert( p.pBt.inTransaction>=p.inTrans );\n    static void btreeIntegrity( Btree p )\n    {\n      Debug.Assert( p.pBt.inTransaction != TRANS_NONE || p.pBt.nTransaction == 0 );\n      Debug.Assert( p.pBt.inTransaction >= p.inTrans );\n    }\n#else\n    static void btreeIntegrity(Btree p) { }\n#endif\n\n    /*\n** The ISAUTOVACUUM macro is used within balance_nonroot() to determine\n** if the database supports auto-vacuum or not. Because it is used\n** within an expression that is an argument to another macro\n** (sqliteMallocRaw), it is not possible to use conditional compilation.\n** So, this macro is defined instead.\n*/\n#if !SQLITE_OMIT_AUTOVACUUM\n    //#define ISAUTOVACUUM (pBt.autoVacuum)\n#else\n//#define ISAUTOVACUUM 0\npublic static bool ISAUTOVACUUM =false;\n#endif\n\n\n    /*\n** This structure is passed around through all the sanity checking routines\n** in order to keep track of some global state information.\n*/\n    //typedef struct IntegrityCk IntegrityCk;\n    public class IntegrityCk\n    {\n      public BtShared pBt;      /* The tree being checked out */\n      public Pager pPager;      /* The associated pager.  Also accessible by pBt.pPager */\n      public Pgno nPage;        /* Number of pages in the database */\n      public int[] anRef;       /* Number of times each page is referenced */\n      public int mxErr;         /* Stop accumulating errors when this reaches zero */\n      public int nErr;          /* Number of messages written to zErrMsg so far */\n      //public int mallocFailed;  /* A memory allocation error has occurred */\n      public StrAccum errMsg = new StrAccum(); /* Accumulate the error message text here */\n    };\n\n    /*\n    ** Read or write a two- and four-byte big-endian integer values.\n    */\n    //#define get2byte(x)   ((x)[0]<<8 | (x)[1])\n    static int get2byte( byte[] p, int offset )\n    { return p[offset + 0] << 8 | p[offset + 1]; }\n\n    //#define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))\n    static void put2byte( byte[] pData, int Offset, u32 v )\n    { pData[Offset + 0] = (byte)( v >> 8 ); pData[Offset + 1] = (byte)v; }\n    static void put2byte( byte[] pData, int Offset, int v )\n    { pData[Offset + 0] = (byte)( v >> 8 ); pData[Offset + 1] = (byte)v; }\n\n    //#define get4byte sqlite3Get4byte\n    //#define put4byte sqlite3Put4byte\n\n  }\n}\n'