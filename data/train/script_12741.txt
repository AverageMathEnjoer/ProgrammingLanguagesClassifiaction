b'\n-- | Unclassified tools\n\nmodule Pdf.Core.Util\n( notice\n, readObjectAtOffset\n, readCompressedObject\n)\nwhere\n\nimport Pdf.Core.IO.Buffer (Buffer)\nimport qualified Pdf.Core.IO.Buffer as Buffer\nimport Pdf.Core.Exception\nimport Pdf.Core.Object\nimport Pdf.Core.Parsers.Object\n\nimport Data.Int\nimport Data.ByteString (ByteString)\nimport Data.Attoparsec.ByteString.Char8 (Parser)\nimport qualified Data.Attoparsec.ByteString.Char8 as Parser\nimport Control.Monad\nimport Control.Exception hiding (throw)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as Streams\nimport qualified System.IO.Streams.Attoparsec as Streams\n\n-- | Add a message to \'Maybe\'\nnotice :: Maybe a -> String -> Either String a\nnotice Nothing = Left\nnotice (Just a) = const (Right a)\n\n-- | Read indirect object at the specified offset\n--\n-- Returns the object and the \'Ref\'. The payload for stream\n-- will be an offset of stream content\nreadObjectAtOffset :: Buffer\n                   -> Int64   -- ^ object offset\n                   -> IO (Ref, Object)\nreadObjectAtOffset buf off = message "readObjectAtOffset" $ do\n  Buffer.seek buf off\n  (ref, o) <- Streams.parseFromStream parseIndirectObject\n    (Buffer.toInputStream buf)\n      `catch` \\(Streams.ParseException msg) -> throwIO (Corrupted msg [])\n  case o of\n    Stream (S dict _) -> do\n      pos <- Buffer.tell buf\n      return (ref, Stream (S dict pos))\n    Ref _ -> throwIO $ Corrupted "Indirect object can\'t be a Ref" []\n    _ -> return (ref, o)\n\n-- | Read object from object stream\n--\n-- Never returns \'Stream\'\nreadCompressedObject :: InputStream ByteString\n                     -- ^ decoded object stream\n                     -> Int64\n                     -- ^ an offset of the first object\n                     -- (\\"First\\" key in dictionary)\n                     -> Int\n                     -- ^ object number to read\n                     -> IO Object\nreadCompressedObject is first num = do\n  (is\', counter) <- Streams.countInput is\n  off <- do\n    res <- Streams.parseFromStream (replicateM (num + 1) headerP) is\'\n      `catch` \\(Streams.ParseException msg) -> throwIO $ Corrupted\n        "Object stream" [msg]\n    when (null res) $\n      error "readCompressedObject: imposible"\n    case last res of\n      (_, off) -> return off\n  pos <- counter\n  Buffer.dropExactly (fromIntegral $ first + off - pos) is\n  Streams.parseFromStream parseObject is\n    `catch` \\(Streams.ParseException msg) -> throwIO $ Corrupted\n      "Object in object stream" [msg]\n  where\n  headerP :: Parser (Int, Int64)\n  headerP = do\n    n <- Parser.decimal\n    Parser.skipSpace\n    off <- Parser.decimal\n    Parser.skipSpace\n    return (n, off)\n'