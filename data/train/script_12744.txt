b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecursiveDo #-}\n\nmodule Hoodle.Web.Handler where\n\nimport Control.Monad (when)\nimport Control.Monad.Trans.Crtn.EventHandler (eventHandler)\nimport Data.Binary (decode)\nimport qualified Data.ByteString.Lazy as BL\nimport GHCJS.Foreign.Callback\n  ( Callback,\n    OnBlocked (ThrowWouldBlock),\n    syncCallback,\n    syncCallback1,\n  )\nimport GHCJS.Types (JSString, JSVal, jsval)\nimport qualified Hoodle.Web.ForeignJS as J\nimport Hoodle.Web.Type.Coroutine (EventVar)\nimport Hoodle.Web.Type.Event (AllEvent (..), SystemEvent (..), UserEvent (..))\nimport Hoodle.Web.Type.State (DocState (..), HoodleState (..), SyncState (..))\nimport Hoodle.Web.Util (arrayBufferToByteString, putStrLnAndFlush)\nimport JavaScript.TypedArray.ArrayBuffer (ArrayBuffer)\nimport qualified JavaScript.Web.MessageEvent as ME\nimport qualified JavaScript.Web.WebSocket as WS\nimport Message (S2CMsg (DataStrokes, RegisterStroke))\n\nonPointerDown ::\n  EventVar ->\n  JSVal ->\n  IO ()\nonPointerDown evar ev = do\n  v <- J.js_pointer_type ev\n  J.js_debug_show (jsval v)\n  t <- J.getPointerType ev\n  when (t /= J.Touch) $ do\n    (x, y) <- J.getXY ev\n    eventHandler evar $ UsrEv $ PointerDown (x, y)\n\nonPointerUp ::\n  EventVar ->\n  JSVal ->\n  IO ()\nonPointerUp evar ev = do\n  J.js_debug_show $ jsval ("ready for input" :: JSString)\n  t <- J.getPointerType ev\n  when (t /= J.Touch) $ do\n    (x, y) <- J.getXY ev\n    eventHandler evar $ UsrEv $ PointerUp (x, y)\n\nonPointerMove ::\n  EventVar ->\n  JSVal ->\n  IO ()\nonPointerMove evar ev = do\n  t <- J.getPointerType ev\n  when (t /= J.Touch) $ do\n    (x, y) <- J.getXY ev\n    eventHandler evar $ UsrEv $ PointerMove (x, y)\n\nonAnimationFrame :: EventVar -> Callback (IO ()) -> IO ()\nonAnimationFrame evar rAF = do\n  eventHandler evar $ SysEv $ ERefresh\n  J.js_requestAnimationFrame rAF\n\nonMessage :: EventVar -> ArrayBuffer -> IO ()\nonMessage evar arrbuf = do\n  let lbs = BL.fromStrict $ arrayBufferToByteString arrbuf\n  case decode lbs of\n    RegisterStroke s\' -> do\n      eventHandler evar $ SysEv $ ERegisterStroke s\'\n    DataStrokes dat -> do\n      eventHandler evar $ SysEv $ EDataStrokes dat\n\ndata Mode = ModePen | ModeEraser | ModeSelect\n  deriving (Show)\n\ndata ModeButtons = ModeButtons\n  { _mbPen :: JSVal,\n    _mbEraser :: JSVal,\n    _mbSelect :: JSVal\n  }\n\nonModeChange :: Mode -> EventVar -> ModeButtons -> JSVal -> IO ()\nonModeChange m evar btns _ = do\n  case m of\n    ModePen -> do\n      J.js_add_class (_mbPen btns) "is-primary"\n      J.js_remove_class (_mbEraser btns) "is-primary"\n      J.js_remove_class (_mbSelect btns) "is-primary"\n      eventHandler evar $ UsrEv ToPenMode\n    ModeEraser -> do\n      J.js_remove_class (_mbPen btns) "is-primary"\n      J.js_add_class (_mbEraser btns) "is-primary"\n      J.js_remove_class (_mbSelect btns) "is-primary"\n      eventHandler evar $ UsrEv ToEraserMode\n    ModeSelect -> do\n      J.js_remove_class (_mbPen btns) "is-primary"\n      J.js_remove_class (_mbEraser btns) "is-primary"\n      J.js_add_class (_mbSelect btns) "is-primary"\n      eventHandler evar $ UsrEv ToSelectMode\n\nsetupCallback :: EventVar -> IO HoodleState\nsetupCallback evar = do\n  putStrLnAndFlush "ghcjs started"\n  hostname <- J.js_hostname\n  J.js_prevent_default_touch_move\n  svg <- J.js_svg_box\n  cvs <- J.js_document_getElementById "overlay"\n  J.js_fix_dpi cvs\n  offcvs <- J.js_create_canvas\n  w <- J.js_get_width cvs\n  h <- J.js_get_height cvs\n  J.js_set_width offcvs w\n  J.js_set_height offcvs h\n  putStrLnAndFlush "websocket start"\n  let wsClose _ =\n        putStrLnAndFlush "connection closed"\n      wsMessage ev msg = do\n        let d = ME.getData msg\n        case d of\n          ME.ArrayBufferData arrbuf -> onMessage ev arrbuf\n          ME.BlobData _ -> putStrLnAndFlush ("BlobData" :: String)\n          ME.StringData _ -> putStrLnAndFlush ("StringData" :: String)\n  xstate <- mdo\n    sock <-\n      WS.connect\n        WS.WebSocketRequest\n          { WS.url = "ws://" <> hostname <> ":7070",\n            WS.protocols = [],\n            WS.onClose = Just wsClose,\n            WS.onMessage = Just (wsMessage evar)\n          }\n    WS.setBinaryType WS.ArrayBuffer sock\n    pure $ HoodleState svg cvs offcvs sock (DocState 0 []) (SyncState []) True\n  onpointerdown <- syncCallback1 ThrowWouldBlock (onPointerDown evar)\n  J.js_addEventListener cvs "pointerdown" onpointerdown\n  onpointermove <- syncCallback1 ThrowWouldBlock (onPointerMove evar)\n  J.js_addEventListener cvs "pointermove" onpointermove\n  onpointerup <- syncCallback1 ThrowWouldBlock (onPointerUp evar)\n  J.js_addEventListener cvs "pointerup" onpointerup\n  mdo\n    rAF <- syncCallback ThrowWouldBlock (onAnimationFrame evar rAF)\n    J.js_requestAnimationFrame rAF\n  pen <- J.js_document_getElementById "pen"\n  eraser <- J.js_document_getElementById "eraser"\n  select <- J.js_document_getElementById "select"\n  let btns = ModeButtons pen eraser select\n  J.js_addEventListener pen "click"\n    =<< syncCallback1 ThrowWouldBlock (onModeChange ModePen evar btns)\n  J.js_addEventListener eraser "click"\n    =<< syncCallback1 ThrowWouldBlock (onModeChange ModeEraser evar btns)\n  J.js_addEventListener select "click"\n    =<< syncCallback1 ThrowWouldBlock (onModeChange ModeSelect evar btns)\n  pure xstate\n'