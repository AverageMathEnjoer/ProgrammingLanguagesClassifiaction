b'using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nusing FILE = System.IO.TextWriter;\n\nusing i64 = System.Int64;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\nusing unsigned = System.UIntPtr;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using Op = CSSQLite.VdbeOp;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2003 September 6\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This is the header file for information that is private to the\n    ** VDBE.  This information used to all be at the top of the single\n    ** source code file "vdbe.c".  When that file became too big (over\n    ** 6000 lines long) it was split up into several smaller files and\n    ** this header information was factored out.\n    **\n    ** $Id: vdbeInt.h,v 1.174 2009/06/23 14:15:04 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#if !_VDBEINT_H_\n    //#define _VDBEINT_H_\n\n    /*\n    ** SQL is translated into a sequence of instructions to be\n    ** executed by a virtual machine.  Each instruction is an instance\n    ** of the following structure.\n    */\n    //typedef struct VdbeOp Op;\n\n    /*\n    ** Boolean values\n    */\n    //typedef unsigned char Bool;\n\n    /*\n    ** A cursor is a pointer into a single BTree within a database file.\n    ** The cursor can seek to a BTree entry with a particular key, or\n    ** loop over all entries of the Btree.  You can also insert new BTree\n    ** entries or retrieve the key or data from the entry that the cursor\n    ** is currently pointing to.\n    **\n    ** Every cursor that the virtual machine has open is represented by an\n    ** instance of the following structure.\n    **\n    ** If the VdbeCursor.isTriggerRow flag is set it means that this cursor is\n    ** really a single row that represents the NEW or OLD pseudo-table of\n    ** a row trigger.  The data for the row is stored in VdbeCursor.pData and\n    ** the rowid is in VdbeCursor.iKey.\n    */\n    public class VdbeCursor\n    {\n      public BtCursor pCursor;     /* The cursor structure of the backend */\n      public int iDb;              /* Index of cursor database in db.aDb[] (or -1) */\n      public i64 lastRowid;        /* Last rowid from a Next or NextIdx operation */\n      public bool zeroed;          /* True if zeroed out and ready for reuse */\n      public bool rowidIsValid;    /* True if lastRowid is valid */\n      public bool atFirst;         /* True if pointing to first entry */\n      public bool useRandomRowid;  /* Generate new record numbers semi-randomly */\n      public bool nullRow;         /* True if pointing to a row with no data */\n      public bool pseudoTable;     /* This is a NEW or OLD pseudo-tables of a trigger */\n      public bool ephemPseudoTable;\n      public bool deferredMoveto;  /* A call to sqlite3BtreeMoveto() is needed */\n      public bool isTable;         /* True if a table requiring integer keys */\n      public bool isIndex;         /* True if an index containing keys only - no data */\n      public i64 movetoTarget;     /* Argument to the deferred sqlite3BtreeMoveto() */\n      public Btree pBt;            /* Separate file holding temporary table */\n      public int nData;            /* Number of bytes in pData */\n      public byte[] pData;         /* Data for a NEW or OLD pseudo-table */\n      public i64 iKey;             /* Key for the NEW or OLD pseudo-table row */\n      public KeyInfo pKeyInfo;     /* Info about index keys needed by index cursors */\n      public int nField;           /* Number of fields in the header */\n      public int seqCount;         /* Sequence counter */\n#if !SQLITE_OMIT_VIRTUALTABLE\npublic sqlite3_vtab_cursor pVtabCursor;  /* The cursor for a virtual table */\npublic readonly sqlite3_module pModule; /* Module for cursor pVtabCursor */\n#endif\n\n      /* Result of last sqlite3BtreeMoveto() done by an OP_NotExists or\n** OP_IsUnique opcode on this cursor. */\n      public int seekResult;\n\n      /* Cached information about the header for the data record that the\n      ** cursor is currently pointing to.  Only valid if cacheValid is true.\n      ** aRow might point to (ephemeral) data for the current row, or it might\n      ** be NULL.\n      */\n      public int cacheStatus;      /* Cache is valid if this matches Vdbe.cacheCtr */\n      public Pgno payloadSize;     /* Total number of bytes in the record */\n      public u32[] aType;          /* Type values for all entries in the record */\n      public u32[] aOffset;        /* Cached offsets to the start of each columns data */\n      public int aRow;             /* Pointer to Data for the current row, if all on one page */\n\n    };\n    //typedef struct VdbeCursor VdbeCursor;\n\n\n    /*\n    ** A value for VdbeCursor.cacheValid that means the cache is always invalid.\n    */\n    const int CACHE_STALE = 0;\n\n    /*\n    ** Internally, the vdbe manipulates nearly all SQL values as Mem\n    ** structures. Each Mem struct may cache multiple representations (string,\n    ** integer etc.) of the same value.  A value (and therefore Mem structure)\n    ** has the following properties:\n    **\n    ** Each value has a manifest type. The manifest type of the value stored\n    ** in a Mem struct is returned by the MemType(Mem*) macro. The type is\n    ** one of SQLITE_NULL, SQLITE_INTEGER, SQLITE_REAL, SQLITE_TEXT or\n    ** SQLITE_BLOB.\n    */\n    public class Mem\n    {\n      public struct union_ip\n      {\n#if DEBUG_CLASS_MEM || DEBUG_CLASS_ALL\npublic i64 _i;              /* First operand */\npublic i64 i\n{\nget { return _i; }\nset { _i = value; }\n}\n#else\n        public i64 i;               /* Integer value. */\n#endif\n        public int nZero;           /* Used when bit MEM_Zero is set in flags */\n        public FuncDef pDef;        /* Used only when flags==MEM_Agg */\n        public RowSet pRowSet;      /* Used only when flags==MEM_RowSet */\n      };\n      public union_ip u;\n      public double r;              /* Real value */\n      public sqlite3 db;            /* The associated database connection */\n      public string z;              /* String value */\n      public byte[] zBLOB;          /* BLOB value */\n      public int n;                 /* Number of characters in string value, excluding \'\\0\' */\n#if DEBUG_CLASS_MEM || DEBUG_CLASS_ALL\npublic u16 _flags;              /* First operand */\npublic u16 flags\n{\nget { return _flags; }\nset { _flags = value; }\n}\n#else\n      public u16 flags = MEM_Null;  /* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */\n#endif\n      public u8 type = SQLITE_NULL; /* One of SQLITE_NULL, SQLITE_TEXT, SQLITE_INTEGER, etc */\n      public u8 enc;                /* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */\n      public dxDel xDel;            /* If not null, call this function to delete Mem.z */\n      // Not used under c#\n      //public string zMalloc;      /* Dynamic buffer allocated by sqlite3Malloc() */\n      public Mem _Mem;              /* Used when C# overload Z as MEM space */\n      public SumCtx _SumCtx;        /* Used when C# overload Z as Sum context */\n      public StrAccum _StrAccum;    /* Used when C# overload Z as STR context */\n      public object _MD5Context;    /* Used when C# overload Z as MD5 context */\n\n\n      public void CopyTo( Mem ct )\n      {\n        ct.u = u;\n        ct.r = r;\n        ct.db = db;\n        ct.z = z;\n        if ( zBLOB == null ) zBLOB = null;\n        else { ct.zBLOB = (byte[])zBLOB.Clone(); }\n        ct.n = n;\n        ct.flags = flags;\n        ct.type = type;\n        ct.enc = enc;\n        ct.xDel = xDel;\n      }\n\n    };\n\n    /* One or more of the following flags are set to indicate the validOK\n    ** representations of the value stored in the Mem struct.\n    **\n    ** If the MEM_Null flag is set, then the value is an SQL NULL value.\n    ** No other flags may be set in this case.\n    **\n    ** If the MEM_Str flag is set then Mem.z points at a string representation.\n    ** Usually this is encoded in the same unicode encoding as the main\n    ** database (see below for exceptions). If the MEM_Term flag is also\n    ** set, then the string is nul terminated. The MEM_Int and MEM_Real\n    ** flags may coexist with the MEM_Str flag.\n    **\n    ** Multiple of these values can appear in Mem.flags.  But only one\n    ** at a time can appear in Mem.type.\n    */\n    //#define MEM_Null      0x0001   /* Value is NULL */\n    //#define MEM_Str       0x0002   /* Value is a string */\n    //#define MEM_Int       0x0004   /* Value is an integer */\n    //#define MEM_Real      0x0008   /* Value is a real number */\n    //#define MEM_Blob      0x0010   /* Value is a BLOB */\n    //#define MEM_RowSet    0x0020   /* Value is a RowSet object */\n    //#define MEM_TypeMask  0x00ff   /* Mask of type bits */\n    const int MEM_Null = 0x0001;  /* Value is NULL */\n    const int MEM_Str = 0x0002;  /* Value is a string */\n    const int MEM_Int = 0x0004;  /* Value is an integer */\n    const int MEM_Real = 0x0008;  /* Value is a real number */\n    const int MEM_Blob = 0x0010;  /* Value is a BLOB */\n    const int MEM_RowSet = 0x0020;  /* Value is a RowSet object */\n    const int MEM_TypeMask = 0x00ff;   /* Mask of type bits */\n\n    /* Whenever Mem contains a valid string or blob representation, one of\n    ** the following flags must be set to determine the memory management\n    ** policy for Mem.z.  The MEM_Term flag tells us whether or not the\n    ** string is \\000 or \\u0000 terminated\n    //    */\n    //#define MEM_Term      0x0200   /* String rep is nul terminated */\n    //#define MEM_Dyn       0x0400   /* Need to call sqliteFree() on Mem.z */\n    //#define MEM_Static    0x0800   /* Mem.z points to a static string */\n    //#define MEM_Ephem     0x1000   /* Mem.z points to an ephemeral string */\n    //#define MEM_Agg       0x2000   /* Mem.z points to an agg function context */\n    //#define MEM_Zero      0x4000   /* Mem.i contains count of 0s appended to blob */\n//#ifdef SQLITE_OMIT_INCRBLOB\n//  #undef MEM_Zero\n//  #define MEM_Zero 0x0000\n//#endif\n    const int MEM_Term = 0x0200;   \n    const int MEM_Dyn = 0x0400;   \n    const int MEM_Static = 0x0800; \n    const int MEM_Ephem = 0x1000;  \n    const int MEM_Agg = 0x2000;   \n#if !SQLITE_OMIT_INCRBLOB\n    const int MEM_Zero = 0x4000;  \n#else\n    const int MEM_Zero = 0x0000;  \n#endif\n\n    /*\n    ** Clear any existing type flags from a Mem and replace them with f\n    */\n    //#define MemSetTypeFlag(p, f) \\\n    //   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)\n    static void MemSetTypeFlag( Mem p, int f ) { p.flags = (u16)( p.flags & ~( MEM_TypeMask | MEM_Zero ) | f ); }// TODO -- Convert back to inline for speed\n\n#if  SQLITE_OMIT_INCRBLOB\n    //#undef MEM_Zero\n#endif\n\n    /* A VdbeFunc is just a FuncDef (defined in sqliteInt.h) that contains\n** additional information about auxiliary information bound to arguments\n** of the function.  This is used to implement the sqlite3_get_auxdata()\n** and sqlite3_set_auxdata() APIs.  The "auxdata" is some auxiliary data\n** that can be associated with a constant argument to a function.  This\n** allows functions such as "regexp" to compile their constant regular\n** expression argument once and reused the compiled code for multiple\n** invocations.\n*/\n    public class AuxData\n    {\n      public string pAux;                     /* Aux data for the i-th argument */\n      public dxDel xDelete; //(void *);      /* Destructor for the aux data */\n    };\n    public class VdbeFunc : FuncDef\n    {\n      public FuncDef pFunc;                   /* The definition of the function */\n      public int nAux;                         /* Number of entries allocated for apAux[] */\n      public AuxData[] apAux = new AuxData[2]; /* One slot for each function argument */\n    };\n\n    /*\n    ** The "context" argument for a installable function.  A pointer to an\n    ** instance of this structure is the first argument to the routines used\n    ** implement the SQL functions.\n    **\n    ** There is a typedef for this structure in sqlite.h.  So all routines,\n    ** even the public interface to SQLite, can use a pointer to this structure.\n    ** But this file is the only place where the internal details of this\n    ** structure are known.\n    **\n    ** This structure is defined inside of vdbeInt.h because it uses substructures\n    ** (Mem) which are only defined there.\n    */\n    public class sqlite3_context\n    {\n      public FuncDef pFunc;        /* Pointer to function information.  MUST BE FIRST */\n      public VdbeFunc pVdbeFunc;   /* Auxilary data, if created. */\n      public Mem s = new Mem();    /* The return value is stored here */\n      public Mem pMem;             /* Memory cell used to store aggregate context */\n      public int isError;          /* Error code returned by the function. */\n      public CollSeq pColl;        /* Collating sequence */\n    };\n\n    /*\n    ** A Set structure is used for quick testing to see if a value\n    ** is part of a small set.  Sets are used to implement code like\n    ** this:\n    **            x.y IN (\'hi\',\'hoo\',\'hum\')\n    */\n    //typedef struct Set Set;\n    public class Set\n    {\n      Hash hash;             /* A set is just a hash table */\n      HashElem prev;         /* Previously accessed hash elemen */\n    };\n\n    /*\n    ** A Context stores the last insert rowid, the last statement change count,\n    ** and the current statement change count (i.e. changes since last statement).\n    ** The current keylist is also stored in the context.\n    ** Elements of Context structure type make up the ContextStack, which is\n    ** updated by the ContextPush and ContextPop opcodes (used by triggers).\n    ** The context is pushed before executing a trigger a popped when the\n    ** trigger finishes.\n    */\n    //typedef struct Context Context;\n    public class Context\n    {\n      public i64 lastRowid;    /* Last insert rowid (sqlite3.lastRowid) */\n      public int nChange;      /* Statement changes (Vdbe.nChanges)     */\n    };\n\n    /*\n    ** An instance of the virtual machine.  This structure contains the complete\n    ** state of the virtual machine.\n    **\n    ** The "sqlite3_stmt" structure pointer that is returned by sqlite3_compile()\n    ** is really a pointer to an instance of this structure.\n    **\n    ** The Vdbe.inVtabMethod variable is set to non-zero for the duration of\n    ** any virtual table method invocations made by the vdbe program. It is\n    ** set to 2 for xDestroy method calls and 1 for all other methods. This\n    ** variable is used for two purposes: to allow xDestroy methods to execute\n    ** "DROP TABLE" statements and to prevent some nasty side effects of\n    ** malloc failure when SQLite is invoked recursively by a virtual table\n    ** method function.\n    */\n    public class Vdbe\n    {\n      public sqlite3 db;             /* The database connection that owns this statement */\n      public Vdbe pPrev;             /* Linked list of VDBEs with the same Vdbe.db */\n      public Vdbe pNext;             /* Linked list of VDBEs with the same Vdbe.db */\n      public int nOp;                /* Number of instructions in the program */\n      public int nOpAlloc;           /* Number of slots allocated for aOp[] */\n      public Op[] aOp;               /* Space to hold the virtual machine\'s program */\n      public int nLabel;             /* Number of labels used */\n      public int nLabelAlloc;        /* Number of slots allocated in aLabel[] */\n      public int[] aLabel;           /* Space to hold the labels */\n      public Mem[] apArg;            /* Arguments to currently executing user function */\n      public Mem[] aColName;         /* Column names to return */\n      public Mem[] pResultSet;       /* Pointer to an array of results */\n      public u16 nResColumn;         /* Number of columns in one row of the result set */\n      public u16 nCursor;            /* Number of slots in apCsr[] */\n      public VdbeCursor[] apCsr;     /* One element of this array for each open cursor */\n      public u8 errorAction;         /* Recovery action to do in case of an error */\n      public u8 okVar;               /* True if azVar[] has been initialized */\n      public u16 nVar;               /* Number of entries in aVar[] */\n      public Mem[] aVar;             /* Values for the OP_Variable opcode. */\n      public string[] azVar;         /* Name of variables */\n      public u32 magic;              /* Magic number for sanity checking */\n      public int nMem;               /* Number of memory locations currently allocated */\n      public Mem[] aMem;             /* The memory locations */\n      public int cacheCtr;           /* VdbeCursor row cache generation counter */\n      public int contextStackTop;    /* Index of top element in the context stack */\n      public int contextStackDepth;  /* The size of the "context" stack */\n      public Context[] contextStack; /* Stack used by opcodes ContextPush & ContextPop*/\n      public int pc;                 /* The program counter */\n      public int rc;                 /* Value to return */\n      public string zErrMsg;         /* Error message written here */\n      public int explain;            /* True if EXPLAIN present on SQL command */\n      public bool changeCntOn;       /* True to update the change-counter */\n      public bool expired;           /* True if the VM needs to be recompiled */\n      public int minWriteFileFormat; /* Minimum file format for writable database files */\n      public int inVtabMethod;       /* See comments above */\n      public bool usesStmtJournal;   /* True if uses a statement journal */\n      public bool readOnly;          /* True for read-only statements */\n      public int nChange;            /* Number of db changes made since last reset */\n      public bool isPrepareV2;       /* True if prepared with prepare_v2() */\n      public int btreeMask;          /* Bitmask of db.aDb[] entries referenced */\n      public u64 startTime;          /* Time when query started - used for profiling */\n      public BtreeMutexArray aMutex; /* An array of Btree used here and needing locks */\n      public int[] aCounter = new int[2]; /* Counters used by sqlite3_stmt_status() */\n      public string zSql = "";       /* Text of the SQL statement that generated this */\n      public object pFree;           /* Free this when deleting the vdbe */\n      public int iStatement;         /* Statement number (or 0 if has not opened stmt) */\n#if SQLITE_DEBUG\n      public FILE trace;                  /* Write an execution trace here, if not NULL */\n#endif\n\n      public Vdbe Copy()\n      {\n        Vdbe cp = (Vdbe)MemberwiseClone();\n        return cp;\n      }\n      public void CopyTo( Vdbe ct )\n      {\n        ct.db = db;\n        ct.pPrev = pPrev;\n        ct.pNext = pNext;\n        ct.nOp = nOp;\n        ct.nOpAlloc = nOpAlloc;\n        ct.aOp = aOp;\n        ct.nLabel = nLabel;\n        ct.nLabelAlloc = nLabelAlloc;\n        ct.aLabel = aLabel;\n        ct.apArg = apArg;\n        ct.aColName = aColName;\n        ct.nCursor = nCursor;\n        ct.apCsr = apCsr;\n        ct.nVar = nVar;\n        ct.aVar = aVar;\n        ct.azVar = azVar;\n        ct.okVar = okVar;\n        ct.magic = magic;\n        ct.nMem = nMem;\n        ct.aMem = aMem;\n        ct.cacheCtr = cacheCtr;\n        ct.contextStackTop = contextStackTop;\n        ct.contextStackDepth = contextStackDepth;\n        ct.contextStack = contextStack;\n        ct.pc = pc;\n        ct.rc = rc;\n        ct.errorAction = errorAction;\n        ct.nResColumn = nResColumn;\n        ct.zErrMsg = zErrMsg;\n        ct.pResultSet = pResultSet;\n        ct.explain = explain;\n        ct.changeCntOn = changeCntOn;\n        ct.expired = expired;\n        ct.minWriteFileFormat = minWriteFileFormat;\n        ct.inVtabMethod = inVtabMethod;\n        ct.usesStmtJournal = usesStmtJournal;\n        ct.readOnly = readOnly;\n        ct.nChange = nChange;\n        ct.isPrepareV2 = isPrepareV2;\n        ct.startTime = startTime;\n        ct.btreeMask = btreeMask;\n        ct.aMutex = aMutex;\n        aCounter.CopyTo( ct.aCounter, 0 );\n        ct.zSql = zSql;\n        ct.pFree = pFree;\n#if SQLITE_DEBUG\n        ct.trace = trace;\n#endif\n        ct.iStatement = iStatement;\n\n#if SQLITE_SSE\nct.fetchId=fetchId;\nct.lru=lru;\n#endif\n#if SQLITE_ENABLE_MEMORY_MANAGEMENT\nct.pLruPrev=pLruPrev;\nct.pLruNext=pLruNext;\n#endif\n      }\n    };\n\n    /*\n    ** The following are allowed values for Vdbe.magic\n    */\n    //#define VDBE_MAGIC_INIT     0x26bceaa5    /* Building a VDBE program */\n    //#define VDBE_MAGIC_RUN      0xbdf20da3    /* VDBE is ready to execute */\n    //#define VDBE_MAGIC_HALT     0x519c2973    /* VDBE has completed execution */\n    //#define VDBE_MAGIC_DEAD     0xb606c3c8    /* The VDBE has been deallocated */\n    const u32 VDBE_MAGIC_INIT = 0x26bceaa5;   /* Building a VDBE program */\n    const u32 VDBE_MAGIC_RUN = 0xbdf20da3;   /* VDBE is ready to execute */\n    const u32 VDBE_MAGIC_HALT = 0x519c2973;   /* VDBE has completed execution */\n    const u32 VDBE_MAGIC_DEAD = 0xb606c3c8;   /* The VDBE has been deallocated */\n    /*\n    ** Function prototypes\n    */\n    //void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);\n    //void sqliteVdbePopStack(Vdbe*,int);\n    //int sqlite3VdbeCursorMoveto(VdbeCursor*);\n    //#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n    //void sqlite3VdbePrintOp(FILE*, int, Op*);\n    //#endif\n    //u32 sqlite3VdbeSerialTypeLen(u32);\n    //u32 sqlite3VdbeSerialType(Mem*, int);\n    //u32sqlite3VdbeSerialPut(unsigned char*, int, Mem*, int);\n    //u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);\n    //void sqlite3VdbeDeleteAuxData(VdbeFunc*, int);\n\n    //int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);\n    //int sqlite3VdbeIdxKeyCompare(VdbeCursor*,UnpackedRecord*,int*);\n    //int sqlite3VdbeIdxRowid(sqlite3 *, i64 *);\n    //int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);\n    //int sqlite3VdbeExec(Vdbe*);\n    //int sqlite3VdbeList(Vdbe*);\n    //int sqlite3VdbeHalt(Vdbe*);\n    //int sqlite3VdbeChangeEncoding(Mem *, int);\n    //int sqlite3VdbeMemTooBig(Mem*);\n    //int sqlite3VdbeMemCopy(Mem*, const Mem*);\n    //void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);\n    //void sqlite3VdbeMemMove(Mem*, Mem*);\n    //int sqlite3VdbeMemNulTerminate(Mem*);\n    //int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));\n    //void sqlite3VdbeMemSetInt64(Mem*, i64);\n    //void sqlite3VdbeMemSetDouble(Mem*, double);\n    //void sqlite3VdbeMemSetNull(Mem*);\n    //void sqlite3VdbeMemSetZeroBlob(Mem*,int);\n    //void sqlite3VdbeMemSetRowSet(Mem*);\n    //int sqlite3VdbeMemMakeWriteable(Mem*);\n    //int sqlite3VdbeMemStringify(Mem*, int);\n    //i64 sqlite3VdbeIntValue(Mem*);\n    //int sqlite3VdbeMemIntegerify(Mem*);\n    //double sqlite3VdbeRealValue(Mem*);\n    //void sqlite3VdbeIntegerAffinity(Mem*);\n    //int sqlite3VdbeMemRealify(Mem*);\n    //int sqlite3VdbeMemNumerify(Mem*);\n    //int sqlite3VdbeMemFromBtree(BtCursor*,int,int,int,Mem*);\n    //void sqlite3VdbeMemRelease(Mem p);\n    //void sqlite3VdbeMemReleaseExternal(Mem p);\n    //int sqlite3VdbeMemFinalize(Mem*, FuncDef*);\n    //const char *sqlite3OpcodeName(int);\n    //int sqlite3VdbeOpcodeHasProperty(int, int);\n    //int sqlite3VdbeMemGrow(Mem pMem, int n, int preserve);\n    //int sqlite3VdbeCloseStatement(Vdbe *, int);\n    //#if SQLITE_ENABLE_MEMORY_MANAGEMENT\n    //int sqlite3VdbeReleaseBuffers(Vdbe p);\n    //#endif\n\n#if !SQLITE_OMIT_SHARED_CACHE\n//void sqlite3VdbeMutexArrayEnter(Vdbe *p);\n#else\n    //# define sqlite3VdbeMutexArrayEnter(p)\n    static void sqlite3VdbeMutexArrayEnter( Vdbe p ) { }\n#endif\n\n    //int sqlite3VdbeMemTranslate(Mem*, u8);\n    //#if SQLITE_DEBUG\n    //  void sqlite3VdbePrintSql(Vdbe*);\n    //  void sqlite3VdbeMemPrettyPrint(Mem pMem, char *zBuf);\n    //#endif\n    //int sqlite3VdbeMemHandleBom(Mem pMem);\n\n#if !SQLITE_OMIT_INCRBLOB\n//  int sqlite3VdbeMemExpandBlob(Mem *);\n#else\n    //  #define sqlite3VdbeMemExpandBlob(x) SQLITE_OK\n    static int sqlite3VdbeMemExpandBlob( Mem x ) { return SQLITE_OK; }\n#endif\n\n    //#endif /* !_VDBEINT_H_) */\n  }\n}\n'