b'/*\n * Copyright 2013 - 2016 Mario Arias\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.funktionale.option\n\nimport org.funktionale.option.Option.None\nimport org.funktionale.option.Option.Some\nimport org.testng.Assert.*\nimport org.testng.annotations.Test\n\nclass OptionTest {\n\n    val some: Option<String> = "kotlin".toOption()\n    val none: Option<String> = Option.empty()\n\n    @Test fun option() {\n\n        val option = some\n        when (option) {\n            is Some<String> -> {\n                assertEquals(option.get(), "kotlin")\n            }\n            is None -> fail()\n        }\n\n        val otherOption = none\n\n        when (otherOption) {\n            is Some<String> -> fail()\n            is None -> assertEquals(otherOption, None)\n        }\n\n    }\n\n    @Test fun getOrElse() {\n        assertEquals(some.getOrElse { "java" }, "kotlin")\n        assertEquals(none.getOrElse { "java" }, "java")\n    }\n\n    @Test fun orNull() {\n        assertNotNull(some.orNull())\n        assertNull(none.orNull())\n    }\n\n    @Test fun map() {\n        assertEquals(some.map(String::toUpperCase).get(), "KOTLIN")\n        assertEquals(none.map(String::toUpperCase), None)\n\n        assertEquals(some.map(Some(12)) { name, version -> "${name.toUpperCase()} M$version" }.get(), "KOTLIN M12")\n        assertEquals(none.map(Some(12)) { name, version -> "${name.toUpperCase()} M$version" }, None)\n    }\n\n    @Test fun fold() {\n        assertEquals(some.fold({ 0 }) { it.length }, 6)\n        assertEquals(none.fold({ 0 }) { it.length }, 0)\n    }\n\n    @Test fun flatMap() {\n        assertEquals(some.flatMap { Some(it.toUpperCase()) }.get(), "KOTLIN")\n        assertEquals(none.flatMap { Some(it.toUpperCase()) }, None)\n    }\n\n    @Test fun filter() {\n        assertEquals(some.filter { it == "java" }, None)\n        assertEquals(none.filter { it == "java" }, None)\n        assertEquals(some.filter { it.startsWith(\'k\') }.get(), "kotlin")\n    }\n\n    @Test fun filterNot() {\n        assertEquals(some.filterNot { it == "java" }.get(), "kotlin")\n        assertEquals(none.filterNot { it == "java" }, None)\n        assertEquals(some.filterNot { it.startsWith(\'k\') }, None)\n    }\n\n    @Test fun exists() {\n        assertTrue(some.exists { it.startsWith(\'k\') })\n        assertFalse(none.exists { it.startsWith(\'k\') })\n\n    }\n\n    @Test fun forEach() {\n        some.forEach {\n            assertEquals(it, "kotlin")\n        }\n\n        none.forEach {\n            fail()\n        }\n    }\n\n    @Test fun orElse() {\n        assertEquals(some.orElse { Some("java") }.get(), "kotlin")\n        assertEquals(none.orElse { Some("java") }.get(), "java")\n    }\n\n    @Test fun toList() {\n        assertEquals(some.toList(), listOf("kotlin"))\n        assertEquals(none.toList(), listOf<String>())\n    }\n\n\n    @Test fun getAsOption() {\n        val map = mapOf(1 to "uno", 2 to "dos", 4 to null)\n        assertEquals(map.option[1], Some("uno"))\n        assertEquals(map.option[3], None)\n        assertEquals(map.option[4], None)\n    }\n\n    @Test fun firstOption() {\n        val l = listOf(1, 2, 3, 4, 5, 6)\n        assertEquals(l.firstOption(), Some(1))\n        assertEquals(l.firstOption { it > 2 }, Some(3))\n    }\n\n    @Test fun optionBody() {\n        assertEquals(optionTry { "1".toInt() }, Some(1))\n        assertEquals(optionTry { "foo".toInt() }, None)\n    }\n\n    @Test fun sequential() {\n        fun parseInts(ints: List<String>): Option<List<Int>> {\n            return ints.map { optionTry { it.toInt() } }.optionSequential()\n        }\n\n        assertEquals(parseInts(listOf("1", "2", "3")), Some(listOf(1, 2, 3)))\n        assertEquals(parseInts(listOf("1", "foo", "3")), None)\n    }\n\n    @Test fun and() {\n        val x = Some(2)\n        val y = Some("Foo")\n        assertEquals(x and y, Some("Foo"))\n        assertEquals(x and None, None)\n        assertEquals(None and x, None)\n        assertEquals(None and None, None)\n\n    }\n\n    @Test fun or() {\n        val x = Some(2)\n        val y = Some(100)\n        assertEquals(x or y, Some(2))\n        assertEquals(x or None, Some(2))\n        assertEquals(None or x, Some(2))\n        assertEquals(None or None, None)\n\n    }\n\n}\n'