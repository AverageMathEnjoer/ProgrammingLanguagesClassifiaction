b'/*\n* The MIT License (MIT)\n\n* Copyright (c) 2015 Michal Tajchert\n\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the "Software"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\npackage com.naman14.timber.permissions;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.Build;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Created by Michal Tajchert on 2015-06-04.\n */\npublic class Nammu {\n    private static final String TAG = Nammu.class.getSimpleName();\n    private static final String KEY_PREV_PERMISSIONS = "previous_permissions";\n    private static final String KEY_IGNORED_PERMISSIONS = "ignored_permissions";\n    private static Context context;\n    private static SharedPreferences sharedPreferences;\n    private static ArrayList<PermissionRequest> permissionRequests = new ArrayList<PermissionRequest>();\n\n    public static void init(Context context) {\n        sharedPreferences = context.getSharedPreferences("pl.tajchert.runtimepermissionhelper", Context.MODE_PRIVATE);\n        Nammu.context = context;\n    }\n\n    /**\n     * Check that all given permissions have been granted by verifying that each entry in the\n     * given array is of the value {@link PackageManager#PERMISSION_GRANTED}.\n     */\n    public static boolean verifyPermissions(int[] grantResults) {\n        for (int result : grantResults) {\n            if (result != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the Activity has access to given permissions.\n     */\n    public static boolean hasPermission(Activity activity, String permission) {\n        return activity.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    /**\n     * Returns true if the Activity has access to a all given permission.\n     */\n    public static boolean hasPermission(Activity activity, String[] permissions) {\n        for (String permission : permissions) {\n            if (activity.checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /*\n     * If we override other methods, lets do it as well, and keep name same as it is already weird enough.\n     * Returns true if we should show explanation why we need this permission.\n     */\n    public static boolean shouldShowRequestPermissionRationale(Activity activity, String permissions) {\n        return activity.shouldShowRequestPermissionRationale(permissions);\n    }\n\n    public static void askForPermission(Activity activity, String permission, PermissionCallback permissionCallback) {\n        askForPermission(activity, new String[]{permission}, permissionCallback);\n    }\n\n    public static void askForPermission(Activity activity, String[] permissions, PermissionCallback permissionCallback) {\n        if (permissionCallback == null) {\n            return;\n        }\n        if (hasPermission(activity, permissions)) {\n            permissionCallback.permissionGranted();\n            return;\n        }\n        PermissionRequest permissionRequest = new PermissionRequest(new ArrayList<String>(Arrays.asList(permissions)), permissionCallback);\n        permissionRequests.add(permissionRequest);\n\n        activity.requestPermissions(permissions, permissionRequest.getRequestCode());\n    }\n\n    public static void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n        PermissionRequest requestResult = new PermissionRequest(requestCode);\n        if (permissionRequests.contains(requestResult)) {\n            PermissionRequest permissionRequest = permissionRequests.get(permissionRequests.indexOf(requestResult));\n            if (verifyPermissions(grantResults)) {\n                //Permission has been granted\n                permissionRequest.getPermissionCallback().permissionGranted();\n            } else {\n                permissionRequest.getPermissionCallback().permissionRefused();\n\n            }\n            permissionRequests.remove(requestResult);\n        }\n        refreshMonitoredList();\n    }\n\n\n    //Permission monitoring part below\n\n    /**\n     * Get list of currently granted permissions, without saving it inside Nammu\n     *\n     * @return currently granted permissions\n     */\n    public static ArrayList<String> getGrantedPermissions() {\n        if (context == null) {\n            throw new RuntimeException("Must call init() earlier");\n        }\n        ArrayList<String> permissions = new ArrayList<String>();\n        ArrayList<String> permissionsGranted = new ArrayList<String>();\n        //Group location\n        permissions.add(Manifest.permission.ACCESS_FINE_LOCATION);\n        permissions.add(Manifest.permission.ACCESS_COARSE_LOCATION);\n        //Group Calendar\n        permissions.add(Manifest.permission.WRITE_CALENDAR);\n        permissions.add(Manifest.permission.READ_CALENDAR);\n        //Group Camera\n        permissions.add(Manifest.permission.CAMERA);\n        //Group Contacts\n        permissions.add(Manifest.permission.WRITE_CONTACTS);\n        permissions.add(Manifest.permission.READ_CONTACTS);\n        permissions.add(Manifest.permission.GET_ACCOUNTS);\n        //Group Microphone\n        permissions.add(Manifest.permission.RECORD_AUDIO);\n        //Group Phone\n        permissions.add(Manifest.permission.CALL_PHONE);\n        permissions.add(Manifest.permission.READ_PHONE_STATE);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n            permissions.add(Manifest.permission.READ_CALL_LOG);\n        }\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n            permissions.add(Manifest.permission.WRITE_CALL_LOG);\n        }\n        permissions.add(Manifest.permission.ADD_VOICEMAIL);\n        permissions.add(Manifest.permission.USE_SIP);\n        permissions.add(Manifest.permission.PROCESS_OUTGOING_CALLS);\n        //Group Body sensors\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH) {\n            permissions.add(Manifest.permission.BODY_SENSORS);\n        }\n        //Group SMS\n        permissions.add(Manifest.permission.SEND_SMS);\n        permissions.add(Manifest.permission.READ_SMS);\n        permissions.add(Manifest.permission.RECEIVE_SMS);\n        permissions.add(Manifest.permission.RECEIVE_WAP_PUSH);\n        permissions.add(Manifest.permission.RECEIVE_MMS);\n        //Group Storage\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n            permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);\n        }\n        permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);\n        for (String permission : permissions) {\n            if (context.checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED) {\n                permissionsGranted.add(permission);\n            }\n        }\n        return permissionsGranted;\n    }\n\n    /**\n     * Refresh currently granted permission list, and save it for later comparing using @permissionCompare()\n     */\n    public static void refreshMonitoredList() {\n        ArrayList<String> permissions = getGrantedPermissions();\n        Set<String> set = new HashSet<String>();\n        for (String perm : permissions) {\n            set.add(perm);\n        }\n        sharedPreferences.edit().putStringSet(KEY_PREV_PERMISSIONS, set).apply();\n    }\n\n    /**\n     * Get list of previous Permissions, from last refreshMonitoredList() call and they may be outdated,\n     * use getGrantedPermissions() to get current\n     */\n    public static ArrayList<String> getPreviousPermissions() {\n        ArrayList<String> prevPermissions = new ArrayList<String>();\n        prevPermissions.addAll(sharedPreferences.getStringSet(KEY_PREV_PERMISSIONS, new HashSet<String>()));\n        return prevPermissions;\n    }\n\n    public static ArrayList<String> getIgnoredPermissions() {\n        ArrayList<String> ignoredPermissions = new ArrayList<String>();\n        ignoredPermissions.addAll(sharedPreferences.getStringSet(KEY_IGNORED_PERMISSIONS, new HashSet<String>()));\n        return ignoredPermissions;\n    }\n\n    /**\n     * Lets see if we already ignore this permission\n     */\n    public static boolean isIgnoredPermission(String permission) {\n        if (permission == null) {\n            return false;\n        }\n        return getIgnoredPermissions().contains(permission);\n    }\n\n    /**\n     * Use to ignore to particular Permission - even if user will deny or add it we won\'t receive a callback.\n     *\n     * @param permission Permission to ignore\n     */\n    public static void ignorePermission(String permission) {\n        if (!isIgnoredPermission(permission)) {\n            ArrayList<String> ignoredPermissions = getIgnoredPermissions();\n            ignoredPermissions.add(permission);\n            Set<String> set = new HashSet<String>();\n            set.addAll(ignoredPermissions);\n            sharedPreferences.edit().putStringSet(KEY_IGNORED_PERMISSIONS, set).apply();\n        }\n    }\n\n    /**\n     * Used to trigger comparing process - @permissionListener will be called each time Permission was revoked, or added (but only once).\n     *\n     * @param permissionListener Callback that handles all permission changes\n     */\n    public static void permissionCompare(PermissionListener permissionListener) {\n        if (context == null) {\n            throw new RuntimeException("Before comparing permissions you need to call Nammu.init(context)");\n\n        }\n        ArrayList<String> previouslyGranted = getPreviousPermissions();\n        ArrayList<String> currentPermissions = getGrantedPermissions();\n        ArrayList<String> ignoredPermissions = getIgnoredPermissions();\n        for (String permission : ignoredPermissions) {\n            if (previouslyGranted != null && !previouslyGranted.isEmpty()) {\n                if (previouslyGranted.contains(permission)) {\n                    previouslyGranted.remove(permission);\n                }\n            }\n\n            if (currentPermissions != null && !currentPermissions.isEmpty()) {\n                if (currentPermissions.contains(permission)) {\n                    currentPermissions.remove(permission);\n                }\n            }\n        }\n        for (String permission : currentPermissions) {\n            if (previouslyGranted.contains(permission)) {\n                //All is fine, was granted and still is\n                previouslyGranted.remove(permission);\n            } else {\n                //We didn\'t have it last time\n                if (permissionListener != null) {\n                    permissionListener.permissionsChanged(permission);\n                    permissionListener.permissionsGranted(permission);\n                }\n            }\n        }\n        if (previouslyGranted != null && !previouslyGranted.isEmpty()) {\n            //Something was granted and removed\n            for (String permission : previouslyGranted) {\n                if (permissionListener != null) {\n                    permissionListener.permissionsChanged(permission);\n                    permissionListener.permissionsRemoved(permission);\n                }\n            }\n        }\n        refreshMonitoredList();\n    }\n\n    /**\n     * Not that needed method but if we override others it is good to keep same.\n     */\n    public static boolean checkPermission(String permissionName) {\n        if (context == null) {\n            throw new RuntimeException("Before comparing permissions you need to call Nammu.init(context)");\n        }\n        return PackageManager.PERMISSION_GRANTED == context.checkSelfPermission(permissionName);\n    }\n}'