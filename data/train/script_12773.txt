b'module Hoodle.Type.Undo where\n\nimport Data.Hoodle.Zipper\n  ( SeqZipper,\n    appendDropSecond,\n    chopFirst,\n    current,\n    moveLeft,\n    moveRight,\n    singletonSZ,\n  )\n\ndata UndoTable a = UndoTable\n  { undo_allowednum :: Int,\n    undo_totalnum :: Int,\n    undo_zipper :: Maybe (SeqZipper a)\n  }\n\nemptyUndo :: Int -> UndoTable a\nemptyUndo n\n  | n > 0 = UndoTable n 0 Nothing\n  | otherwise = error "undo table must be larger than 0"\n\nsingletonUndo :: Int -> a -> UndoTable a\nsingletonUndo n = addToUndo (emptyUndo n)\n\naddToUndo :: UndoTable a -> a -> UndoTable a\naddToUndo utable e =\n  let tn = undo_totalnum utable\n      an = undo_allowednum utable\n      mzs = undo_zipper utable\n   in case mzs of\n        Nothing -> UndoTable an 1 . Just . singletonSZ $ e\n        Just zs ->\n          if tn < an\n            then -- FIXME: this causes undo_totalnum to be an overestimate and can\n            --        cause the oldest undo item to be dropped unnecessarily.\n              UndoTable an (length zs\') . Just $ zs\'\n            else UndoTable an (length zs\') . chopFirst $ zs\'\n          where\n            zs\' = appendDropSecond zs e\n\ngetCurrentUndoItem :: UndoTable a -> Maybe a\ngetCurrentUndoItem = fmap current . undo_zipper\n\ngetPrevUndo :: UndoTable a -> Maybe (a, UndoTable a)\ngetPrevUndo t = do\n  newzs <- moveLeft =<< undo_zipper t\n  return (current newzs, t {undo_zipper = Just newzs})\n\ngetNextUndo :: UndoTable a -> Maybe (a, UndoTable a)\ngetNextUndo t = do\n  newzs <- moveRight =<< undo_zipper t\n  return (current newzs, t {undo_zipper = Just newzs})\n\nnumOfUndo :: UndoTable a -> Int\nnumOfUndo = undo_totalnum\n'