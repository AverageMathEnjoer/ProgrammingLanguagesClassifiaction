b'{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Graphics.Hoodle.Render.Primitive\n  ( drawStrokeCurve,\n    drawVWStrokeCurve,\n  )\nwhere\n\nimport Control.Monad (foldM_)\nimport Data.Strict.Tuple (Pair ((:!:)))\nimport qualified Graphics.Rendering.Cairo as Cairo\n\n------------------\n-- draw utility --\n------------------\n\n-- |\ndrawStrokeCurve :: [Pair Double Double] -> Cairo.Render ()\ndrawStrokeCurve ((x0 :!: y0) : xs) = do\n  x0 `seq` y0 `seq` Cairo.moveTo x0 y0\n  mapM_ f xs\n  where\n    f (x :!: y) = x `seq` y `seq` Cairo.lineTo x y\ndrawStrokeCurve [] = return ()\n\n-- |\ndrawVWStrokeCurve :: [(Double, Double, Double)] -> Cairo.Render ()\ndrawVWStrokeCurve [] = return ()\ndrawVWStrokeCurve [_] = return ()\ndrawVWStrokeCurve ((xo, yo, _zo) : xs) = do\n  Cairo.moveTo xo yo\n  let ((xlast, ylast, _zlast) : rxs) = reverse xs\n  foldM_ forward (xo, yo) xs\n  foldM_ forward (xlast, ylast) rxs\n  where\n    turn (x, y) = (negate y, x)\n    norm (x, y) = sqrt (x * x + y * y)\n    (x1, y1) .-. (x0, y0) = (x1 - x0, y1 - y0)\n    (x1, y1) .+. (x0, y0) = (x1 + x0, y1 + y0)\n    z *. (x0, y0) = (z * x0, z * y0)\n    zFactor = 0.5 -- to be tuned\n    forward p0 (x, y, z) = do\n      let p1 = (x, y)\n          dp = p1 .-. p0\n          dist = norm dp\n      if dist < 0.01 -- otherwise normalisation can diverge\n        then return p0\n        else do\n          -- shift the current position perpendicularly to the\n          -- direction of movement, by an amount proportional to\n          -- the pressure (z).\n          let shift = turn $ ((1 / dist) * z * zFactor) *. dp\n          Prelude.uncurry Cairo.lineTo $ shift .+. p1\n          return p1\n'