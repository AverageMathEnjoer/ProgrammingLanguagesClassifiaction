b'{-# LANGUAGE RankNTypes, NamedFieldPuns, BangPatterns,\n             ExistentialQuantification, CPP, ScopedTypeVariables,\n             TypeSynonymInstances, MultiParamTypeClasses,\n             GeneralizedNewtypeDeriving, RecordWildCards #-}\n{-# OPTIONS_GHC -Wall -fno-warn-name-shadowing -fno-warn-unused-do-bind #-}\n\n{- |\n\n  A monad-par tranfsormer which avoids continuation passing style by\n  using actual IO threads to capture continuations (but only to\n  capture continuations on blocking gets).\n\n  Note that this version makes spawn cheaper at the expense of get.\n  This is largely a strawman for comparison with other schedulers.\n\n  This implementation is similar to @Direct.hs@ without \'ContT\'.\n  Ideally, common pieces of the two would be factored out.\n\n -}\n\n\nmodule Control.Monad.Par.Scheds.ContFree (\n   Sched(..), Par, IVar(..),\n    runPar,\n    new, get, put_, fork,\n    newFull, newFull_, put,\n    spawn, spawn_, spawn1_, spawnP\n ) where\n\n\nimport Control.Applicative\nimport Control.Concurrent hiding (yield)\nimport Control.Monad.Cont as C\nimport qualified Control.Monad.Reader as R\nimport qualified Control.Monad.Par.Class as PC\nimport Control.DeepSeq\nimport Data.IORef\nimport qualified Data.Set as Set\nimport Debug.Trace\nimport GHC.IO (unsafePerformIO, unsafeDupablePerformIO)\nimport GHC.Conc\nimport System.Random.MWC as Random\nimport System.Mem.StableName\nimport Text.Printf\n\n\n-- #define DEBUG\n#ifdef DEBUG\ndbg = True\n#else\ndbg = False\n#endif\n-- define FORKPARENT\n-- define WAKEIDLE\n\n--------------------------------------------------------------------------------\n-- Core type definitions\n--------------------------------------------------------------------------------\n\n-- Our monad stack looks like this:\n--      ---------\n--       ReaderT\n--         IO\n--      ---------\n-- The ReaderT monad is there for retrieving the scheduler given the\n-- fact that the API calls do not get it as an argument.\n--\nnewtype Par a = Par { unPar :: R.ReaderT Sched IO a }\n    deriving (Monad, MonadIO, R.MonadReader Sched)\n\ndata Sched = Sched\n    {\n      ---- Per worker ----\n      no       :: {-# UNPACK #-} !Int,\n      workpool :: HotVar (Deque (Par ())),\n      rng      :: HotVar GenIO, -- Random number gen for work stealing.\n      -- Mortal set: currently distinct set per processor:\n      mortal   :: HotVar (Set.Set Int), -- Could possibly use a vector....\n\n      ---- Global data: ----\n      killflag :: HotVar Bool,\n      idle     :: HotVar [MVar Bool],\n      scheds   :: [Sched] -- A global list of schedulers.\n     }\n\nnewtype IVar a = IVar (IORef (IVarContents a))\n\ndata IVarContents a = Full a | Empty | Blocked (MVar a)\n  -- | Future a\n\n\n--------------------------------------------------------------------------------\n-- Helpers #1:  Simple Deques\n--------------------------------------------------------------------------------\n\n-- atomicModifyIORef :: IORef a -> (a -> (a,b)) -> IO b\n-- atomicModifyIORef (IORef (STRef r#)) f = IO $ \\s -> atomicModifyMutVar# r# f s\n\ncasIORef = undefined\n\nemptydeque :: Deque a\naddfront  :: a -> Deque a -> Deque a\naddback   :: a -> Deque a -> Deque a\n\n-- takefront :: Deque a -> Maybe (Deque a, a)\ntakefront :: Deque a -> (Deque a, Maybe a)\ntakeback  :: Deque a -> (Deque a, Maybe a)\n\ndqlen :: Deque a -> Int\n\n-- [2011.03.21] Presently lists are out-performing Seqs:\n#if 1\nnewtype Deque a = DQ [a]\nemptydeque = DQ []\n\naddfront x (DQ l)    = -- trace (" * addfront brought queue up to: " ++ show (length (x:l))) $\n\t\t       DQ (x:l)\naddback x (DQ [])    = DQ [x]\naddback x (DQ (h:t)) = DQ (h : rest)\n where DQ rest = addback x (DQ t)\n\ntakefront (DQ [])     = (emptydeque, Nothing)\ntakefront (DQ (x:xs)) = -- trace (" * takefront popped one, remaining: " ++ show (length xs)) $\n\t\t\t(DQ xs, Just x)\ntakeback  (DQ [])     = (emptydeque, Nothing)\ntakeback  (DQ ls)     = -- trace (" * takeback popped one, remaining: " ++ show (length rest)) $\n\t\t\t(DQ rest, Just final)\n where\n  (final,rest) = loop ls []\n  loop [x]    acc = (x, reverse acc)\n  loop (h:tl) acc = loop tl (h:acc)\n  loop []     _   = error "this shouldn\'t happen"\n\ndqlen (DQ l) = length l\n#endif\n\n--------------------------------------------------------------------------------\n-- Helpers #2:  Atomic Variables\n--------------------------------------------------------------------------------\n-- TEMP: Experimental\n\n#ifndef HOTVAR\n#define HOTVAR 1\n#endif\nnewHotVar      :: a -> IO (HotVar a)\nmodifyHotVar   :: HotVar a -> (a -> (a,b)) -> IO b\nmodifyHotVar_  :: HotVar a -> (a -> a) -> IO ()\nwriteHotVar    :: HotVar a -> a -> IO ()\nreadHotVar     :: HotVar a -> IO a\n-- readHotVarRaw  :: HotVar a -> m a\n-- writeHotVarRaw :: HotVar a -> m a\n\n{-# INLINE newHotVar     #-}\n{-# INLINE modifyHotVar  #-}\n{-# INLINE modifyHotVar_ #-}\n{-# INLINE readHotVar    #-}\n{-# INLINE writeHotVar   #-}\n\n#if HOTVAR == 1\ntype HotVar a = IORef a\nnewHotVar     = newIORef\nmodifyHotVar  = atomicModifyIORef\nmodifyHotVar_ v fn = atomicModifyIORef v (\\a -> (fn a, ()))\nreadHotVar    = readIORef\nwriteHotVar   = writeIORef\ninstance Show (IORef a) where\n  show ref = "<ioref>"\n\n-- hotVarTransaction = id\nhotVarTransaction = error "Transactions not currently possible for IO refs"\nreadHotVarRaw  = readHotVar\nwriteHotVarRaw = writeHotVar\n\n\n#elif HOTVAR == 2\n#warning "Using MVars for hot atomic variables."\n-- This uses MVars that are always full with *something*\ntype HotVar a = MVar a\nnewHotVar   x = do v <- newMVar; putMVar v x; return v\nmodifyHotVar  v fn = modifyMVar  v (return . fn)\nmodifyHotVar_ v fn = modifyMVar_ v (return . fn)\nreadHotVar    = readMVar\nwriteHotVar v x = do swapMVar v x; return ()\ninstance Show (MVar a) where\n  show ref = "<mvar>"\n\n-- hotVarTransaction = id\n-- We could in theory do this by taking the mvar to grab the lock.\n-- But we\'d need some temporary storage....\nhotVarTransaction = error "Transactions not currently possible for MVars"\nreadHotVarRaw  = readHotVar\nwriteHotVarRaw = writeHotVar\n\n\n#elif HOTVAR == 3\n#warning "Using TVars for hot atomic variables."\n-- Simon Marlow said he saw better scaling with TVars (surprise to me):\ntype HotVar a = TVar a\nnewHotVar = newTVarIO\nmodifyHotVar  tv fn = atomically (do x <- readTVar tv\n\t\t\t\t     let (x2,b) = fn x\n\t\t\t\t     writeTVar tv x2\n\t\t\t\t     return b)\nmodifyHotVar_ tv fn = atomically (do x <- readTVar tv; writeTVar tv (fn x))\nreadHotVar x = atomically $ readTVar x\nwriteHotVar v x = atomically $ writeTVar v x\ninstance Show (TVar a) where\n  show ref = "<tvar>"\n\nhotVarTransaction = atomically\nreadHotVarRaw  = readTVar\nwriteHotVarRaw = writeTVar\n\n#endif\n\n-----------------------------------------------------------------------------\n-- Helpers #3:  Pushing and popping work.\n-----------------------------------------------------------------------------\n\n{-# INLINE popWork  #-}\npopWork :: Sched -> IO (Maybe (Par ()))\npopWork Sched{ workpool } =\n  modifyHotVar  workpool  takefront\n\n{-# INLINE pushWork #-}\npushWork :: Sched -> Par () -> IO ()\npushWork Sched { workpool, idle } task = do\n  modifyHotVar_ workpool (addfront task)\n#ifdef WAKEIDLE\n  -- If any worker is idle, wake one up and give it work to do.\n  idles <- readHotVar idle\n  when (not (null idles)) $ do\n    when dbg$ printf "Waking %d idle thread(s).\\n" (length idles)\n    r <- modifyHotVar idle (\\is -> case is of\n                             [] -> ([], return ())\n                             (i:is) -> (is, putMVar i False))\n    r -- wake one up\n#endif\n\nrand :: HotVar GenIO -> IO Int\nrand ref = uniformR (0, numCapabilities-1) =<< readHotVar ref\n\n\n--------------------------------------------------------------------------------\n-- Running computations in the Par monad\n--------------------------------------------------------------------------------\n\ninstance NFData (IVar a) where\n   rnf !_ = ()\n\nrunPar userComp = unsafePerformIO $ do\n   allscheds <- makeScheds\n\n#if __GLASGOW_HASKELL__ >= 701 /* 20110301 */\n    --\n    -- We create a thread on each CPU with forkOnIO.  The CPU on which\n    -- the current thread is running will host the main thread; the\n    -- other CPUs will host worker threads.\n    --\n    -- Note: GHC 7.1.20110301 is required for this to work, because that\n    -- is when threadCapability was added.\n    --\n   (main_cpu, _) <- threadCapability =<< myThreadId\n#else\n    --\n    -- Lacking threadCapability, we always pick CPU #0 to run the main\n    -- thread.  If the current thread is not running on CPU #0, this\n    -- will require some data to be shipped over the memory bus, and\n    -- hence will be slightly slower than the version above.\n    --\n   let main_cpu = 0\n#endif\n\n   mv <- newEmptyMVar\n   sn <- makeStableName mv\n\n   forM_ (zip [0..] allscheds) $ \\(cpu,sched) ->\n        forkOnIO cpu $\n          if (cpu /= main_cpu)\n             then do when dbg$ printf "CPU %d entering scheduling loop.\\n" cpu\n\t\t     R.runReaderT enterScheduler sched\n\t\t     when dbg$ printf "    CPU %d exited scheduling loop.  FINISHED.\\n" cpu\n             else do\n                  rref <- newIORef Empty\n\t\t  let userComp\'  = do when dbg$ liftIO$ printf "Starting Par computation on main thread (%d).\\n" main_cpu\n\t\t\t\t      res <- userComp\n                                      finalSched <- R.ask\n\t\t\t\t      when dbg$ liftIO$ printf "Out of Par computation on thread (%d).\\n" (no finalSched)\n#ifdef DEBUG\n\t\t\t\t      liftIO$ putStrLn$ "Result was " ++ (show res)\n#endif\n                                      -- If we are not purely continuation-stealing that means we may\n\t\t\t\t      -- get to this point and have work left in our queue.  We need to reschedule.\n                                      dq <- liftIO$ readHotVar (workpool finalSched)\n                                      when (dqlen dq > 0) $ do\n                                         when dbg$ liftIO$ putStrLn "Main thread still has work in queue... rescheduling."\n\t\t\t\t\t Par enterScheduler\n\n                                      when dbg$ liftIO$ putStrLn "MAIN THREAD ABOUT TO FORCE THE FINAL RESULT."\n                                      -- After that we know that this worker has done all its work.\n\t\t\t\t      -- However, if there\'s anyone else unfinished we may still\n\t\t\t\t      -- block on "res" in the following put, which is fine.\n\t\t\t\t      put_ (IVar rref) res\n\n\t\t  R.runReaderT (unPar userComp\') sched\n\n                  when dbg$ printf " *** Completely out of users computation.  Writing final value to MVar %d\\n" (hashStableName sn)\n                  readIORef rref >>= putMVar mv\n\n   when dbg$ do\n      printf " *** Main thread about to take final result from MVar %d\\n" (hashStableName sn)\n   r <- takeMVar mv\n   case r of\n     Full a -> return a\n     Blocked cs -> error "Work still blocked at end of Par computation. Something went wrong."\n     _ -> error "No result from Par computation.  Something went wrong."\n\n\n-- Create the default scheduler(s) state:\nmakeScheds = do\n   workpools <- replicateM numCapabilities $ newHotVar emptydeque\n   rngs      <- replicateM numCapabilities $ Random.create >>= newHotVar\n   idle <- newHotVar []\n   killflag <- newHotVar False\n   mortals  <- mapM newHotVar (replicate numCapabilities Set.empty)\n   let states = [ Sched { no=x, idle, killflag,\n\t\t\t  workpool=wp, scheds=states, rng=rng,\n\t\t\t  mortal\n\t\t\t}\n                | ((x,wp),(rng,mortal)) <- zip (zip [0..] workpools)\n\t\t                               (zip rngs mortals)]\n   return states\n\n\nregulatePopulation Sched{..} =\n  do\n     return ()\n\nreplaceWorker :: Sched -> IO ThreadId\nreplaceWorker sch@Sched{no} = do\n  -- EXPERIMENTAL: Because our deques are threadsafe on both ends we\n  -- can try just reusing the same Sched structure.\n  --   We use forkOnIO to stay on the same processor as the thread we\n  -- are replacing.  Therefore we expect no contention from our Sched\n  -- reuse because the reusing thread is on the same physical core.\n  --\n  -- We do need to change the identifying \'no\' though and thereforewe\n  -- copy the Sched structure.  (We advance our \'no\' by\n  -- numCapabilities to avoid collision.)\n  --\n  -- TODO: Compare this partial reuse of the Sched structure to just\n  -- allocating a completely fresh one.\n  --\n  when dbg $ liftIO$ printf " [%d] Replacing with worker %d\\n" no (no+numCapabilities)\n  forkOnIO no (R.runReaderT enterScheduler sch{no= no + numCapabilities})\n\n-- Register the current thread as being already replaced.\nmakeMortal sch@Sched{no, mortal} =\n  modifyHotVar_ mortal (Set.insert no)\n\n\n--------------------------------------------------------------------------------\n-- IVar operations\n--------------------------------------------------------------------------------\n\n{-# INLINE new  #-}\n-- | Creates a new @IVar@\nnew :: Par (IVar a)\nnew  = liftIO $ do r <- newIORef Empty\n                   return (IVar r)\n\n-- This makes debugging somewhat easier:\nspinReadMVar :: Sched -> MVar b -> IO b\nspinReadMVar Sched{..} mv = do\n  sn <- makeStableName mv\n  let loop = do v <- tryTakeMVar mv\n\t\tcase v of\n\t\t  Nothing -> do printf "                 [%d] thread spinning to try to read MVar %d\\n" no (hashStableName sn)\n\t\t\t\tthreadDelay (100 * 1000) -- 1/10 a second\n\t\t\t\tloop\n\t\t  Just x -> do printf "[%d] SUCCESSFULLY read MVar %d\\n" no (hashStableName sn)\n\t\t\t       putMVar mv x\n\t\t\t       return x\n  loop\n\n\n{-# INLINE get  #-}\n-- | Read the value in an @IVar@.  The \'get\' operation can only return when the\n-- value has been written by a prior or parallel @put@ to the same\n-- @IVar@.\nget (IVar v) = do\n       -- Optimistically read without writing, maybe the value is already there:\n       e  <- liftIO$ readIORef v\n       case e of\n\t  Full a   -> return a\n--\t  Future a -> return a\n          -- Otherwise we need to do a write:\n\t  _ -> do\n            sch <- R.ask\n            mv <- liftIO$ newEmptyMVar\n\t    sn <- liftIO$ makeStableName mv\n            let rd mv x =\n                   let\n#ifdef DEBUG\n\t\t       act = spinReadMVar sch mv\n#else\n\t\t       act = readMVar mv\n#endif\n\t\t       act\' = -- do regulatePopulation sch; act\n\t\t              do makeMortal sch; replaceWorker sch; act\n\t\t       val = unsafePerformIO act\' -- dupable?\n\t\t   in (x, val)\n\n            when dbg$ liftIO$ printf "  It looks like we may go down to block MVar %d for a get.  Thread %d\\n" (hashStableName sn) (no sch)\n\n\t    -- The thread modifying the IO ref will block until the MVar is filled in:\n\t    val <- liftIO$ atomicModifyIORef v $ \\e ->\n\t     case e of\n\t       Empty         -> rd mv (Blocked mv)\n\t       x@(Full a)    -> (x, a) -- This happened 1114 times on fib(24)\n\t       x@(Blocked mv) -> rd mv x\n            -- Make sure that we have the actual value (not just a thunk) before proceding:\n#ifdef DEBUG\n            trace (" !! performing unsafeIO read of MVar "++ show (hashStableName sn) ++"... thread "++ show (no sch)) $\n             val `pseq`\n              trace (" !! COMPLETED read of MVar "++ show (hashStableName sn) ++" on thread "++ show (no sch) ++ " value " ++ show val) $\n              (return val)\n#else\n            val `pseq` return val\n#endif\n\n\n\n{-# INLINE put_ #-}\n-- | @put_@ is a version of @put@ that is head-strict rather than fully-strict.\nput_ (IVar v) !content = do\n   sched <- R.ask -- Have to do this here because the modify fn is pure:\n#ifdef DEBUG\n   sn <- liftIO$ makeStableName v\n   when dbg$ liftIO$ printf "    !! [%d] PUTTING value %s to ivar %d\\n" (no sched) (show content) (hashStableName sn)\n#endif\n   liftIO$ do\n      mmv <- atomicModifyIORef v $ \\e -> case e of\n               Empty      -> (Full content, Nothing)\n               Blocked mv -> (Full content, Just mv)\n               Full _     -> error "multiple put"\n      case mmv of\n        Just mv -> do\n\t\t      when dbg$ do sn <- makeStableName mv\n\t\t\t\t   printf "    !! [thread %d] Putting MVar %d, unblocking thread(s).\\n"  (hashStableName sn) (no sched)\n\t\t      putMVar mv content\n        Nothing -> return ()\n\n{-# INLINE fork #-}\nfork :: Par () -> Par ()\nfork task = do\n   sch <- R.ask\n   liftIO$ when dbg$ printf "  *** forking task from cpu %d...\\n" (no sch)\n   liftIO$ pushWork sch task\n\n-- enterScheduler is the main entrypoint for the scheduler.\nenterScheduler :: R.ReaderT Sched IO ()\nenterScheduler = do\n  mysched <- R.ask\n  when dbg$ liftIO$ printf " - Reschedule: CPU %d\\n" (no mysched)\n  mtask <- liftIO$ popWork mysched\n  case mtask of\n    Nothing -> liftIO (steal mysched)\n    Just task -> do\n       -- When popping work from our own queue the Sched (Reader value) stays the same:\n       when dbg $ liftIO$ printf "  popped work from own queue (cpu %d)\\n" (no mysched)\n       -- Run the stolen tasK:\n       unPar task\n       when dbg$ do sch <- R.ask; liftIO$ printf "  + task finished successfully on cpu %d\\n" (no sch)\n       -- Before going around again, we check if we have become "mortal":\n       mortset <- liftIO$ readHotVar (mortal mysched)\n       if Set.member (no mysched) mortset then\n          when dbg$ liftIO$ printf " [%d] Thread is mortal, shutting down.\\n" (no mysched)\n        else enterScheduler\n\n-- | Attempt to steal work or, failing that, give up and go idle.\nsteal :: Sched -> IO ()\nsteal mysched@Sched{ idle, scheds, rng, no=my_no } = do\n  when dbg$ printf "cpu %d stealing\\n" my_no\n  i <- rand rng  -- Pick an initial victim.\n  go maxtries i\n where\n#ifdef WAKEIDLE\n    maxtries = numCapabilities -- How many times should we attempt theft before going idle?\n#else\n    maxtries = 20 * numCapabilities -- More if they don\'t wake up after.\n#endif\n\n    ----------------------------------------\n    -- IDLING behavior:\n    go 0 _ =\n            do mv <- newEmptyMVar\n               when dbg$ printf "cpu %d Tired of stealing... giving up.\\n" my_no\n               r <- modifyHotVar idle $ \\is -> (mv:is, is)\n               if length r == numCapabilities - 1\n                  then do\n                     -- If we were the LAST one to go idle:\n                     when dbg$ printf "cpu %d initiating shutdown\\n" my_no\n                     mapM_ (\\m -> putMVar m True) r\n                  else do\n                    when dbg$ printf "cpu %d taking mvar to go idle...\\n" my_no\n                    done <- takeMVar mv\n                    if done\n                       then do\n                         when dbg$ printf "cpu %d shutting down\\n" my_no\n                         return ()\n                       else do\n                         when dbg$ printf "cpu %d woken up\\n" my_no\n\t\t\t i <- rand rng\n                         go maxtries i\n\n    ----------------------------------------\n    go tries i\n      | i == my_no = do i\' <- rand rng\n\t\t\tgo (tries-1) i\'\n\n      | otherwise     = do\n         let schd = scheds!!i -- TEMP, FIXME, linear access of a list.\n         when dbg$ printf "cpu %d trying steal from %d\\n" my_no (no schd)\n\n         r <- modifyHotVar (workpool schd) takeback\n         case r of\n           Just task  -> do\n              when dbg$ printf "cpu %d got work from cpu %d\\n" my_no (no schd)\n\t      R.runReaderT (unPar task) mysched\n           Nothing -> do i\' <- rand rng\n\t\t\t go (tries-1) i\'\n\n{-# INLINE spawn1_ #-}\n-- Spawn a one argument function instead of a thunk.  This is good for debugging if the value supports "Show".\nspawn1_ f x =\n#ifdef DEBUG\n do sch <- R.ask; when dbg$ liftIO$ printf " [%d] spawning fn with arg %s\\n" (no sch) (show x)\n#endif\n    spawn_ (f x)\n\n\n----------------------------------------------------------------------------------------------------\n-- TEMPORARY -- SCRAP:\n\n-- The following is usually inefficient!\nnewFull_ a = do v <- new\n\t\tput_ v a\n\t\treturn v\n\nnewFull :: NFData a => a -> Par (IVar a)\nnewFull a = deepseq a (newFull a)\n\n{-# INLINE put #-}\nput v a = deepseq a (put_ v a)\n\n-- Here we use the same mechanism an in Spark.hs:\nspawnP :: NFData a => a -> Par (IVar a)\nspawnP a = do ref <- liftIO$ newIORef (Full (rnf a `pseq` a))\n\t      a `par` return (IVar ref)\n\n\n\n--------------------------------------------------------------------------------\n-- MonadPar instance for IO; TEMPORARY\n--------------------------------------------------------------------------------\n\n-- <boilerplate>\nspawn p  = do r <- new;  fork (p >>= put r);   return r\nspawn_ p = do r <- new;  fork (p >>= put_ r);  return r\n-- </boilerplate>\n\n#ifdef DEBUG\nput    :: (Show a, NFData a) => IVar a -> a -> Par ()\nspawn  :: (Show a, NFData a) => Par a -> Par (IVar a)\nspawn_ :: Show a => Par a -> Par (IVar a)\nput_   :: Show a => IVar a -> a -> Par ()\nget    :: Show a => IVar a -> Par a\nrunPar :: Show a => Par a -> a\nnewFull_ ::  Show a => a -> Par (IVar a)\n#else\nspawn  :: NFData a => Par a -> Par (IVar a)\nspawn_ :: Par a -> Par (IVar a)\nput_   :: IVar a -> a -> Par ()\nput    :: NFData a => IVar a -> a -> Par ()\nget    :: IVar a -> Par a\nrunPar :: Par a -> a\nnewFull_ ::  a -> Par (IVar a)\n\ninstance PC.ParFuture IVar Par where\n  get    = get\n  spawn  = spawn\n  spawn_ = spawn_\n  spawnP = spawnP\n\ninstance PC.ParIVar IVar Par where\n  fork = fork\n  new  = new\n  put_ = put_\n  newFull = newFull\n  newFull_ = newFull_\n#endif\n\ninstance Functor Par where\n   fmap f xs = xs >>= return . f\n\ninstance Applicative Par where\n   (<*>) = ap\n   pure  = return\n'