b'\xef\xbb\xbf//  Copyright 2019 Google Inc. All Rights Reserved.\n//\n//  Licensed under the Apache License, Version 2.0 (the "License");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an "AS IS" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\n\nusing Rubeus.Utilities.Text;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace Rubeus.Ndr.Marshal\n{\n#pragma warning disable 1591\n    /// <summary>\n    /// A buffer to unmarshal NDR data from.\n    /// </summary>\n    /// <remarks>This class is primarily for internal use only.</remarks>\n    public class NdrUnmarshalBuffer : IDisposable\n    {\n        #region Private Members\n\n        private readonly MemoryStream _stm;\n        private readonly BinaryReader _reader;\n        private NdrDeferralStack _deferred_reads;\n        private int[] _conformance_values;\n        private Dictionary<int, object> _full_pointers;\n\n        private string[] ReadStringArray(int[] refs, Func<string> reader)\n        {\n            string[] ret = new string[refs.Length];\n            for (int i = 0; i < refs.Length; ++i)\n            {\n                if (refs[i] == 0)\n                {\n                    ret[i] = string.Empty;\n                }\n                else\n                {\n                    int pos = i;\n                    _deferred_reads.Add(() => ret[pos] = reader());\n                }\n            }\n            return ret;\n        }\n\n        private bool SetupConformance(int dimensions)\n        {\n            if (_conformance_values == null)\n            {\n                _conformance_values = new int[dimensions];\n                for (int i = 0; i < dimensions; ++i)\n                {\n                    _conformance_values[i] = ReadInt32();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private int[] ReadConformance(int dimensions)\n        {\n            int[] ret;\n            if (_conformance_values != null)\n            {\n                System.Diagnostics.Debug.Assert(_conformance_values.Length == dimensions);\n                ret = _conformance_values;\n                _conformance_values = null;\n            }\n            else\n            {\n                ret = new int[dimensions];\n                for (int i = 0; i < dimensions; ++i)\n                {\n                    ret[i] = ReadInt32();\n                }\n            }\n            return ret;\n        }\n\n        private T ReadFullPointer<T>(int referent, Func<T> unmarshal_func)\n        {\n            if (!_full_pointers.ContainsKey(referent))\n            {\n                _full_pointers[referent] = unmarshal_func();\n            }\n\n            return (T)_full_pointers[referent];\n        }\n\n        private T ReadStructInternal<T>() where T : new()\n        {\n            INdrStructure s = (INdrStructure)new T();\n            Align(s.GetAlignment());\n            s.Unmarshal(this);\n            return (T)s;\n        }\n\n        private void Align(int alignment)\n        {\n            _stm.Position += NdrNativeUtils.CalculateAlignment((int)_stm.Position, alignment);\n            System.Diagnostics.Debug.WriteLine($"Pos: {_stm.Position} - Align: {alignment}");\n        }\n\n        #endregion\n\n        #region Constructors\n        public NdrUnmarshalBuffer(byte[] buffer, NdrDataRepresentation data_represenation)\n        {\n            _stm = new MemoryStream(buffer);\n            _reader = new BinaryReader(_stm, Encoding.Unicode);\n            _deferred_reads = new NdrDeferralStack();\n            _full_pointers = new Dictionary<int, object>();\n            CheckDataRepresentation(data_represenation);\n        }\n        public NdrUnmarshalBuffer(byte[] buffer) \n            : this(buffer,  new NdrDataRepresentation())\n        {\n        }\n\n \n        public NdrUnmarshalBuffer(NdrPickledType pickled_type) \n            : this(pickled_type.Data, pickled_type.DataRepresentation)\n        {\n        }\n\n        #endregion\n\n        #region Misc Methods\n\n        public NdrContextHandle ReadContextHandle()\n        {\n            int attributes = ReadInt32();\n            Guid uuid = ReadGuid();\n            return new NdrContextHandle(attributes, uuid);\n        }\n\n        public NdrUnsupported ReadUnsupported(string name)\n        {\n            throw new NotImplementedException($"Reading type {name} is unsupported");\n        }\n\n        public NdrEmpty ReadEmpty()\n        {\n            return new NdrEmpty();\n        }\n\n        public NdrInterfacePointer ReadInterfacePointer()\n        {\n            return ReadStruct<NdrInterfacePointer>();\n        }\n\n        public NdrPipe<T> ReadPipe<T>() where T : struct\n        {\n            throw new NotImplementedException("Pipe support is not implemented");\n        }\n\n        internal static void CheckDataRepresentation(NdrDataRepresentation data_represenation)\n        {\n            if (data_represenation.IntegerRepresentation != NdrIntegerRepresentation.LittleEndian ||\n                data_represenation.FloatingPointRepresentation != NdrFloatingPointRepresentation.IEEE ||\n                data_represenation.CharacterRepresentation != NdrCharacterRepresentation.ASCII)\n            {\n                throw new ArgumentException("Unsupported NDR data representation");\n            }\n        }\n\n        #endregion\n\n        #region Primitive Types\n\n        public byte ReadByte()\n        {\n            return _reader.ReadByte();\n        }\n\n        public sbyte ReadSByte()\n        {\n            return _reader.ReadSByte();\n        }\n\n        public short ReadInt16()\n        {\n            Align(2);\n            return _reader.ReadInt16();\n        }\n\n        public ushort ReadUInt16()\n        {\n            Align(2);\n            return _reader.ReadUInt16();\n        }\n\n        public int ReadInt32()\n        {\n            Align(4);\n            return _reader.ReadInt32();\n        }\n\n        public uint ReadUInt32()\n        {\n            Align(4);\n            return _reader.ReadUInt32();\n        }\n\n        public long ReadInt64()\n        {\n            Align(8);\n            return _reader.ReadInt64();\n        }\n\n        public ulong ReadUInt64()\n        {\n            Align(8);\n            return _reader.ReadUInt64();\n        }\n\n        public float ReadFloat()\n        {\n            Align(4);\n            return _reader.ReadSingle();\n        }\n\n        public NdrInt3264 ReadInt3264()\n        {\n            return new NdrInt3264(ReadInt32());\n        }\n\n        public NdrUInt3264 ReadUInt3264()\n        {\n            return new NdrUInt3264(ReadUInt32());\n        }\n\n        public double ReadDouble()\n        {\n            Align(8);\n            return _reader.ReadDouble();\n        }\n\n        public char ReadChar()\n        {\n            Align(2);\n            return _reader.ReadChar();\n        }\n\n        public NdrEnum16 ReadEnum16()\n        {\n            return ReadInt16();\n        }\n\n        #endregion\n\n        #region Fixed Array Types\n\n        public byte[] ReadFixedByteArray(int count)\n        {\n            byte[] ret = _reader.ReadBytes(count);\n            if (ret.Length < count)\n            {\n                throw new EndOfStreamException();\n            }\n            return ret;\n        }\n\n        public char[] ReadFixedCharArray(int count)\n        {\n            char[] chars = _reader.ReadChars(count);\n            if (chars.Length < count)\n            {\n                throw new EndOfStreamException();\n            }\n            return chars;\n        }\n\n        public T[] ReadFixedPrimitiveArray<T>(int actual_count) where T : struct\n        {\n            int size = NdrNativeUtils.GetPrimitiveTypeSize<T>();\n            Align(size);\n            byte[] total_buffer = ReadFixedByteArray(size * actual_count);\n            T[] ret = new T[actual_count];\n            Buffer.BlockCopy(total_buffer, 0, ret, 0, total_buffer.Length);\n            return ret;\n        }\n\n        public T[] ReadFixedArray<T>(Func<T> reader, int actual_count)\n        {\n            T[] ret = new T[actual_count];\n            for (int i = 0; i < actual_count; ++i)\n            {\n                ret[i] = reader();\n            }\n            return ret;\n        }\n\n        public T[] ReadFixedStructArray<T>(int actual_count) where T : INdrStructure, new()\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadFixedArray(ReadStruct<T>, actual_count);\n            }\n        }\n\n        #endregion\n\n        #region Conformant Array Types\n\n        public byte[] ReadConformantByteArray()\n        {\n            int max_count = ReadConformance(1)[0];\n            return ReadFixedByteArray(max_count);\n        }\n\n        public char[] ReadConformantCharArray()\n        {\n            int max_count = ReadConformance(1)[0];\n            return ReadFixedCharArray(max_count);\n        }\n\n        public T[] ReadConformantPrimitiveArray<T>() where T : struct\n        {\n            int max_count = ReadConformance(1)[0];\n            return ReadFixedPrimitiveArray<T>(max_count);\n        }\n\n        public T[] ReadConformantArrayCallback<T>(Func<T> reader)\n        {\n            int max_count = ReadConformance(1)[0];\n            T[] ret = new T[max_count];\n            for (int i = 0; i < max_count; ++i)\n            {\n                ret[i] = reader();\n            }\n            return ret;\n        }\n\n        public T[] ReadConformantStructArray<T>() where T : INdrStructure, new()\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadConformantArrayCallback(() => ReadStructInternal<T>());\n            }\n        }\n\n        public string[] ReadConformantStringArray(Func<string> reader)\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadStringArray(ReadConformantArrayCallback(ReadInt32), reader);\n            }\n        }\n\n        public T[] ReadConformantArray<T>() where T : struct\n        {\n            if (typeof(T) == typeof(byte))\n            {\n                return ReadConformantByteArray().Cast<byte, T>();\n            }\n            else if (typeof(T) == typeof(char))\n            {\n                return ReadConformantCharArray().Cast<char, T>();\n            }\n            else if (typeof(T) == typeof(INdrStructure))\n            {\n                using (var queue = _deferred_reads.Push())\n                {\n                    return ReadConformantArrayCallback(ReadStructInternal<T>);\n                }\n            }\n            else if (typeof(T).IsPrimitive)\n            {\n                return ReadConformantPrimitiveArray<T>();\n            }\n            throw new ArgumentException($"Invalid type {typeof(T)} for {nameof(ReadConformantArray)}");\n        }\n\n        #endregion\n\n        #region Varying Array Types\n\n        public byte[] ReadVaryingByteArray()\n        {\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n            byte[] ret = new byte[offset + actual_count];\n            if (_stm.Read(ret, offset, actual_count) != actual_count)\n            {\n                throw new EndOfStreamException();\n            }\n\n            return ret;\n        }\n\n        public char[] ReadVaryingCharArray()\n        {\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n            if (offset == 0)\n            {\n                return ReadFixedCharArray(actual_count);\n            }\n\n            char[] tmp = ReadFixedCharArray(actual_count);\n            char[] ret = new char[offset + actual_count];\n            Array.Copy(tmp, 0, ret, offset, actual_count);\n            return ret;\n        }\n\n        public T[] ReadVaryingPrimitiveArray<T>() where T : struct\n        {\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n            T[] tmp = ReadFixedPrimitiveArray<T>(actual_count);\n            T[] ret = new T[offset + actual_count];\n            Array.Copy(tmp, 0, ret, offset, actual_count);\n            return ret;\n        }\n\n        public T[] ReadVaryingArrayCallback<T>(Func<T> reader)\n        {\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n            T[] ret = new T[offset + actual_count];\n            for (int i = 0; i < actual_count; ++i)\n            {\n                ret[i + offset] = reader();\n            }\n            return ret;\n        }\n\n        public T[] ReadVaryingStructArray<T>() where T : INdrStructure, new()\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadVaryingArrayCallback(ReadStruct<T>);\n            }\n        }\n\n        public string[] ReadVaryingStringArray(Func<string> reader)\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadStringArray(ReadVaryingArrayCallback(ReadInt32), reader);\n            }\n        }\n\n        public T[] ReadVaryingArray<T>() where T : struct\n        {\n            if (typeof(T) == typeof(byte))\n            {\n                return ReadVaryingByteArray().Cast<byte, T>();\n            }\n            else if (typeof(T) == typeof(char))\n            {\n                return ReadVaryingCharArray().Cast<char, T>();\n            }\n            else if (typeof(T) == typeof(INdrStructure))\n            {\n                using (var queue = _deferred_reads.Push())\n                {\n                    return ReadVaryingArrayCallback(ReadStructInternal<T>);\n                }\n            }\n            else if (typeof(T).IsPrimitive)\n            {\n                return ReadVaryingPrimitiveArray<T>();\n            }\n            throw new ArgumentException($"Invalid type {typeof(T)} for {nameof(ReadVaryingArray)}");\n        }\n\n        #endregion\n\n        #region Conformant Varying Array Types\n\n        public byte[] ReadConformantVaryingByteArray()\n        {\n            int max_count = ReadConformance(1)[0];\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n            byte[] ret = new byte[max_count];\n            if (_stm.Read(ret, offset, actual_count) != actual_count)\n            {\n                throw new EndOfStreamException();\n            }\n\n            return ret;\n        }\n\n        public char[] ReadConformantVaryingCharArray()\n        {\n            int max_count = ReadConformance(1)[0];\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n\n            char[] tmp = ReadFixedCharArray(actual_count);\n\n            if (max_count == actual_count && offset == 0)\n            {\n                return tmp;\n            }\n\n            char[] ret = new char[max_count];\n            Array.Copy(tmp, 0, ret, offset, actual_count);\n            return ret;\n        }\n\n        public T[] ReadConformantVaryingPrimitiveArray<T>() where T : struct\n        {\n            int max_count = ReadConformance(1)[0];\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n\n            T[] tmp = ReadFixedPrimitiveArray<T>(actual_count);\n            if (max_count == actual_count && offset == 0)\n            {\n                return tmp;\n            }\n\n            T[] ret = new T[max_count];\n            Array.Copy(tmp, 0, ret, offset, actual_count);\n            return ret;\n        }\n\n        public T[] ReadConformantVaryingArrayCallback<T>(Func<T> reader)\n        {\n            int max_count = ReadConformance(1)[0];\n            int offset = ReadInt32();\n            int actual_count = ReadInt32();\n            T[] ret = new T[offset + actual_count];\n            for (int i = 0; i < actual_count; ++i)\n            {\n                ret[i + offset] = reader();\n            }\n            return ret;\n        }\n\n        public T[] ReadConformantVaryingStructArray<T>() where T : INdrStructure, new()\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadConformantVaryingArrayCallback(ReadStructInternal<T>);\n            }\n        }\n\n        public string[] ReadConformantVaryingStringArray(Func<string> reader)\n        {\n            using (var queue = _deferred_reads.Push())\n            {\n                return ReadStringArray(ReadConformantVaryingArrayCallback(ReadInt32), reader);\n            }\n        }\n\n        public T[] ReadConformantVaryingArray<T>() where T : struct\n        {\n            if (typeof(T) == typeof(byte))\n            {\n                return ReadConformantVaryingByteArray().Cast<byte, T>();\n            }\n            else if (typeof(T) == typeof(char))\n            {\n                return ReadConformantVaryingCharArray().Cast<char, T>();\n            }\n            else if (typeof(T) == typeof(INdrStructure))\n            {\n                using (var queue = _deferred_reads.Push())\n                {\n                    return ReadConformantVaryingArrayCallback(ReadStructInternal<T>);\n                }\n            }\n            else if (typeof(T).IsPrimitive)\n            {\n                return ReadConformantVaryingPrimitiveArray<T>();\n            }\n            throw new ArgumentException($"Invalid type {typeof(T)} for {nameof(ReadConformantVaryingArray)}");\n        }\n\n        #endregion\n\n        #region String Types\n\n        public string ReadFixedString(int count)\n        {\n            return new string(ReadFixedCharArray(count));\n        }\n\n        public string ReadFixedAnsiString(int count)\n        {\n            return BinaryEncoding.Instance.GetString(ReadFixedByteArray(count));\n        }\n\n        public string ReadConformantVaryingAnsiString()\n        {\n            return BinaryEncoding.Instance.GetString(ReadConformantVaryingByteArray()).TrimEnd(\'\\0\');\n        }\n\n        public string ReadConformantVaryingString()\n        {\n            return new string(ReadConformantVaryingCharArray()).TrimEnd(\'\\0\');\n        }\n\n        public string ReadVaryingString()\n        {\n            return new string(ReadVaryingCharArray()).TrimEnd(\'\\0\');\n        }\n\n        public string ReadVaryingAnsiString()\n        {\n            return BinaryEncoding.Instance.GetString(ReadVaryingByteArray()).TrimEnd(\'\\0\');\n        }\n\n        #endregion\n\n        #region Pointer Types\n\n        public T? ReadReferentValue<T>(Func<T> unmarshal_func, bool full_pointer) where T : struct\n        {\n            int referent = ReadInt32();\n            if (referent == 0)\n            {\n                return null;\n            }\n\n            return full_pointer ? ReadFullPointer(referent, unmarshal_func) : unmarshal_func();\n        }\n\n        public T? ReadReferentValue<T, U>(Func<U, T> unmarshal_func, bool full_pointer, U arg) where T : struct\n        {\n            return ReadReferentValue(() => unmarshal_func(arg), full_pointer);\n        }\n\n        public T? ReadReferentValue<T, U, V>(Func<U, V, T> unmarshal_func, bool full_pointer, U arg1, V arg2) where T : struct\n        {\n            return ReadReferentValue(() => unmarshal_func(arg1, arg2), full_pointer);\n        }\n\n        public T ReadReferent<T>(Func<T> unmarshal_func, bool full_pointer) where T : class\n        {\n            int referent = ReadInt32();\n            if (referent == 0)\n            {\n                return null;\n            }\n            return full_pointer ? ReadFullPointer(referent, unmarshal_func) : unmarshal_func();\n        }\n\n        public T ReadReferent<T, U>(Func<U, T> unmarshal_func, bool full_pointer, U arg) where T : class\n        {\n            return ReadReferent(() => unmarshal_func(arg), full_pointer);\n        }\n\n        public T ReadReferent<T, U, V>(Func<U, V, T> unmarshal_func, bool full_pointer, U arg1, V arg2) where T : class\n        {\n            return ReadReferent(() => unmarshal_func(arg1, arg2), full_pointer);\n        }\n\n        public NdrEmbeddedPointer<T> ReadEmbeddedPointer<T>(Func<T> unmarshal_func, bool full_pointer)\n        {\n            int referent = ReadInt32();\n            if (referent == 0)\n            {\n                return null;\n            }\n\n            if (full_pointer)\n            {\n                unmarshal_func = () => ReadFullPointer(referent, unmarshal_func);\n            }\n\n            var deferred_reader = NdrEmbeddedPointer<T>.CreateDeferredReader(unmarshal_func);\n            _deferred_reads.Add(deferred_reader.Item2);\n            return deferred_reader.Item1;\n        }\n\n        public NdrEmbeddedPointer<T> ReadEmbeddedPointer<T, U>(Func<U, T> unmarshal_func, bool full_pointer, U arg)\n        {\n            return ReadEmbeddedPointer(() => unmarshal_func(arg), full_pointer);\n        }\n\n        public NdrEmbeddedPointer<T> ReadEmbeddedPointer<T, U, V>(Func<U, V, T> unmarshal_func, bool full_pointer, U arg, V arg2)\n        {\n            return ReadEmbeddedPointer(() => unmarshal_func(arg, arg2), full_pointer);\n        }\n\n        #endregion\n\n        #region Structure Types\n\n        public Guid ReadGuid()\n        {\n            Align(4);\n            return new Guid(ReadFixedByteArray(16));\n        }\n\n        public T ReadStruct<T>() where T : INdrStructure, new()\n        {\n            INdrStructure s = (INdrStructure)new T();\n            bool conformant = false;\n            if (s is INdrConformantStructure conformant_struct)\n            {\n                conformant = SetupConformance(conformant_struct.GetConformantDimensions());\n                System.Diagnostics.Debug.Assert(_conformance_values != null);\n            }\n\n            T ret;\n            using (var queue = _deferred_reads.Push())\n            {\n                ret = ReadStructInternal<T>();\n            }\n\n            if (conformant)\n            {\n                System.Diagnostics.Debug.Assert(_conformance_values == null);\n            }\n\n            return ret;\n        }\n\n        #endregion\n\n        #region Dispose Support\n        public virtual void Dispose()\n        {\n         \n        }\n        #endregion\n    }\n#pragma warning restore 1591\n}\n'