b'data Tree = Leaf Int |\n            Fork Tree Tree\n            deriving (Show, Eq)\n\ntree_1 :: Tree\ntree_1 = Fork (Leaf 3) (Leaf 5)\n\ntree_2 :: Tree\ntree_2 = Fork \n            (Fork \n                (Fork (Leaf 8) (Leaf 2))\n                (Leaf 7))\n            (Fork \n                (Leaf 9)\n                (Fork (Leaf 6) \n                    (Fork (Leaf 3) (Leaf 5))))\n\ncost :: Tree -> Int\ncost (Leaf x) = x\ncost (Fork u v) = 1 + max (cost u) (cost v)\n\nfringe :: Tree -> [Int]\nfringe (Leaf x) = [x]\nfringe (Fork u v) = fringe u ++ fringe v\n\nfoldrn :: (a -> b -> b) -> (a -> b) -> [a] -> b \nfoldrn f g [x]      = g x\nfoldrn f g (x:xs)   = f x (foldrn f g xs)\n\ntype Forest = [Tree]\n\ntrees :: [Int] -> [Tree]\ntrees = map rollup . forests\n\nforests :: [Int ] -> [Forest]\nforests = foldrn (concatMap . prefixes) (wrap . wrap . Leaf )\n\nwrap :: a -> [a]\nwrap x = [x]\n\nprefixes :: Int -> Forest -> [Forest ] \nprefixes x ts = [Leaf x : rollup (take k ts) : drop k ts | k <- [1 .. length ts]]\n\nrollup :: Forest -> Tree \nrollup = foldl1 Fork\n\nminBy :: Ord b => (a -> b) -> [a] -> a\nminBy f = foldl1 (cmp f)\n\ncmp :: Ord b => (a -> b) -> a -> a -> a\ncmp f u v = if f u <= f v then u else v\n\n'