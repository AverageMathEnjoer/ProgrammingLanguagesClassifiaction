b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | PDF document\n\nmodule Pdf.Document.Document\n(\n  Document,\n  documentCatalog,\n  documentInfo,\n  documentEncryption\n)\nwhere\n\nimport Pdf.Core.Object\nimport Pdf.Core.Object.Util\nimport Pdf.Core.Exception\nimport Pdf.Core.Util\n\nimport Pdf.Document.Pdf\nimport Pdf.Document.Internal.Types\n\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Exception hiding (throw)\n\ndict :: Document -> Dict\ndict (Document _ d) = d\n\npdf :: Document -> Pdf\npdf (Document p _) = p\n\n-- | Get the document catalog\ndocumentCatalog :: Document -> IO Catalog\ndocumentCatalog doc = do\n  ref <- sure $ (HashMap.lookup "Root" (dict doc) >>= refValue)\n    `notice` "trailer: Root should be an indirect reference"\n  obj <- lookupObject (pdf doc) ref\n  d <- sure $ dictValue obj `notice` "catalog should be a dictionary"\n  return (Catalog (pdf doc) ref d)\n\n-- | Infornation dictionary for the document\ndocumentInfo :: Document -> IO (Maybe Info)\ndocumentInfo doc = do\n  case HashMap.lookup "Info" (dict doc) of\n    Nothing -> return Nothing\n    Just (Ref ref) -> do\n      obj <- lookupObject (pdf doc) ref\n      d <- sure $ dictValue obj `notice` "info should be a dictionary"\n      return (Just (Info (pdf doc) ref d))\n    _ -> throwIO $ Corrupted "document Info should be an indirect reference" []\n\n-- | Document encryption dictionary\ndocumentEncryption :: Document -> IO (Maybe Dict)\ndocumentEncryption doc = do\n  case HashMap.lookup "Encrypt" (dict doc) of\n    Nothing -> return Nothing\n    Just o -> do\n      o\' <- deref (pdf doc) o\n      case o\' of\n        Dict d -> return (Just d)\n        Null -> return Nothing\n        _ -> throwIO (Corrupted "document Encrypt should be a dictionary" [])\n'