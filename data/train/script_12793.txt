b'{-# LANGUAGE\n    DeriveDataTypeable\n  , NoImplicitPrelude\n  #-}\nmodule Api.Post\n  ( Identifier (..)\n  , WithPost\n  , resource\n  , postFromIdentifier\n  ) where\n\nimport Prelude.Compat\n\nimport Control.Concurrent.STM (STM, TVar, atomically, modifyTVar, readTVar)\nimport Control.Monad (unless)\nimport Control.Monad.Error.Class\nimport Control.Monad.Reader (ReaderT, asks)\nimport Control.Monad.Trans (lift, liftIO)\nimport Control.Monad.Trans.Except (ExceptT)\nimport Data.List (sortBy)\nimport Data.Ord (comparing)\nimport Data.Set (Set)\nimport Data.Time\nimport Data.Typeable\nimport Safe\nimport qualified Data.Foldable as F\nimport qualified Data.Set      as Set\nimport qualified Data.Text     as T\n\nimport Rest\nimport Rest.Info\nimport Rest.ShowUrl\nimport qualified Rest.Resource as R\n\nimport ApiTypes\nimport Type.CreatePost (CreatePost)\nimport Type.Post (Post (Post))\nimport Type.PostError (PostError (..))\nimport Type.User (User)\nimport Type.UserPost (UserPost (UserPost))\nimport qualified Type.CreatePost as CreatePost\nimport qualified Type.Post       as Post\nimport qualified Type.User       as User\n\ndata Identifier\n  = Latest\n  | ById Int\n  deriving (Eq, Show, Read, Typeable)\n\ninstance Info Identifier where\n  describe _ = "identifier"\n\ninstance ShowUrl Identifier where\n  showUrl Latest = "latest"\n  showUrl (ById i) = show i\n\n-- | Post extends the root of the API with a reader containing the ways to identify a Post in our URLs.\n-- Currently only by the title of the post.\ntype WithPost = ReaderT Identifier BlogApi\n\n-- | Defines the /post api end-point.\nresource :: Resource BlogApi WithPost Identifier () Void\nresource = mkResourceReader\n  { R.name   = "post" -- Name of the HTTP path segment.\n  , R.schema = withListing () $ named [("id", singleRead ById), ("latest", single Latest)]\n  , R.list   = const list -- list is requested by GET /post which gives a listing of posts.\n  , R.create = Just create -- PUT /post to create a new Post.\n  , R.get    = Just get\n  , R.remove = Just remove\n  }\n\npostFromIdentifier :: Identifier -> TVar (Set Post) -> STM (Maybe Post)\npostFromIdentifier i pv = finder <$> readTVar pv\n  where\n    finder = case i of\n      ById ident -> F.find ((== ident) . Post.id) . Set.toList\n      Latest     -> headMay . sortBy (flip $ comparing Post.createdTime) . Set.toList\n\nget :: Handler WithPost\nget = mkIdHandler xmlJsonO handler\n  where\n    handler :: () -> Identifier -> ExceptT Reason_ WithPost Post\n    handler _ i = do\n      mpost <- liftIO . atomically . postFromIdentifier i =<< (lift . lift) (asks posts)\n      case mpost of\n        Nothing -> throwError NotFound\n        Just a  -> return a\n\n-- | List Posts with the most recent posts first.\nlist :: ListHandler BlogApi\nlist = mkListing xmlJsonO handler\n  where\n    handler :: Range -> ExceptT Reason_ BlogApi [Post]\n    handler r = do\n      psts <- liftIO . atomically . readTVar =<< asks posts\n      return . take (count r) . drop (offset r) . sortBy (flip $ comparing Post.createdTime) . Set.toList $ psts\n\ncreate :: Handler BlogApi\ncreate = mkInputHandler (xmlJsonE . xmlJson) handler\n  where\n    handler :: UserPost -> ExceptT (Reason PostError) BlogApi Post\n    handler (UserPost usr pst) = do\n      -- Make sure the credentials are valid\n      checkLogin usr\n      pstsVar <- asks posts\n      psts <- liftIO . atomically . readTVar $ pstsVar\n      post <- liftIO $ toPost (Set.size psts + 1) usr pst\n      -- Validate and save the post in the same transaction.\n      merr <- liftIO . atomically $ do\n        let vt = validTitle pst psts\n        if not vt\n          then return . Just $ domainReason InvalidTitle\n          else if not (validContent pst)\n            then return . Just $ domainReason InvalidContent\n            else modifyTVar pstsVar (Set.insert post) >> return Nothing\n      maybe (return post) throwError merr\n\nremove :: Handler WithPost\nremove = mkIdHandler id handler\n  where\n    handler :: () -> Identifier -> ExceptT Reason_ WithPost ()\n    handler _ i = do\n      pstsVar <- lift . lift $ asks posts\n      merr <- liftIO . atomically $ do\n        mpost <- postFromIdentifier i pstsVar\n        case mpost of\n          Nothing -> return . Just $ NotFound\n          Just post -> modifyTVar pstsVar (Set.delete post) >> return Nothing\n      maybe (return ()) throwError merr\n\n-- | Convert a User and CreatePost into a Post that can be saved.\ntoPost :: Int -> User -> CreatePost -> IO Post\ntoPost i u p = do\n  t <- getCurrentTime\n  return Post\n    { Post.id          = i\n    , Post.author      = User.name u\n    , Post.createdTime = t\n    , Post.title       = CreatePost.title p\n    , Post.content     = CreatePost.content p\n    }\n\n-- | A Post\'s title must be unique and non-empty.\nvalidTitle :: CreatePost -> Set Post -> Bool\nvalidTitle p psts =\n  let pt        = CreatePost.title p\n      nonEmpty  = (>= 1) . T.length $ pt\n      available = F.all ((pt /=) . Post.title) psts\n  in available && nonEmpty\n\n-- | A Post\'s content must be non-empty.\nvalidContent :: CreatePost -> Bool\nvalidContent = (>= 1) . T.length . CreatePost.content\n\n-- | Throw an error if the user isn\'t logged in.\ncheckLogin :: User -> ExceptT (Reason e) BlogApi ()\ncheckLogin usr = do\n  usrs <- liftIO . atomically . readTVar =<< asks users\n  unless (usr `F.elem` usrs) $ throwError NotAllowed\n'