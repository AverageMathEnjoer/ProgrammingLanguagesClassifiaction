b'{-# LANGUAGE BangPatterns, OverloadedStrings #-}\n\n-- Embarrassingly parallel.\n-- If this doesn\'t get a speedup nothing will!\n\n-- Note: This program is an example of a dependence on "put" being\n-- strict.  If it were not the real work would be deferred until after\n-- the parallel computation is finished!\n\nimport GHC.Conc\nimport Debug.Trace\nimport Control.Monad\n-- import Control.Monad.IO.Class (liftIO)\n\nimport Control.Exception (evaluate)\nimport System.Environment\nimport qualified Control.Monad.State.Strict as S \nimport qualified Data.ByteString.Char8 as BS\nimport System.IO.Unsafe (unsafePerformIO)\nimport Control.Concurrent (yield)\n\n\n-- import Control.Monad.Par.Scheds.Direct (Par, spawn_, get, runPar)\n-- import Control.Monad.Par.Unsafe ()\n-- import Control.Monad.Par.IO (ParIO, spawn_, get, runPar)\n-- type Par = ParIO\nimport Control.Monad.Par (Par, spawn_, get, runPar)\n\n-- Compute sum_n(1/n)\nwork :: Int -> Int -> Double -> Double\nwork offset 0 n = n\nwork offset i n | i `mod` 10000 == 0 = \n  unsafePerformIO $ do yield\n--\t\t       putStr "."\n\t\t       return (work offset (i-1) (n + 1 / fromIntegral (i+offset)))\nwork offset (!i) (!n) = work offset (i-1) (n + 1 / fromIntegral (i+offset))\n\n-- runit :: (Double,Int) -> IO ()\nrunit :: Int -> Int -> IO ()\nrunit total partitions = evaluate $ runPar $ \n   do \n      prnt$ "Running embarrassingly parallel benchmark."\n      prnt$ "Running "++ show total ++" total iterations"\n      prnt$ "Spawning "++show partitions++" tasks..."\n      results <- mapM (spawn_ . kernel) [0 .. partitions-1] \n      prnt "Done initializing."\n\n      final <- foldM (\\ acc (ind,iv) -> \n\t\t      do prnt$ "  Retrieving output "++ show ind ++": "\n\t\t\t n <- get iv\n\t\t\t prnt$ show n\n\t\t\t return (acc + n))\n\t\t  0.0 (zip [0..] results)\n      prnt$ "Final Output: " ++ show final\n where  \n  oneshare = total `quot` partitions\n  kernel jid =\n     do \n        tid <- io myThreadId \n\tprnt$ (show tid++" job "++show jid++":  About to do a chunk of work ("++ show oneshare ++" iterations)...")\n        res <- io$ evaluate $ work (oneshare * jid) oneshare 0.0\n\tprnt$ (show tid++"   job "++show jid++":  done with work (result "++ show res ++")")\n        return res\n\nprnt :: String -> Par ()\nprnt str = trace str $ return ()\n\nio :: IO a -> Par a\nio act = let x = unsafePerformIO act in \n         seq x (return x)\n\n-- prnt :: String -> Par ()\n-- prnt = io . BS.putStrLn . BS.pack \n\n-- -- io :: IO a -> Par a\n-- io :: ParUnsafe p iv => IO a -> p a\n-- io act = unsafeParIO act\n\nmain = do args <- getArgs \n\t  case args of \n\t      []        -> runit  (50*1000*1000) numCapabilities\n\t      -- The input is a power of 10:\n\t      [n]       -> runit  (round (10 ** read n)) numCapabilities\n\t      [n,parts] -> runit  (round (10 ** read n)) (read parts)\n'