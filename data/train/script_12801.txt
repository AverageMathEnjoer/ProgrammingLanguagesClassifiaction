b'{-# LANGUAGE RecordWildCards #-}\nmodule Main where\n\nimport Database.Beam\nimport Database.Beam.Migrate.Tool\nimport Database.Beam.Migrate.Types\n\nimport Control.Monad\n\nimport Data.Monoid\nimport Data.Proxy\nimport Data.Dynamic\n\nimport Options.Applicative\nimport Options.Applicative.Internal\nimport Options.Applicative.Types\n\nimport System.Directory\nimport System.IO\nimport System.Exit\nimport System.Environment\n\nimport Language.Haskell.Interpreter\nimport Language.Haskell.Interpreter.Unsafe\n\nshowUsage :: Either (String, ExitCode) (ParserFailure ParserHelp) -> ParserInfo a -> IO b\nshowUsage failure opts =\n  do progn <- getProgName\n     let (helpMsg, exit) =\n           case failure of\n             Left (helpMsg, exit) -> (helpMsg, exit)\n             Right failure -> renderFailure failure progn\n\n     hPutStrLn stderr helpMsg\n     exitWith exit\n\nparsePartial :: ParserInfo a -> Args -> Either (ParserFailure ParserHelp) (a, Args)\nparsePartial info a =\n  let p = runParser (if infoIntersperse info then SkipOpts else AllowOpts) CmdStart (infoParser info) a\n  in case runP p defaultPrefs of\n    (Left err, ctxt) -> Left (parserFailure defaultPrefs info err ctxt)\n    (Right (a, remaining), ctxt) -> Right (a, remaining)\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n\n  let bareInfo = migrationCommandAndSubcommandOptions (pure ())\n  case parsePartial bareInfo args of\n    Left err ->\n      do hPutStrLn stderr "Could not determine backend"\n         showUsage (Right err) bareInfo\n    Right ((BeamMigrationCommand {..}, _), _) ->\n      do putStrLn $ "Loading backend \'" ++ migrationCommandBackend ++ "\'..."\n         putStrLn $ "Loading dirs " ++ show migrationCommandPackagePath\n         let ghciArgs = foldMap (\\p -> [ "-package-db " <>  p]) migrationCommandPackagePath\n             runInterpreter\' :: InterpreterT IO a -> IO (Either InterpreterError a)\n             runInterpreter\' = unsafeRunInterpreterWithArgs ghciArgs\n         res <- runInterpreter\' $ do\n           unsafeSetGhcOption "-v"\n\n           setImports [ "Database.Beam.Migrate.Tool",  migrationCommandBackend ]\n           interpret "SomeBeamMigrationBackend migrationBackend" (undefined :: SomeBeamMigrationBackend)\n         case res of\n           Left err -> hPutStrLn stderr ("Plugin load error: " ++ show err)\n           Right (SomeBeamMigrationBackend be@(BeamMigrationBackend { ..} :: BeamMigrationBackend be cmdSyntax beOptions)) ->\n             do let withBackendInfo = migrationCommandAndSubcommandOptions backendOptsParser\n                (opts, subcommand) <- execParser withBackendInfo\n                case (migrationCommandMigrationModule, subcommand) of\n                  (Just migrationCommandMigrationModule, Just subcommand) ->\n                    do putStrLn "Loading migration from migrations directory..."\n                       res <- runInterpreter\' $ do\n                         reset\n                         set [ languageExtensions := [ TypeFamilies, GADTs, RankNTypes, FlexibleInstances, FlexibleContexts, DeriveGeneric\n                                                     , ScopedTypeVariables, MultiParamTypeClasses, OverloadedStrings ] ]\n                         loadModules [ migrationCommandMigrationModule ]\n                         setImports [ "Data.Dynamic"\n                                    , "Database.Beam.Migrate.Types"\n                                    , "Database.Beam.Migrate.Tool"\n                                    , migrationCommandBackend ]\n                         setTopLevelModules [ migrationCommandMigrationModule ]\n                         migration <- interpret "toDyn (eraseMigrationType () migration)" (undefined :: Dynamic)\n                         checkedDb <- interpret "SomeCheckedDatabase (evaluateDatabase migration)" (undefined :: SomeCheckedDatabase be)\n                         pure (migration, checkedDb)\n                       case res of\n                         Left err -> do hPutStrLn stderr "Plugin error: could not load migrations: "\n                                        case err of\n                                          WontCompile errs -> mapM_ (hPutStrLn stderr . errMsg) errs\n                                          _ -> hPutStrLn stderr (show err)\n                         Right (migration, checkedDb) ->\n                           case (,) <$> fromDynamic migration <*> pure checkedDb of\n                             Nothing -> hPutStrLn stderr "Migration did not have correct type"\n                             Just (migration :: MigrationSteps cmdSyntax () (), checkedDb :: SomeCheckedDatabase be) ->\n                               invokeMigrationTool be opts subcommand migration checkedDb\n                  (Nothing, _) -> showUsage (Left ("No migration module supplied", ExitFailure 1)) withBackendInfo\n                  (_, Nothing) -> showUsage (Left ("Please specify a command", ExitFailure 1)) withBackendInfo\n'