b'{-# LANGUAGE DeriveGeneric, DeriveAnyClass, StandaloneDeriving #-}\n\nmodule Database.Beam.Postgres.Test.DataTypes where\n\nimport Database.Beam\nimport Database.Beam.Postgres\nimport Database.Beam.Postgres.Test\nimport Database.Beam.Migrate\nimport Database.Beam.Backend.SQL.BeamExtensions\n\nimport Control.Exception (SomeException(..), handle)\n\nimport Data.ByteString (ByteString)\nimport Data.Int\nimport Data.Text (Text)\n\nimport Test.Tasty\nimport Test.Tasty.HUnit\n\ntests :: IO ByteString -> TestTree\ntests postgresConn =\n    testGroup "Data-type unit tests"\n    [ jsonNulTest postgresConn\n    , errorOnSchemaMismatch postgresConn ]\n\ndata JsonT f\n    = JsonT\n    { _key :: C f Int32\n    , _field1 :: C f (PgJSON String) }\n    deriving (Generic, Beamable)\n\ninstance Table JsonT where\n    data PrimaryKey JsonT f = JsonKey (C f Int32)\n      deriving (Generic, Beamable)\n    primaryKey = JsonKey <$> _key\n\ndata JsonDb entity\n    = JsonDb\n    { jsonTable :: entity (TableEntity JsonT) }\n    deriving (Generic, Database Postgres)\n\n-- | Regression test for <https://github.com/haskell-beam/beam/issues/297 #297>\njsonNulTest :: IO ByteString -> TestTree\njsonNulTest pgConn =\n    testCase "JSON NUL handling (#297)" $\n    withTestPostgres "db_jsonnul" pgConn $ \\conn -> do\n      readback <-\n        runBeamPostgres conn $ do\n          db <- fmap unCheckDatabase $\n                executeMigration runNoReturn\n                (JsonDb <$> createTable "json_test"\n                              (JsonT (field "key" int notNull)\n                                     (field "value" json notNull)))\n\n          runInsert $ insert (jsonTable db) $\n            insertValues [ JsonT 1 (PgJSON "hello\\0world") ]\n          runInsert $ insert (jsonTable db) $\n            insertValues [ JsonT 2 (PgJSON "\\0\\0\\0") ]\n          runInsert $ insert (jsonTable db) $\n            insertValues [ JsonT 3 (PgJSON "\\0hello") ]\n          runInsert $ insert (jsonTable db) $\n            insertValues [ JsonT 4 (PgJSON "hello\\0") ]\n          runInsert $ insert (jsonTable db) $\n            insertValues [ JsonT 5 (PgJSON "\\0hello\\0") ]\n          runInsert $ insert (jsonTable db) $\n            insertValues [ JsonT 6 (PgJSON "\\0he\\0\\0llo\\0") ]\n\n          fmap (fmap (\\(PgJSON v) -> v)) $\n            runSelectReturningList $ select $\n            fmap (\\(JsonT _ v) -> v) $\n            orderBy_ (\\(JsonT k _) -> asc_ k) $\n            all_ (jsonTable db)\n\n      readback @?= [ "hello\\0world"\n                   , "\\0\\0\\0"\n                   , "\\0hello"\n                   , "hello\\0"\n                   , "\\0hello\\0"\n                   , "\\0he\\0\\0llo\\0" ]\n\n      return ()\n\ndata TblT f\n    = Tbl { _tblKey :: C f Int32, _tblValue :: C f Text }\n      deriving (Generic, Beamable)\n\nderiving instance Show (TblT Identity)\nderiving instance Eq (TblT Identity)\n\ninstance Table TblT where\n    data PrimaryKey TblT f = TblKey (C f Int32)\n      deriving (Generic, Beamable)\n    primaryKey = TblKey <$> _tblKey\n\ndata WrongTblT f\n    = WrongTbl { _wrongTblKey :: C f Int32, _wrongTblValue :: C f Int32 }\n      deriving (Generic, Beamable)\n\ninstance Table WrongTblT where\n    data PrimaryKey WrongTblT f = WrongTblKey (C f Int32)\n      deriving (Generic, Beamable)\n    primaryKey = WrongTblKey <$> _wrongTblKey\n\ndata RealDb entity\n    = RealDb { _realTbl :: entity (TableEntity TblT) }\n      deriving (Generic, Database Postgres)\n\ndata WrongDb entity\n    = WrongDb { _wrongTbl :: entity (TableEntity WrongTblT) }\n      deriving (Generic, Database Postgres)\n\n-- | Regression test for <https://github.com/haskell-beam/beam/issues/112>\nerrorOnSchemaMismatch :: IO ByteString -> TestTree\nerrorOnSchemaMismatch pgConn =\n    testCase "runInsertReturningList should error on schema mismatch (#112)" $\n    withTestPostgres "db_failures" pgConn $ \\conn -> do\n      vs <-\n        runBeamPostgres conn $ do\n          realDb <- fmap unCheckDatabase $ executeMigration runNoReturn\n            (RealDb <$> createTable "tbl1" (Tbl (field "key" int notNull)\n                                                (field "value" (varchar Nothing) notNull)))\n\n          runInsertReturningList $ insert (_realTbl realDb) $ insertValues [ Tbl 1 "hello", Tbl 2 "world", Tbl 3 "foo" ]\n\n      vs @?= [ Tbl 1 "hello", Tbl 2 "world", Tbl 3 "foo" ]\n\n      let wrongDb = unCheckDatabase $\n                    runMigrationSilenced (WrongDb <$> createTable "tbl1"\n                                                        (WrongTbl (field "key" int notNull)\n                                                                  (field "value" int notNull)))\n\n      didFail <- handle (\\(_ :: SomeException) -> pure True) $\n        runBeamPostgres conn $ do\n          _ <- runInsertReturningList $ insert (_wrongTbl wrongDb) $ insertValues [ WrongTbl 4 23, WrongTbl 5 24, WrongTbl 6 24 ]\n          pure False\n\n      assertBool "runInsertReturningList succeeded" didFail\n      didFail @?= True\n'