b'\xef\xbb\xbfusing System;\nusing Asn1;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.IO;\nusing Rubeus.Kerberos;\nusing Rubeus.Kerberos.PAC;\n\nnamespace Rubeus\n{\n    public class EncTicketPart\n    {\n        //EncTicketPart::= [APPLICATION 3] SEQUENCE {\n        //   flags[0] TicketFlags,\n        //   key[1] EncryptionKey,\n        //   crealm[2] Realm,\n        //   cname[3] PrincipalName,\n        //   transited[4] TransitedEncoding,\n        //   authtime[5] KerberosTime,\n        //   starttime[6] KerberosTime OPTIONAL,\n        //   endtime[7] KerberosTime,\n        //   renew-till[8] KerberosTime OPTIONAL,\n        //   caddr[9] HostAddresses OPTIONAL,\n        //  authorization-data[10] AuthorizationData OPTIONAL\n        //}\n\n        public EncTicketPart(byte[] sessionKey, Interop.KERB_ETYPE etype, string domain, string user, Interop.TicketFlags ticketFlags, DateTime startTime)\n        {\n            // flags\n            flags = ticketFlags;\n\n            // default times\n            authtime = startTime;\n            starttime = startTime;\n            endtime = starttime.AddHours(10);\n            renew_till = starttime.AddDays(7);\n\n            // set session key\n            key = new EncryptionKey();\n            key.keytype = (int)etype;\n            key.keyvalue = sessionKey;\n\n            // cname information\n            crealm = domain;\n            cname = new PrincipalName(user);\n\n            // default empty TransitedEncoding\n            transited = new TransitedEncoding();\n\n            // null caddr and authdata\n            caddr = null;\n            authorization_data = null;\n\n        }\n        public EncTicketPart(AsnElt body, byte[] asrepKey = null, bool noAdData = false)\n        {\n            foreach (AsnElt s in body.Sub)\n            {\n                switch (s.TagValue)\n                {\n                    case 0:\n                        UInt32 temp = Convert.ToUInt32(s.Sub[0].GetInteger());\n                        byte[] tempBytes = BitConverter.GetBytes(temp);\n                        flags = (Interop.TicketFlags)BitConverter.ToInt32(tempBytes, 0);\n                        break;\n                    case 1:\n                        key = new EncryptionKey(s);\n                        break;\n                    case 2:\n                        crealm = Encoding.ASCII.GetString(s.Sub[0].GetOctetString());\n                        break;\n                    case 3:\n                        cname = new PrincipalName(s.Sub[0]);\n                        break;\n                    case 4:\n                        transited = new TransitedEncoding(s.Sub[0]);\n                        break;\n                    case 5:\n                        authtime = s.Sub[0].GetTime();\n                        break;\n                    case 6:\n                        starttime = s.Sub[0].GetTime();\n                        break;\n                    case 7:\n                        endtime = s.Sub[0].GetTime();\n                        break;\n                    case 8:\n                        renew_till = s.Sub[0].GetTime();\n                        break;\n                    case 9:\n                        // caddr (optional)\n                        caddr = new List<HostAddress>();\n                        caddr.Add(new HostAddress(s.Sub[0]));\n                        break;\n                    case 10:\n                        // authorization-data (optional)\n                        authorization_data = new List<AuthorizationData>();\n                        if (noAdData)\n                        {\n                            authorization_data.Add(new ADIfRelevant(s.Sub[0].Sub[0].Sub[1].Sub[0].CopyValue()));\n                        }\n                        else\n                        {\n                            foreach (AsnElt tmp in s.Sub[0].Sub)\n                            {\n                                authorization_data.Add(new ADIfRelevant(tmp, asrepKey));\n                            }\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        public AsnElt Encode()\n        {\n            List<AsnElt> allNodes = new List<AsnElt>();\n\n            // flags           [0] TicketFlags\n            byte[] flagBytes = BitConverter.GetBytes((UInt32)flags);\n            if (BitConverter.IsLittleEndian)\n            {\n                Array.Reverse(flagBytes);\n            }\n            AsnElt flagBytesAsn = AsnElt.MakeBitString(flagBytes);\n            AsnElt flagBytesSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { flagBytesAsn });\n            flagBytesSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 0, flagBytesSeq);\n            allNodes.Add(flagBytesSeq);\n\n            // key             [1] EncryptionKey\n            AsnElt keyAsn = key.Encode();\n            keyAsn = AsnElt.MakeImplicit(AsnElt.CONTEXT, 1, keyAsn);\n            allNodes.Add(keyAsn);\n\n            // crealm                   [2] Realm\n            //                          -- clients realm\n            AsnElt realmAsn = AsnElt.MakeString(AsnElt.IA5String, crealm);\n            realmAsn = AsnElt.MakeImplicit(AsnElt.UNIVERSAL, AsnElt.GeneralString, realmAsn);\n            AsnElt realmSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { realmAsn });\n            realmSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 2, realmSeq);\n            allNodes.Add(realmSeq);\n\n            // cname                   [3] PrincipalName\n            if (cname != null)\n            {\n                AsnElt cnameElt = cname.Encode();\n                cnameElt = AsnElt.MakeImplicit(AsnElt.CONTEXT, 3, cnameElt);\n                allNodes.Add(cnameElt);\n            }\n\n            // transited                    [4] TransitedEncoding\n            AsnElt transitedElt = transited.Encode();\n            transitedElt = AsnElt.MakeImplicit(AsnElt.CONTEXT, 4, transitedElt);\n            allNodes.Add(transitedElt);\n\n            // authtime                    [5] KerberosTime\n            AsnElt authTimeAsn = AsnElt.MakeString(AsnElt.GeneralizedTime, authtime.ToString("yyyyMMddHHmmssZ"));\n            AsnElt authTimeSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { authTimeAsn });\n            authTimeSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 5, authTimeSeq);\n            allNodes.Add(authTimeSeq);\n\n            // starttime                    [6] KerberosTime OPTIONAL\n            if (starttime != null)\n            {\n                AsnElt startTimeAsn = AsnElt.MakeString(AsnElt.GeneralizedTime, starttime.ToString("yyyyMMddHHmmssZ"));\n                AsnElt startTimeSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { startTimeAsn });\n                startTimeSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 6, startTimeSeq);\n                allNodes.Add(startTimeSeq);\n            }\n\n            // endtime                    [7] KerberosTime\n            AsnElt endTimeAsn = AsnElt.MakeString(AsnElt.GeneralizedTime, endtime.ToString("yyyyMMddHHmmssZ"));\n            AsnElt endTimeSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { endTimeAsn });\n            endTimeSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 7, endTimeSeq);\n            allNodes.Add(endTimeSeq);\n\n            // renew-till                    [8] KerberosTime OPTIONAL\n            if (renew_till != null)\n            {\n                AsnElt renewTimeAsn = AsnElt.MakeString(AsnElt.GeneralizedTime, renew_till.ToString("yyyyMMddHHmmssZ"));\n                AsnElt renewTimeSeq = AsnElt.Make(AsnElt.SEQUENCE, new[] { renewTimeAsn });\n                renewTimeSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 8, renewTimeSeq);\n                allNodes.Add(renewTimeSeq);\n            }\n\n            // caddr                    [9] HostAddresses OPTIONAL\n            if (caddr != null)\n            {\n                List<AsnElt> addrList = new List<AsnElt>();\n                foreach (HostAddress addr in caddr)\n                {\n                    AsnElt addrElt = addr.Encode();\n                    addrList.Add(addrElt);\n                }\n                AsnElt addrSeqTotal1 = AsnElt.Make(AsnElt.SEQUENCE, addrList.ToArray());\n                AsnElt addrSeqTotal2 = AsnElt.Make(AsnElt.SEQUENCE, addrSeqTotal1);\n                addrSeqTotal2 = AsnElt.MakeImplicit(AsnElt.CONTEXT, 9, addrSeqTotal2);\n                allNodes.Add(addrSeqTotal2);\n            }\n\n            // authorization-data            [10] AuthorizationData OPTIONAL\n            if (authorization_data != null)\n            {\n                List<AsnElt> adList = new List<AsnElt>();\n\n                foreach (AuthorizationData ad in authorization_data)\n                {\n                    AsnElt addrElt = ad.Encode();\n                    adList.Add(addrElt);\n                }\n                AsnElt authDataSeq = AsnElt.Make(AsnElt.SEQUENCE, adList.ToArray());\n                AsnElt addrSeqTotal1 = AsnElt.Make(AsnElt.SEQUENCE, authDataSeq);\n                authDataSeq = AsnElt.MakeImplicit(AsnElt.CONTEXT, 10, addrSeqTotal1);\n                allNodes.Add(authDataSeq);\n\n            }\n\n            AsnElt seq = AsnElt.Make(AsnElt.SEQUENCE, allNodes.ToArray());\n            AsnElt seq2 = AsnElt.Make(AsnElt.SEQUENCE, new[] { seq });\n            seq2 = AsnElt.MakeImplicit(AsnElt.APPLICATION, 3, seq2);\n\n            return seq2;\n        }\n\n        public PACTYPE GetPac(byte[] asrepKey)\n        {\n            if (authorization_data != null)\n            {\n                foreach (var addata in authorization_data)\n                {\n                    foreach (var ifrelevant in ((ADIfRelevant)addata).ADData)\n                    {\n                        if (ifrelevant is ADWin2KPac win2k_pac)\n                        {\n                            return win2k_pac.Pac;\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n\n        public void SetPac(PACTYPE pac) {\n            if (authorization_data == null)\n            {\n                authorization_data = new List<AuthorizationData>();\n            }\n            List<AuthorizationData> oldAuthData = new List<AuthorizationData>();\n            foreach (var authdata in authorization_data)\n            {\n                ADIfRelevant tmpifrelevant = new ADIfRelevant();\n                foreach (var adData in ((ADIfRelevant)authdata).ADData)\n                {\n                    if (!(adData is ADWin2KPac win2k_pac))\n                    {\n                        tmpifrelevant.ADData.Add(adData);\n                    }\n                }\n                if (tmpifrelevant.ADData.Count > 0)\n                {\n                    oldAuthData.Add(tmpifrelevant);\n                }\n            }\n            authorization_data = new List<AuthorizationData>();\n            ADIfRelevant ifrelevant = new ADIfRelevant();\n            ifrelevant.ADData.Add(new ADWin2KPac(pac));\n            authorization_data.Add(ifrelevant);\n            foreach (var authdata in oldAuthData)\n            {\n                authorization_data.Add(authdata);\n            }\n        }\n\n        public Tuple<bool, bool, bool> ValidatePac(byte[] serviceKey, byte[] krbKey = null)\n        {\n            byte[] pacBytes = null;\n            if (authorization_data != null)\n            {\n                foreach (var addata in authorization_data)\n                {\n                    foreach (var ifrelevant in ((ADIfRelevant)addata).ADData)\n                    {\n                        if (ifrelevant is ADWin2KPac win2k_pac)\n                        {\n                            pacBytes = win2k_pac.ad_data;\n                        }\n                    }\n                }\n            }\n            if (pacBytes == null)\n            {\n                return null;\n            }\n            BinaryReader br = new BinaryReader(new MemoryStream(pacBytes));\n            int cBuffers = br.ReadInt32();\n            int Version = br.ReadInt32();\n            long offset = 0, svrOffset = 0, kdcOffset = 0;\n            Interop.KERB_CHECKSUM_ALGORITHM svrSigType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256;\n            Interop.KERB_CHECKSUM_ALGORITHM kdcSigType = Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_SHA1_96_AES256;\n            int svrLength = 12, kdcLength = 12;\n            byte[] oldSvrSig = null, oldKdcSig = null;\n\n            for (int idx = 0; idx < cBuffers; ++idx)\n            {\n\n                var type = (PacInfoBufferType)br.ReadInt32();\n                var bufferSize = br.ReadInt32();\n                offset = br.ReadInt64();\n\n                long oldPostion = br.BaseStream.Position;\n                br.BaseStream.Position = offset;\n                var pacData = br.ReadBytes(bufferSize);\n                br.BaseStream.Position = oldPostion;\n                BinaryReader brPacData = new BinaryReader(new MemoryStream(pacData));\n\n                switch (type)\n                {\n                    case PacInfoBufferType.KDCChecksum:\n                        kdcOffset = offset + 4;\n                        kdcSigType = (Interop.KERB_CHECKSUM_ALGORITHM)brPacData.ReadInt32();\n                        if (kdcSigType == Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5)\n                        {\n                            kdcLength = 16;\n                        }\n                        oldKdcSig = brPacData.ReadBytes(kdcLength);\n                        break;\n                    case PacInfoBufferType.ServerChecksum:\n                        svrOffset = offset + 4;\n                        svrSigType = (Interop.KERB_CHECKSUM_ALGORITHM)brPacData.ReadInt32();\n                        if (svrSigType == Interop.KERB_CHECKSUM_ALGORITHM.KERB_CHECKSUM_HMAC_MD5)\n                        {\n                            svrLength = 16;\n                        }\n                        oldSvrSig = brPacData.ReadBytes(svrLength);\n                        break;\n\n                }\n            }\n\n            byte[] svrZeros = new byte[svrLength], kdcZeros = new byte[kdcLength];\n            Array.Clear(svrZeros, 0, svrLength);\n            Array.Clear(kdcZeros, 0, kdcLength);\n            Array.Copy(svrZeros, 0, pacBytes, svrOffset, svrLength);\n            Array.Copy(kdcZeros, 0, pacBytes, kdcOffset, kdcLength);\n\n            byte[] svrSig = Crypto.KerberosChecksum(serviceKey, pacBytes, svrSigType);\n\n            if (krbKey == null)\n            {\n                return Tuple.Create((Helpers.ByteArrayToString(oldSvrSig) == Helpers.ByteArrayToString(svrSig)), false, false);\n            }\n\n            byte[] kdcSig = Crypto.KerberosChecksum(krbKey, oldSvrSig, kdcSigType);\n            return Tuple.Create((Helpers.ByteArrayToString(oldSvrSig) == Helpers.ByteArrayToString(svrSig)), (Helpers.ByteArrayToString(oldKdcSig) == Helpers.ByteArrayToString(kdcSig)), ValidateTicketChecksum(krbKey));\n        }\n\n        public byte[] CalculateTicketChecksum(byte[] krbKey, Interop.KERB_CHECKSUM_ALGORITHM krbChecksumType)\n        {\n            byte[] ticketChecksum = null;\n            byte[] oldWin2kPacData = null;\n            PACTYPE oldWin2kPac = null;\n            EncTicketPart tmpEncTicketPart = this;\n\n            // find the PAC and place a zero in it\'s ad-data\n            List<AuthorizationData> newAuthData = new List<AuthorizationData>();\n            foreach (var tmpadData in tmpEncTicketPart.authorization_data)\n            {\n                ADIfRelevant tmpifrelevant = new ADIfRelevant();\n                foreach (var ifrelevant in ((ADIfRelevant)tmpadData).ADData)\n                {\n                    if (ifrelevant is ADWin2KPac win2k_pac)\n                    {\n                        oldWin2kPacData = win2k_pac.ad_data;\n                        oldWin2kPac = win2k_pac.Pac;\n                        ADWin2KPac tmpWin2k = new ADWin2KPac();\n                        tmpWin2k.ad_data = new byte[] { 0x00 };\n                        tmpWin2k.Pac = null;\n                        tmpifrelevant.ADData.Add(tmpWin2k);\n                    }\n                    else\n                    {\n                        tmpifrelevant.ADData.Add(ifrelevant);\n                    }\n                }\n                newAuthData.Add(tmpifrelevant);\n            }\n            tmpEncTicketPart.authorization_data = newAuthData;\n\n            ticketChecksum = Crypto.KerberosChecksum(krbKey, tmpEncTicketPart.Encode().Encode(), krbChecksumType);\n\n            foreach (var tmpadData in tmpEncTicketPart.authorization_data)\n            {\n                ADIfRelevant tmpifrelevant = new ADIfRelevant();\n                foreach (var ifrelevant in ((ADIfRelevant)tmpadData).ADData)\n                {\n                    if (ifrelevant is ADWin2KPac win2k_pac)\n                    {\n                        win2k_pac.ad_data = oldWin2kPacData;\n                        win2k_pac.Pac = oldWin2kPac;\n                    }\n                }\n            }\n\n            return ticketChecksum;\n        }\n\n        public bool ValidateTicketChecksum(byte[] krbKey)\n        {\n            SignatureData ticketSig = null;\n\n            // find the PAC the old TicketChecksum\n            foreach (var tmpadData in authorization_data)\n            {\n                foreach (var ifrelevant in ((ADIfRelevant)tmpadData).ADData)\n                {\n                    if (ifrelevant is ADWin2KPac win2k_pac)\n                    {\n                        foreach (var PacInfoBuffer in win2k_pac.Pac.PacInfoBuffers)\n                        {\n                            if (PacInfoBuffer.Type is PacInfoBufferType.TicketChecksum)\n                            {\n                                ticketSig = (SignatureData)PacInfoBuffer;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (ticketSig == null)\n            {\n                return false;\n            }\n\n            byte[] calculatedSig = CalculateTicketChecksum(krbKey, ticketSig.SignatureType);\n\n            return (Helpers.ByteArrayToString(calculatedSig) == Helpers.ByteArrayToString(ticketSig.Signature));\n        }\n\n        public bool TicketChecksumExists()\n        {\n            bool ret = false;\n            PACTYPE pt = null;\n\n            // get the PAC\n            if (authorization_data != null)\n            {\n                foreach (var addata in authorization_data)\n                {\n                    foreach (var ifrelevant in ((ADIfRelevant)addata).ADData)\n                    {\n                        if (ifrelevant is ADWin2KPac win2k_pac)\n                        {\n                            pt = win2k_pac.Pac;\n                        }\n                    }\n                }\n            }\n\n            // If not PAC was retrieved return false\n            if (pt == null)\n            {\n                return ret;\n            }\n\n            // look for the TicketChecksum\n            foreach (var pacInfoBuffer in pt.PacInfoBuffers)\n            {\n                if (pacInfoBuffer.Type is PacInfoBufferType.TicketChecksum)\n                {\n                    ret = true;\n                }\n            }\n\n            return ret;\n        }\n\n        public Interop.TicketFlags flags { get; set; }\n\n        public EncryptionKey key { get; set; }\n\n        public string crealm { get; set; }\n\n        public PrincipalName cname { get; set; }\n\n        public TransitedEncoding transited { get; set; }\n\n        public DateTime authtime { get; set; }\n\n        public DateTime starttime { get; set; }\n\n        public DateTime endtime { get; set; }\n\n        public DateTime renew_till { get; set; }\n\n        public List<HostAddress> caddr { get; set; }\n\n        public List<AuthorizationData> authorization_data { get; set; }\n    }\n}\n'