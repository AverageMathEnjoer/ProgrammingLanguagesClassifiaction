b'\nimport Control.Monad\nimport Control.Monad.Par\nimport qualified Data.Vector.Unboxed as V \nimport qualified Data.Vector.Unboxed.Mutable as MV\n\nimport System.Random\nimport System.Environment\nimport Control.Exception\nimport Test.QuickCheck\nimport Control.DeepSeq (NFData(..), deepseq)\nimport Control.Parallel.Strategies (rdeepseq, runEval)\n\nimport Data.List.Split (chunk)\nimport Data.List (intersperse)\nimport System.CPUTime (getCPUTime)\nimport Text.Printf\n\n\nimport qualified Data.List as L\n\nimport qualified Data.Vector.Algorithms.Intro as VA\n\n-- Haskell standard library\nsort_list1 l = L.sort l\n\n\n-- vector-algorithms package which uses a similar algorithm as the C++ STL sort:\nsort_vector2 v = \n  V.create $ do mut <- V.thaw v \n                VA.sort mut\n                return mut\n\n-- main = do args <- getArgs\n--           let (t, size) = case args of\n--                             [] -> (2, 18)\n--                             [t] -> ((read t), 18)\n--                             [t, n] -> ((read t), (read n))\n\n--           g <- getStdGen\n--           let rands = genRandoms size g\n\n--           putStrLn $ "Merge sorting " ++ show (V.length rands) ++ \n--                      " elements. First deepseq the rands."\n--           --evaluate (deepseq rands ())\n\n\n--           putStrLn "Monad-par based version:"\n--           print $ take 8 $ V.toList $ runPar $ mergesort t rands\n\n\n\n-- Create a vector containing the numbers [0,N) in random order.\nrandomPermutation :: Int -> StdGen -> V.Vector Int\nrandomPermutation len rng = \n  -- Annoyingly there is no MV.generate:\n  V.create (do v <- V.unsafeThaw$ V.generate len id\n               loop 0 v rng)\n  -- loop 0 (MV.generate len id)\n where \n  loop n vec g | n == len  = return vec\n\t       | otherwise = do \n    let (offset,g\') = randomR (0, len - n - 1) g\n--    MV.unsafeSwap vec n \n    MV.swap vec n (n + offset)\n    loop (n+1) vec g\'\n\n\ncommaint :: (Show a, Integral a) => a -> String\ncommaint n | n < 0 = "-" ++ commaint (-n)\ncommaint n = \n   reverse $ concat $\n   intersperse "," $ \n   chunk 3 $ reverse (show n)\n\n\nvecSortMain sorter = do \n     args <- getArgs\n     let (t, exponent) = case args of\n\t\t       []  -> (2, 18)\n\t\t       [t] -> (read t, 18)\n\t\t       [t, n] -> (read t, read n)\n\n     g <- getStdGen\n\n     putStrLn $ "Sorting " ++ commaint (2^exponent) ++ \n\t\t" elements. First generate a random permutation:"\n\n     start <- getCPUTime\n     let rands = randomPermutation (2^exponent) g\n     evaluate$ rands\n     evaluate$ rands V.! 0\n     end   <- getCPUTime\n     printf "Creating vector took %0.3f sec.\\n"\n\t    ((fromIntegral$ end - start) / (10^12) :: Double)\n\n     putStrLn "Executing monad-par based sort..."\n     start <- getCPUTime\n     let sorted = sorter rands\n     putStr "Prefix of sorted list:\\n  "\n     print $ V.slice 0 8 sorted\n     end   <- getCPUTime\n     printf "Sorting vector took %0.3f sec.\\n" \n\t    ((fromIntegral$ end - start) / (10^12) :: Double)\n\n--     printf "Checksum: "\n\n     when (exponent <= 4) $ do\n       putStrLn$ "  Unsorted: " ++  show rands\n       putStrLn$ "  Sorted  : " ++  show sorted\n\n\nmain = vecSortMain sort_vector2\n'