b'\xef\xbb\xbf// UVa816 Abbott\'s Revenge\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct Node {\n  int r, c, dir; // \xe7\xab\x99\xe5\x9c\xa8(r,c)\xef\xbc\x8c\xe9\x9d\xa2\xe6\x9c\x9d\xe6\x96\xb9\xe5\x90\x91dir(0~3\xe5\x88\x86\xe5\x88\xab\xe8\xa1\xa8\xe7\xa4\xbaN, E, S, W)\n  Node(int r=0, int c=0, int dir=0):r(r),c(c),dir(dir) {}\n};\n\nconst int maxn = 10;\nconst char* dirs = "NESW"; // \xe9\xa1\xba\xe6\x97\xb6\xe9\x92\x88\xe6\x97\x8b\xe8\xbd\xac\nconst char* turns = "FLR";\n\nint has_edge[maxn][maxn][4][3];\nint d[maxn][maxn][4];\nNode p[maxn][maxn][4];\nint r0, c0, dir, r1, c1, r2, c2;\n\nint dir_id(char c) { return strchr(dirs, c) - dirs; }\nint turn_id(char c) { return strchr(turns, c) - turns; }\n\nconst int dr[] = {-1, 0, 1, 0};\nconst int dc[] = {0, 1, 0, -1};\n\nNode walk(const Node& u, int turn) {\n  int dir = u.dir;\n  if(turn == 1) dir = (dir + 3) % 4; // \xe9\x80\x86\xe6\x97\xb6\xe9\x92\x88\n  if(turn == 2) dir = (dir + 1) % 4; // \xe9\xa1\xba\xe6\x97\xb6\xe9\x92\x88\n  return Node(u.r + dr[dir], u.c + dc[dir], dir);\n}\n\nbool inside(int r, int c) {\n  return r >= 1 && r <= 9 && c >= 1 && c <= 9;\n}\n\nbool read_case() {\n  char s[99], s2[99];\n  if(scanf("%s%d%d%s%d%d", s, &r0, &c0, s2, &r2, &c2) != 6) return false;\n  printf("%s\\n", s);\n\n  dir = dir_id(s2[0]);\n  r1 = r0 + dr[dir];\n  c1 = c0 + dc[dir];\n\n  memset(has_edge, 0, sizeof(has_edge));\n  for(;;) {\n    int r, c;\n    scanf("%d", &r);\n    if(r == 0) break;\n    scanf("%d", &c);\n    while(scanf("%s", s) == 1 && s[0] != \'*\') {\n      for(int i = 1; i < strlen(s); i++)\n        has_edge[r][c][dir_id(s[0])][turn_id(s[i])] = 1;\n    }\n  }\n  return true;\n}\n\nvoid print_ans(Node u) {\n  // \xe4\xbb\x8e\xe7\x9b\xae\xe6\xa0\x87\xe7\xbb\x93\xe7\x82\xb9\xe9\x80\x86\xe5\xba\x8f\xe8\xbf\xbd\xe6\xba\xaf\xe5\x88\xb0\xe5\x88\x9d\xe5\xa7\x8b\xe7\xbb\x93\xe7\x82\xb9\n  vector<Node> nodes;\n  for(;;) {\n    nodes.push_back(u);\n    if(d[u.r][u.c][u.dir] == 0) break;\n    u = p[u.r][u.c][u.dir];\n  }\n  nodes.push_back(Node(r0, c0, dir));\n\n  // \xe6\x89\x93\xe5\x8d\xb0\xe8\xa7\xa3\xef\xbc\x8c\xe6\xaf\x8f\xe8\xa1\x8c10\xe4\xb8\xaa\n  int cnt = 0;\n  for(int i = nodes.size()-1; i >= 0; i--) {\n    if(cnt % 10 == 0) printf(" ");\n    printf(" (%d,%d)", nodes[i].r, nodes[i].c);\n    if(++cnt % 10 == 0) printf("\\n");\n  }\n  if(nodes.size() % 10 != 0) printf("\\n");\n}\n\nvoid solve() {\n  queue<Node> q;\n  memset(d, -1, sizeof(d));\n  Node u(r1, c1, dir);\n  d[u.r][u.c][u.dir] = 0;\n  q.push(u);\n  while(!q.empty()) {\n    Node u = q.front(); q.pop();\n    if(u.r == r2 && u.c == c2) { print_ans(u); return; }\n    for(int i = 0; i < 3; i++) {\n      Node v = walk(u, i);\n      if(has_edge[u.r][u.c][u.dir][i] && inside(v.r, v.c) && d[v.r][v.c][v.dir] < 0) {\n        d[v.r][v.c][v.dir] = d[u.r][u.c][u.dir] + 1;\n        p[v.r][v.c][v.dir] = u;\n        q.push(v);\n      }\n    }\n  }\n  printf("  No Solution Possible\\n");\n}\n\nint main() {\n  while(read_case()) {\n    solve();\n  }\n  return 0;\n}\n'