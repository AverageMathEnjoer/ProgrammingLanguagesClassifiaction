b'#include "stdafx.h"\n#include <stdio.h>\n#include <tchar.h>\n#include <malloc.h>\n#include <assert.h>\n#include "InstallerDataFormat.h"\n#include "ModInstaller.h"\n#include "MakeIconResource.h"\n#include <algorithm>\n\nDWORD GetFileOffsetFromRVA(IMAGE_DOS_HEADER *pDosHeader, DWORD rva)\n{\n\tIMAGE_NT_HEADERS *pNtHeaders = (IMAGE_NT_HEADERS*)((uintptr_t)pDosHeader + pDosHeader->e_lfanew);\n\tIMAGE_SECTION_HEADER *pSectionHeaders = (IMAGE_SECTION_HEADER*)((uintptr_t)pNtHeaders + \n\t\tsizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER) + pNtHeaders->FileHeader.SizeOfOptionalHeader);\n\tfor (unsigned int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++)\n\t{\n\t\tif (rva >= pSectionHeaders[i].VirtualAddress && rva < (pSectionHeaders[i].VirtualAddress + pSectionHeaders[i].SizeOfRawData))\n\t\t{\n\t\t\treturn rva - pSectionHeaders[i].VirtualAddress + pSectionHeaders[i].PointerToRawData;\n\t\t}\n\t}\n\treturn 0;\n}\n//searches an export in a not mapped module (directly loaded as a file)\n//Assumes that all section headers are in bounds.\nDWORD SearchExportByName_RawModule(PIMAGE_DOS_HEADER pModule, size_t fileSize, const char *name)\n{\n\tPIMAGE_NT_HEADERS32 pNTHeaders32 = (PIMAGE_NT_HEADERS32)&((uint8_t*)pModule)[pModule->e_lfanew];\n\tPIMAGE_EXPORT_DIRECTORY pExportsDirectory;\n\tif (pNTHeaders32->FileHeader.Machine == 0x014C)\n\t{\n\t\tDWORD offset = GetFileOffsetFromRVA(pModule, pNTHeaders32->OptionalHeader.DataDirectory[0].VirtualAddress);\n\t\tif (!offset)\n\t\t\treturn 0;\n\t\tpExportsDirectory = (PIMAGE_EXPORT_DIRECTORY)&((uint8_t*)pModule)[offset];\n\t}\n\telse if (pNTHeaders32->FileHeader.Machine == 0x8664) //is AMD64 / 64bit\n\t{\n\t\tPIMAGE_NT_HEADERS64 pNTHeaders64 = (PIMAGE_NT_HEADERS64)pNTHeaders32;\n\t\tDWORD offset = GetFileOffsetFromRVA(pModule, pNTHeaders64->OptionalHeader.DataDirectory[0].VirtualAddress);\n\t\tif (!offset)\n\t\t\treturn 0;\n\t\tpExportsDirectory = (PIMAGE_EXPORT_DIRECTORY)&((uint8_t*)pModule)[offset];\n\t}\n\telse\n\t\treturn 0;\n\tif ((uintptr_t)((uint8_t*)pExportsDirectory - (uint8_t*)pModule) >= fileSize\n\t\t|| (uintptr_t)((uint8_t*)&pExportsDirectory[1] - (uint8_t*)pModule) > fileSize)\n\t\treturn 0;\n\tDWORD nameTableOffset = GetFileOffsetFromRVA(pModule, pExportsDirectory->AddressOfNames);\n\tDWORD nameOrdinalTableOffset = GetFileOffsetFromRVA(pModule, pExportsDirectory->AddressOfNameOrdinals);\n\tDWORD funcTableOffset = GetFileOffsetFromRVA(pModule, pExportsDirectory->AddressOfFunctions);\n\tif ((!nameTableOffset) || (!nameOrdinalTableOffset) || (!funcTableOffset))\n\t\treturn 0;\n\tDWORD *nameTable = (DWORD*)&((uint8_t*)pModule)[nameTableOffset];\n\tif (nameTableOffset >= fileSize || (uint64_t)(nameTableOffset + pExportsDirectory->NumberOfNames * sizeof(DWORD)) > (uint64_t)fileSize)\n\t\treturn 0;\n\tuint16_t *nameOrdinalTable = (uint16_t*)&((uint8_t*)pModule)[nameOrdinalTableOffset];\n\tif (nameOrdinalTableOffset >= fileSize || (uint64_t)(nameOrdinalTableOffset + pExportsDirectory->NumberOfNames * sizeof(uint16_t)) > (uint64_t)fileSize)\n\t\treturn 0;\n\tDWORD *funcTable = (DWORD*)&((uint8_t*)pModule)[funcTableOffset];\n\tif (funcTableOffset >= fileSize || (uint64_t)(funcTableOffset + pExportsDirectory->NumberOfFunctions * sizeof(DWORD)) > (uint64_t)fileSize)\n\t\treturn 0;\n\tfor (DWORD i = 0; i < pExportsDirectory->NumberOfNames; i++)\n\t{\n\t\tif (nameTable[i] != 0)\n\t\t{\n\t\t\tDWORD nameOffset = GetFileOffsetFromRVA(pModule, nameTable[i]);\n\t\t\tif ((nameOffset != 0) && !strcmp((char*)&((uint8_t*)pModule)[nameOffset], name))\n\t\t\t{\n\t\t\t\t//The name ordinal table actually contains indices into the function table (name index -> function ordinal)\n\t\t\t\tDWORD functionIndex = nameOrdinalTable[i]; \n\t\t\t\tif (functionIndex < pExportsDirectory->NumberOfFunctions)\n\t\t\t\t{\n\t\t\t\t\treturn funcTable[functionIndex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic IMAGE_RESOURCE_DIRECTORY_ENTRY *FindResourceDirEntry(IMAGE_DOS_HEADER *pModule, size_t fileSize, DWORD resourceBaseOffset, std::vector<uint16_t> idPath)\n{\n\tIMAGE_RESOURCE_DIRECTORY *pDir = (PIMAGE_RESOURCE_DIRECTORY)&((uint8_t*)pModule)[resourceBaseOffset];\n\twhile (pDir != nullptr && !idPath.empty())\n\t{\n\t\tif ((uintptr_t)pDir - (uintptr_t)pModule >= fileSize || ((uintptr_t)&pDir[1] - (uintptr_t)pModule) > fileSize)\n\t\t\treturn nullptr;\n\t\tIMAGE_RESOURCE_DIRECTORY_ENTRY *pBeginEntry = &((IMAGE_RESOURCE_DIRECTORY_ENTRY*)&pDir[1])[pDir->NumberOfNamedEntries];\n\t\tIMAGE_RESOURCE_DIRECTORY_ENTRY *pEndEntry = &pBeginEntry[pDir->NumberOfIdEntries];\n\t\tif ((uintptr_t)pBeginEntry - (uintptr_t)pModule >= fileSize || ((uintptr_t)pEndEntry - (uintptr_t)pModule) > fileSize)\n\t\t\treturn nullptr;\n\t\t//Note: The resource IDs are actually sorted, so a binary search would be possible.\n\t\t// We have only ~4 entries to search through for the UABE installer, so a linear search is good enough.\n\t\tfor (IMAGE_RESOURCE_DIRECTORY_ENTRY *pCurEntry = pBeginEntry; pCurEntry != pEndEntry; ++pCurEntry)\n\t\t{\n\t\t\tif (!pCurEntry->NameIsString && pCurEntry->Id == idPath.front())\n\t\t\t{\n\t\t\t\tidPath.erase(idPath.begin());\n\t\t\t\tif (idPath.empty())\n\t\t\t\t\treturn pCurEntry;\n\t\t\t\tif (!pCurEntry->DataIsDirectory)\n\t\t\t\t\treturn nullptr;\n\t\t\t\tpDir = (PIMAGE_RESOURCE_DIRECTORY)&((uint8_t*)pModule)[resourceBaseOffset + pCurEntry->OffsetToDirectory];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nullptr;\n}\n\n//Also checks that all section headers are in bounds.\nbool ConvertToEXE(IMAGE_DOS_HEADER *pDLL, size_t fileSize)\n{\n\tIMAGE_NT_HEADERS32 *pNtHeaders = (IMAGE_NT_HEADERS32*)((uintptr_t)pDLL + pDLL->e_lfanew);\n\tif (pDLL->e_lfanew > fileSize || (pDLL->e_lfanew + sizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER)) > fileSize\n\t\t|| (pDLL->e_lfanew + sizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER) + pNtHeaders->FileHeader.SizeOfOptionalHeader) > fileSize)\n\t\treturn false;\n\tIMAGE_SECTION_HEADER *pSectionHeaders = (IMAGE_SECTION_HEADER*)((uintptr_t)pNtHeaders + \n\t\tsizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER) + pNtHeaders->FileHeader.SizeOfOptionalHeader);\n\tif (fileSize < (DWORD)pNtHeaders->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)\n\t\t|| (uintptr_t)((uint8_t*)pSectionHeaders - (uint8_t*)pDLL) > (fileSize - (DWORD)pNtHeaders->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)))\n\t\treturn false;\n\n\tpNtHeaders->FileHeader.Characteristics &= ~0x2000; //disable dll flag\n\t//DWORD winMainOffs = (DWORD)((uintptr_t)GetProcAddress(hModule, "_tWinMain") - (uintptr_t)hModule);\n\tDWORD winMainRVA = SearchExportByName_RawModule(pDLL, fileSize, "_WinMain");\n\tif (!winMainRVA)\n\t\treturn false;\n\t//patch entry point\n\tif (pNtHeaders->FileHeader.Machine == 0x014C) //is i386 / 32bit\n\t\tpNtHeaders->OptionalHeader.AddressOfEntryPoint = winMainRVA;\n\telse if (pNtHeaders->FileHeader.Machine == 0x8664) //is AMD64 / 64bit\n\t\t((IMAGE_NT_HEADERS64*)pNtHeaders)->OptionalHeader.AddressOfEntryPoint = winMainRVA;\n\t\n\t//Find the resources directory.\n\tDWORD resourceDirOffset = 0;\n\tif (pNtHeaders->FileHeader.Machine == 0x014C) //is i386 / 32bit\n\t{\n\t\tif (((uintptr_t)&pNtHeaders->OptionalHeader.DataDirectory[3] - (uintptr_t)pDLL) >= fileSize)\n\t\t\treturn false;\n\t\tresourceDirOffset = GetFileOffsetFromRVA(pDLL, pNtHeaders->OptionalHeader.DataDirectory[2].VirtualAddress);\n\t}\n\telse if (pNtHeaders->FileHeader.Machine == 0x8664) //is AMD64 / 64bit\n\t{\n\t\tPIMAGE_NT_HEADERS64 pNTHeaders64 = (PIMAGE_NT_HEADERS64)pNtHeaders;\n\t\tif (((uintptr_t)&pNTHeaders64->OptionalHeader.DataDirectory[3] - (uintptr_t)pDLL) >= fileSize)\n\t\t\treturn false;\n\t\tresourceDirOffset = GetFileOffsetFromRVA(pDLL, pNTHeaders64->OptionalHeader.DataDirectory[2].VirtualAddress);\n\t}\n\telse\n\t\treturn false;\n\tif (resourceDirOffset == 0)\n\t\treturn false;\n\t\n\t//Fix the manifest resource ID:\n\t//ISOLATIONAWARE_MANIFEST_RESOURCE_ID is the manifest resource ID for dlls, \n\t//CREATEPROCESS_MANIFEST_RESOURCE_ID is the manifest resource ID for exes.\n\t//-> Change the manifest resource ID, since Windows otherwise would not find the manifest upon loading the process.\n\t//The manifest is required to make Windows load the 6.0+ comctrl.dll instead of the pre-XP one that lacks features and looks outdated.\n\tstd::vector<uint16_t> idPath(2); idPath[0] = (uint16_t)RT_MANIFEST; idPath[1] = (uint16_t)ISOLATIONAWARE_MANIFEST_RESOURCE_ID;\n\tIMAGE_RESOURCE_DIRECTORY_ENTRY *pSearchedEntry = FindResourceDirEntry(pDLL, fileSize, resourceDirOffset, std::move(idPath));\n\tif (pSearchedEntry == nullptr)\n\t\treturn false;\n\tpSearchedEntry->Id = (uint16_t)CREATEPROCESS_MANIFEST_RESOURCE_ID;\n\n\treturn true;\n}\n\n//Shifts the imports from MSVC++ redist after the import directories\' null terminator.\n//-> The PE loader will not resolve these imports by itself so they can be resolved by the .exe later.\n//Also gives the new .exe pointers to the new import descriptors.\n//Assumes that all section headers are in bounds.\nint CreateLateResolveImports(IMAGE_DOS_HEADER *pModule, size_t fileSize)\n{\n\tPIMAGE_NT_HEADERS32 pNTHeaders32 = (PIMAGE_NT_HEADERS32)&((uint8_t*)pModule)[pModule->e_lfanew];\n\tIMAGE_IMPORT_DESCRIPTOR *importDir; DWORD importDirRVA;\n\tbool isAMD64 = false;\n\tif (pNTHeaders32->FileHeader.Machine == 0x014C)\n\t{\n\t\tDWORD offset = GetFileOffsetFromRVA(pModule, pNTHeaders32->OptionalHeader.DataDirectory[1].VirtualAddress);\n\t\tif (!offset)\n\t\t\treturn -1;\n\t\timportDirRVA = pNTHeaders32->OptionalHeader.DataDirectory[1].VirtualAddress;\n\t\timportDir = (IMAGE_IMPORT_DESCRIPTOR*)&((uint8_t*)pModule)[offset];\n\t}\n\telse if (pNTHeaders32->FileHeader.Machine == 0x8664) //is AMD64 / 64bit\n\t{\n\t\tisAMD64 = true;\n\t\tPIMAGE_NT_HEADERS64 pNTHeaders64 = (PIMAGE_NT_HEADERS64)pNTHeaders32;\n\t\tDWORD offset = GetFileOffsetFromRVA(pModule, pNTHeaders64->OptionalHeader.DataDirectory[1].VirtualAddress);\n\t\tif (!offset)\n\t\t\treturn -1;\n\t\timportDirRVA = pNTHeaders64->OptionalHeader.DataDirectory[1].VirtualAddress;\n\t\timportDir = (IMAGE_IMPORT_DESCRIPTOR*)&((uint8_t*)pModule)[offset];\n\t}\n\telse\n\t\treturn -1;\n\tif ((uintptr_t)((uint8_t*)importDir - (uint8_t*)pModule) >= fileSize || (uintptr_t)((uint8_t*)&importDir[1] - (uint8_t*)pModule) > fileSize\n\t\t|| fileSize < sizeof(IMAGE_IMPORT_DESCRIPTOR))\n\t\treturn -1;\n\n\tIMAGE_IMPORT_DESCRIPTOR *curImportDir = importDir;\n\tbool patchedMSVCR = false, patchedAssetsTools = false;\n\n\tstatic constexpr size_t maxNumDelayedImports = 32;\n\tstd::vector<DWORD> patchImportDirOffsets;\n\twhile (curImportDir\t&& curImportDir->Name != 0)\n\t{\n\t\tDWORD offset = GetFileOffsetFromRVA(pModule, curImportDir->Name);\n\t\tif (!offset || offset >= fileSize)\n\t\t\tcontinue;\n\t\tconst char *moduleName = (const char*)&((uint8_t*)pModule)[offset];\n\t\tif (!strncmp(moduleName, "MSVCR", 5) || !strncmp(moduleName, "MSVCP", 5) || !strncmp(moduleName, "api-ms", 5)\n\t\t\t|| !strncmp(moduleName, "VCRUNTIME", 9) || !strncmp(moduleName, "ucrt", 4))\n\t\t{\n\t\t\tpatchImportDirOffsets.push_back((DWORD)((uintptr_t)curImportDir - (uintptr_t)pModule));\n\t\t}\n\t\t{\n\t\t\t/*DWORD offset = GetFileOffsetFromRVA(pModule, curImportDir->OriginalFirstThunk);\n\t\t\tif (!offset)\n\t\t\t\tcontinue;\n\t\t\tIMAGE_THUNK_DATA *pThunkData = (IMAGE_THUNK_DATA*)&((uint8_t*)pModule)[offset];*/\n\t\t}\n\t\t++curImportDir;\n\t}\n\t//Check bounds for null-terminating import descriptor.\n\tif (curImportDir && (uintptr_t)((uint8_t*)curImportDir - (uint8_t*)pModule) > fileSize - sizeof(IMAGE_IMPORT_DESCRIPTOR))\n\t\treturn -1;\n\tif (patchImportDirOffsets.size() > maxNumDelayedImports)\n\t\tpatchImportDirOffsets.resize(maxNumDelayedImports);\n\n\tfor (size_t i = 0; i < patchImportDirOffsets.size(); i++)\n\t{\n\t\t//Move the current import descriptor past the null terminator.\n\t\tIMAGE_IMPORT_DESCRIPTOR *curImportDir = ((IMAGE_IMPORT_DESCRIPTOR*)&((uint8_t*)pModule)[patchImportDirOffsets[i]]);\n\t\tIMAGE_IMPORT_DESCRIPTOR tempCopy = *curImportDir;\n\t\tIMAGE_IMPORT_DESCRIPTOR *lastImportDir;\n\t\tdo\n\t\t{\n\t\t\tlastImportDir = curImportDir;\n\t\t\tcurImportDir = (IMAGE_IMPORT_DESCRIPTOR*)&((uint8_t*)curImportDir)[sizeof(IMAGE_IMPORT_DESCRIPTOR)];\n\t\t\tmemcpy(lastImportDir, curImportDir, sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\t\t} while (curImportDir && curImportDir->Name);\n\t\tmemcpy(curImportDir, &tempCopy, sizeof(IMAGE_IMPORT_DESCRIPTOR));\n\t\t//Correct the offsets for the other descriptors that were just shifted in the opposite direction.\n\t\t//-> Note: patchImportDirOffsets[0..i-1] are already moved past the null terminator, and hence are not touched again.\n\t\tfor (size_t k = i+1; k < patchImportDirOffsets.size(); k++)\n\t\t{\n\t\t\tif (patchImportDirOffsets[k] > patchImportDirOffsets[i])\n\t\t\t\tpatchImportDirOffsets[k] -= sizeof(IMAGE_IMPORT_DESCRIPTOR);\n\t\t}\n\t\t//Correct the offset for the current descriptor.\n\t\tpatchImportDirOffsets[i] = (DWORD)( ((uintptr_t)curImportDir - (uintptr_t)importDir) + (DWORD)importDirRVA);\n\t}\n\tDWORD importDirRVABack_RVA = SearchExportByName_RawModule(pModule, fileSize, "delayResolveImportRVAs");\n\tif (!importDirRVABack_RVA)\n\t\treturn -2;\n\tDWORD importDirRVABack_Offset = GetFileOffsetFromRVA(pModule, importDirRVABack_RVA);\n\tif (!importDirRVABack_Offset || importDirRVABack_Offset >= fileSize || importDirRVABack_Offset + patchImportDirOffsets.size() > fileSize)\n\t\treturn -2;\n\tmemcpy(&((uint8_t*)pModule)[importDirRVABack_Offset], patchImportDirOffsets.data(), patchImportDirOffsets.size() * sizeof(DWORD));\n\treturn 0;\n}\n\n__declspec(dllexport) bool MakeInstaller(const TCHAR *installerDllPath, InstallerPackageFile *installerData, const TCHAR *outPath, const std::vector<uint8_t> &iconData)\n{\n\tstd::unique_ptr<IAssetsReader> pDllReader(Create_AssetsReaderFromFile(installerDllPath, true, RWOpenFlags_Immediately));\n\tif (!pDllReader)\n\t\treturn false;\n\n\tpDllReader->Seek(AssetsSeek_End, 0);\n\tQWORD fileSize = 0;\n\tpDllReader->Tell(fileSize);\n\tfileSize = (size_t)fileSize;\n\tpDllReader->Seek(AssetsSeek_Begin, 0);\n\tstd::vector<uint8_t> fileBuf(fileSize+2); //Two extra bytes as a \'security\' null terminator for strings.\n\tpDllReader->Read(fileSize, fileBuf.data());\n\tpDllReader.reset();\n\n\tif (!ConvertToEXE((IMAGE_DOS_HEADER*)fileBuf.data(), fileSize))\n\t\treturn false;\n\tif (CreateLateResolveImports((IMAGE_DOS_HEADER*)fileBuf.data(), fileSize) < 0)\n\t\treturn false;\n\t\n\tstd::unique_ptr<IAssetsWriter> pExeWriter(Create_AssetsWriterToFile(outPath, true, true, RWOpenFlags_Immediately));\n\tif (!pExeWriter)\n\t\treturn false;\n\tpExeWriter->Write(fileSize, fileBuf.data());\n\tpExeWriter.reset();\n\tfileBuf = std::vector<uint8_t>(); assert(fileBuf.empty());\n\n\t//Set the icon resource, if requested.\n\t//-> Do it before appending the resource data, as it can change the PE file size.\n\tif (!iconData.empty())\n\t\tSetProgramIconResource(outPath, iconData);\n\t\n\t//Reopen the exe file for reading, potentially with the icon resource attached.\n\tstd::unique_ptr<IAssetsReader> pExeReader(Create_AssetsReaderFromFile(outPath, true, RWOpenFlags_Immediately));\n\tif (!pExeReader)\n\t\treturn false;\n\t//Retrieve the PE overlay offset.\n\tsize_t overlayOffset = GetPEOverlayOffset(pExeReader.get());\n\tif (overlayOffset == 0)\n\t\treturn false;\n\tpExeReader.reset();\n\n\t//Now append the installer package as the overlay.\n\tpExeWriter.reset(Create_AssetsWriterToFile(outPath, false, true, RWOpenFlags_Immediately));\n\tif (!pExeWriter)\n\t\treturn false;\n\tpExeWriter->Seek(AssetsSeek_End, 0);\n\tQWORD endPos = 0;\n\tpExeWriter->Tell(endPos);\n\t//Test the assumption: End of file == overlay start.\n\tif (endPos != overlayOffset)\n\t\treturn false;\n\tbool ret = installerData->Write(endPos, pExeWriter.get());\n\tpExeWriter.reset();\n\n\treturn ret;\n}'