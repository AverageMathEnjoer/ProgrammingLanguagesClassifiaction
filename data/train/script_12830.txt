b'{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE OverloadedStrings #-}\n\n{- mimic server side session store -}\n\nmodule Session where\n\nimport Control.Concurrent.MVar\nimport Control.Monad.IO.Class\nimport Control.Monad.Trans.Except\nimport Data.HashMap.Strict qualified as Map\nimport Data.Text.Lazy qualified as TL\nimport Types\n\ntype CacheStore = MVar (Map.HashMap TL.Text DemoAppEnv)\n\ninitCacheStore :: IO CacheStore\ninitCacheStore = newMVar Map.empty\n\nallValues :: CacheStore -> IO [DemoAppEnv]\nallValues store = do\n  m1 <- tryReadMVar store\n  return $ maybe [] Map.elems m1\n\nremoveKey :: CacheStore -> TL.Text -> IO ()\nremoveKey store idpKey = do\n  m1 <- takeMVar store\n  let m2 = Map.update updateIdpData idpKey m1\n  putMVar store m2\n  where\n    updateIdpData (DemoAppEnv app sessionD) = Just (DemoAppEnv app sessionD {loginUser = Nothing})\n\nlookupKey ::\n  MonadIO m =>\n  CacheStore ->\n  TL.Text ->\n  ExceptT TL.Text m DemoAppEnv\nlookupKey store idpKey = ExceptT $ do\n  m1 <- liftIO $ tryReadMVar store\n  return $ maybe (Left ("unknown Idp " <> idpKey)) Right (Map.lookup idpKey =<< m1)\n\nupsertDemoAppEnv :: MonadIO m => CacheStore -> DemoAppEnv -> ExceptT TL.Text m ()\nupsertDemoAppEnv store val = liftIO $ do\n  m1 <- takeMVar store\n  let m2 =\n        if Map.member (toLabel val) m1\n          then Map.adjust (const val) (toLabel val) m1\n          else Map.insert (toLabel val) val m1\n  putMVar store m2\n'