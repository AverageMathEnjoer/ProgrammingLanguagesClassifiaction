b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This is the implementation of generic hash-tables\n    ** used in SQLite.\n    **\n    ** $Id: hash.c,v 1.38 2009/05/09 23:29:12 drh Exp\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n    //#include <assert.h>\n\n    /* Turn bulk memory into a hash table object by initializing the\n    ** fields of the Hash structure.\n    **\n    ** "pNew" is a pointer to the hash table that is to be initialized.\n    */\n    static void sqlite3HashInit( Hash pNew )\n    {\n      Debug.Assert( pNew != null );\n      pNew.first = null;\n      pNew.count = 0;\n      pNew.htsize = 0;\n      pNew.ht = null;\n    }\n\n    /* Remove all entries from a hash table.  Reclaim all memory.\n    ** Call this routine to delete a hash table or to reset a hash table\n    ** to the empty state.\n    */\n    static void sqlite3HashClear( Hash pH )\n    {\n      HashElem elem;         /* For looping over all elements of the table */\n\n      Debug.Assert( pH != null );\n      elem = pH.first;\n      pH.first = null;\n      //sqlite3_free( ref  pH.ht );\n      pH.ht = null;\n      pH.htsize = 0;\n      while ( elem != null )\n      {\n        HashElem next_elem = elem.next;\n        ////sqlite3_free(ref  elem );\n        elem = next_elem;\n      }\n      pH.count = 0;\n    }\n\n    /*\n    ** The hashing function.\n    */\n    static u32 strHash( string z, int nKey )\n    {\n      int h = 0;\n      Debug.Assert( nKey >= 0 );\n      int _z = 0;\n      while ( nKey > 0 )\n      {\n        h = ( h << 3 ) ^ h ^ ( ( _z < z.Length ) ? (int)sqlite3UpperToLower[(byte)z[_z++]] : 0 );\n        nKey--;\n      }\n      return (u32)h;\n    }\n\n    /* Link pNew element into the hash table pH.  If pEntry!=0 then also\n    ** insert pNew into the pEntry hash bucket.\n    */\n    static void insertElement(\n    Hash pH,              /* The complete hash table */\n    _ht pEntry,           /* The entry into which pNew is inserted */\n    HashElem pNew         /* The element to be inserted */\n    )\n    {\n      HashElem pHead;       /* First element already in pEntry */\n      if ( pEntry != null )\n      {\n        pHead = pEntry.count != 0 ? pEntry.chain : null;\n        pEntry.count++;\n        pEntry.chain = pNew;\n      }\n      else\n      {\n        pHead = null;\n      }\n      if ( pHead != null )\n      {\n        pNew.next = pHead;\n        pNew.prev = pHead.prev;\n        if ( pHead.prev != null ) { pHead.prev.next = pNew; }\n        else { pH.first = pNew; }\n        pHead.prev = pNew;\n      }\n      else\n      {\n        pNew.next = pH.first;\n        if ( pH.first != null ) { pH.first.prev = pNew; }\n        pNew.prev = null;\n        pH.first = pNew;\n      }\n    }\n\n    /* Resize the hash table so that it cantains "new_size" buckets.\n    **\n    ** The hash table might fail to resize if sqlite3_malloc() fails or\n    ** if the new size is the same as the prior size.\n    ** Return TRUE if the resize occurs and false if not.\n    */\n    static bool rehash( ref Hash pH, u32 new_size )\n    {\n      _ht[] new_ht;            /* The new hash table */\n      HashElem elem;\n      HashElem next_elem;    /* For looping over existing elements */\n\n#if SQLITE_MALLOC_SOFT_LIMIT\nif( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){\nnew_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht);\n}\nif( new_size==pH->htsize ) return false;\n#endif\n\n      /* There is a call to sqlite3Malloc() inside rehash(). If there is\n** already an allocation at pH.ht, then if this malloc() fails it\n** is benign (since failing to resize a hash table is a performance\n** hit only, not a fatal error).\n*/\n      sqlite3BeginBenignMalloc();\n      new_ht = new _ht[new_size]; //(struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );\n      for ( int i = 0 ; i < new_size ; i++ ) new_ht[i] = new _ht();\n      sqlite3EndBenignMalloc();\n\n      if ( new_ht == null ) return false;\n      //sqlite3_free( ref  pH.ht );\n      pH.ht = new_ht;\n      // pH.htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);\n      //memset(new_ht, 0, new_size*sizeof(struct _ht));\n      pH.htsize = new_size;\n\n      for ( elem = pH.first, pH.first = null ; elem != null ; elem = next_elem )\n      {\n        u32 h = strHash( elem.pKey, elem.nKey ) % new_size;\n        next_elem = elem.next;\n        insertElement( pH, new_ht[h], elem );\n      }\n      return true;\n    }\n\n    /* This function (for internal use only) locates an element in an\n    ** hash table that matches the given key.  The hash for this key has\n    ** already been computed and is passed as the 4th parameter.\n    */\n    static HashElem findElementGivenHash(\n    Hash pH,       /* The pH to be searched */\n    string pKey,   /* The key we are searching for */\n    int nKey,      /* Bytes in key (not counting zero terminator) */\n    u32 h         /* The hash for this key. */\n    )\n    {\n      HashElem elem;                /* Used to loop thru the element list */\n      int count;                    /* Number of elements left to test */\n\n      if ( pH.ht != null && pH.ht[h] != null )\n      {\n        _ht pEntry = pH.ht[h];\n        elem = pEntry.chain;\n        count = (int)pEntry.count;\n      }\n      else\n      {\n        elem = pH.first;\n        count = (int)pH.count;\n      }\n      while ( count-- > 0 && ALWAYS( elem ) )\n      {\n        if ( elem.nKey == nKey && sqlite3StrNICmp( elem.pKey, pKey, nKey ) == 0 )\n        {\n          return elem;\n        }\n        elem = elem.next;\n      }\n      return null;\n    }\n\n    /* Remove a single entry from the hash table given a pointer to that\n    ** element and a hash on the element\'s key.\n    */\n    static void removeElementGivenHash(\n    Hash pH,            /* The pH containing "elem" */\n    ref HashElem elem,  /* The element to be removed from the pH */\n    u32 h               /* Hash value for the element */\n    )\n    {\n      _ht pEntry;\n      if ( elem.prev != null )\n      {\n        elem.prev.next = elem.next;\n      }\n      else\n      {\n        pH.first = elem.next;\n      }\n      if ( elem.next != null )\n      {\n        elem.next.prev = elem.prev;\n      }\n      if ( pH.ht != null && pH.ht[h] != null )\n      {\n        pEntry = pH.ht[h];\n        if ( pEntry.chain == elem )\n        {\n          pEntry.chain = elem.next;\n        }\n        pEntry.count--;\n        Debug.Assert( pEntry.count >= 0 );\n      }\n      //sqlite3_free( ref  elem );\n      pH.count--;\n      if ( pH.count <= 0 )\n      {\n        Debug.Assert( pH.first == null );\n        Debug.Assert( pH.count == 0 );\n        sqlite3HashClear( pH );\n      }\n    }\n\n    /* Attempt to locate an element of the hash table pH with a key\n    ** that matches pKey,nKey.  Return the data for this element if it is\n    ** found, or NULL if there is no match.\n    */\n    static object sqlite3HashFind( Hash pH, string pKey, int nKey )\n    {\n      HashElem elem;  /* The element that matches key */\n      u32 h;          /* A hash on key */\n\n      Debug.Assert( pH != null );\n      Debug.Assert( pKey != null );\n      Debug.Assert( nKey >= 0 );\n      if ( pH.ht != null )\n      {\n        h = strHash( pKey, nKey ) % pH.htsize;\n      }\n      else\n      {\n        h = 0;\n      }\n      elem = findElementGivenHash( pH, pKey, nKey, h );\n      return elem != null ? elem.data : null;\n    }\n\n    /* Insert an element into the hash table pH.  The key is pKey,nKey\n    ** and the data is "data".\n    **\n    ** If no element exists with a matching key, then a new\n    ** element is created and NULL is returned.\n    **\n    ** If another element already exists with the same key, then the\n    ** new data replaces the old data and the old data is returned.\n    ** The key is not copied in this instance.  If a malloc fails, then\n    ** the new data is returned and the hash table is unchanged.\n    **\n    ** If the "data" parameter to this function is NULL, then the\n    ** element corresponding to "key" is removed from the hash table.\n    */\n    static object sqlite3HashInsert( ref Hash pH, string pKey, int nKey, object data )\n    {\n      u32 h;       /* the hash of the key modulo hash table size */\n\n      HashElem elem;       /* Used to loop thru the element list */\n      HashElem new_elem;   /* New element added to the pH */\n\n      Debug.Assert( pH != null );\n      Debug.Assert( pKey != null );\n      Debug.Assert( nKey >= 0 );\n\n      if ( pH.htsize != 0 )\n      {\n        h = strHash( pKey, nKey ) % pH.htsize;\n      }\n      else\n      {\n        h = 0;\n      }\n      elem = findElementGivenHash( pH, pKey, nKey, h );\n      if ( elem != null )\n      {\n        object old_data = elem.data;\n        if ( data == null )\n        {\n          removeElementGivenHash( pH, ref elem, h );\n        }\n        else\n        {\n          elem.data = data;\n          elem.pKey = pKey;\n          Debug.Assert( nKey == elem.nKey );\n        }\n        return old_data;\n      }\n      if ( data == null ) return null;\n      new_elem = new HashElem();//(HashElem*)sqlite3Malloc( sizeof(HashElem) );\n      if ( new_elem == null ) return data;\n      new_elem.pKey = pKey;\n      new_elem.nKey = nKey;\n      new_elem.data = data;\n      pH.count++;\n      if ( pH.count >= 10 && pH.count > 2 * pH.htsize )\n      {\n        if ( rehash( ref  pH, pH.count * 2 ) )\n        {\n          Debug.Assert( pH.htsize > 0 );\n          h = strHash( pKey, nKey ) % pH.htsize;\n        }\n      }\n      if ( pH.ht != null )\n      {\n        insertElement( pH, pH.ht[h], new_elem );\n\n      }\n      else\n      {\n        insertElement( pH, null, new_elem );\n      }\n      return null;\n    }\n\n  }\n}\n'