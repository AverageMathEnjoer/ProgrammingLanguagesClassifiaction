b'using System.Diagnostics;\n\nnamespace CS_SQLite3\n{\n\n  using u8 = System.Byte;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** An tokenizer for SQL\n    **\n    ** This file contains C code that implements the sqlite3_complete() API.\n    ** This code used to be part of the tokenizer.c source file.  But by\n    ** separating it out, the code will be automatically omitted from\n    ** static links that do not use it.\n    **\n    ** $Id: complete.c,v 1.8 2009/04/28 04:46:42 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n#if !SQLITE_OMIT_COMPLETE\n\n    /*\n** This is defined in tokenize.c.  We just have to import the definition.\n*/\n#if !SQLITE_AMALGAMATION\n#if  SQLITE_ASCII\n    //extern const char sqlite3IsAsciiIdChar[];\n    //#define IdChar(C)  (((c=C)&0x80)!=0 || (c>0x1f && sqlite3IsAsciiIdChar[c-0x20]))\n    static bool IdChar( u8 C ) { u8 c; return ( ( c = C ) & 0x80 ) != 0 || ( c > 0x1f && sqlite3IsAsciiIdChar[c - 0x20] ); }\n#endif\n#if  SQLITE_EBCDIC\n//extern const char sqlite3IsEbcdicIdChar[];\n//#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))\n#endif\n#endif // * SQLITE_AMALGAMATION */\n\n\n    /*\n** Token types used by the sqlite3_complete() routine.  See the header\n** comments on that procedure for additional information.\n*/\n    const int tkSEMI = 0;\n    const int tkWS = 1;\n    const int tkOTHER = 2;\n    const int tkEXPLAIN = 3;\n    const int tkCREATE = 4;\n    const int tkTEMP = 5;\n    const int tkTRIGGER = 6;\n    const int tkEND = 7;\n\n    /*\n    ** Return TRUE if the given SQL string ends in a semicolon.\n    **\n    ** Special handling is require for CREATE TRIGGER statements.\n    ** Whenever the CREATE TRIGGER keywords are seen, the statement\n    ** must end with ";END;".\n    **\n    ** This implementation uses a state machine with 7 states:\n    **\n    **   (0) START     At the beginning or end of an SQL statement.  This routine\n    **                 returns 1 if it ends in the START state and 0 if it ends\n    **                 in any other state.\n    **\n    **   (1) NORMAL    We are in the middle of statement which ends with a single\n    **                 semicolon.\n    **\n    **   (2) EXPLAIN   The keyword EXPLAIN has been seen at the beginning of\n    **                 a statement.\n    **\n    **   (3) CREATE    The keyword CREATE has been seen at the beginning of a\n    **                 statement, possibly preceeded by EXPLAIN and/or followed by\n    **                 TEMP or TEMPORARY\n    **\n    **   (4) TRIGGER   We are in the middle of a trigger definition that must be\n    **                 ended by a semicolon, the keyword END, and another semicolon.\n    **\n    **   (5) SEMI      We\'ve seen the first semicolon in the ";END;" that occurs at\n    **                 the end of a trigger definition.\n    **\n    **   (6) END       We\'ve seen the ";END" of the ";END;" that occurs at the end\n    **                 of a trigger difinition.\n    **\n    ** Transitions between states above are determined by tokens extracted\n    ** from the input.  The following tokens are significant:\n    **\n    **   (0) tkSEMI      A semicolon.\n    **   (1) tkWS        Whitespace\n    **   (2) tkOTHER     Any other SQL token.\n    **   (3) tkEXPLAIN   The "explain" keyword.\n    **   (4) tkCREATE    The "create" keyword.\n    **   (5) tkTEMP      The "temp" or "temporary" keyword.\n    **   (6) tkTRIGGER   The "trigger" keyword.\n    **   (7) tkEND       The "end" keyword.\n    **\n    ** Whitespace never causes a state transition and is always ignored.\n    **\n    ** If we compile with SQLITE_OMIT_TRIGGER, all of the computation needed\n    ** to recognize the end of a trigger can be omitted.  All we have to do\n    ** is look for a semicolon that is not part of an string or comment.\n    */\n    public static int sqlite3_complete( string zSql )\n    {\n      int state = 0;   /* Current state, using numbers defined in header comment */\n      int token;       /* Value of the next token */\n\n#if !SQLITE_OMIT_TRIGGER\n      /* A complex statement machine used to detect the end of a CREATE TRIGGER\n** statement.  This is the normal case.\n*/\n      u8[][] trans = new u8[][]       {\n/* Token:                                                */\n/* State:       **  SEMI  WS  OTHER EXPLAIN  CREATE  TEMP  TRIGGER  END  */\n/* 0   START: */ new u8[] {    0,  0,     1,      2,      3,    1,       1,   1,  },\n/* 1  NORMAL: */  new u8[]{    0,  1,     1,      1,      1,    1,       1,   1,  },\n/* 2 EXPLAIN: */  new u8[]{    0,  2,     2,      1,      3,    1,       1,   1,  },\n/* 3  CREATE: */  new u8[]{    0,  3,     1,      1,      1,    3,       4,   1,  },\n/* 4 TRIGGER: */  new u8[]{    5,  4,     4,      4,      4,    4,       4,   4,  },\n/* 5    SEMI: */  new u8[]{    5,  5,     4,      4,      4,    4,       4,   6,  },\n/* 6     END: */  new u8[]{    0,  6,     4,      4,      4,    4,       4,   4,  },\n};\n#else\n/* If triggers are not suppored by this compile then the statement machine\n** used to detect the end of a statement is much simplier\n*/\nstatic const u8 trans[2][3] = {\n/* Token:           */\n/* State:       **  SEMI  WS  OTHER */\n/* 0   START: */ {    0,  0,     1, },\n/* 1  NORMAL: */ {    0,  1,     1, },\n};\n#endif // * SQLITE_OMIT_TRIGGER */\n\n      int zIdx = 0;\n      while ( zIdx < zSql.Length )\n      {\n        switch ( zSql[zIdx] )\n        {\n          case \';\':\n            {  /* A semicolon */\n              token = tkSEMI;\n              break;\n            }\n          case \' \':\n          case \'\\r\':\n          case \'\\t\':\n          case \'\\n\':\n          case \'\\f\':\n            {  /* White space is ignored */\n              token = tkWS;\n              break;\n            }\n          case \'/\':\n            {   /* C-style comments */\n              if ( zSql[zIdx + 1] != \'*\' )\n              {\n                token = tkOTHER;\n                break;\n              }\n              zIdx += 2;\n              while ( zIdx < zSql.Length && zSql[zIdx] != \'*\' || zIdx < zSql.Length - 1 && zSql[zIdx + 1] != \'/\' ) { zIdx++; }\n              if ( zIdx == zSql.Length ) return 0;\n              zIdx++;\n              token = tkWS;\n              break;\n            }\n          case \'-\':\n            {   /* SQL-style comments from "--" to end of line */\n              if ( zSql[zIdx + 1] != \'-\' )\n              {\n                token = tkOTHER;\n                break;\n              }\n              while ( zIdx < zSql.Length && zSql[zIdx] != \'\\n\' ) { zIdx++; }\n              if ( zIdx == zSql.Length ) return state == 0 ? 1 : 0;\n              token = tkWS;\n              break;\n            }\n          case \'[\':\n            {   /* Microsoft-style identifiers in [...] */\n              zIdx++;\n              while ( zIdx < zSql.Length && zSql[zIdx] != \']\' ) { zIdx++; }\n              if ( zIdx == zSql.Length ) return 0;\n              token = tkOTHER;\n              break;\n            }\n          case \'`\':     /* Grave-accent quoted symbols used by MySQL */\n          case \'"\':     /* single- and double-quoted strings */\n          case \'\\\'\':\n            {\n              int c = zSql[zIdx];\n              zIdx++;\n              while ( zIdx < zSql.Length && zSql[zIdx] != c ) { zIdx++; }\n              if ( zIdx == zSql.Length ) return 0;\n              token = tkOTHER;\n              break;\n            }\n          default:\n            {\n              int c;\n              if ( IdChar( (u8)zSql[zIdx] ) )\n              {\n                /* Keywords and unquoted identifiers */\n                int nId;\n                for ( nId = 1 ; ( zIdx + nId ) < zSql.Length && IdChar( (u8)zSql[zIdx + nId] ) ; nId++ ) { }\n#if  SQLITE_OMIT_TRIGGER\ntoken = tkOTHER;\n#else\n                switch ( zSql[zIdx] )\n                {\n                  case \'c\':\n                  case \'C\':\n                    {\n                      if ( nId == 6 && sqlite3StrNICmp( zSql, zIdx, "create", 6 ) == 0 )\n                      {\n                        token = tkCREATE;\n                      }\n                      else\n                      {\n                        token = tkOTHER;\n                      }\n                      break;\n                    }\n                  case \'t\':\n                  case \'T\':\n                    {\n                      if ( nId == 7 && sqlite3StrNICmp( zSql, zIdx, "trigger", 7 ) == 0 )\n                      {\n                        token = tkTRIGGER;\n                      }\n                      else if ( nId == 4 && sqlite3StrNICmp( zSql, zIdx, "temp", 4 ) == 0 )\n                      {\n                        token = tkTEMP;\n                      }\n                      else if ( nId == 9 && sqlite3StrNICmp( zSql, zIdx, "temporary", 9 ) == 0 )\n                      {\n                        token = tkTEMP;\n                      }\n                      else\n                      {\n                        token = tkOTHER;\n                      }\n                      break;\n                    }\n                  case \'e\':\n                  case \'E\':\n                    {\n                      if ( nId == 3 && sqlite3StrNICmp( zSql, zIdx, "end", 3 ) == 0 )\n                      {\n                        token = tkEND;\n                      }\n                      else\n#if ! SQLITE_OMIT_EXPLAIN\n                        if ( nId == 7 && sqlite3StrNICmp( zSql, zIdx, "explain", 7 ) == 0 )\n                        {\n                          token = tkEXPLAIN;\n                        }\n                        else\n#endif\n                        {\n                          token = tkOTHER;\n                        }\n                      break;\n                    }\n                  default:\n                    {\n                      token = tkOTHER;\n                      break;\n                    }\n                }\n#endif // * SQLITE_OMIT_TRIGGER */\n                zIdx += nId - 1;\n              }\n              else\n              {\n                /* Operators and special symbols */\n                token = tkOTHER;\n              }\n              break;\n            }\n        }\n        state = trans[state][token];\n        zIdx++;\n      }\n      return ( state == 0 ) ? 1 : 0;\n    }\n\n#if ! SQLITE_OMIT_UTF16\n/*\n** This routine is the same as the sqlite3_complete() routine described\n** above, except that the parameter is required to be UTF-16 encoded, not\n** UTF-8.\n*/\nint sqlite3_complete16(const void *zSql){\nsqlite3_value pVal;\nchar const *zSql8;\nint rc = SQLITE_NOMEM;\n\n#if !SQLITE_OMIT_AUTOINIT\nrc = sqlite3_initialize();\nif( rc !=0) return rc;\n#endif\npVal = sqlite3ValueNew(0);\nsqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC);\nzSql8 = sqlite3ValueText(pVal, SQLITE_UTF8);\nif( zSql8 ){\nrc = sqlite3_complete(zSql8);\n}else{\nrc = SQLITE_NOMEM;\n}\nsqlite3ValueFree(pVal);\nreturn sqlite3ApiExit(0, rc);\n}\n#endif // * SQLITE_OMIT_UTF16 */\n#endif // * SQLITE_OMIT_COMPLETE */\n  }\n}\n'