b'\nmodule GrammarChecker (Option(..), GrammaticalUnits(..), checkGrammar) where\n\nimport Data.Map (Map, (!))\nimport Data.List (stripPrefix)\n\n-- En Token \xc3\xa4r det som i BNF skulle vara inom <>\n-- En Literal \xc3\xa4r det som i BNF skulle vara inom ""\n--\n-- testliteral kontrollerar om det finns en Literal (av flera m\xc3\xb6jliga)\n--     i b\xc3\xb6rjan av kodstr\xc3\xa4ngen\n-- testtoken kontrollerar om det finns en Token (av en flera m\xc3\xb6jliga)\n--     i b\xc3\xb6rjan av kodstr\xc3\xa4ngen\n--\n-- testgrammar tar vad som skulle vara en hel rad i BNF och kontrollerar\n--     om den finns i b\xc3\xb6rjan av kodstr\xc3\xa4ngen\n\ntype Literal = String\ntype Token = String\ntype Code = String\n\ndata GrammaticalUnits = Tokens Option [Token]\n                      | Literals Option [Literal]\ndata Option = Mandatory | Optional\noptional (Tokens Optional _) = True\noptional (Literals Optional _) = True\noptional _ = False\n\n\ntestliteral :: [Literal] -> Code -> (Bool, Code)\ntestliteral [] code = (False, code)\ntestliteral (literal:literals) code =\n  case stripPrefix literal code of\n       Just new -> (True, new)\n       Nothing -> testliteral literals code\n\ntesttoken :: Map Token [GrammaticalUnits] -> Code -> [Token] -> (Bool, Code)\ntesttoken _ [] _ = (True, [])\ntesttoken _ code [] = (False, code)\ntesttoken syntaxmap code (t:tokens) =\n  let (yn, new) = testgrammar syntaxmap code $ syntaxmap ! t\n  in  if yn\n         then (True, new)\n         else testtoken syntaxmap code tokens\n\ntestgrammar :: Map Token [GrammaticalUnits] -> Code -> [GrammaticalUnits] -> (Bool, Code)\ntestgrammar _ [] [] = (True, [])\ntestgrammar _ code [] = (True, code)\ntestgrammar syntaxmap code (first:rest) =\n  let (yn, new) = case first of\n                       Tokens _ tokens -> testtoken syntaxmap code tokens\n                       Literals _ literals -> testliteral literals code\n  in  if yn\n         then testgrammar syntaxmap new rest\n         else if optional first\n              then testgrammar syntaxmap code rest\n              else (False, code)\n\ncheckGrammar :: Map Token [GrammaticalUnits] -> Code -> Token -> (Bool, Code)\ncheckGrammar syntaxmap code initial =\n  let (yn, rest) = testgrammar syntaxmap code $ syntaxmap ! initial\n  in  if not $ null rest\n         then (False, rest)\n         else (yn, rest)\n'