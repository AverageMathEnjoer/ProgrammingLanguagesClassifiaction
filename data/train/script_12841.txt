b'import Control.Applicative((<|>))\nimport Data.Char (isSpace)\nimport Text.Trifecta\nimport System.Environment (getArgs)\n\ndata SExpr = Atom String | List [SExpr] deriving Show\n\nprogram :: Parser [SExpr]\nprogram = sexpr `sepEndBy` spaces\n\nsexpr :: Parser SExpr\nsexpr =  list <|> atom\n\natom :: Parser SExpr\natom = Atom <$> some identifierChar <* spaces\n\nidentifierChar :: Parser Char\nidentifierChar = satisfy $ \\c -> not (isSpace c) && c /= \'(\' && c /= \')\'\n\nlist :: Parser SExpr\nlist = do\n  symbol "("\n  ret <- many sexpr\n  symbol ")"\n  return $ List ret\n\nprocessFile :: FilePath -> IO ()\nprocessFile filename = do\n  result <- parseFromFile program filename\n  case result of\n    Nothing -> putStrLn "parse error."\n    Just x -> mapM_ print x\n\nmain :: IO ()\nmain = do\n  filenames <- getArgs\n  mapM_ processFile filenames\n'