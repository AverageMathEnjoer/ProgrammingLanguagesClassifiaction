b'{-# LANGUAGE BangPatterns, CPP #-}\n-- Author: Ryan Newton \n\n-- Embarassingly parallel.\n-- If this doesn\'t get a speedup nothing will!\n\n-- Note: This program is an example of a program that depends\n-- critically on "put" being strict.  If it were not the real work\n-- would be deferred until after the parallel computation is finished!\n\nimport GHC.Conc\nimport Debug.Trace\nimport Control.Monad\nimport System.Environment\n\nimport Microbench.Flops\n-- import Control.Monad.Par.Scheds.Trace\nimport Control.Exception\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\nputs = unsafeIO . putStr\n\nrunit total = runPar$ do\n\n  let oneshare = total `quot` numCapabilities\n      mystep jid = do \n        tid <- unsafeIO myThreadId \n\tputs (show tid++" job "++show jid++":  About to do work chunk ("++ show oneshare ++" iterations)...\\n")\n--        let res = work (oneshare * jid) oneshare 0.0\n\t--tid2 <- S.lift$ myThreadId \n--\tstepPutStr (show tid++"   job "++show jid++":  done with work (result "++ show res ++"), putting item...\\n")\n        return$ sillysum (oneshare * jid) oneshare \n\n--      fn jid = work (oneshare * jid) oneshare 0.0\n\n  puts$ "Running embarassingly parallel benchmark.  Monad par variant: "++ show "hmm..." ++"\\n"\n  puts$ "Running "++ show total ++" total iterations\\n"\n  puts$ "Begin initialize.  Splitting work into "++show numCapabilities++" pieces\\n"\n\n  ivs <- mapM (spawn_ . mystep) [0 .. numCapabilities-1]\n\n  puts$ "About to block on output:\\n"\n  final <- \n\t    foldM (\\ acc i -> \n\t\t    do n <- get i\n\t\t       return (acc + n)) \n\t\t  0.0 ivs\n  puts$ "Final Output: " ++ show final ++"\\n"\n  return final\n\n\nmain = do args <- getArgs \n\t  let x = loop args\n          putStrLn$ "Done: "++ show x\n  where \n    loop args = \n       case args of \n\t   []  -> runit $ 50*1000*1000\n\t   [n] -> runit $ let num = read n in \n\t\t          -- Here\'s a bit of a hack, if the input is inexact treat it as an exponent.\n\t\t\t  -- Otherwise as a plain scalar.\n\t\t\t  if num == fromIntegral (round num)\n                          then round num\n\t\t          else round (10 ** read n)\n--\t   [trials, n] -> doTrials (read trials) (loop [n])\n'