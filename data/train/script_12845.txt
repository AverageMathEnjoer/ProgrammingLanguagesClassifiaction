b'{-# LANGUAGE CPP #-}\n{-# OPTIONS_GHC -O2 #-}\nimport Data.Int\nimport System.Environment\nimport GHC.Conc\n#ifdef PARSCHED \nimport PARSCHED\n#else\nimport Control.Monad.Par\n#endif\n\ntype FibType = Int64\n\n-- sequential version of the code\nfib :: FibType -> FibType\nfib 0 = 1\nfib 1 = 1\nfib x = fib (x-2) + fib (x-1)\n\n#ifdef OLDTYPES\n#define PAR Par\n#else\n#define PAR Par d s\n#endif\n\n-- Par monad version:\nparfib1 :: FibType -> PAR FibType\nparfib1 n | n < 2 = return 1\nparfib1 n = do \n--    xf <- spawn1_ parfib1 (n-1)\n    xf <- spawn_$ parfib1 (n-1)\n    y  <-         parfib1 (n-2)\n    x  <- get xf\n    return (x+y)\n\n-- Par monad version, with threshold:\nparfib1B :: FibType -> FibType -> PAR FibType\nparfib1B n c | n <= c = return $ fib n\nparfib1B n c = do \n    xf <- spawn_$ parfib1B (n-1) c\n    y  <-         parfib1B (n-2) c\n    x  <- get xf\n    return (x+y)\n\n-- Gratuitously nested Par monad version:\nparfibNest :: FibType -> FibType -> PAR FibType\nparfibNest n c | n <= c = return $ fib n\nparfibNest n c = do \n    xf <- spawnP $ runPar $ helper (n-1) c\n    yf <- spawnP $ runPar $ helper (n-2) c\n    x  <- get xf\n    y  <- get yf\n    return (x+y)\n where \n  -- Alternate between nesting and regular spawning:\n  helper :: FibType -> FibType -> PAR FibType\n  helper n c | n <= c = return $ fib n\n  helper n c = do \n    xf <- spawn_$ parfibNest (n-1) c\n    y  <-         parfibNest (n-2) c\n    x  <- get xf\n    return (x+y)\n\n\nmain :: IO ()\nmain = do \n    args <- getArgs\n    let (version, size, cutoff) = case args of \n            []      -> ("monad", 20, 1)\n            [v]     -> (v,       20, 1)\n            [v,n]   -> (v, read n,   1)\n            [v,n,c] -> (v, read n, read c)\n\n    case version of \n        "nested" -> do \n                print$ runPar$ parfibNest size cutoff\n        "monad"  -> \n\t\tif cutoff == 1 \n                then do putStrLn "Using non-thresholded version:"\n                        print$ runPar$ parfib1  size \n\t\telse    print$ runPar$ parfib1B size cutoff\n        -- TEMP: force thresholded version even if cutoff==1\n        "thresh" -> print$ runPar$ parfib1B size cutoff\n        "seq"    -> print$ fib size\n        _        -> error$ "unknown version: "++version\n\n\n{- \n\n[2011.03] On 4-core nehalem, 3.33ghz:\n-------------------------------------\n\n  Non-monadic version, real/user time:\n  fib(40) 4 threads: 1.1s 4.4s\n  fib(42) 1 threads: 9.7s  \n  fib(42) 4 threads: 2.86s 11.6s  17GB allocated -- 3.39X\n  \n     SPARKS: 433784785 (290 converted, 280395620 pruned)\n\n  Monad-par version:\n  fib(38) non-threaded: 23.3s 23.1s\n  fib(38) 1 thread :    24.7s 24.5s\n  fib(38) 4 threads:     8.2s 31.3s\n\n  fib(40) 4 threads:    20.6s 78.6s 240GB allocated\n\n\nFor comparison, Cilkarts Cilk++:\n  fib(42) 4 threads:  3.029s 23.610s\n\nIntel Cilk Plus:\n  fib(42) 4 threads:  4.212s 16.770s\n\n   1 thread: 17.53 -- e.g. 4.16X speedup\n\n\n[2011.03.29] {A bit more measurement}\n-------------------------------------\n\nIf I run a CnC/C++ parfib where results are (multiply) written into an\nitem collection (so there are many insertions, but only a small\nnumber of resident items), then I get these numbers:\n\n  fib(34) 1 thread: 22.78\n  fib(34) 4 thread: 13.96 -- 1.63X \n\nESTIMATED 3573.76 seconds for fib(42).\n\n\n[2011.10.20] {ContFree approach}\n--------------------------------\n\nInitial version forks a new thread on every get, which does terribly of course.\n\n    +RTS -N1 : \n     fib(24) 2.3s vs. 0.086\n\n\n[2011.10.11] {Westmere 3.1GHz NoHT 4-core testing}\n--------------------------------------------------\n\nTesting schedulers directly, without going through the generic (type\nclass) interface.  Starting with Scheds.Sparks:\n  user/system time: \n\n  fib(42) 4 threads: 4.56  17.83   -- Sparks\n  fib(42) 4 threads: 50.0  191.6   -- Trace \n\n\n[2011.10.24] {Timing nested scheduler version} \n----------------------------------------------\n\nChecking for performance regression.  This is on a 3.1 GHz Westmere\nwith hyperthreading disabled.  First a plain fib on the nested branch:\n\nData Schema:            User, system, productivity, alloc\n    fib(38) 1 thread :   20.2  19.7   94.1%  82GB   -- TraceNested\n    fib(38) 4 threads:   6.23  24.2   90.6%  85GB   -- TraceNested\n\nAnd for arguments sake with a cutoff of 10:\n    fib(42) 1 thread :   5.5   5.5    89.2%  8.2GB  -- TraceNested\n    fib(42) 4 threads:   1.72  6.38   87.5%  8.4GB  -- TraceNested\n\nAnd with the Sparks scheduler:\n    fib(38) 1 thread :   2.2\n    fib(38) 4 threads:   .75   2.7    69.0%  7.5GB\n    fib(42) 1 thread :   14.8  14.5   82.8%  52GB\n    fib(42) 4 threads:   4.7   18.3   71.1%  52GB\n    fib(42) 4 threads:   1.0   3.8    100%   11MB -- cutoff 10\n\nAnd the plain par/pseq version:\n    fib(42) 1 thread :   8.7   8.6    86.2%  17GB \n    fib(42) 4 threads:   2.8   10.5   73.9%  17GB\n\nAnd then for regression testing the ORIGINAL Trace scheduler (no nesting support):\n    fib(38) 1 thread :   22.1  21.5   93.8%  97GB -- TraceOrig\n    fib(38) 4 threads:   7.5   28.6   90.4%  97GB -- TraceOrig\n\nIndeed, rather than regression, it would seem that Daniel improved the\nparfib performance!\n\nSuper-nested parfib:\n-----------------------\nAnd the perversely Nested parfib:\n    nfib(38) 1 thread :   3.3   3.2    82.7%  12G      -- nested but Sparks.hs\n    nfib(38) 4 threads:   1.1   4.1    70.9%  12.9GB   -- nested but Sparks.hs\n\nOops!  That was with the sparks scheduler!  Here\'s the actual Trace/nested:    \n    nfib(30) 4 threads:   1.3   4.8    93.5%  7GB    -- super nested fib / trace\n    nfib(32) 4 threads:   3.26  11.7   92.9%  18GB\n    nfib(42) 4 threads:   6.5   23.5   94.7%  29.6GB -- cutoff 10:\n  (Note, those only used 376% cpu.)\n\nFinally, this is the original Trace scheduler on the perversely nested parfib:\n\n    nfib(30) 1 thread :   1.8   1.8    92.1%  5GB\n    nfib(32) 1 threads:   4.9   4.8    91.7%  14.9GB\n    nfib(32) 4 threads:   -- memory explosion\n    nfib(28) 4 threads:   9.7   37.2   33.8%  5.8GB -- 2GB ram usage\n\nOne interesting consequence here is that while the Sparks scheduler\nhas an 8X advantage over Trace (and par/pseq an additional 60%\nadvantage, 13.8X total), that advantage widens to over 256X in the\ncase of the perversely nested parfib!!!\n\n\n[2013.10.03] {Grabbing some numbers on Seq and IO threads versions}\n-------------------------------------------------------------------\n\nSame westmere MINE machines (slate): \nGHC 7.6.3:\n\n    ghc -i../../../monad-par/ -O2 -threaded parfib-monad.hs -o parfib-monad.exe\n\n    fib(42) - Sequential, compiled with -threaded: 3.108s\n\n    fib(30) - sequential 20ms, but at least 5ms is startup overhead.\n              let\'s say 15ms.\n\n    fib(30) -N1 - IO threads: 5.76s\n    fib(30) -N2 - IO threads: 4.1s\n    fib(30) -N3 - IO threads: 3.5s\n    fib(30) -N4 - IO threads: 3.3s, 400% cpu\n    fib(32) -N4 - IO threads: 804s, ~300% cpu.... gosh taking forever.\n                              13m24s\n\nfib(30) = 1346269  (/ 1000000000 (/ 1346269 3.3)) = 2,451 nanoseconds\nfib(32) = 3524578  (/ 1000000000 (/ 3524578 804)) = 228,000 nanoseconds\n\nfib(42) = 433494437,  seq version:  (/ 1000000000 (/ 433494437 3.1)) = 6.4 ns\n\nfib(42) = 433494437,  par/pseq version -N1: (/ 1000000000 (/ 433494437 8.7)) = 20ns - 6.4ns = 14ns\n\nfib(35) = 14930352, trace version -N1: 4.9s (/ 1000000000 (/ 14930352 4.9)) = 328ns\n\n-}\n'