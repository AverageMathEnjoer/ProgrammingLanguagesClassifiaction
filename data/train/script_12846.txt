b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns, GeneralizedNewtypeDeriving #-}\n\nmodule Main where\n\nimport Control.DeepSeq (rnf)\nimport Control.Exception (evaluate)\nimport Test.Tasty.Bench (bench, defaultMain, whnf)\nimport Data.List (foldl\')\nimport Data.Monoid (Sum(..))\nimport qualified Data.IntSet as IS\n-- benchmarks for "instance Ord IntSet"\n-- uses IntSet as keys of maps, and elements of sets\nimport qualified Data.Set as S\nimport qualified Data.IntMap as IM\nimport qualified Data.Map.Strict as M\n\nmain = do\n    let s = IS.fromAscList elems :: IS.IntSet\n        s_even = IS.fromAscList elems_even :: IS.IntSet\n        s_odd = IS.fromAscList elems_odd :: IS.IntSet\n        s_sparse = IS.fromAscList elems_sparse :: IS.IntSet\n    evaluate $ rnf [s, s_even, s_odd, s_sparse]\n    defaultMain\n        [ bench "member" $ whnf (member elems) s\n        , bench "insert" $ whnf (ins elems) IS.empty\n        , bench "map" $ whnf (IS.map (+ 1)) s\n        , bench "filter" $ whnf (IS.filter ((== 0) . (`mod` 2))) s\n        , bench "partition" $ whnf (IS.partition ((== 0) . (`mod` 2))) s\n        , bench "fold" $ whnf (IS.fold (:) []) s\n        , bench "delete" $ whnf (del elems) s\n        , bench "findMin" $ whnf IS.findMin s\n        , bench "findMax" $ whnf IS.findMax s\n        , bench "deleteMin" $ whnf IS.deleteMin s\n        , bench "deleteMax" $ whnf IS.deleteMax s\n        , bench "unions" $ whnf IS.unions [s_even, s_odd]\n        , bench "union" $ whnf (IS.union s_even) s_odd\n        , bench "difference" $ whnf (IS.difference s) s_even\n        , bench "intersection" $ whnf (IS.intersection s) s_even\n        , bench "fromList" $ whnf IS.fromList elems\n        , bench "fromAscList" $ whnf IS.fromAscList elems\n        , bench "fromDistinctAscList" $ whnf IS.fromDistinctAscList elems\n        , bench "disjoint:false" $ whnf (IS.disjoint s) s_even\n        , bench "disjoint:true" $ whnf (IS.disjoint s_odd) s_even\n        , bench "null.intersection:false" $ whnf (IS.null. IS.intersection s) s_even\n        , bench "null.intersection:true" $ whnf (IS.null. IS.intersection s_odd) s_even\n        , bench "instanceOrd:dense" -- the IntSet will just use one Tip\n          $ whnf (num_transitions . det 2 0) $ hard_nfa    1 16\n        , bench "instanceOrd:sparse" -- many Bin, each Tip is singleton\n          $ whnf (num_transitions . det 2 0) $ hard_nfa 1111 16\n        , bench "spanAntitone:dense" $ whnf (IS.spanAntitone (<elem_mid)) s\n        , bench "spanAntitone:sparse" $ whnf (IS.spanAntitone (<elem_sparse_mid)) s_sparse\n        , bench "split:dense" $ whnf (IS.split elem_mid) s\n        , bench "split:sparse" $ whnf (IS.split elem_sparse_mid) s_sparse\n        , bench "splitMember:dense" $ whnf (IS.splitMember elem_mid) s\n        , bench "splitMember:sparse" $ whnf (IS.splitMember elem_sparse_mid) s_sparse\n        ]\n  where\n    elems = [1..2^12]\n    elems_even = [2,4..2^12]\n    elems_odd = [1,3..2^12]\n    elem_mid = 2^11 + 31 -- falls in the middle of a packed Tip bitmask (assuming 64-bit words)\n    elems_sparse = map (*64) elems -- when built into a map, each Tip is a singleton\n    elem_sparse_mid = 2^11 * 64\n\nmember :: [Int] -> IS.IntSet -> Int\nmember xs s = foldl\' (\\n x -> if IS.member x s then n + 1 else n) 0 xs\n\nins :: [Int] -> IS.IntSet -> IS.IntSet\nins xs s0 = foldl\' (\\s a -> IS.insert a s) s0 xs\n\ndel :: [Int] -> IS.IntSet -> IS.IntSet\ndel xs s0 = foldl\' (\\s k -> IS.delete k s) s0 xs\n\n\n\n-- | Automata contain just the transitions\ntype NFA = IM.IntMap (IM.IntMap IS.IntSet)\ntype DFA = IM.IntMap (M.Map IS.IntSet IS.IntSet)\n\nnewtype State = State Int deriving (Num, Enum)\ninstance Show State where show (State s) = show s\nnewtype Sigma = Sigma Int deriving (Num, Enum, Eq)\n\nnum_transitions :: DFA -> Int\nnum_transitions = getSum . foldMap (Sum . M.size)\n\ndet :: Sigma -> State -> NFA -> DFA\ndet sigma (State initial) aut =\n  let get :: State -> Sigma -> IS.IntSet\n      get (State p) (Sigma s) = IM.findWithDefault IS.empty p\n              $ IM.findWithDefault IM.empty s aut\n      go :: DFA -> S.Set IS.IntSet -> S.Set IS.IntSet -> DFA\n      go !accu !done !todo = case S.minView todo of\n        Nothing -> accu\n        Just (t, odo) ->\n          if S.member t done\n          then go accu done odo\n          else let ts = do\n                     s <- [0 .. sigma-1]\n                     let next :: IS.IntSet\n                         next = foldMap (\\p -> get (State p) s) $ IS.toList t\n                     return (t, s, next)\n               in  go (union_dfa (dfa ts) accu)\n                      (S.insert t done)\n                      (Data.List.foldl\' (\\ o (_,_,q) -> S.insert q o) odo ts)\n  in go IM.empty S.empty $ S.singleton $ IS.singleton initial\n\nnfa :: [(State,Sigma,State)] -> NFA \nnfa ts = IM.fromListWith ( IM.unionWith IS.union )\n  $ Prelude.map (\\(State p,Sigma s,State q) ->\n           (s, IM.singleton p (IS.singleton q))) ts\n\ndfa :: [(IS.IntSet, Sigma, IS.IntSet)] -> DFA\ndfa ts = IM.fromListWith ( M.unionWith ( error "WAT") )\n  $ Prelude.map (\\( p, Sigma s, q) ->\n           (s, M.singleton p q)) ts\n\nunion_dfa a b = IM.unionWith (M.unionWith (error "WAT")) a b\n\n-- | for the language Sigma^* 1 Sigma^{n-2}  where Sigma={0,1}.\n-- this NFA has  n  states. DFA has 2^(n-1) states\n-- since it needs to remember the last n characters.\n-- Extra parameter delta: the automaton will use states [0, delta .. ]\n-- for IntSet, larger deltas should be harder,\n-- since for delta=1, all the states do fit in one Tip\nhard_nfa :: State -> Int -> NFA\nhard_nfa delta n = nfa\n  $ [ (0, 0, 0), (0,1,0), (0, 1, delta) ]\n  ++ do k <- [1 .. State n - 2] ; c <- [0,1] ; return (delta * k,c,delta *(k+1))\n'