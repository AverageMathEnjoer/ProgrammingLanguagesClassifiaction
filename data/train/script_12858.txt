b'#\' How much memory is currently used by R?\n#\'\n#\' R breaks down memory usage into Vcells (memory used by vectors) and\n#\' Ncells (memory used by everything else). However, neither this distinction\n#\' nor the "gc trigger" and "max used" columns are typically important. What\n#\' we\'re usually most interested in is the the first column: the total memory\n#\' used. This function wraps around \\code{gc()} to return the total amount of\n#\' memory (in megabytes) currently used by R.\n#\'\n#\' @export\n#\' @return Megabytes of ram used by R objects.\n#\' @examples\n#\' mem_used()\nmem_used <- function() {\n  show_bytes(sum(gc()[, 1] * c(node_size(), 8)))\n}\n\nnode_size <- function() {\n  bit <- 8L * .Machine$sizeof.pointer\n  if (!(bit == 32L || bit == 64L)) {\n    stop("Unknown architecture", call. = FALSE)\n  }\n\n  if (bit == 32L) 28L else 56L\n}\n\n#\' Determine change in memory from running code\n#\'\n#\' @param code Code to evaluate.\n#\' @return Change in memory (in megabytes) before and after running code.\n#\' @examples\n#\' # Need about 4 mb to store 1 million integers\n#\' mem_change(x <- 1:1e6)\n#\' # We get that memory back when we delete it\n#\' mem_change(rm(x))\n#\' @export\nmem_change <- function(code) {\n  start <- mem_used()\n\n  expr <- substitute(code)\n  eval(expr, parent.frame())\n  rm(code, expr)\n\n  show_bytes(mem_used() - start)\n}\n\nshow_bytes <- function(x) {\n  structure(x, class = "pryr_bytes")\n}\n\n#\' @export\nprint.pryr_bytes <- function(x, digits = 3, ...) {\n  power <- min(floor(log(abs(x), 1000)), 4)\n  if (power < 1) {\n    unit <- "B"\n  } else {\n    unit <- c("kB", "MB", "GB", "TB")[[power]]\n    x <- x / (1000 ^ power)\n  }\n\n  formatted <- format(signif(x, digits = digits), big.mark = ",",\n    scientific = FALSE)\n\n  cat(formatted, " ", unit, "\\n", sep = "")\n}\n'