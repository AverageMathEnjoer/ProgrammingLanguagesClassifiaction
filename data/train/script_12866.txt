b'// Copyright (c) 2022-2023 Manuel Schneider\n\n#include "albert/albert.h"\n#include "albert/logging.h"\n#include "rpcserver.h"\n#include <QRegularExpression>\n#include <QCoreApplication>\n#include <QLocalSocket>\n#include <QStandardPaths>\n#include <QString>\n#include <iostream>\n\nstatic QString socket_path = QStandardPaths::writableLocation(QStandardPaths::GenericCacheLocation) + "/albert_socket";\n\nstatic std::map<QString, std::function<QString(const QString&)>> actions =\n{\n        {"show", [](const QString& param){\n            albert::show(param);\n            return "Albert set visible.";\n        }},\n        {"hide", [](const QString&){\n            albert::hide();\n            return "Albert set hidden.";\n        }},\n        {"toggle", [](const QString&){\n            albert::toggle();\n            return "Albert visibility toggled.";\n        }},\n        {"settings", [](const QString&){\n            albert::showSettings();\n            return "Settings opened,";\n        }},\n        {"restart", [](const QString&){\n            albert::restart();\n            return "Triggered restart.";\n        }},\n        {"quit", [](const QString&){\n            albert::quit();\n            return "Triggered quit.";\n        }}\n};\n\n\nRPCServer::RPCServer()\n{\n\n    QLocalSocket socket;\n    DEBG << "Checking for a running instance\xe2\x80\xa6";\n    socket.connectToServer(socket_path);\n    if (socket.waitForConnected(100)) {\n        INFO << "There is another instance of albert running.";\n        ::exit(2);\n    }\n\n    // Remove pipes potentially leftover after crash\n    QLocalServer::removeServer(socket_path);\n\n    DEBG << "Creating local socket" << socket_path;\n    if (!local_server.listen(socket_path))\n        qFatal("Failed creating IPC server: %s", qPrintable(local_server.errorString()));\n\n    QObject::connect(&local_server, &QLocalServer::newConnection,\n                     [this](){RPCServer::onNewConnection();});\n}\n\nRPCServer::~RPCServer()\n{\n    local_server.close();\n}\n\nvoid RPCServer::onNewConnection()\n{\n    QLocalSocket* socket = local_server.nextPendingConnection();\n    socket->waitForReadyRead(50);\n    if (socket->bytesAvailable()) {\n        auto message = QString::fromLocal8Bit(socket->readAll());\n        DEBG << "Received message:" << message;\n\n        message = message.mid(message.indexOf(QRegularExpression("\\\\S")));  // Trim left spaces\n        auto op = message.section(\' \', 0, 0);\n        auto param = message.section(\' \', 1, -1);\n\n        try{\n            socket->write(actions.at(op)(param).toLocal8Bit());\n        } catch (const std::out_of_range &) {\n            QStringList l{QString("Invalid RPC command: \'%1\'. Use these").arg(message)};\n            for (const auto &[key, value] : actions)\n                l << key;\n            socket->write(l.join(QChar::LineFeed).toLocal8Bit());\n            INFO << QString("Received invalid RPC command: %1").arg(message);\n        }\n    }\n    socket->flush();\n    socket->close();\n    socket->deleteLater();\n}\n\nbool RPCServer::trySendMessageAndExit(const QString &message)\n{\n    QLocalSocket socket;\n    socket.connectToServer(socket_path);\n    if (socket.waitForConnected(500)){\n        socket.write(message.toUtf8());\n        socket.flush();\n        socket.waitForReadyRead(1000);\n        std::cout << socket.readAll().toStdString() << std::endl;\n        socket.close();\n        ::exit(EXIT_SUCCESS);\n    } else {\n        std::cout << "Failed to connect to albert." << std::endl;\n        ::exit(EXIT_FAILURE);\n    }\n}\n'