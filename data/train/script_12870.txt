b'// Listing 18.1\ntype Sum = int seq -> int\ntype Average = float seq -> float \ntype Count<\'T> = \'T seq -> int\n\n// Listing 18.2\nlet sum inputs =\n    let mutable accumulator = 0\n    for input in inputs do\n        accumulator <- accumulator + input\n    accumulator\n\n// Now you try #1\nlet length inputs =\n    let mutable accumulator = 0\n    for input in inputs do\n        accumulator <- accumulator + 1\n    accumulator\nlet lettersInTheAlphabet = [ \'a\' .. \'z\' ] |> length\n\n// Listing 18.3\ndo\n    let sum inputs =\n        Seq.fold\n            (fun state input -> state + input)\n            0\n            inputs\n    ()\n\n// Listing 18.4\ndo\n    let sum inputs =\n        Seq.fold\n            (fun state input ->\n                let newState = state + input\n                printfn "Current state is %d, input is %d, new state value is %d" state input newState\n                newState)\n            0\n            inputs\n\n    sum [ 1 .. 5 ]\n    ()\n\n// Now you try #2\nlet lengthFold inputs =\n    Seq.fold\n        (fun state input -> state + 1)\n        0\n        inputs\n\nlet foldAlphabet = [ \'a\' .. \'z\' ] |> lengthFold\n\nlet maxFold inputs =\n    Seq.fold\n        (fun state input -> if input > state then input else state)\n        0\n        inputs\nlet shouldBeTwenty = [ 1;2;5;3;20;13;18 ] |> maxFold\n\n// Listing 18.5\nlet inputs = [ 1 .. 5 ]\nSeq.fold (fun state input -> state + input) 0 inputs\ninputs |> Seq.fold (fun state input -> state + input) 0\n(0, inputs) ||> Seq.fold (fun state input -> state + input)\n\n// Listing 18.6\nopen System.IO\nlet mutable totalChars = 0\nlet sr = new StreamReader(File.OpenRead "book.txt")\n\nwhile (not sr.EndOfStream) do\n    let line = sr.ReadLine()\n    totalChars <- totalChars + line.ToCharArray().Length\n\n// Listing 18.7\nlet lines : string seq =\n    seq {\n        use sr = new StreamReader(File.OpenRead @"book.txt")\n        while (not sr.EndOfStream) do\n            yield sr.ReadLine() }\n\n(0, lines) ||> Seq.fold(fun total line -> total + line.Length)\n\n// Listing 18.8\nopen System\ntype Rule = string -> bool * string \n\nlet rules : Rule list =\n    [ fun text -> (text.Split \' \').Length = 3, "Must be three words"\n      fun text -> text.Length <= 30, "Max length is 30 characters"\n      fun text -> text.ToCharArray()\n                  |> Array.filter Char.IsLetter\n                  |> Array.forall Char.IsUpper, "All letters must be caps" ]\n\n// Listing 18.9\nlet validateManual (rules: Rule list) word =\n    let passed, error = rules.[0] word\n    if not passed then false, error\n    else\n        let passed, error = rules.[1] word\n        if not passed then false, error\n        else\n            let passed, error = rules.[2] word\n            if not passed then false, error\n            else true, ""\n\n// Listing 18.10\nlet buildValidator (rules : Rule list) =\n    rules\n    |> List.reduce(fun firstRule secondRule ->\n        fun word ->\n            let passed, error = firstRule word\n            if passed then\n                let passed, error = secondRule word\n                if passed then true, "" else false, error\n            else false, error)\n\nlet validate = buildValidator rules\nlet word = "HELLO FrOM F#"\n\nvalidate word\n \n// Now you try #3\nmodule Rules =\n    let threeWordRule (text:string) =\n        printfn "Running three word rule"\n        (text.Split \' \').Length = 3, "Must be three words"\n    let maxLengthRule (text:string) =\n        printfn "Running max length rule"\n        text.Length <= 30, "Max length is 30 characters"\n    let allCapsRule (text:string) =\n        printfn "Running all caps rule"\n        text\n        |> Seq.filter Char.IsLetter\n        |> Seq.forall Char.IsUpper, "All letters must be caps"\n    let noNumbersRule (text:string) =\n        printfn "Running no numbers rule"\n        text\n        |> Seq.forall (Char.IsNumber >> not), "Numbers are not permitted"\n\n    let allRules = [ threeWordRule; allCapsRule; maxLengthRule; noNumbersRule ]\n\nlet debugValidate = buildValidator Rules.allRules\nlet pass = debugValidate "HELLO FROM F#"\nlet fail = debugValidate "HELLO FR0M F#"'