b"{-# LANGUAGE FlexibleInstances, UndecidableInstances  #-}\n\n-- | This module defines another Par-related class to capture the\n--   random number generation capability.\n--\n--   The `rand` operation provides deterministic parallel random\n--   number generation from within a Par monad.\n--\n--   Most likely one will simply use the `ParRand` the instance\n--   provided in this file, which is based on a state transformer\n--   carrying the random generator.\n\n\nmodule Control.Monad.Par.RNG\n (\n  ParRand(..), runParRand, ParRandStd\n ) where\n\nimport System.Random\nimport Control.Exception\n\nimport Control.Monad.Par.Class\nimport Control.Monad.Par.State\nimport Control.Monad.Trans\nimport Control.Monad.Trans.State.Strict as S\n\n-- | A `ParRand` monad is a Par monad with support for random number generation..\nclass ParRand p where\n  rand :: Random a => p a\n  -- This can be more efficient:\n  randInt :: p Int\n  randInt = rand\n\n-- | Trivial instance.\ninstance RandomGen g => SplittableState g where\n  splitState = split\n\n-- | The most straightforward way to get a `ParRand` monad: carry a\n--   RNG in a state transformer.\ninstance (ParFuture fut p, RandomGen g) => ParRand (StateT g p) where\n  rand    = do\n               g <- S.get\n               let (x,g') = random g\n               S.put g'\n               return x\n  randInt = do\n               g <- S.get\n               let (x,g') = next g\n               S.put g'\n               return x\n\n-- An alternative is for these operators to be standalone without a class:\n-- rand    :: (ParFuture p fut, RandomGen g, Random a) => StateT g p a\n-- randInt :: (ParFuture p fut, RandomGen g)           => StateT g p Int\n\n-- runParRand :: ParRand p => (p a -> a) -> p a -> IO a\nrunParRand :: ParFuture fut p => (p a -> a) -> StateT StdGen p a -> IO a\nrunParRand runPar m =\n  do g <- newStdGen\n     evaluate (runPar (evalStateT m g))\n\n\n-- | A convenience type for the most standard\ntype ParRandStd par a = StateT StdGen par a\n"