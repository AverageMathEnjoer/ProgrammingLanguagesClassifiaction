b'{-# LANGUAGE\n    CPP\n  , GADTs\n  , LambdaCase\n  , NoImplicitPrelude\n  , ScopedTypeVariables\n  , TemplateHaskell\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\nmodule Rest.Gen.Base.ActionInfo\n  ( Accessor\n  , ActionInfo (..)\n  , ActionType (..)\n  , ActionTarget (..)\n  , DataType (..)\n  , ResourceId\n  , accessLink\n  , accessors\n  , chooseType\n\n  , DataDesc (..)\n  , dataType\n  , haskellType\n  , haskellModules\n\n  , DataMeta (..)\n  , dataTypeDesc\n  , dataSchema\n  , dataExample\n\n  , DataDescription (..)\n  , desc\n  , meta\n\n  , ResponseType (..)\n  , responseAcceptType\n  , dataTypesToAcceptHeader\n  , chooseResponseType\n\n  , isAccessor\n  , listGetterActionInfo\n  , mkActionDescription\n  , namedActionInfo\n  , resourceToAccessors\n  , resourceToActionInfo\n  , selectActionInfo\n  , singleActionInfo\n  ) where\n\nimport Prelude.Compat hiding (id, (.))\n\nimport Control.Category\nimport Control.Monad\nimport Data.Foldable (find)\nimport Data.Label.Derive\nimport Data.List (intercalate, intersect, nub, sortBy)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.Maybe\nimport Data.Ord\nimport Data.Proxy\nimport Data.Typeable\nimport Safe\nimport qualified Data.JSON.Schema             as J\nimport qualified Data.Label.Total             as L\nimport qualified Data.List.NonEmpty           as NList\nimport qualified Language.Haskell.Exts.Parser as H\nimport qualified Language.Haskell.Exts.Syntax as H\n\nimport Rest.Dictionary (Error (..), Input (..), Output (..), Param (..))\nimport Rest.Driver.Routing (mkListHandler, mkMultiHandler)\nimport Rest.Gen.Types\nimport Rest.Handler\nimport Rest.Info\nimport Rest.Resource hiding (description)\nimport Rest.Schema\nimport qualified Rest.Dictionary as Dict\nimport qualified Rest.Resource   as Rest\n\nimport Rest.Gen.Base.ActionInfo.Ident (Ident (Ident))\nimport Rest.Gen.Base.Link\nimport qualified Rest.Gen.Base.ActionInfo.Ident as Ident\nimport qualified Rest.Gen.Base.JSON             as J\nimport qualified Rest.Gen.Base.XML              as X\nimport qualified Rest.Gen.NoAnnotation          as N\n\n--------------------\n-- * The types describing a resource\'s actions.\n\n-- | Representation of resource\ntype ResourceId  = [String]\n\n-- | Intermediate data representation of Rest structure\ndata RequestMethod = GET | POST | PUT | DELETE deriving (Show, Eq)\n\ndata ActionType = Retrieve | Create | Delete | DeleteMany | List | Update | UpdateMany | Modify\n  deriving (Show, Eq)\n\ndata ActionTarget = Self | Any deriving (Show, Eq)\n\ndata DataType = String | XML | JSON | File | Other deriving (Show, Eq)\n\n-- | Core information about the type of the input/output\ndata DataDesc = DataDesc\n  { _dataType       :: DataType\n  , _haskellType    :: N.Type\n  , _haskellModules :: [N.ModuleName]\n  } deriving (Show, Eq)\n\nmkLabel \'\'DataDesc\n\n-- | Documentation information about the input/output\ndata DataMeta = DataMeta\n  { _dataTypeDesc :: String       -- ^ The name of the DataType, or a custom value if dataType is Other\n  , _dataSchema   :: Maybe String -- ^ Just if dataType is XML\n  , _dataExample  :: [String]     -- ^ Non empty if dataType is XML or JSON\n  } deriving (Show, Eq)\n\nmkLabel \'\'DataMeta\n\n-- | Combines the core and documentation information for input/output\ndata DataDescription = DataDescription\n  { _desc :: DataDesc\n  , _meta :: DataMeta\n  } deriving (Show, Eq)\n\nmkLabel \'\'DataDescription\n\ndata ActionInfo = ActionInfo\n  { ident        :: Maybe Ident -- Requires extra identifier in url? e.g. page/<identifier>\n  , postAction   :: Bool        -- Works on identified resources? e.g. uri/<uri>/action\n  , actionType   :: ActionType\n  , actionTarget :: ActionTarget\n  , resDir       :: String      -- Resource directory\n  , method       :: RequestMethod\n  , inputs       :: [DataDescription]\n  , outputs      :: [DataDescription]\n  , errors       :: [DataDescription]\n  , params       :: [String]\n  , https        :: Bool\n  , link         :: Link\n  } deriving (Show, Eq)\n\nisAccessor :: ActionInfo -> Bool\nisAccessor ai = actionType ai == Retrieve && actionTarget ai == Self\n\ndefaultDescription :: DataType -> String -> N.Type -> DataDescription\ndefaultDescription typ typeDesc htype =\n  DataDescription\n    { _desc = DataDesc\n        { _dataType       = typ\n        , _haskellType    = htype\n        , _haskellModules = []\n        }\n    , _meta = DataMeta\n        { _dataTypeDesc = typeDesc\n        , _dataSchema   = Nothing\n        , _dataExample  = []\n        }\n    }\n\nchooseType :: NonEmpty DataDescription -> DataDescription\nchooseType ls = fromMaybe (NList.head ls) $ find ((JSON ==) . L.get (dataType . desc)) ls\n\ndata ResponseType = ResponseType\n  { errorType  :: Maybe DataDesc\n  , outputType :: Maybe DataDesc\n  } deriving Show\n\nresponseAcceptType :: ResponseType -> [DataType] -- TODO make non empty list Maybe (NonEmpty DataType)\nresponseAcceptType (ResponseType e o) = typs\n  where\n    typs :: [DataType]\n    typs = nub $ f e ++ f o\n      where\n        f :: Maybe DataDesc -> [DataType]\n        f = maybeToList . fmap (L.get dataType)\n\n-- | First argument is the default accept header to use if there is no\n-- output or errors, must be XML or JSON.\ndataTypesToAcceptHeader :: DataType -> [DataType] -> String\ndataTypesToAcceptHeader def = \\case\n  [] -> dataTypeToAcceptHeader def\n  xs -> intercalate "," . map dataTypeToAcceptHeader . (xs ++) $\n          [def | null (xs `intersect` [XML, JSON])]\n\ndataTypeToAcceptHeader :: DataType -> String\ndataTypeToAcceptHeader = \\case\n  String -> "text/plain"\n  XML    -> "text/xml"\n  JSON   -> "text/json"\n  File   -> "application/octet-stream"\n  Other  -> "text/plain"\n\nchooseResponseType :: ActionInfo -> ResponseType\nchooseResponseType ai = case (NList.nonEmpty $ outputs ai, NList.nonEmpty $ errors ai) of\n  -- No outputs or errors defined\n  (Nothing, Nothing) ->\n    ResponseType\n      { errorType  = Nothing\n      , outputType = Nothing\n      }\n  -- Only an error type\n  (Nothing, Just e ) ->\n    ResponseType\n      { errorType  = Just . L.get desc $ chooseType e\n      , outputType = Nothing\n      }\n  -- Only an output type\n  (Just o , Nothing) ->\n    ResponseType\n      { errorType  = Nothing\n      , outputType = Just . L.get desc $ chooseType o\n      }\n  -- Output and error\n  (Just o , Just e ) -> intersection o e\n\n  where\n\n    intersection :: NonEmpty DataDescription -> NonEmpty DataDescription -> ResponseType\n    intersection o e =\n      -- Try to find a response type that can be used for both output and error.\n      case f o `intersect` f e of\n        -- If the response types are disjoint we need to specify both.\n        [] ->\n          ResponseType\n            { errorType  = Just . L.get desc $ chooseType e\n            , outputType = Just . L.get desc $ chooseType o\n            }\n        xs ->\n          ResponseType\n            { errorType  = matching xs e\n            , outputType = matching xs o\n            }\n        where\n          f = map (L.get (dataType . desc)) . NList.toList\n          matching :: [DataType] -> NonEmpty DataDescription -> Maybe DataDesc\n          matching dts = fmap (L.get desc) . headMay\n                       -- Prioritize formats\n                       . sortBy (comparing cmp)\n                       -- Pick only the data types in the intersection of outputs and errors\n                       . filter ((`elem` dts) . L.get (dataType . desc))\n                       . NList.toList\n          -- When we have an intersection with multiple possible\n          -- types, we prefer JSON over XML, and XML over the rest.\n          cmp :: DataDescription -> Int\n          cmp dt = case L.get (dataType . desc) dt of\n            JSON -> 0\n            XML  -> 1\n            _    -> 2\n\n--------------------\n-- * Traverse a resource\'s Schema and Handlers to create a [ActionInfo].\n\nresourceToActionInfo :: forall m s sid mid aid. Resource m s sid mid aid -> [ActionInfo]\nresourceToActionInfo r =\n  case schema r of\n    Schema mTopLevel step -> foldMap (topLevelActionInfo r) mTopLevel\n                          ++ stepActionInfo r step\n                          ++ foldMap (return . createActionInfo) (Rest.create r)\n                          ++ foldMap (return . removeActionInfo accLnk) (Rest.remove r)\n                          ++ map (uncurry (selectActionInfo accLnk)) (Rest.selects r)\n                          ++ map (uncurry (actionActionInfo accLnk)) (Rest.actions r)\n      where\n        accLnk = accessLink (accessors step)\n\naccessLink :: [Accessor] -> Link\naccessLink [] = []\naccessLink xs = [LAccess . map f $ xs]\n  where\n    f ("", x) = par x\n    f (pth, x) = LAction pth : par x\n    par = maybe [] (return . LParam . Ident.description)\n\naccessors :: Step sid mid aid -> [Accessor]\naccessors (Named hs) = mapMaybe (uncurry accessorsNamed) hs\n  where\n    accessorsNamed pth (Right (Single g)) = Just (pth, getId g)\n    accessorsNamed _ _ = Nothing\n    getId (Singleton _) = Nothing\n    getId (By id_) = Just . idIdent $ id_\naccessors (Unnamed (Single id_)) = [("", Just . idIdent $ id_)]\naccessors (Unnamed (Many _)) = []\n\ntype Accessor = (String, Maybe Ident)\n\nresourceToAccessors :: Resource m s sid mid aid -> [Accessor]\nresourceToAccessors r =\n  case schema r of\n    Schema _ step -> accessors step\n\ntopLevelActionInfo :: Resource m s sid mid aid -> Cardinality sid mid -> [ActionInfo]\ntopLevelActionInfo r            (Single _  ) = singleActionInfo r Nothing ""\ntopLevelActionInfo r@Resource{} (Many   mid) = maybeToList\n                                             . listActionInfo Nothing ""\n                                             . Rest.list r\n                                             $ mid\n\nstepActionInfo :: Resource m s sid mid aid -> Step sid mid aid -> [ActionInfo]\nstepActionInfo r (Named hs) = concatMap (uncurry (namedActionInfo r)) hs\nstepActionInfo r (Unnamed h) = unnamedActionInfo r h\n\nnamedActionInfo :: Resource m s sid mid aid -> String -> Endpoint sid mid aid -> [ActionInfo]\nnamedActionInfo r pth (Left aid) = [staticActionInfo pth (Rest.statics r aid)]\nnamedActionInfo r pth (Right (Single g)) = getterActionInfo     r pth g\nnamedActionInfo r pth (Right (Many   l)) = listGetterActionInfo r pth l\n\nunnamedActionInfo :: Resource m s sid mid aid -> Cardinality (Id sid) (Id mid) -> [ActionInfo]\nunnamedActionInfo r@Resource{} unnamed =\n  case unnamed of\n    Single id_             -> singleActionInfo r (Just id_) ""\n    Many   id_@(Id _ midF) -> maybeToList $\n      listActionInfo (Just id_) "" (Rest.list r (midF listIdErr))\n\ngetterActionInfo :: Resource m s sid mid aid -> String -> Getter sid -> [ActionInfo]\ngetterActionInfo r pth (Singleton _) = singleActionInfo r Nothing    pth\ngetterActionInfo r pth (By id_     ) = singleActionInfo r (Just id_) pth\n\nlistGetterActionInfo :: Resource m s sid mid aid -> String -> Getter mid -> [ActionInfo]\nlistGetterActionInfo r@Resource{} pth getter = maybeToList $\n  case getter of\n    Singleton mid      -> listActionInfo Nothing    pth (Rest.list r mid)\n    By id_@(Id _ midF) -> listActionInfo (Just id_) pth (Rest.list r (midF listIdErr))\n\nlistIdErr :: mid\nlistIdErr = error $ "Don\'t evaluate the fields of a list identifier unless in the body of the handler. "\n                 ++ "They are undefined during generation of documentation and code."\n\nsingleActionInfo :: Resource m s sid mid aid -> Maybe (Id sid) -> String -> [ActionInfo]\nsingleActionInfo r@Resource{} mId pth\n   = foldMap (return . getActionInfo         mId pth) (Rest.get     r)\n  ++ foldMap (return . updateActionInfo      mId pth) (Rest.update  r)\n  ++ maybeToList (join $ multiUpdateActionInfo <$> mId <*> pure pth <*> Rest.update r)\n  ++ maybeToList (join $ multiRemoveActionInfo <$> mId <*> pure pth <*> Rest.remove r)\n\n--------------------\n-- * Smart constructors for ActionInfo.\n\ngetActionInfo :: Maybe (Id sid) -> String -> Handler m -> ActionInfo\ngetActionInfo mId pth = handlerActionInfo mId False Retrieve Self pth GET []\n\nupdateActionInfo :: Maybe (Id sid) -> String -> Handler m -> ActionInfo\nupdateActionInfo mId pth = handlerActionInfo mId False Update Any pth PUT []\n\nmultiUpdateActionInfo :: Monad m => Id sid -> String -> Handler m -> Maybe ActionInfo\nmultiUpdateActionInfo id_ pth h =  handlerActionInfo Nothing False UpdateMany Any pth PUT []\n                               <$> mkMultiHandler id_ (const id) h\n\nremoveActionInfo :: Link -> Handler m -> ActionInfo\nremoveActionInfo = handlerActionInfo Nothing True Delete Self "" DELETE\n\nmultiRemoveActionInfo :: Monad m => Id sid -> String -> Handler m -> Maybe ActionInfo\nmultiRemoveActionInfo id_ pth h =  handlerActionInfo Nothing False DeleteMany Any pth DELETE []\n                               <$> mkMultiHandler id_ (const id) h\n\nlistActionInfo :: Monad m => Maybe (Id mid) -> String -> ListHandler m -> Maybe ActionInfo\nlistActionInfo mId pth h = handlerActionInfo mId False List Self pth GET [] <$> mkListHandler h\n\nstaticActionInfo :: String -> Handler m -> ActionInfo\nstaticActionInfo pth = handlerActionInfo Nothing False Modify Any pth POST []\n\ncreateActionInfo :: Handler m -> ActionInfo\ncreateActionInfo = handlerActionInfo Nothing False Create Self "" POST []\n\nselectActionInfo :: Link -> String -> Handler m -> ActionInfo\nselectActionInfo lnk pth = handlerActionInfo Nothing True Retrieve Any pth GET lnk\n\nactionActionInfo :: Link -> String -> Handler m -> ActionInfo\nactionActionInfo lnk pth = handlerActionInfo Nothing True Modify Any pth POST lnk\n\nhandlerActionInfo :: Maybe (Id id)\n                  -> Bool\n                  -> ActionType\n                  -> ActionTarget\n                  -> String\n                  -> RequestMethod\n                  -> Link\n                  -> Handler m\n                  -> ActionInfo\nhandlerActionInfo mId postAct actType actTarget pth mth ac h = ActionInfo\n  { ident        = id_\n  , postAction   = postAct\n  , actionType   = actType\n  , actionTarget = actTarget\n  , resDir       = pth\n  , method       = mth\n  , inputs       = handlerInputs  h\n  , outputs      = handlerOutputs h\n  , errors       = handlerErrors  h\n  , params       = handlerParams  h\n  , https        = secure         h\n  , link         = makeLink\n  }\n  where\n    id_ = idIdent <$> mId\n    makeLink :: Link\n    makeLink\n      | postAct   = ac ++ dirPart ++ identPart\n      | otherwise = dirPart ++ identPart\n      where dirPart   = [LAction pth | pth /= ""]\n            identPart = maybe [] ((:[]) . LParam . Ident.description) id_\n\n\n--------------------\n-- * Utilities for extraction information from Handlers.\n\nhandlerParams :: GenHandler m f -> [String]\nhandlerParams (GenHandler dict _ _) = paramNames (L.get Dict.params dict)\n\n-- | A `Param` can contain the same parameter multiple times. For\n-- example, \'offset\' and \'count\' are added in Rest.Handler.mkListing,\n-- and in Rest.Driver.Routing.mkListHandler. For that reason, we nub\n-- here.\n\nparamNames :: Param a -> [String]\nparamNames = nub . paramNames_\n\nparamNames_ :: Param a -> [String]\nparamNames_ NoParam = []\nparamNames_ (Param s _) = s\nparamNames_ (TwoParams p1 p2) = paramNames p1 ++ paramNames p2\n\n-- | Extract input description from handlers\nhandlerInputs :: Handler m -> [DataDescription]\nhandlerInputs (GenHandler dict _ _) = map (handlerInput Proxy) (Dict.getDicts_ . L.get Dict.inputs $ dict)\n  where\n    handlerInput :: Proxy i -> Input i -> DataDescription\n    handlerInput d c = case c of\n      ReadI          -> L.set (haskellModules . desc) (modString d)\n                      $ defaultDescription Other (describe d) (toHaskellType d)\n      StringI        -> defaultDescription String "String" haskellStringType\n      XmlI           -> L.set (haskellModules . desc) (modString d)\n                      . L.set (dataSchema     . meta) (pure . X.showSchema  . X.getXmlSchema $ d)\n                      . L.set (dataExample    . meta) (pure . X.showExample . X.getXmlSchema $ d)\n                      $ defaultDescription XML "XML" (toHaskellType d)\n      XmlTextI       -> defaultDescription XML "XML" haskellStringType\n      RawXmlI        -> defaultDescription XML "XML" haskellStringType\n      JsonI          -> L.set (haskellModules . desc) (modString d)\n                      . L.set (dataExample    . meta) (J.showExamples . J.schema $ d)\n                      $ defaultDescription JSON "JSON" (toHaskellType d)\n      RawJsonI       -> defaultDescription JSON "JSON" haskellStringType\n      -- Picking JSON or XML is arbitrary here since both are possible\n      -- so we stick with the convention of preferring JSON.\n      RawJsonAndXmlI -> defaultDescription File "File" haskellByteStringType\n      FileI          -> defaultDescription File "File" haskellByteStringType\n\n-- | Extract output description from handlers\nhandlerOutputs :: Handler m -> [DataDescription]\nhandlerOutputs (GenHandler dict _ _) = map (handlerOutput Proxy) (Dict.getDicts_ . L.get Dict.outputs $ dict)\n  where\n    handlerOutput :: Proxy a -> Output a -> DataDescription\n    handlerOutput d c = case c of\n      StringO        -> defaultDescription String "String" haskellStringType\n      XmlO           -> L.set (haskellModules . desc) (modString d)\n                      . L.set (dataSchema     . meta) (pure . X.showSchema  . X.getXmlSchema $ d)\n                      . L.set (dataExample    . meta) (pure . X.showExample . X.getXmlSchema $ d)\n                      $ defaultDescription XML "XML" (toHaskellType d)\n      RawXmlO        -> defaultDescription XML "XML" haskellStringType\n      JsonO          -> L.set (haskellModules . desc) (modString d)\n                      . L.set (dataExample    . meta) (J.showExamples . J.schema $ d)\n                      $ defaultDescription JSON "JSON" (toHaskellType d)\n      RawJsonO       -> defaultDescription JSON "JSON" haskellStringType\n      -- Picking JSON or XML is arbitrary here since both are possible\n      -- so we stick with the convention of preferring JSON.\n      RawJsonAndXmlO -> defaultDescription File "File" haskellStringType\n      FileO          -> defaultDescription File "File" haskellByteStringType\n      -- TODO: MultiPartO\n\n-- | Extract input description from handlers\nhandlerErrors :: Handler m -> [DataDescription]\nhandlerErrors (GenHandler dict _ _) = map (handleError Proxy) (Dict.getDicts_ . L.get Dict.errors $ dict)\n  where\n    handleError :: Proxy a -> Error a -> DataDescription\n    handleError d c = case c of\n      XmlE  -> L.set (dataSchema     . meta) (pure . X.showSchema  . X.getXmlSchema $ d)\n             . L.set (dataExample    . meta) (pure . X.showExample . X.getXmlSchema $ d)\n             . L.set (haskellModules . desc) (modString d)\n             $ defaultDescription XML "XML" (toHaskellType d)\n      JsonE -> L.set (dataExample    . meta) (J.showExamples . J.schema $ d)\n             . L.set (haskellModules . desc) (modString d)\n             $ defaultDescription JSON "JSON" (toHaskellType d)\n\ntypeString :: forall a. Typeable a => Proxy a -> String\ntypeString _ = typeString\' . typeOf $ (undefined :: a)\n  where typeString\' tr =\n          let (tyCon, subs) = splitTyConApp tr\n              showTyCon _ "[]" r = "[" ++ r ++ "]"\n              showTyCon _ "()" _ = "()"\n              showTyCon m d s | take 4 m == "GHC." = d ++ s\n                              | otherwise = m ++ "." ++ d ++ s\n          in  showTyCon (tyConModule tyCon)\n                        (tyConName tyCon)\n                        (concatMap (\\t -> " (" ++ typeString\' t ++ ")") subs)\n\nmodString :: forall a. Typeable a => Proxy a -> [N.ModuleName]\nmodString _ = map (H.ModuleName ()) . filter (\\v -> v /= "" && take 4 v /= "GHC.") . modString\' . typeOf $ (undefined :: a)\n  where modString\' tr =\n          let (tyCon, subs) = splitTyConApp tr\n          in  tyConModule tyCon : concatMap modString\' subs\n\ntoHaskellType :: forall a. Typeable a => Proxy a -> N.Type\ntoHaskellType ty =\n  case H.parseType (typeString ty) of\n    H.ParseOk parsedType -> void parsedType\n    H.ParseFailed _loc msg -> error msg\n\nidIdent :: Id id -> Ident\nidIdent (Id idnt _) = actionIdent idnt\n\nactionIdent :: forall a. Dict.Ident a -> Ident\nactionIdent Dict.StringId\n  = Ident\n    { Ident.description    = "string"\n    , Ident.haskellType    = haskellStringType\n    , Ident.haskellModules = []\n    }\nactionIdent Dict.ReadId\n  = Ident\n    { Ident.description    = describe proxy_\n    , Ident.haskellType    = toHaskellType proxy_\n    , Ident.haskellModules = modString proxy_\n    }\n  where\n    proxy_ :: Proxy a\n    proxy_ = Proxy\n\nmkActionDescription :: String -> ActionInfo -> String\nmkActionDescription res ai =\n  let targetS =\n        case actionTarget ai of\n          Self -> res\n          Any  -> "information"\n  in case actionType ai of\n      Retrieve   -> "Retrieve " ++ targetS ++ " data"\n      Create     -> "Create " ++ targetS\n      Delete     -> "Delete " ++ targetS\n      DeleteMany -> "Delete many " ++ targetS\n      List       -> "List " ++ targetS ++ "s"\n      Update     -> "Update " ++ targetS\n      UpdateMany -> "Update many " ++ targetS\n      Modify     -> "Modify " ++ targetS\n'