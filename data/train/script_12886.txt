b'{-# LANGUAGE CPP #-}\n\n#ifdef STRICT\nimport Data.IntMap.Strict as Data.IntMap hiding (showTree)\nimport Data.IntMap.Strict.Internal (traverseMaybeWithKey)\nimport Data.IntMap.Merge.Strict\n#else\nimport Data.IntMap.Lazy as Data.IntMap hiding (showTree)\nimport Data.IntMap.Internal (traverseMaybeWithKey)\nimport Data.IntMap.Merge.Lazy\n#endif\nimport Data.IntMap.Internal.Debug (showTree)\nimport IntMapValidity (valid)\n\nimport Control.Applicative (Applicative(..))\nimport Control.Monad ((<=<))\nimport Data.Monoid\nimport Data.Maybe hiding (mapMaybe)\nimport qualified Data.Maybe as Maybe (mapMaybe)\nimport Data.Ord\nimport Data.Foldable (foldMap)\nimport Data.Function\nimport Data.Traversable (Traversable(traverse), foldMapDefault)\nimport Prelude hiding (lookup, null, map, filter, foldr, foldl)\nimport qualified Prelude (map)\n\nimport Data.List (nub,sort)\nimport qualified Data.List as List\nimport qualified Data.IntSet as IntSet\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck\nimport Test.QuickCheck.Function (apply)\nimport Test.QuickCheck.Poly (A, B, C)\n\ndefault (Int)\n\nmain :: IO ()\nmain = defaultMain $ testGroup "intmap-properties"\n         [\n               testCase "index"      test_index\n             , testCase "index_lookup" test_index_lookup\n             , testCase "size"       test_size\n             , testCase "size2"      test_size2\n             , testCase "member"     test_member\n             , testCase "notMember"  test_notMember\n             , testCase "lookup"     test_lookup\n             , testCase "findWithDefault"     test_findWithDefault\n             , testCase "lookupLT"   test_lookupLT\n             , testCase "lookupGT"   test_lookupGT\n             , testCase "lookupLE"   test_lookupLE\n             , testCase "lookupGE"   test_lookupGE\n             , testCase "empty" test_empty\n             , testCase "mempty" test_mempty\n             , testCase "singleton" test_singleton\n             , testCase "insert" test_insert\n             , testCase "insertWith" test_insertWith\n             , testCase "insertWithKey" test_insertWithKey\n             , testCase "insertLookupWithKey" test_insertLookupWithKey\n             , testCase "delete" test_delete\n             , testCase "adjust" test_adjust\n             , testCase "adjustWithKey" test_adjustWithKey\n             , testCase "update" test_update\n             , testCase "updateWithKey" test_updateWithKey\n             , testCase "updateLookupWithKey" test_updateLookupWithKey\n             , testCase "alter" test_alter\n             , testCase "union" test_union\n             , testCase "mappend" test_mappend\n             , testCase "unionWith" test_unionWith\n             , testCase "unionWithKey" test_unionWithKey\n             , testCase "unions" test_unions\n             , testCase "mconcat" test_mconcat\n             , testCase "unionsWith" test_unionsWith\n             , testCase "difference" test_difference\n             , testCase "differenceWith" test_differenceWith\n             , testCase "differenceWithKey" test_differenceWithKey\n             , testCase "intersection" test_intersection\n             , testCase "intersectionWith" test_intersectionWith\n             , testCase "intersectionWithKey" test_intersectionWithKey\n             , testCase "map" test_map\n             , testCase "mapWithKey" test_mapWithKey\n             , testCase "mapAccum" test_mapAccum\n             , testCase "mapAccumWithKey" test_mapAccumWithKey\n             , testCase "mapAccumRWithKey" test_mapAccumRWithKey\n             , testCase "mapKeys" test_mapKeys\n             , testCase "mapKeysWith" test_mapKeysWith\n             , testCase "mapKeysMonotonic" test_mapKeysMonotonic\n             , testCase "elems" test_elems\n             , testCase "keys" test_keys\n             , testCase "assocs" test_assocs\n             , testCase "keysSet" test_keysSet\n             , testCase "keysSet" test_fromSet\n             , testCase "toList" test_toList\n             , testCase "fromList" test_fromList\n             , testCase "fromListWith" test_fromListWith\n             , testCase "fromListWithKey" test_fromListWithKey\n             , testCase "toAscList" test_toAscList\n             , testCase "toDescList" test_toDescList\n             , testCase "showTree" test_showTree\n             , testCase "fromAscList" test_fromAscList\n             , testCase "fromAscListWith" test_fromAscListWith\n             , testCase "fromAscListWithKey" test_fromAscListWithKey\n             , testCase "fromDistinctAscList" test_fromDistinctAscList\n             , testCase "filter" test_filter\n             , testCase "filterWithKey" test_filteWithKey\n             , testCase "partition" test_partition\n             , testCase "partitionWithKey" test_partitionWithKey\n             , testCase "mapMaybe" test_mapMaybe\n             , testCase "mapMaybeWithKey" test_mapMaybeWithKey\n             , testCase "mapEither" test_mapEither\n             , testCase "mapEitherWithKey" test_mapEitherWithKey\n             , testCase "split" test_split\n             , testCase "splitLookup" test_splitLookup\n             , testCase "isSubmapOfBy" test_isSubmapOfBy\n             , testCase "isSubmapOf" test_isSubmapOf\n             , testCase "isProperSubmapOfBy" test_isProperSubmapOfBy\n             , testCase "isProperSubmapOf" test_isProperSubmapOf\n             , testCase "lookupMin" test_lookupMin\n             , testCase "lookupMax" test_lookupMax\n             , testCase "findMin" test_findMin\n             , testCase "findMax" test_findMax\n             , testCase "deleteMin" test_deleteMin\n             , testCase "deleteMax" test_deleteMax\n             , testCase "deleteFindMin" test_deleteFindMin\n             , testCase "deleteFindMax" test_deleteFindMax\n             , testCase "updateMin" test_updateMin\n             , testCase "updateMax" test_updateMax\n             , testCase "updateMinWithKey" test_updateMinWithKey\n             , testCase "updateMaxWithKey" test_updateMaxWithKey\n             , testCase "minView" test_minView\n             , testCase "maxView" test_maxView\n             , testCase "minViewWithKey" test_minViewWithKey\n             , testCase "maxViewWithKey" test_maxViewWithKey\n             , testCase "minimum" test_minimum\n             , testCase "maximum" test_maximum\n             , testProperty "valid"                prop_valid\n             , testProperty "empty valid"          prop_emptyValid\n             , testProperty "insert to singleton"  prop_singleton\n             , testProperty "insert then lookup"   prop_insertLookup\n             , testProperty "insert then delete"   prop_insertDelete\n             , testProperty "delete non member"    prop_deleteNonMember\n             , testProperty "union model"          prop_unionModel\n             , testProperty "union singleton"      prop_unionSingleton\n             , testProperty "union associative"    prop_unionAssoc\n             , testProperty "union+unionWith"      prop_unionWith\n             , testProperty "union sum"            prop_unionSum\n             , testProperty "difference model"     prop_differenceModel\n             , testProperty "intersection model"   prop_intersectionModel\n             , testProperty "intersectionWith model" prop_intersectionWithModel\n             , testProperty "intersectionWithKey model" prop_intersectionWithKeyModel\n             , testProperty "mergeWithKey model"   prop_mergeWithKeyModel\n             , testProperty "merge valid"          prop_merge_valid\n             , testProperty "mergeA effects"       prop_mergeA_effects\n             , testProperty "fromAscList"          prop_ordered\n             , testProperty "fromList then toList" prop_list\n             , testProperty "toDescList"           prop_descList\n             , testProperty "toAscList+toDescList" prop_ascDescList\n             , testProperty "fromList"             prop_fromList\n             , testProperty "alter"                prop_alter\n             , testProperty "index"                prop_index\n             , testProperty "index_lookup"         prop_index_lookup\n             , testProperty "null"                 prop_null\n             , testProperty "size"                 prop_size\n             , testProperty "member"               prop_member\n             , testProperty "notmember"            prop_notmember\n             , testProperty "lookup"               prop_lookup\n             , testProperty "find"                 prop_find\n             , testProperty "findWithDefault"      prop_findWithDefault\n             , testProperty "lookupLT"             prop_lookupLT\n             , testProperty "lookupGT"             prop_lookupGT\n             , testProperty "lookupLE"             prop_lookupLE\n             , testProperty "lookupGE"             prop_lookupGE\n             , testProperty "disjoint"             prop_disjoint\n             , testProperty "compose"              prop_compose\n             , testProperty "lookupMin"            prop_lookupMin\n             , testProperty "lookupMax"            prop_lookupMax\n             , testProperty "findMin"              prop_findMin\n             , testProperty "findMax"              prop_findMax\n             , testProperty "deleteMin"            prop_deleteMinModel\n             , testProperty "deleteMax"            prop_deleteMaxModel\n             , testProperty "filter"               prop_filter\n             , testProperty "partition"            prop_partition\n             , testProperty "takeWhileAntitone"    prop_takeWhileAntitone\n             , testProperty "dropWhileAntitone"    prop_dropWhileAntitone\n             , testProperty "spanAntitone"         prop_spanAntitone\n             , testProperty "map"                  prop_map\n             , testProperty "fmap"                 prop_fmap\n             , testProperty "mapkeys"              prop_mapkeys\n             , testProperty "split"                prop_splitModel\n             , testProperty "splitLookup"          prop_splitLookup\n             , testProperty "splitRoot"            prop_splitRoot\n             , testProperty "foldr"                prop_foldr\n             , testProperty "foldr\'"               prop_foldr\'\n             , testProperty "foldl"                prop_foldl\n             , testProperty "foldl\'"               prop_foldl\'\n             , testProperty "foldr==foldMap"       prop_foldrEqFoldMap\n             , testProperty\n                 "foldrWithKey==foldMapWithKey"\n                 prop_foldrWithKeyEqFoldMapWithKey\n             , testProperty\n                 "prop_FoldableTraversableCompat"\n                 prop_FoldableTraversableCompat\n             , testProperty "keysSet"              prop_keysSet\n             , testProperty "fromSet"              prop_fromSet\n             , testProperty "restrictKeys"         prop_restrictKeys\n             , testProperty "withoutKeys"          prop_withoutKeys\n             , testProperty "traverseWithKey identity"              prop_traverseWithKey_identity\n             , testProperty "traverseWithKey->mapWithKey"           prop_traverseWithKey_degrade_to_mapWithKey\n             , testProperty "traverseMaybeWithKey identity"         prop_traverseMaybeWithKey_identity\n             , testProperty "traverseMaybeWithKey->mapMaybeWithKey" prop_traverseMaybeWithKey_degrade_to_mapMaybeWithKey\n             , testProperty "traverseMaybeWithKey->traverseWithKey" prop_traverseMaybeWithKey_degrade_to_traverseWithKey\n             ]\n\napply2 :: Fun (a, b) c -> a -> b -> c\napply2 f a b = apply f (a, b)\n\napply3 :: Fun (a, b, c) d -> a -> b -> c -> d\napply3 f a b c = apply f (a, b, c)\n\n\n{--------------------------------------------------------------------\n  Arbitrary, reasonably balanced trees\n--------------------------------------------------------------------}\n\ninstance Arbitrary a => Arbitrary (IntMap a) where\n  arbitrary = fmap fromList arbitrary\n\nnewtype NonEmptyIntMap a = NonEmptyIntMap {getNonEmptyIntMap :: IntMap a} deriving (Eq, Show)\n\ninstance Arbitrary a => Arbitrary (NonEmptyIntMap a) where\n  arbitrary = fmap (NonEmptyIntMap . fromList . getNonEmpty) arbitrary\n\n\n------------------------------------------------------------------------\n\ntype UMap = IntMap ()\ntype IMap = IntMap Int\ntype SMap = IntMap String\n\n----------------------------------------------------------------\n-- Unit tests\n----------------------------------------------------------------\n\n----------------------------------------------------------------\n-- Operators\n\ntest_index :: Assertion\ntest_index = do\n    fromList [(5,\'a\'), (3,\'b\')] ! 5 @?= \'a\'\n\n    fromList [(5,\'a\'), (-3,\'b\')] ! (-3) @?= \'b\'\n\ntest_index_lookup :: Assertion\ntest_index_lookup = do\n    fromList [(5,\'a\'), (3,\'b\')] !? 1 @?= Nothing\n    fromList [(5,\'a\'), (3,\'b\')] !? 5 @?= Just \'a\'\n\n    fromList [(5,\'a\'), (-3,\'b\')] !? 1 @?= Nothing\n    fromList [(5,\'a\'), (-3,\'b\')] !? 5 @?= Just \'a\'\n    fromList [(5,\'a\'), (-3,\'b\')] !? (-3) @?= Just \'b\'\n\n----------------------------------------------------------------\n-- Query\n\ntest_size :: Assertion\ntest_size = do\n    null (empty)           @?= True\n    null (singleton 1 \'a\') @?= False\n\n    null (singleton (-1) \'a\') @?= False\n\ntest_size2 :: Assertion\ntest_size2 = do\n    size empty                                   @?= 0\n    size (singleton 1 \'a\')                       @?= 1\n    size (fromList([(1,\'a\'), (2,\'c\'), (3,\'b\')])) @?= 3\n\n    size (fromList [(-2, \'?\'),(5,\'a\'), (3,\'b\')]) @?= 3\n\ntest_member :: Assertion\ntest_member = do\n    member 5 (fromList [(5,\'a\'), (3,\'b\')]) @?= True\n    member 1 (fromList [(5,\'a\'), (3,\'b\')]) @?= False\n\n    member 5    (fromList [(5,\'a\'), (-3,\'b\')]) @?= True\n    member 1    (fromList [(5,\'a\'), (-3,\'b\')]) @?= False\n    member (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= True\n\ntest_notMember :: Assertion\ntest_notMember = do\n    notMember 5 (fromList [(5,\'a\'), (3,\'b\')]) @?= False\n    notMember 1 (fromList [(5,\'a\'), (3,\'b\')]) @?= True\n\n    notMember 5    (fromList [(5,\'a\'), (-3,\'b\')]) @?= False\n    notMember 1    (fromList [(5,\'a\'), (-3,\'b\')]) @?= True\n    notMember (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= False\n\ntest_lookup :: Assertion\ntest_lookup = do\n    employeeCurrency 1      @?= Just 1\n    employeeCurrency 2      @?= Just 2\n    employeeCurrency 3      @?= Just 3\n    employeeCurrency 4      @?= Just 4\n    employeeCurrency 5      @?= Nothing\n    employeeCurrency (2^10) @?= Just 42\n    employeeCurrency 6      @?= Nothing\n  where\n    employeeDept    = fromList [(1,2), (2, 14), (3, 10), (4, 18), (2^10, 100)]\n    deptCountry     = fromList [(1,1), (14, 14), (10, 10), (18, 18), (100, 100), (2,2)]\n    countryCurrency = fromList [(1, 2), (2, 1), (14, 2), (10, 3), (18, 4), (100, 42)]\n    employeeCurrency :: Int -> Maybe Int\n    employeeCurrency name = do\n        dept <- lookup name employeeDept\n        country <- lookup dept deptCountry\n        lookup country countryCurrency\n\ntest_findWithDefault :: Assertion\ntest_findWithDefault = do\n    findWithDefault \'x\' 1 (fromList [(5,\'a\'), (3,\'b\')]) @?= \'x\'\n    findWithDefault \'x\' 5 (fromList [(5,\'a\'), (3,\'b\')]) @?= \'a\'\n\n    findWithDefault \'x\' 1    (fromList [(5,\'a\'), (-3,\'b\')]) @?= \'x\'\n    findWithDefault \'x\' 5    (fromList [(5,\'a\'), (-3,\'b\')]) @?= \'a\'\n    findWithDefault \'x\' (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= \'b\'\n\n\n\ntest_lookupLT :: Assertion\ntest_lookupLT = do\n    lookupLT 3 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n    lookupLT 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (3, \'a\')\n\n    lookupLT (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Nothing\n    lookupLT (-2) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupLT 4    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupLT 6    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n\ntest_lookupGT :: Assertion\ntest_lookupGT = do\n    lookupGT 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (5, \'b\')\n    lookupGT 5 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n\n    lookupGT (-4) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupGT (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n    lookupGT 4    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n    lookupGT 5    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Nothing\n\ntest_lookupLE :: Assertion\ntest_lookupLE = do\n    lookupLE 2 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n    lookupLE 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (3, \'a\')\n    lookupLE 5 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (5, \'b\')\n\n    lookupLE (-4) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Nothing\n    lookupLE (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupLE 4    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupLE 5    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n    lookupLE 6    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n\ntest_lookupGE :: Assertion\ntest_lookupGE = do\n    lookupGE 3 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (3, \'a\')\n    lookupGE 4 (fromList [(3,\'a\'), (5,\'b\')]) @?= Just (5, \'b\')\n    lookupGE 6 (fromList [(3,\'a\'), (5,\'b\')]) @?= Nothing\n\n    lookupGE (-4) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupGE (-3) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (-3, \'b\')\n    lookupGE (-2) (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n    lookupGE 5    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Just (5, \'a\')\n    lookupGE 6    (fromList [(5,\'a\'), (-3,\'b\')]) @?= Nothing\n\n----------------------------------------------------------------\n-- Construction\n\ntest_empty :: Assertion\ntest_empty = do\n    (empty :: UMap)  @?= fromList []\n    size empty @?= 0\n\ntest_mempty :: Assertion\ntest_mempty = do\n    (mempty :: UMap)  @?= fromList []\n    size (mempty :: UMap) @?= 0\n\ntest_singleton :: Assertion\ntest_singleton = do\n    singleton 1 \'a\'        @?= fromList [(1, \'a\')]\n    size (singleton 1 \'a\') @?= 1\n\n    singleton (-1) \'a\'        @?= fromList [(-1, \'a\')]\n    size (singleton (-1) \'a\') @?= 1\n\ntest_insert :: Assertion\ntest_insert = do\n    insert 5 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) @?= fromList [(3, \'b\'), (5, \'x\')]\n    insert 7 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) @?= fromList [(3, \'b\'), (5, \'a\'), (7, \'x\')]\n    insert 5 \'x\' empty                         @?= singleton 5 \'x\'\n\n    insert 5    \'x\' (fromList [(5,\'a\'), (-3,\'b\')]) @?= fromList [(-3, \'b\'), (5, \'x\')]\n    insert 7    \'x\' (fromList [(5,\'a\'), (-3,\'b\')]) @?= fromList [(-3, \'b\'), (5, \'a\'), (7, \'x\')]\n    insert (-3) \'x\' empty                          @?= singleton (-3) \'x\'\n    insert (-3) \'x\' (fromList [(5,\'a\'), (-3,\'b\')]) @?= fromList [(-3, \'x\'), (5, \'a\')]\n    insert (-7) \'x\' (fromList [(5,\'a\'), (-3,\'b\')]) @?= fromList [(-3, \'b\'), (5, \'a\'), (-7, \'x\')]\n\ntest_insertWith :: Assertion\ntest_insertWith = do\n    insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "xxxa")]\n    insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "xxx")]\n    insertWith (++) 5 "xxx" empty                         @?= singleton 5 "xxx"\n\n    insertWith (++) 5 "xxx"    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "xxxa")]\n    insertWith (++) 7 "xxx"    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a"), (7, "xxx")]\n    insertWith (++) (-3) "xxx" empty                          @?= singleton (-3) "xxx"\n    insertWith (++) (-3) "xxx" (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "xxxb"), (5, "a")]\n    insertWith (++) (-7) "xxx" (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a"), (-7, "xxx")]\n\ntest_insertWithKey :: Assertion\ntest_insertWithKey = do\n    insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "5:xxx|a")]\n    insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "xxx")]\n    insertWithKey f 5 "xxx" empty                         @?= singleton 5 "xxx"\n\n    insertWithKey f 5 "xxx"    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "5:xxx|a")]\n    insertWithKey f 7 "xxx"    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a"), (7, "xxx")]\n    insertWithKey f (-3) "xxx" empty                          @?= singleton (-3) "xxx"\n    insertWithKey f (-3) "xxx" (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "-3:xxx|b"), (5, "a")]\n    insertWithKey f (-7) "xxx" (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a"), (-7, "xxx")]\n  where\n    f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n\ntest_insertLookupWithKey :: Assertion\ntest_insertLookupWithKey = do\n    insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) @?= (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])\n    insertLookupWithKey f 2 "xxx" (fromList [(5,"a"), (3,"b")]) @?= (Nothing,fromList [(2,"xxx"),(3,"b"),(5,"a")])\n    insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) @?= (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])\n    insertLookupWithKey f 5 "xxx" empty                         @?= (Nothing,  singleton 5 "xxx")\n\n    insertLookupWithKey f 5 "xxx"    (fromList [(5,"a"), (-3,"b")]) @?= (Just "a", fromList [(-3, "b"), (5, "5:xxx|a")])\n    insertLookupWithKey f 7 "xxx"    (fromList [(5,"a"), (-3,"b")]) @?= (Nothing,  fromList [(-3, "b"), (5, "a"), (7, "xxx")])\n    insertLookupWithKey f (-3) "xxx" empty                          @?= (Nothing,  singleton (-3) "xxx")\n    insertLookupWithKey f (-3) "xxx" (fromList [(5,"a"), (-3,"b")]) @?= (Just "b", fromList [(-3, "-3:xxx|b"), (5, "a")])\n    insertLookupWithKey f (-7) "xxx" (fromList [(5,"a"), (-3,"b")]) @?= (Nothing,  fromList [(-3, "b"), (5, "a"), (-7, "xxx")])\n  where\n    f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n\n----------------------------------------------------------------\n-- Delete/Update\n\ntest_delete :: Assertion\ntest_delete = do\n    delete 5 (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    delete 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    delete 5 empty                         @?= (empty :: IMap)\n\n    delete 5    (fromList [(5,"a"), (-3,"b")]) @?= singleton (-3) "b"\n    delete 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    delete (-3) empty                          @?= (empty :: IMap)\n    delete (-3) (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "a"\n    delete (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n\ntest_adjust :: Assertion\ntest_adjust = do\n    adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "new a")]\n    adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    adjust ("new " ++) 7 empty                         @?= empty\n\n    adjust ("new " ++) 5    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "new a")]\n    adjust ("new " ++) 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    adjust ("new " ++) (-3) empty                          @?= empty\n    adjust ("new " ++) (-3) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "new b"), (5, "a")]\n    adjust ("new " ++) (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n\ntest_adjustWithKey :: Assertion\ntest_adjustWithKey = do\n    adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "5:new a")]\n    adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    adjustWithKey f 7 empty                         @?= empty\n\n    adjustWithKey f 5    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "5:new a")]\n    adjustWithKey f 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    adjustWithKey f (-3) empty                          @?= empty\n    adjustWithKey f (-3) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "-3:new b"), (5, "a")]\n    adjustWithKey f (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n  where\n    f key x = (show key) ++ ":new " ++ x\n\ntest_update :: Assertion\ntest_update = do\n    update f 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "new a")]\n    update f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    update f 3 (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\n    update f 5    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "new a")]\n    update f 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    update f (-3) (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "a"\n    update f (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n  where\n    f x = if x == "a" then Just "new a" else Nothing\n\ntest_updateWithKey :: Assertion\ntest_updateWithKey = do\n    updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "5:new a")]\n    updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\n    updateWithKey f 5    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "5:new a")]\n    updateWithKey f 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    updateWithKey f (-3) (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "a"\n    updateWithKey f (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n where\n     f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n\ntest_updateLookupWithKey :: Assertion\ntest_updateLookupWithKey = do\n    updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) @?= (Just "a", fromList [(3, "b"), (5, "5:new a")])\n    updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) @?= (Nothing,  fromList [(3, "b"), (5, "a")])\n    updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) @?= (Just "b", singleton 5 "a")\n\n    updateLookupWithKey f 5    (fromList [(5,"a"), (-3,"b")]) @?= (Just "a", fromList [(-3, "b"), (5, "5:new a")])\n    updateLookupWithKey f 7    (fromList [(5,"a"), (-3,"b")]) @?= (Nothing,  fromList [(-3, "b"), (5, "a")])\n    updateLookupWithKey f (-3) (fromList [(5,"a"), (-3,"b")]) @?= (Just "b", singleton 5 "a")\n    updateLookupWithKey f (-7) (fromList [(5,"a"), (-3,"b")]) @?= (Nothing,  fromList [(-3, "b"), (5, "a")])\n  where\n    f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n\ntest_alter :: Assertion\ntest_alter = do\n    alter f 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a")]\n    alter f 5 (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    alter g 7 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "a"), (7, "c")]\n    alter g 5 (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "c")]\n\n    alter f 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    alter f 5    (fromList [(5,"a"), (-3,"b")]) @?= singleton (-3) "b"\n    alter f (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a")]\n    alter f (-3) (fromList [(5,"a"), (-3,"b")]) @?= singleton (5) "a"\n    alter g 7    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a"), (7, "c")]\n    alter g 5    (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "c")]\n    alter g (-7) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "a"), (-7, "c")]\n    alter g (-3) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "c"), (5, "a")]\n  where\n    f _ = Nothing\n    g _ = Just "c"\n\n----------------------------------------------------------------\n-- Combine\n\ntest_union :: Assertion\ntest_union = do\n    union (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n    union (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(-3, "b"), (5, "a"), (7, "C")]\n\ntest_mappend :: Assertion\ntest_mappend = do\n    mappend (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n    mappend (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(-3, "b"), (5, "a"), (7, "C")]\n\ntest_unionWith :: Assertion\ntest_unionWith = do\n    unionWith (++) (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "aA"), (7, "C")]\n    unionWith (++) (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(-3, "b"), (5, "aA"), (7, "C")]\n\ntest_unionWithKey :: Assertion\ntest_unionWithKey = do\n    unionWithKey f (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= fromList [(3, "b"), (5, "5:a|A"), (7, "C")]\n    unionWithKey f (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= fromList [(-3, "b"), (5, "5:a|A"), (7, "C")]\n  where\n    f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value\n\ntest_unions :: Assertion\ntest_unions = do\n    unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n        @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n    unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]\n        @?= fromList [(3, "B3"), (5, "A3"), (7, "C")]\n\n    unions [(fromList [(5, "a"), (-3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (-3, "B3")])]\n        @?= fromList [(-3, "b"), (5, "a"), (7, "C")]\n    unions [(fromList [(5, "A3"), (-3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (-3, "b")])]\n        @?= fromList [(-3, "B3"), (5, "A3"), (7, "C")]\n\ntest_mconcat :: Assertion\ntest_mconcat = do\n    mconcat [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n        @?= fromList [(3, "b"), (5, "a"), (7, "C")]\n    mconcat [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]\n        @?= fromList [(3, "B3"), (5, "A3"), (7, "C")]\n\n    mconcat [(fromList [(5, "a"), (-3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (-3, "B3")])]\n        @?= fromList [(-3, "b"), (5, "a"), (7, "C")]\n    mconcat [(fromList [(5, "A3"), (-3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (-3, "b")])]\n        @?= fromList [(-3, "B3"), (5, "A3"), (7, "C")]\n\ntest_unionsWith :: Assertion\ntest_unionsWith = do\n    unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n        @?= fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]\n    unionsWith (++) [(fromList [(5, "a"), (-3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (-3, "B3")])]\n        @?= fromList [(-3, "bB3"), (5, "aAA3"), (7, "C")]\n\ntest_difference :: Assertion\ntest_difference = do\n    difference (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= singleton 3 "b"\n    difference (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton (-3) "b"\n\ntest_differenceWith :: Assertion\ntest_differenceWith = do\n    differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])\n        @?= singleton 3 "b:B"\n    differenceWith f (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (-3, "B"), (7, "C")])\n        @?= singleton (-3) "b:B"\n where\n   f al ar = if al== "b" then Just (al ++ ":" ++ ar) else Nothing\n\ntest_differenceWithKey :: Assertion\ntest_differenceWithKey = do\n    differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])\n        @?= singleton 3 "3:b|B"\n    differenceWithKey f (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (-3, "B"), (10, "C")])\n        @?= singleton (-3) "-3:b|B"\n  where\n    f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing\n\ntest_intersection :: Assertion\ntest_intersection = do\n    intersection (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "a"\n    intersection (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "a"\n\n\ntest_intersectionWith :: Assertion\ntest_intersectionWith = do\n    intersectionWith (++) (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "aA"\n    intersectionWith (++) (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "aA"\n\ntest_intersectionWithKey :: Assertion\ntest_intersectionWithKey = do\n    intersectionWithKey f (fromList [(5, "a"), (3, "b")])  (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "5:a|A"\n    intersectionWithKey f (fromList [(5, "a"), (-3, "b")]) (fromList [(5, "A"), (7, "C")]) @?= singleton 5 "5:a|A"\n  where\n    f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar\n\n----------------------------------------------------------------\n-- Traversal\n\ntest_map :: Assertion\ntest_map = do\n    map (++ "x") (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "bx"), (5, "ax")]\n    map (++ "x") (fromList [(5,"a"), (3,"b"), (-1,"c")])\n            @?= fromList [(3, "bx"), (5, "ax"), (-1,"cx")]\n\ntest_mapWithKey :: Assertion\ntest_mapWithKey = do\n    mapWithKey f (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "3:b"), (5, "5:a")]\n    mapWithKey f (fromList [(5,"a"), (3,"b"), (-1,"c")])\n            @?= fromList [(3, "3:b"), (5, "5:a"), (-1,"-1:c")]\n  where\n    f key x = (show key) ++ ":" ++ x\n\ntest_mapAccum :: Assertion\ntest_mapAccum = do\n    mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) @?= ("Everything: ba", fromList [(3, "bX"), (5, "aX")])\n    mapAccum f "Everything: " (fromList [(5,"a"), (3,"b"), (-1,"c")])\n        @?= ("Everything: cba", fromList [(3, "bX"), (5, "aX"), (-1, "cX")])\n  where\n    f a b = (a ++ b, b ++ "X")\n\ntest_mapAccumWithKey :: Assertion\ntest_mapAccumWithKey = do\n    mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) @?= ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])\n    mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b"), (-1,"c")])\n        @?= ("Everything: -1-c 3-b 5-a", fromList [(3, "bX"), (5, "aX"), (-1,"cX")])\n  where\n    f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n\ntest_mapAccumRWithKey :: Assertion\ntest_mapAccumRWithKey = do\n    mapAccumRWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) @?= ("Everything: 5-a 3-b", fromList [(3, "bX"), (5, "aX")])\n    mapAccumRWithKey f "Everything:" (fromList [(5,"a"), (3,"b"), (-1,"c")])\n        @?= ("Everything: 5-a 3-b -1-c", fromList [(3, "bX"), (5, "aX"), (-1,"cX")])\n  where\n    f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n\ntest_mapKeys :: Assertion\ntest_mapKeys = do\n    mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        @?= fromList [(4, "b"), (6, "a")]\n    mapKeys (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 1 "c"\n    mapKeys (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 3 "c"\n\n    mapKeys (+ 1) (fromList [(5,"a"), (3,"b"), (-2,"c")])\n            @?= fromList [(4, "b"), (6, "a"), (-1,"c")]\n    mapKeys (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (-4,"c")])\n            @?= singleton 1 "d"\n    mapKeys (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (-3,"d"), (4,"c")])\n            @?= singleton 3 "c"\n\ntest_mapKeysWith :: Assertion\ntest_mapKeysWith = do\n    mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 1 "cdab"\n    mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) @?= singleton 3 "cdab"\n\n    mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (-4,"c")]) @?= singleton 1 "dabc"\n    mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (-2,"a"), (3,"d"), (4,"c")]) @?= singleton 3 "cdba"\n\ntest_mapKeysMonotonic :: Assertion\ntest_mapKeysMonotonic = do\n    mapKeysMonotonic (+ 1) (fromList [(5,"a"), (3,"b")])          @?= fromList [(4, "b"), (6, "a")]\n    mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b")]) @?= fromList [(6, "b"), (10, "a")]\n\n    mapKeysMonotonic (+ 1) (fromList [(5,"a"), (3,"b"), (-2,"c")])\n        @?= fromList [(4, "b"), (6, "a"), (-1, "c")]\n    mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b"), (-2,"c")])\n        @?= fromList [(6, "b"), (10, "a"), (-4, "c")]\n\n----------------------------------------------------------------\n-- Conversion\n\ntest_elems :: Assertion\ntest_elems = do\n    elems (fromList [(5,"a"), (3,"b")]) @?= ["b","a"]\n    elems (fromList [(5,"a"), (-3,"b")]) @?= ["b","a"]\n    elems (empty :: UMap) @?= []\n\ntest_keys :: Assertion\ntest_keys = do\n    keys (fromList [(5,"a"), (3,"b")]) @?= [3,5]\n    keys (fromList [(5,"a"), (-3,"b")]) @?= [-3,5]\n    keys (empty :: UMap) @?= []\n\ntest_assocs :: Assertion\ntest_assocs = do\n    assocs (fromList [(5,"a"), (3,"b")]) @?= [(3,"b"), (5,"a")]\n    assocs (fromList [(5,"a"), (-3,"b")]) @?= [(-3,"b"), (5,"a")]\n    assocs (empty :: UMap) @?= []\n\ntest_keysSet :: Assertion\ntest_keysSet = do\n    keysSet (fromList [(5,"a"), (3,"b")]) @?= IntSet.fromList [3,5]\n    keysSet (fromList [(5,"a"), (-3,"b")]) @?= IntSet.fromList [-3,5]\n    keysSet (empty :: UMap) @?= IntSet.empty\n\ntest_fromSet :: Assertion\ntest_fromSet = do\n   fromSet (\\k -> replicate k \'a\') (IntSet.fromList [3, 5]) @?= fromList [(5,"aaaaa"), (3,"aaa")]\n   fromSet (\\k -> replicate k \'a\') (IntSet.fromList [-3, 2, 5]) @?= fromList [(5,"aaaaa"), (-3,""), (2,"aa")]\n   fromSet undefined IntSet.empty @?= (empty :: IMap)\n\n----------------------------------------------------------------\n-- Lists\n\ntest_toList :: Assertion\ntest_toList = do\n    toList (fromList [(5,"a"), (3,"b")]) @?= [(3,"b"), (5,"a")]\n    toList (fromList [(5,"a"), (-3,"b")]) @?= [(-3,"b"), (5,"a")]\n    toList (empty :: SMap) @?= []\n\ntest_fromList :: Assertion\ntest_fromList = do\n    fromList [] @?= (empty :: SMap)\n    fromList [(5,"a"), (3,"b"), (5, "c")] @?= fromList [(5,"c"), (3,"b")]\n    fromList [(5,"c"), (3,"b"), (5, "a")] @?= fromList [(5,"a"), (3,"b")]\n\n    fromList [(5,"a"), (-3,"b"), (5, "c")] @?= fromList [(5,"c"), (-3,"b")]\n    fromList [(5,"c"), (-3,"b"), (5, "a")] @?= fromList [(5,"a"), (-3,"b")]\n\ntest_fromListWith :: Assertion\ntest_fromListWith = do\n    fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] @?= fromList [(3, "ab"), (5, "aba")]\n    fromListWith (++) [(5,"a"), (5,"b"), (-3,"b"), (-3,"a"), (5,"a")] @?= fromList [(-3, "ab"), (5, "aba")]\n    fromListWith (++) [] @?= (empty :: SMap)\n\ntest_fromListWithKey :: Assertion\ntest_fromListWithKey = do\n    fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] @?= fromList [(3, "3ab"), (5, "5a5ba")]\n    fromListWithKey f [(5,"a"), (5,"b"), (-3,"b"), (-3,"a"), (5,"a")] @?= fromList [(-3, "-3ab"), (5, "5a5ba")]\n    fromListWithKey f [] @?= (empty :: SMap)\n  where\n    f k a1 a2 = (show k) ++ a1 ++ a2\n\n----------------------------------------------------------------\n-- Ordered lists\n\ntest_toAscList :: Assertion\ntest_toAscList = do\n    toAscList (fromList [(5,"a"), (3,"b")]) @?= [(3,"b"), (5,"a")]\n    toAscList (fromList [(5,"a"), (-3,"b")]) @?= [(-3,"b"), (5,"a")]\n\ntest_toDescList :: Assertion\ntest_toDescList = do\n    toDescList (fromList [(5,"a"), (3,"b")]) @?= [(5,"a"), (3,"b")]\n    toDescList (fromList [(5,"a"), (-3,"b")]) @?= [(5,"a"), (-3,"b")]\n\ntest_showTree :: Assertion\ntest_showTree = do\n    showTree posTree @?= expectedPosTree\n    showTree negTree @?= expectedNegTree\n  where mkAscTree ls = fromDistinctAscList [(x,()) | x <- ls]\n        posTree = mkAscTree [1..5]\n        negTree = mkAscTree [(-2)..2]\n        expectedPosTree = unlines\n            [ "*"\n            , "+--*"\n            , "|  +-- 1:=()"\n            , "|  +--*"\n            , "|     +-- 2:=()"\n            , "|     +-- 3:=()"\n            , "+--*"\n            , "   +-- 4:=()"\n            , "   +-- 5:=()"\n            ]\n        expectedNegTree = unlines\n            [ "*"\n            , "+--*"\n            , "|  +--*"\n            , "|  |  +-- 0:=()"\n            , "|  |  +-- 1:=()"\n            , "|  +-- 2:=()"\n            , "+--*"\n            , "   +-- -2:=()"\n            , "   +-- -1:=()"\n            ]\n\ntest_fromAscList :: Assertion\ntest_fromAscList = do\n    fromAscList [(3,"b"), (5,"a")]          @?= fromList [(3, "b"), (5, "a")]\n    fromAscList [(3,"b"), (5,"a"), (5,"b")] @?= fromList [(3, "b"), (5, "b")]\n\n    fromAscList [(-3,"b"), (5,"a")]          @?= fromList [(-3, "b"), (5, "a")]\n    fromAscList [(-3,"b"), (5,"a"), (5,"b")] @?= fromList [(-3, "b"), (5, "b")]\n\n\ntest_fromAscListWith :: Assertion\ntest_fromAscListWith = do\n    fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] @?= fromList [(3, "b"), (5, "ba")]\n    fromAscListWith (++) [(-3,"b"), (5,"a"), (5,"b")] @?= fromList [(-3, "b"), (5, "ba")]\n\ntest_fromAscListWithKey :: Assertion\ntest_fromAscListWithKey = do\n    fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] @?= fromList [(3, "b"), (5, "5:b5:ba")]\n    fromAscListWithKey f [(-3,"b"), (5,"a"), (5,"b"), (5,"b")] @?= fromList [(-3, "b"), (5, "5:b5:ba")]\n  where\n    f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2\n\ntest_fromDistinctAscList :: Assertion\ntest_fromDistinctAscList = do\n    fromDistinctAscList [(3,"b"), (5,"a")] @?= fromList [(3, "b"), (5, "a")]\n    fromDistinctAscList [(-3,"b"), (5,"a")] @?= fromList [(-3, "b"), (5, "a")]\n\n----------------------------------------------------------------\n-- Filter\n\ntest_filter :: Assertion\ntest_filter = do\n    filter (> "a") (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n    filter (> "x") (fromList [(5,"a"), (3,"b")]) @?= empty\n    filter (< "a") (fromList [(5,"a"), (3,"b")]) @?= empty\n\n    filter (> "a") (fromList [(5,"a"), (-3,"b")]) @?= singleton (-3) "b"\n    filter (> "x") (fromList [(5,"a"), (-3,"b")]) @?= empty\n    filter (< "a") (fromList [(5,"a"), (-3,"b")]) @?= empty\n\ntest_filteWithKey :: Assertion\ntest_filteWithKey = do\n    filterWithKey (\\k _ -> k > 4) (fromList [(5,"a"), (3,"b")])  @?= singleton 5 "a"\n    filterWithKey (\\k _ -> k > 4) (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "a"\n\ntest_partition :: Assertion\ntest_partition = do\n    partition (> "a") (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", singleton 5 "a")\n    partition (< "x") (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3, "b"), (5, "a")], empty)\n    partition (> "x") (fromList [(5,"a"), (3,"b")]) @?= (empty, fromList [(3, "b"), (5, "a")])\n\n    partition (> "a") (fromList [(5,"a"), (-3,"b")]) @?= (singleton (-3) "b", singleton 5 "a")\n    partition (< "x") (fromList [(5,"a"), (-3,"b")]) @?= (fromList [(-3, "b"), (5, "a")], empty)\n    partition (> "x") (fromList [(5,"a"), (-3,"b")]) @?= (empty, fromList [(-3, "b"), (5, "a")])\n\ntest_partitionWithKey :: Assertion\ntest_partitionWithKey = do\n    partitionWithKey (\\ k _ -> k > 3) (fromList [(5,"a"), (3,"b")]) @?= (singleton 5 "a", singleton 3 "b")\n    partitionWithKey (\\ k _ -> k < 7) (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3, "b"), (5, "a")], empty)\n    partitionWithKey (\\ k _ -> k > 7) (fromList [(5,"a"), (3,"b")]) @?= (empty, fromList [(3, "b"), (5, "a")])\n\n    partitionWithKey (\\ k _ -> k > 3) (fromList [(5,"a"), (-3,"b")]) @?= (singleton 5 "a", singleton (-3) "b")\n    partitionWithKey (\\ k _ -> k < 7) (fromList [(5,"a"), (-3,"b")]) @?= (fromList [(-3, "b"), (5, "a")], empty)\n    partitionWithKey (\\ k _ -> k > 7) (fromList [(5,"a"), (-3,"b")]) @?= (empty, fromList [(-3, "b"), (5, "a")])\n\ntest_mapMaybe :: Assertion\ntest_mapMaybe = do\n    mapMaybe f (fromList [(5,"a"), (3,"b")])  @?= singleton 5 "new a"\n    mapMaybe f (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "new a"\n  where\n    f x = if x == "a" then Just "new a" else Nothing\n\ntest_mapMaybeWithKey :: Assertion\ntest_mapMaybeWithKey = do\n    mapMaybeWithKey f (fromList [(5,"a"), (3,"b")])  @?= singleton 3 "key : 3"\n    mapMaybeWithKey f (fromList [(5,"a"), (-3,"b")]) @?= singleton (-3) "key : -3"\n  where\n    f k _ = if k < 5 then Just ("key : " ++ (show k)) else Nothing\n\ntest_mapEither :: Assertion\ntest_mapEither = do\n    mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n        @?= (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n    mapEither (\\ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n        @?= ((empty :: SMap), fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n\n    mapEither f (fromList [(5,"a"), (-3,"b"), (1,"x"), (7,"z")])\n        @?= (fromList [(-3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n    mapEither (\\ a -> Right a) (fromList [(5,"a"), (-3,"b"), (1,"x"), (7,"z")])\n        @?= ((empty :: SMap), fromList [(5,"a"), (-3,"b"), (1,"x"), (7,"z")])\n where\n   f a = if a < "c" then Left a else Right a\n\ntest_mapEitherWithKey :: Assertion\ntest_mapEitherWithKey = do\n    mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n     @?= (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])\n    mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n     @?= ((empty :: SMap), fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])\n\n    mapEitherWithKey f (fromList [(5,"a"), (-3,"b"), (1,"x"), (7,"z")])\n     @?= (fromList [(1,2), (-3,-6)], fromList [(5,"aa"), (7,"zz")])\n    mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (-3,"b"), (1,"x"), (7,"z")])\n     @?= ((empty :: SMap), fromList [(1,"x"), (-3,"b"), (5,"a"), (7,"z")])\n  where\n    f k a = if k < 5 then Left (k * 2) else Right (a ++ a)\n\ntest_split :: Assertion\ntest_split = do\n    split 2 (fromList [(5,"a"), (3,"b")]) @?= (empty, fromList [(3,"b"), (5,"a")])\n    split 3 (fromList [(5,"a"), (3,"b")]) @?= (empty, singleton 5 "a")\n    split 4 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", singleton 5 "a")\n    split 5 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", empty)\n    split 6 (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3,"b"), (5,"a")], empty)\n\n    split (-4) (fromList [(5,"a"), (-3,"b")]) @?= (empty, fromList [(-3,"b"), (5,"a")])\n    split (-3) (fromList [(5,"a"), (-3,"b")]) @?= (empty, singleton 5 "a")\n    split 4 (fromList [(5,"a"), (-3,"b")]) @?= (singleton (-3) "b", singleton 5 "a")\n    split 5 (fromList [(5,"a"), (-3,"b")]) @?= (singleton (-3) "b", empty)\n    split 6 (fromList [(5,"a"), (-3,"b")]) @?= (fromList [(-3,"b"), (5,"a")], empty)\n\ntest_splitLookup :: Assertion\ntest_splitLookup = do\n    splitLookup 2 (fromList [(5,"a"), (3,"b")]) @?= (empty, Nothing, fromList [(3,"b"), (5,"a")])\n    splitLookup 3 (fromList [(5,"a"), (3,"b")]) @?= (empty, Just "b", singleton 5 "a")\n    splitLookup 4 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", Nothing, singleton 5 "a")\n    splitLookup 5 (fromList [(5,"a"), (3,"b")]) @?= (singleton 3 "b", Just "a", empty)\n    splitLookup 6 (fromList [(5,"a"), (3,"b")]) @?= (fromList [(3,"b"), (5,"a")], Nothing, empty)\n\n    splitLookup (-4) (fromList [(5,"a"), (-3,"b")]) @?= (empty, Nothing, fromList [(-3,"b"), (5,"a")])\n    splitLookup (-3) (fromList [(5,"a"), (-3,"b")]) @?= (empty, Just "b", singleton 5 "a")\n    splitLookup 4 (fromList [(5,"a"), (-3,"b")]) @?= (singleton (-3) "b", Nothing, singleton 5 "a")\n    splitLookup 5 (fromList [(5,"a"), (-3,"b")]) @?= (singleton (-3) "b", Just "a", empty)\n    splitLookup 6 (fromList [(5,"a"), (-3,"b")]) @?= (fromList [(-3,"b"), (5,"a")], Nothing, empty)\n\n----------------------------------------------------------------\n-- Submap\n\ntest_isSubmapOfBy :: Assertion\ntest_isSubmapOfBy = do\n    isSubmapOfBy (==) (fromList [(fromEnum \'a\',1)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= True\n    isSubmapOfBy (<=) (fromList [(fromEnum \'a\',1)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= True\n    isSubmapOfBy (==) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= True\n    isSubmapOfBy (==) (fromList [(fromEnum \'a\',2)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= False\n    isSubmapOfBy (<)  (fromList [(fromEnum \'a\',1)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= False\n    isSubmapOfBy (==) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) (fromList [(fromEnum \'a\',1)]) @?= False\n\n    isSubmapOfBy (==) (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= True\n    isSubmapOfBy (<=) (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= True\n    isSubmapOfBy (==) (fromList [(-1,1),(2,2)]) (fromList [(-1,1),(2,2)]) @?= True\n    isSubmapOfBy (==) (fromList [(-1,2)]) (fromList [(-1,1),(2,2)]) @?= False\n    isSubmapOfBy (>)  (fromList [(-1,2)]) (fromList [(-1,1),(2,2)]) @?= True\n    isSubmapOfBy (<)  (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= False\n    isSubmapOfBy (==) (fromList [(-1,1),(2,2)]) (fromList [(-1,1)]) @?= False\n\ntest_isSubmapOf :: Assertion\ntest_isSubmapOf = do\n    isSubmapOf (fromList [(fromEnum \'a\',1)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= True\n    isSubmapOf (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= True\n    isSubmapOf (fromList [(fromEnum \'a\',2)]) (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) @?= False\n    isSubmapOf (fromList [(fromEnum \'a\',1),(fromEnum \'b\',2)]) (fromList [(fromEnum \'a\',1)]) @?= False\n\n    isSubmapOf (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= True\n    isSubmapOf (fromList [(-1,1),(2,2)]) (fromList [(-1,1),(2,2)]) @?= True\n    isSubmapOf (fromList [(-1,2)]) (fromList [(-1,1),(2,2)]) @?= False\n    isSubmapOf (fromList [(-1,1),(2,2)]) (fromList [(-1,1)]) @?= False\n\ntest_isProperSubmapOfBy :: Assertion\ntest_isProperSubmapOfBy = do\n    isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)]) @?= True\n    isProperSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)]) @?= True\n    isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)]) @?= False\n    isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)]) @?= False\n    isProperSubmapOfBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)]) @?= False\n\n    isProperSubmapOfBy (==) (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= True\n    isProperSubmapOfBy (<=) (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= True\n    isProperSubmapOfBy (==) (fromList [(-1,1),(2,2)]) (fromList [(-1,1),(2,2)]) @?= False\n    isProperSubmapOfBy (==) (fromList [(-1,1),(2,2)]) (fromList [(-1,1)]) @?= False\n    isProperSubmapOfBy (<)  (fromList [(-1,1)])       (fromList [(-1,1),(2,2)]) @?= False\n\ntest_isProperSubmapOf :: Assertion\ntest_isProperSubmapOf = do\n    isProperSubmapOf (fromList [(1,1)]) (fromList [(1,1),(2,2)]) @?= True\n    isProperSubmapOf (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)]) @?= False\n    isProperSubmapOf (fromList [(1,1),(2,2)]) (fromList [(1,1)]) @?= False\n\n    isProperSubmapOf (fromList [(-1,1)]) (fromList [(-1,1),(2,2)]) @?= True\n    isProperSubmapOf (fromList [(-1,1),(2,2)]) (fromList [(-1,1),(2,2)]) @?= False\n    isProperSubmapOf (fromList [(-1,1),(2,2)]) (fromList [(-1,1)]) @?= False\n\n----------------------------------------------------------------\n-- Min/Max\n\ntest_lookupMin :: Assertion\ntest_lookupMin = do\n  lookupMin (fromList [(5,"a"), (3,"b")])  @?= Just (3,"b")\n  lookupMin (fromList [(5,"a"), (-3,"b")]) @?= Just (-3,"b")\n  lookupMin (empty :: SMap) @?= Nothing\n\ntest_lookupMax :: Assertion\ntest_lookupMax = do\n  lookupMax (fromList [(5,"a"), (3,"b")]) @?= Just (5,"a")\n  lookupMax (fromList [(5,"a"), (-3,"b")]) @?= Just (5,"a")\n  lookupMax (empty :: SMap) @?= Nothing\n\ntest_findMin :: Assertion\ntest_findMin = do\n    findMin (fromList [(5,"a"), (3,"b")]) @?= (3,"b")\n    findMin (fromList [(5,"a"), (-3,"b")]) @?= (-3,"b")\n\ntest_findMax :: Assertion\ntest_findMax = do\n    findMax (fromList [(5,"a"), (3,"b")]) @?= (5,"a")\n    findMax (fromList [(5,"a"), (-3,"b")]) @?= (5,"a")\n\ntest_deleteMin :: Assertion\ntest_deleteMin = do\n    deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) @?= fromList [(5,"a"), (7,"c")]\n    deleteMin (fromList [(5,"a"), (-3,"b"), (7,"c")]) @?= fromList [(5,"a"), (7,"c")]\n    deleteMin (empty :: SMap) @?= empty\n\ntest_deleteMax :: Assertion\ntest_deleteMax = do\n    deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) @?= fromList [(3,"b"), (5,"a")]\n    deleteMax (fromList [(5,"a"), (-3,"b"), (7,"c")]) @?= fromList [(-3,"b"), (5,"a")]\n    deleteMax (empty :: SMap) @?= empty\n\ntest_deleteFindMin :: Assertion\ntest_deleteFindMin = do\n    deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) @?= ((3,"b"), fromList[(5,"a"), (10,"c")])\n    deleteFindMin (fromList [(5,"a"), (-3,"b"), (10,"c")]) @?= ((-3,"b"), fromList[(5,"a"), (10,"c")])\n\ntest_deleteFindMax :: Assertion\ntest_deleteFindMax = do\n    deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) @?= ((10,"c"), fromList [(3,"b"), (5,"a")])\n    deleteFindMax (fromList [(5,"a"), (-3,"b"), (10,"c")]) @?= ((10,"c"), fromList [(-3,"b"), (5,"a")])\n\ntest_updateMin :: Assertion\ntest_updateMin = do\n    updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "Xb"), (5, "a")]\n    updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\n    updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "Xb"), (5, "a")]\n    updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "a"\n\ntest_updateMax :: Assertion\ntest_updateMax = do\n    updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3, "b"), (5, "Xa")]\n    updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n\n    updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3, "b"), (5, "Xa")]\n    updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (-3,"b")]) @?= singleton (-3) "b"\n\ntest_updateMinWithKey :: Assertion\ntest_updateMinWithKey = do\n    updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3,"3:b"), (5,"a")]\n    updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) @?= singleton 5 "a"\n\n    updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3,"-3:b"), (5,"a")]\n    updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (-3,"b")]) @?= singleton 5 "a"\n\ntest_updateMaxWithKey :: Assertion\ntest_updateMaxWithKey = do\n    updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) @?= fromList [(3,"b"), (5,"5:a")]\n    updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) @?= singleton 3 "b"\n\n    updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (-3,"b")]) @?= fromList [(-3,"b"), (5,"5:a")]\n    updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (-3,"b")]) @?= singleton (-3) "b"\n\ntest_minView :: Assertion\ntest_minView = do\n    minView (fromList [(5,"a"), (3,"b")]) @?= Just ("b", singleton 5 "a")\n    minView (fromList [(5,"a"), (-3,"b")]) @?= Just ("b", singleton 5 "a")\n    minView (empty :: SMap) @?= Nothing\n\ntest_maxView :: Assertion\ntest_maxView = do\n    maxView (fromList [(5,"a"), (3,"b")]) @?= Just ("a", singleton 3 "b")\n    maxView (fromList [(5,"a"), (-3,"b")]) @?= Just ("a", singleton (-3) "b")\n    maxView (empty :: SMap) @?= Nothing\n\ntest_minViewWithKey :: Assertion\ntest_minViewWithKey = do\n    minViewWithKey (fromList [(5,"a"), (3,"b")]) @?= Just ((3,"b"), singleton 5 "a")\n    minViewWithKey (fromList [(5,"a"), (-3,"b")]) @?= Just ((-3,"b"), singleton 5 "a")\n    minViewWithKey (empty :: SMap) @?= Nothing\n\ntest_maxViewWithKey :: Assertion\ntest_maxViewWithKey = do\n    maxViewWithKey (fromList [(5,"a"), (3,"b")]) @?= Just ((5,"a"), singleton 3 "b")\n    maxViewWithKey (fromList [(5,"a"), (-3,"b")]) @?= Just ((5,"a"), singleton (-3) "b")\n    maxViewWithKey (empty :: SMap) @?= Nothing\n\ntest_minimum :: Assertion\ntest_minimum = do\n    getOW (minimum testOrdMap) @?= "min"\n    minimum (elems testOrdMap) @?= minimum testOrdMap\n  where getOW (OrdWith s _) = s\n\ntest_maximum :: Assertion\ntest_maximum = do\n    getOW (maximum testOrdMap) @?= "max"\n    maximum (elems testOrdMap) @?= maximum testOrdMap\n  where getOW (OrdWith s _) = s\n\ntestOrdMap :: IntMap (OrdWith Int)\ntestOrdMap = fromList [(1,OrdWith "max" 1),(-1,OrdWith "min" 1)]\n\ndata OrdWith a = OrdWith String a\n    deriving (Eq, Show)\n\ninstance Ord a => Ord (OrdWith a) where\n    OrdWith _ a1 <= OrdWith _ a2 = a1 <= a2\n\n----------------------------------------------------------------\n-- Valid IntMaps\n----------------------------------------------------------------\n\nforValid :: Testable b => (SMap -> b) -> Property\nforValid f = forAll arbitrary $ \\t ->\n    classify (size t == 0) "empty" $\n    classify (size t > 0 && size t <= 10) "small" $\n    classify (size t > 10 && size t <= 64) "medium" $\n    classify (size t > 64) "large" $ f t\n\nforValidUnitTree :: Testable b => (SMap -> b) -> Property\nforValidUnitTree f = forValid f\n\nprop_valid :: Property\nprop_valid = forValidUnitTree $ \\t -> valid t\n\n----------------------------------------------------------------\n-- QuickCheck\n----------------------------------------------------------------\n\nprop_emptyValid :: Property\nprop_emptyValid = valid empty\n\nprop_singleton :: Int -> Int -> Property\nprop_singleton k x =\n  case singleton k x of\n    s ->\n      valid s .&&.\n      s === insert k x empty\n\nprop_insertLookup :: Int -> UMap -> Bool\nprop_insertLookup k t = lookup k (insert k () t) /= Nothing\n\nprop_insertDelete :: Int -> UMap -> Property\nprop_insertDelete k t =\n  lookup k t == Nothing ==>\n    case delete k (insert k () t) of\n      t\' -> valid t\' .&&. t\' === t\n\nprop_deleteNonMember :: Int -> UMap -> Property\nprop_deleteNonMember k t = (lookup k t == Nothing) ==> (delete k t == t)\n\n----------------------------------------------------------------\n\nprop_unionModel :: [(Int,Int)] -> [(Int,Int)] -> Property\nprop_unionModel xs ys =\n  case union (fromList xs) (fromList ys) of\n    t ->\n      valid t .&&.\n      sort (keys t) === sort (nub (Prelude.map fst xs ++ Prelude.map fst ys))\n\nprop_unionSingleton :: IMap -> Int -> Int -> Bool\nprop_unionSingleton t k x = union (singleton k x) t == insert k x t\n\nprop_unionAssoc :: IMap -> IMap -> IMap -> Bool\nprop_unionAssoc t1 t2 t3 = union t1 (union t2 t3) == union (union t1 t2) t3\n\nprop_unionWith :: IMap -> IMap -> Bool\nprop_unionWith t1 t2 = (union t1 t2 == unionWith (\\_ y -> y) t2 t1)\n\nprop_unionSum :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_unionSum xs ys\n  = sum (elems (unionWith (+) (fromListWith (+) xs) (fromListWith (+) ys)))\n    == (sum (Prelude.map snd xs) + sum (Prelude.map snd ys))\n\nprop_differenceModel :: [(Int,Int)] -> [(Int,Int)] -> Property\nprop_differenceModel xs ys =\n  case difference (fromListWith (+) xs) (fromListWith (+) ys) of\n    t ->\n      valid t .&&.\n      sort (keys t) === sort ((List.\\\\)\n                                 (nub (Prelude.map fst xs))\n                                 (nub (Prelude.map fst ys)))\n\nprop_intersectionModel :: [(Int,Int)] -> [(Int,Int)] -> Property\nprop_intersectionModel xs ys =\n  case intersection (fromListWith (+) xs) (fromListWith (+) ys) of\n    t ->\n      valid t .&&.\n      sort (keys t) === sort (nub ((List.intersect)\n                                      (Prelude.map fst xs)\n                                      (Prelude.map fst ys)))\n\nprop_intersectionWithModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_intersectionWithModel xs ys\n  = toList (intersectionWith f (fromList xs\') (fromList ys\'))\n    == [(kx, f vx vy ) | (kx, vx) <- List.sort xs\', (ky, vy) <- ys\', kx == ky]\n    where xs\' = List.nubBy ((==) `on` fst) xs\n          ys\' = List.nubBy ((==) `on` fst) ys\n          f l r = l + 2 * r\n\nprop_intersectionWithKeyModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_intersectionWithKeyModel xs ys\n  = toList (intersectionWithKey f (fromList xs\') (fromList ys\'))\n    == [(kx, f kx vx vy) | (kx, vx) <- List.sort xs\', (ky, vy) <- ys\', kx == ky]\n    where xs\' = List.nubBy ((==) `on` fst) xs\n          ys\' = List.nubBy ((==) `on` fst) ys\n          f k l r = k + 2 * l + 3 * r\n\nprop_disjoint :: UMap -> UMap -> Property\nprop_disjoint m1 m2 = disjoint m1 m2 === null (intersection m1 m2)\n\nprop_compose :: IMap -> IMap -> Int -> Property\nprop_compose bc ab k = (compose bc ab !? k) === ((bc !?) <=< (ab !?)) k\n\n-- TODO: the second argument should be simply an \'IntSet\', but that\n-- runs afoul of our orphan instance.\nprop_restrictKeys :: IMap -> IMap -> Property\nprop_restrictKeys m s0 =\n    m `restrictKeys` s === filterWithKey (\\k _ -> k `IntSet.member` s) m\n  where\n    s = keysSet s0\n\n-- TODO: the second argument should be simply an \'IntSet\', but that\n-- runs afoul of our orphan instance.\nprop_withoutKeys :: IMap -> IMap -> Property\nprop_withoutKeys m s0 =\n    m `withoutKeys` s === filterWithKey (\\k _ -> k `IntSet.notMember` s) m\n  where\n    s = keysSet s0\n\nprop_mergeWithKeyModel :: [(Int,Int)] -> [(Int,Int)] -> Bool\nprop_mergeWithKeyModel xs ys\n  = and [ testMergeWithKey f keep_x keep_y\n        | f <- [ \\_k x1  _x2 -> Just x1\n               , \\_k _x1 x2  -> Just x2\n               , \\_k _x1 _x2 -> Nothing\n               , \\k  x1  x2  -> if k `mod` 2 == 0 then Nothing else Just (2 * x1 + 3 * x2)\n               ]\n        , keep_x <- [ True, False ]\n        , keep_y <- [ True, False ]\n        ]\n\n    where xs\' = List.nubBy ((==) `on` fst) xs\n          ys\' = List.nubBy ((==) `on` fst) ys\n\n          xm = fromList xs\'\n          ym = fromList ys\'\n\n          testMergeWithKey f keep_x keep_y\n            = toList (mergeWithKey f (keep keep_x) (keep keep_y) xm ym) == emulateMergeWithKey f keep_x keep_y\n              where keep False _ = empty\n                    keep True  m = m\n\n                    emulateMergeWithKey f keep_x keep_y\n                      = Maybe.mapMaybe combine (sort $ List.union (List.map fst xs\') (List.map fst ys\'))\n                        where combine k = case (List.lookup k xs\', List.lookup k ys\') of\n                                            (Nothing, Just y) -> if keep_y then Just (k, y) else Nothing\n                                            (Just x, Nothing) -> if keep_x then Just (k, x) else Nothing\n                                            (Just x, Just y) -> (\\v -> (k, v)) `fmap` f k x y\n\n          -- We prevent inlining testMergeWithKey to disable the SpecConstr\n          -- optimalization. There are too many call patterns here so several\n          -- warnings are issued if testMergeWithKey gets inlined.\n          {-# NOINLINE testMergeWithKey #-}\n\nprop_merge_valid\n    :: Fun (Key, A) (Maybe C)\n    -> Fun (Key, B) (Maybe C)\n    -> Fun (Key, A, B) (Maybe C)\n    -> IntMap A\n    -> IntMap B\n    -> Property\nprop_merge_valid whenMissingA whenMissingB whenMatched xs ys\n  = valid m\n  where\n    m =\n      merge\n        (mapMaybeMissing (applyFun2 whenMissingA))\n        (mapMaybeMissing (applyFun2 whenMissingB))\n        (zipWithMaybeMatched (applyFun3 whenMatched))\n        xs\n        ys\n\n-- This uses the instance\n--     Monoid a => Applicative ((,) a)\n-- to test that effects are sequenced in ascending key order.\nprop_mergeA_effects :: UMap -> UMap -> Property\nprop_mergeA_effects xs ys\n  = effects === sort effects\n  where\n    (effects, _m) = mergeA whenMissing whenMissing whenMatched xs ys\n    whenMissing = traverseMissing (\\k _ -> ([k], ()))\n    whenMatched = zipWithAMatched (\\k _ _ -> ([k], ()))\n\n----------------------------------------------------------------\n\nprop_ordered :: Property\nprop_ordered\n  = forAll (choose (5,100)) $ \\n ->\n    let xs = [(x,()) | x <- [0..n::Int]]\n    in fromAscList xs == fromList xs\n\nprop_list :: [Int] -> Bool\nprop_list xs = (sort (nub xs) == [x | (x,()) <- toList (fromList [(x,()) | x <- xs])])\n\nprop_descList :: [Int] -> Bool\nprop_descList xs = (reverse (sort (nub xs)) == [x | (x,()) <- toDescList (fromList [(x,()) | x <- xs])])\n\nprop_ascDescList :: [Int] -> Bool\nprop_ascDescList xs = toAscList m == reverse (toDescList m)\n  where m = fromList $ zip xs $ repeat ()\n\nprop_fromList :: [Int] -> Property\nprop_fromList xs\n  = case fromList (zip xs xs) of\n      t -> valid t .&&.\n           t === fromAscList (zip sort_xs sort_xs) .&&.\n           t === fromDistinctAscList (zip nub_sort_xs nub_sort_xs) .&&.\n           t === List.foldr (uncurry insert) empty (zip xs xs)\n  where sort_xs = sort xs\n        nub_sort_xs = List.map List.head $ List.group sort_xs\n\n----------------------------------------------------------------\n\nprop_alter :: UMap -> Int -> Property\nprop_alter t k = valid t\' .&&. case lookup k t of\n    Just _  -> (size t - 1) == size t\' && lookup k t\' == Nothing\n    Nothing -> (size t + 1) == size t\' && lookup k t\' /= Nothing\n  where\n    t\' = alter f k t\n    f Nothing   = Just ()\n    f (Just ()) = Nothing\n\n------------------------------------------------------------------------\n-- Compare against the list model (after nub on keys)\n\nprop_index :: [Int] -> Property\nprop_index xs = length xs > 0 ==>\n  let m  = fromList (zip xs xs)\n  in  xs == [ m ! i | i <- xs ]\n\nprop_index_lookup :: [Int] -> Property\nprop_index_lookup xs = length xs > 0 ==>\n  let m  = fromList (zip xs xs)\n  in  (Prelude.map Just xs) == [ m !? i | i <- xs ]\n\nprop_null :: IMap -> Bool\nprop_null m = null m == (size m == 0)\n\nprop_size :: UMap -> Property\nprop_size im = sz === foldl\' (\\i _ -> i + 1) (0 :: Int) im .&&.\n               sz === List.length (toList im)\n  where sz = size im\n\nprop_member :: [Int] -> Int -> Bool\nprop_member xs n =\n  let m  = fromList (zip xs xs)\n  in all (\\k -> k `member` m == (k `elem` xs)) (n : xs)\n\nprop_notmember :: [Int] -> Int -> Bool\nprop_notmember xs n =\n  let m  = fromList (zip xs xs)\n  in all (\\k -> k `notMember` m == (k `notElem` xs)) (n : xs)\n\nprop_lookup :: [(Int, Int)] -> Int -> Bool\nprop_lookup xs n =\n  let xs\' = List.nubBy ((==) `on` fst) xs\n      m = fromList xs\'\n  in all (\\k -> lookup k m == List.lookup k xs\') (n : List.map fst xs\')\n\nprop_find :: [(Int, Int)] -> Bool\nprop_find xs =\n  let xs\' = List.nubBy ((==) `on` fst) xs\n      m = fromList xs\'\n  in all (\\(k, v) -> m ! k == v) xs\'\n\nprop_findWithDefault :: [(Int, Int)] -> Int -> Int -> Bool\nprop_findWithDefault xs n x =\n  let xs\' = List.nubBy ((==) `on` fst) xs\n      m = fromList xs\'\n  in all (\\k -> findWithDefault x k m == maybe x id (List.lookup k xs\')) (n : List.map fst xs\')\n\ntest_lookupSomething :: (Int -> IntMap Int -> Maybe (Int, Int)) -> (Int -> Int -> Bool) -> [(Int, Int)] -> Bool\ntest_lookupSomething lookup\' cmp xs =\n  let odd_sorted_xs = filter_odd $ sort $ List.nubBy ((==) `on` fst) xs\n      t = fromList odd_sorted_xs\n      test k = case List.filter ((`cmp` k) . fst) odd_sorted_xs of\n                 []             -> lookup\' k t == Nothing\n                 cs | 0 `cmp` 1 -> lookup\' k t == Just (last cs) -- we want largest such element\n                    | otherwise -> lookup\' k t == Just (head cs) -- we want smallest such element\n  in all test (List.map fst xs)\n\n  where filter_odd [] = []\n        filter_odd [_] = []\n        filter_odd (_ : o : xs) = o : filter_odd xs\n\nprop_lookupLT :: [(Int, Int)] -> Bool\nprop_lookupLT = test_lookupSomething lookupLT (<)\n\nprop_lookupGT :: [(Int, Int)] -> Bool\nprop_lookupGT = test_lookupSomething lookupGT (>)\n\nprop_lookupLE :: [(Int, Int)] -> Bool\nprop_lookupLE = test_lookupSomething lookupLE (<=)\n\nprop_lookupGE :: [(Int, Int)] -> Bool\nprop_lookupGE = test_lookupSomething lookupGE (>=)\n\nprop_lookupMin :: IntMap Int -> Property\nprop_lookupMin im = lookupMin im === listToMaybe (toAscList im)\n\nprop_lookupMax :: IntMap Int -> Property\nprop_lookupMax im = lookupMax im === listToMaybe (toDescList im)\n\nprop_findMin :: NonEmptyIntMap Int -> Property\nprop_findMin (NonEmptyIntMap im) = findMin im === head (toAscList im)\n\nprop_findMax :: NonEmptyIntMap Int -> Property\nprop_findMax (NonEmptyIntMap im) = findMax im === head (toDescList im)\n\nprop_deleteMinModel :: [(Int, Int)] -> Property\nprop_deleteMinModel ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  toAscList (deleteMin m) == tail (sort xs)\n\nprop_deleteMaxModel :: [(Int, Int)] -> Property\nprop_deleteMaxModel ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  toAscList (deleteMax m) == init (sort xs)\n\nprop_filter :: Fun Int Bool -> [(Int, Int)] -> Property\nprop_filter p ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = filter (apply p) (fromList xs)\n  in  valid m .&&.\n      m === fromList (List.filter (apply p . snd) xs)\n\nprop_partition :: Fun Int Bool -> [(Int, Int)] -> Property\nprop_partition p ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m@(l, r) = partition (apply p) (fromList xs)\n  in  valid l .&&.\n      valid r .&&.\n      m === let (a,b) = (List.partition (apply p . snd) xs)\n            in (fromList a, fromList b)\n\nprop_takeWhileAntitone :: Int -> [(Int, Int)] -> Property\nprop_takeWhileAntitone x ys =\n  let l = takeWhileAntitone (<x) (fromList ys)\n  in  valid l .&&.\n      l === fromList (List.filter ((<x) . fst) ys)\n\nprop_dropWhileAntitone :: Int -> [(Int, Int)] -> Property\nprop_dropWhileAntitone x ys =\n  let r = dropWhileAntitone (<x) (fromList ys)\n  in  valid r .&&.\n      r === fromList (List.filter ((>=x) . fst) ys)\n\nprop_spanAntitone :: Int -> [(Int, Int)] -> Property\nprop_spanAntitone x ys =\n  let (l, r) = spanAntitone (<x) (fromList ys)\n  in  valid l .&&.\n      valid r .&&.\n      l === fromList (List.filter ((<x) . fst) ys) .&&.\n      r === fromList (List.filter ((>=x) . fst) ys)\n\nprop_map :: Fun Int Int -> [(Int, Int)] -> Property\nprop_map f ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  map (apply f) m == fromList [ (a, apply f b) | (a,b) <- xs ]\n\nprop_fmap :: Fun Int Int -> [(Int, Int)] -> Property\nprop_fmap f ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  fmap (apply f) m == fromList [ (a, apply f b) | (a,b) <- xs ]\n\nprop_mapkeys :: Fun Int Int -> [(Int, Int)] -> Property\nprop_mapkeys f ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  mapKeys (apply f) m == (fromList $ List.nubBy ((==) `on` fst) $ reverse [ (apply f a, b) | (a,b) <- sort xs])\n\nprop_splitModel :: Int -> [(Int, Int)] -> Property\nprop_splitModel n ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      (l, r) = split n $ fromList xs\n  in  valid l .&&.\n      valid r .&&.\n      toAscList l === sort [(k, v) | (k,v) <- xs, k < n] .&&.\n      toAscList r === sort [(k, v) | (k,v) <- xs, k > n]\n\nprop_splitLookup :: Int -> [(Int, Int)] -> Property\nprop_splitLookup n ys =\n    let xs = List.nubBy ((==) `on` fst) ys\n        (l, x, r) = splitLookup n (fromList xs)\n    in  valid l .&&.\n        valid r .&&.\n        x === List.lookup n xs .&&.\n        toAscList l === sort [(k, v) | (k,v) <- xs, k < n] .&&.\n        toAscList r === sort [(k, v) | (k,v) <- xs, k > n]\n\nprop_splitRoot :: IMap -> Bool\nprop_splitRoot s = loop ls && (s == unions ls)\n where\n  ls = splitRoot s\n  loop [] = True\n  loop (s1:rst) = List.null\n                  [ (x,y) | x <- toList s1\n                          , y <- toList (unions rst)\n                          , x > y ]\n\nprop_foldr :: Int -> [(Int, Int)] -> Property\nprop_foldr n ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  foldr (+) n m == List.foldr (+) n (List.map snd xs) &&\n      foldr (:) [] m == List.map snd (List.sort xs) &&\n      foldrWithKey (\\_ a b -> a + b) n m == List.foldr (+) n (List.map snd xs) &&\n      foldrWithKey (\\k _ b -> k + b) n m == List.foldr (+) n (List.map fst xs) &&\n      foldrWithKey (\\k x xs -> (k,x):xs) [] m == List.sort xs\n\n\nprop_foldr\' :: Int -> [(Int, Int)] -> Property\nprop_foldr\' n ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  foldr\' (+) n m == List.foldr (+) n (List.map snd xs) &&\n      foldr\' (:) [] m == List.map snd (List.sort xs) &&\n      foldrWithKey\' (\\_ a b -> a + b) n m == List.foldr (+) n (List.map snd xs) &&\n      foldrWithKey\' (\\k _ b -> k + b) n m == List.foldr (+) n (List.map fst xs) &&\n      foldrWithKey\' (\\k x xs -> (k,x):xs) [] m == List.sort xs\n\nprop_foldl :: Int -> [(Int, Int)] -> Property\nprop_foldl n ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  foldl (+) n m == List.foldr (+) n (List.map snd xs) &&\n      foldl (flip (:)) [] m == reverse (List.map snd (List.sort xs)) &&\n      foldlWithKey (\\b _ a -> a + b) n m == List.foldr (+) n (List.map snd xs) &&\n      foldlWithKey (\\b k _ -> k + b) n m == List.foldr (+) n (List.map fst xs) &&\n      foldlWithKey (\\xs k x -> (k,x):xs) [] m == reverse (List.sort xs)\n\nprop_foldl\' :: Int -> [(Int, Int)] -> Property\nprop_foldl\' n ys = length ys > 0 ==>\n  let xs = List.nubBy ((==) `on` fst) ys\n      m  = fromList xs\n  in  foldl\' (+) n m == List.foldr (+) n (List.map snd xs) &&\n      foldl\' (flip (:)) [] m == reverse (List.map snd (List.sort xs)) &&\n      foldlWithKey\' (\\b _ a -> a + b) n m == List.foldr (+) n (List.map snd xs) &&\n      foldlWithKey\' (\\b k _ -> k + b) n m == List.foldr (+) n (List.map fst xs) &&\n      foldlWithKey\' (\\xs k x -> (k,x):xs) [] m == reverse (List.sort xs)\n\nprop_foldrEqFoldMap :: IntMap Int -> Property\nprop_foldrEqFoldMap m =\n  foldr (:) [] m === Data.Foldable.foldMap (:[]) m\n\nprop_foldrWithKeyEqFoldMapWithKey :: IntMap Int -> Property\nprop_foldrWithKeyEqFoldMapWithKey m =\n  foldrWithKey (\\k v -> ((k,v):)) [] m === foldMapWithKey (\\k v -> ([(k,v)])) m\n\nprop_FoldableTraversableCompat :: Fun A [B] -> IntMap A -> Property\nprop_FoldableTraversableCompat fun m = foldMap f m === foldMapDefault f m\n  where f = apply fun\n\nprop_keysSet :: [(Int, Int)] -> Bool\nprop_keysSet xs =\n  keysSet (fromList xs) == IntSet.fromList (List.map fst xs)\n\nprop_fromSet :: [(Int, Int)] -> Bool\nprop_fromSet ys =\n  let xs = List.nubBy ((==) `on` fst) ys\n  in fromSet (\\k -> fromJust $ List.lookup k xs) (IntSet.fromList $ List.map fst xs) == fromList xs\n\nnewtype Identity a = Identity a\n    deriving (Eq, Show)\n\ninstance Functor Identity where\n  fmap f (Identity a) = Identity (f a)\n\ninstance Applicative Identity where\n  pure a = Identity a\n  Identity f <*> Identity a = Identity (f a)\n\nprop_traverseWithKey_identity :: IntMap A -> Property\nprop_traverseWithKey_identity mp = mp === newMap\n  where Identity newMap = traverseWithKey (\\_ -> Identity) mp\n\nprop_traverseWithKey_degrade_to_mapWithKey :: Fun (Int, A) B -> IntMap A -> Property\nprop_traverseWithKey_degrade_to_mapWithKey fun mp =\n    mapWithKey f mp === newMap\n  where f = applyFun2 fun\n        g k v = Identity $ f k v\n        Identity newMap = traverseWithKey g mp\n\nprop_traverseMaybeWithKey_identity :: IntMap A -> Property\nprop_traverseMaybeWithKey_identity mp = mp === newMap\n  where Identity newMap = traverseMaybeWithKey (\\_ -> Identity . Just) mp\n\nprop_traverseMaybeWithKey_degrade_to_mapMaybeWithKey :: Fun (Int, A) (Maybe B) -> IntMap A -> Property\nprop_traverseMaybeWithKey_degrade_to_mapMaybeWithKey fun mp =\n    mapMaybeWithKey f mp === newMap\n  where f = applyFun2 fun\n        g k v = Identity $ f k v\n        Identity newMap = traverseMaybeWithKey g mp\n\nprop_traverseMaybeWithKey_degrade_to_traverseWithKey :: Fun (Int, A) B -> IntMap A -> Property\nprop_traverseMaybeWithKey_degrade_to_traverseWithKey fun mp =\n    traverseWithKey f mp === traverseMaybeWithKey g mp\n        -- used (,) since its Applicative is monoidal in the left argument,\n        -- so this also checks the order of traversing is the same.\n  where f k v = (show k, applyFun2 fun k v)\n        g k v = fmap Just $ f k v\n'