b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\nmodule Main where\n\nimport           TreeSitter.Parser\nimport           TreeSitter.Tree\nimport           TreeSitter.Language\nimport           TreeSitter.Haskell\nimport           TreeSitter.Node\nimport           Foreign.C.String\nimport           Foreign.C.Types\nimport           Foreign.Ptr                    ( Ptr(..)\n                                                , nullPtr\n                                                , plusPtr\n                                                )\nimport           Foreign.Marshal.Alloc          ( malloc\n                                                , mallocBytes\n                                                )\nimport           Foreign.Marshal.Array          ( mallocArray )\nimport           Foreign.Storable               ( peek\n                                                , peekElemOff\n                                                , poke\n                                                )\nimport           Foreign.Marshal.Utils          ( new )\nimport           Control.Monad\n\n\nmain :: IO ()\nmain = do\n  parser <- ts_parser_new\n  ts_parser_set_language parser tree_sitter_haskell\n\n  let source =\n        "module Test (main) where\\nimport Lib\\nf1 = undefined\\nf2 = undefined"\n\n  (str, len) <- newCStringLen source\n  tree       <- ts_parser_parse_string parser nullPtr str len\n\n  n          <- malloc\n  ts_tree_root_node_p tree n\n\n  print "module (root) ------------"\n  n@Node {..} <- peek n\n  let childCount = fromIntegral nodeChildCount\n\n  children <- mallocArray childCount\n  tsNode   <- malloc\n  poke tsNode nodeTSNode\n  ts_node_copy_child_nodes tsNode children\n\n  printChildren children childCount\n\n  print "where ------------"\n  n@Node {..} <- peekElemOff children 3\n  let nextChildCount = fromIntegral nodeChildCount\n\n  nextChildren <- mallocArray nextChildCount\n  nextTsNode   <- malloc\n  poke nextTsNode nodeTSNode\n  ts_node_copy_child_nodes nextTsNode nextChildren\n\n  printChildren nextChildren nextChildCount\n\n  print "END"\n\nprintChildren :: Ptr Node -> Int -> IO ()\nprintChildren children count = forM_\n  [0 .. count - 1]\n  (\\n -> do\n    child <- peekElemOff children n\n    printNode child\n  )\n\nprintNode :: Node -> IO ()\nprintNode Node {..} = do\n  theType <- peekCString nodeType\n  let TSPoint {..} = nodeStartPoint\n      start        = "(" ++ show pointRow ++ "," ++ show pointColumn ++ ")"\n  let TSPoint {..} = nodeEndPoint\n      end          = "(" ++ show pointRow ++ "," ++ show pointColumn ++ ")"\n  print $ theType ++ start ++ "-" ++ end\n'