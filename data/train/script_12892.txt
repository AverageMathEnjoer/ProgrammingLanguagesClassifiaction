b"{-# LANGUAGE DeriveDataTypeable, NamedFieldPuns #-}\nmodule KMeansCommon where\n\nimport Control.Applicative\nimport Data.List (foldl')\nimport Data.Typeable (Typeable)\nimport Data.Data (Data)\nimport qualified Data.Serialize as Ser\nimport qualified Data.ByteString.Char8 as B\nimport qualified Data.Vector.Storable as SV\nimport qualified Data.Vector         as V\nimport Data.Vector.Serialize\nimport Data.Vector.Storable.UnsafeSerialize\nimport Control.DeepSeq\nimport Control.Monad\nimport System.Random.MWC\n\n-- data Point = Point {-#UNPACK#-}!Double {-#UNPACK#-}!Double deriving (Show,Read,Typeable,Data,Eq)\n\n-- instance Binary Point where put (Point a b) = put a>>put b\n--                              get = do a<-get\n--                                       b<-get\n--                                       return $ Point a b\n--\n\n\n-- change vectorSize to control how many dimensions Point has and then\n-- recompile\nvectorSize :: Int\nvectorSize = 100\n\ntype Point = SV.Vector Double\n\ndata Cluster = Cluster\n               {\n                  clId    :: {-#UNPACK#-}!Int,\n                  clCount :: {-#UNPACK#-}!Int,\n                  clSum   :: !Point,\n                  clCent  :: !Point\n               } deriving (Show,Read,Typeable,Data,Eq)\n\n{-\ninstance Ser.Serialize Cluster where\n  put Cluster{ clId, clCount, clSum, clCent } =\n    Ser.put clId >> Ser.put clCount >> Ser.put clSum >> Ser.put clCent\n  get = Cluster <$> Ser.get <*> Ser.get <*> Ser.get <*> Ser.get\n-}\n\ninstance NFData Cluster  -- default should be fine\n\nsqDistance :: Point -> Point -> Double\nsqDistance p1 p2 =\n   foldl' (\\a i -> a + ((p1 SV.! i) - (p2 SV.! i)) ^ 2) 0 [0..vectorSize-1] :: Double\n\nmakeCluster :: Int -> [Point] -> Cluster\nmakeCluster clid pts\n   = Cluster { clId = clid,\n               clCount = count,\n               clSum = vecsum,\n               clCent = centre\n             }\n   where vecsum = foldl' addPoint zeroPoint pts\n         centre = SV.map (\\a -> a / fromIntegral count) vecsum\n         count = length pts\n\ncombineClusters c1 c2 =\n  Cluster {clId = clId c1,\n           clCount = count,\n           clSum = vecsum,\n           clCent = centre }\n  where count = clCount c1 + clCount c2\n        centre = SV.map (\\a -> a / fromIntegral count) vecsum\n        vecsum = addPoint (clSum c1) (clSum c2)\n\naddPoint p1 p2 = SV.imap (\\i v -> v + (p2 SV.! i)) p1\nzeroPoint = SV.replicate vectorSize 0\n\ngenChunk :: Int -> Int -> IO (V.Vector Point)\ngenChunk id n = do\n  g <- initialize $ SV.singleton $ fromIntegral id\n  V.replicateM n (SV.replicateM vectorSize (uniform g))\n\n-- getPoints :: FilePath -> IO [Point]\n-- getPoints fp = do c <- readFile fp\n--                   return $ read c\n\ngenCluster :: Int -> IO Cluster\ngenCluster id = do\n  g <- initialize (SV.singleton (fromIntegral $ -1 * id))\n  centre <- SV.replicateM vectorSize (uniform g)\n  return (Cluster id 0 centre centre)\n\ngetClusters :: FilePath -> IO [Cluster]\ngetClusters fp = do c <- readFile fp\n                    return $ read c\n\n--readPoints :: FilePath -> IO [Point]\n--readPoints f = do\n--  s <- B.readFile f\n--  let ls = map B.words $ B.lines s\n--      points = [ Point (read (B.unpack sx)) (read (B.unpack sy))\n--               | (sx:sy:_) <- ls ]\n--\n--  return points\n"