b'using u8 = System.Byte;\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This is the header file for the generic hash-table implemenation\n    ** used in SQLite.\n    **\n    ** $Id: hash.h,v 1.15 2009/05/02 13:29:38 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#if !_SQLITE_HASH_H_\n    //#define _SQLITE_HASH_H_\n\n    /* Forward declarations of structures. */\n    //typedef struct Hash Hash;\n    //typedef struct HashElem HashElem;\n\n    /* A complete hash table is an instance of the following structure.\n    ** The internals of this structure are intended to be opaque -- client\n    ** code should not attempt to access or modify the fields of this structure\n    ** directly.  Change this structure only by using the routines below.\n    ** However, some of the "procedures" and "functions" for modifying and\n    ** accessing this structure are really macros, so we can\'t really make\n    ** this structure opaque.\n    **\n    ** All elements of the hash table are on a single doubly-linked list.\n    ** Hash.first points to the head of this list.\n    **\n    ** There are Hash.htsize buckets.  Each bucket points to a spot in\n    ** the global doubly-linked list.  The contents of the bucket are the\n    ** element pointed to plus the next _ht.count-1 elements in the list.\n    **\n    ** Hash.htsize and Hash.ht may be zero.  In that case lookup is done\n    ** by a linear search of the global list.  For small tables, the\n    ** Hash.ht table is never allocated because if there are few elements\n    ** in the table, it is faster to do a linear search than to manage\n    ** the hash table.\n    */\n    public class _ht\n    {            /* the hash table */\n      public int count;               /* Number of entries with this hash */\n      public HashElem chain;         /* Pointer to first entry with this hash */\n    };\n\n    public class Hash\n    {\n      public u32 htsize = 31;     /* Number of buckets in the hash table */\n      public u32 count;           /* Number of entries in this table */\n      public HashElem first;      /* The first element of the array */\n      public _ht[] ht;\n      public Hash Copy()\n      {\n        if ( this == null )\n          return null;\n        else\n        {\n          Hash cp = (Hash)MemberwiseClone();\n          return cp;\n        }\n      }\n    };\n\n    /* Each element in the hash table is an instance of the following\n    ** structure.  All elements are stored on a single doubly-linked list.\n    **\n    ** Again, this structure is intended to be opaque, but it can\'t really\n    ** be opaque because it is used by macros.\n    */\n    public class HashElem\n    {\n      public HashElem next;\n      public HashElem prev;          /* Next and previous elements in the table */\n      public object data;            /* Data associated with this element */\n      public string pKey;\n      public int nKey;               /* Key associated with this element */\n    };\n\n    /*\n    ** Access routines.  To delete, insert a NULL pointer.\n    */\n    //void sqlite3HashInit(Hash*);\n    //void *sqlite3HashInsert(Hash*, const char *pKey, int nKey, void *pData);\n    //void *sqlite3HashFind(const Hash*, const char *pKey, int nKey);\n    //void sqlite3HashClear(Hash*);\n\n    /*\n    ** Macros for looping over all elements of a hash table.  The idiom is\n    ** like this:\n    **\n    **   Hash h;\n    **   HashElem p;\n    **   ...\n    **   for(p=sqliteHashFirst(&h); p; p=sqliteHashNext(p)){\n    **     SomeStructure pData = sqliteHashData(p);\n    **     // do something with pData\n    **   }\n    */\n    //#define sqliteHashFirst(H)  ((H).first)\n    static HashElem sqliteHashFirst( Hash H ) { return H.first; }\n    //#define sqliteHashNext(E)   ((E).next)\n    static HashElem sqliteHashNext( HashElem E ) { return E.next; }\n    //#define sqliteHashData(E)   ((E).data)\n    static object sqliteHashData( HashElem E ) { return E.data; }\n    /* #define sqliteHashKey(E)    ((E)->pKey) // NOT USED */\n    /* #define sqliteHashKeysize(E) ((E)->nKey)  // NOT USED */\n\n    /*\n    ** Number of entries in a hash table\n    */\n    /* #define sqliteHashCount(H)  ((H)->count) // NOT USED */\n\n    //#endif // * _SQLITE_HASH_H_ */\n  }\n}\n'