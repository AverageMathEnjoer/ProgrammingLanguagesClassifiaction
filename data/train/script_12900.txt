b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Render \'Object\' to bytestring\n\nmodule Pdf.Core.Object.Builder\n( buildIndirectObject\n, buildIndirectStream\n, buildObject\n, buildNumber\n, buildBool\n, buildName\n, buildDict\n, buildArray\n, buildString\n, buildRef\n, buildStream\n)\nwhere\n\nimport Data.Char\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString.Char8 as Char8\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.ByteString.Builder\nimport qualified Data.ByteString.Base16 as Base16\nimport Data.Scientific (Scientific)\nimport qualified Data.Scientific as Scientific\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Text.Printf\n\nimport Pdf.Core.Object\nimport qualified Pdf.Core.Name as Name\n\n-- | Build indirect object except streams\nbuildIndirectObject :: Ref -> Object -> Builder\nbuildIndirectObject ref object =\n  buildObjectWith ref $\n    buildObject object\n\n-- | Build indirect stream\nbuildIndirectStream :: Ref -> Dict -> BSL.ByteString -> Builder\nbuildIndirectStream ref dict dat =\n  buildObjectWith ref $\n    buildStream dict dat\n\nbuildObjectWith :: Ref -> Builder -> Builder\nbuildObjectWith (R i g) inner =\n  char7 \'\\n\' `mappend`\n  intDec i `mappend`\n  char7 \' \' `mappend`\n  intDec g `mappend`\n  byteString " obj\\n" `mappend`\n  inner `mappend`\n  byteString "\\nendobj\\n"\n\n-- | Render inline object (without \\"obj/endobj\\").\n-- It is \'error\' to supply \'Stream\', because it could not\n-- be inlined, but should always be an indirect object\nbuildObject :: Object -> Builder\nbuildObject (Number n) = buildNumber n\nbuildObject (Bool b) = buildBool b\nbuildObject (Name n) = buildName n\nbuildObject (Dict d) = buildDict d\nbuildObject (Array a) = buildArray a\nbuildObject (String s) = buildString s\nbuildObject (Ref r) = buildRef r\nbuildObject (Stream _) = error "buildObject: please don\'t pass streams to me"\nbuildObject Null = byteString "null"\n\n-- | Build a stream\n--\n-- The function doesn\'t try to encode or encrypt the content\nbuildStream :: Dict -> BSL.ByteString -> Builder\nbuildStream dict content = mconcat\n  [ buildDict dict\n  , byteString "stream\\n"\n  , lazyByteString content\n  , byteString "\\nendstream"\n  ]\n\n-- | Build a number\nbuildNumber :: Scientific -> Builder\nbuildNumber\n  = either bFloat intDec\n  . Scientific.floatingOrInteger\n  where\n  bFloat d = string7 $ printf "%f" (d :: Double)\n\n-- | Build a bool\nbuildBool :: Bool -> Builder\nbuildBool True = byteString "true"\nbuildBool False = byteString "false"\n\n-- | Build a name\nbuildName :: Name -> Builder\n-- XXX: escaping\nbuildName n = char7 \'/\' `mappend` byteString (Name.toByteString n)\n\nintercalate :: Builder -> [Builder] -> Builder\nintercalate _ [] = mempty\nintercalate sep (x:xs) = x `mappend` go xs\n  where\n  go [] = mempty\n  go (y:ys) = sep `mappend` y `mappend` go ys\n\n-- | Build a dictionary\nbuildDict :: Dict -> Builder\nbuildDict dict =\n  byteString "<<" `mappend`\n  intercalate (char7 \' \') (concatMap build $ HashMap.toList dict) `mappend`\n  byteString ">>"\n  where\n  build (key, val) = [buildName key, buildObject val]\n\n-- | Build an array\nbuildArray :: Array -> Builder\nbuildArray xs =\n  char7 \'[\' `mappend`\n  intercalate (char7 \' \') (map buildObject $ Vector.toList xs) `mappend`\n  char7 \']\'\n\n-- | Build a string\n--\n-- It may produce literal or hex string based on the context.\nbuildString :: ByteString -> Builder\nbuildString s =\n  if Char8.all isPrint s\n    then mconcat\n      [ char7 \'(\'\n      , byteString . Char8.pack . concatMap escape . Char8.unpack $ s\n      , char7 \')\'\n      ]\n    else mconcat\n      [ char7 \'<\'\n      , byteString $ Base16.encode s\n      , char7 \'>\'\n      ]\n  where\n  escape \'(\' = "\\\\("\n  escape \')\' = "\\\\)"\n  escape \'\\\\\' = "\\\\\\\\"\n  escape \'\\n\' = "\\\\n"\n  escape \'\\r\' = "\\\\r"\n  escape \'\\t\' = "\\\\t"\n  escape \'\\b\' = "\\\\b"\n  escape ch = [ch]\n\n-- | Build a reference\nbuildRef :: Ref -> Builder\nbuildRef (R i j) = mconcat\n  [ intDec i\n  , char7 \' \'\n  , intDec j\n  , byteString " R"\n  ]\n'