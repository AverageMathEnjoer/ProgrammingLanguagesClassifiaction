b'// UVa1672 Disjoint Regular Expressions\n// Rujia Liu\n//\n// This is Problem 12-2 of <<Beginning Algorithm Contests>> 2nd edition\n//\n// This code is neither simplest nor most efficient, but it\'s easy to understand and fast enough.\n// Algorithm implemented here: \n//   1. build epsilon-NFA from the regex\n//   2. build NFA by removing epsilon from epsilon-NFA. Note that we did NOT optimize the epsilon-NFA as described in the book.\n//   3. use BFS to find a common string of these two NFAs\n// Attention: the output should NOT be empty so we used a little trick.\n//\n// Alternative algorithm: do BFS directly on epsilon-NFAs. \n// State is (s1,s2,b) where b=1 iff at least one non-epsilon transition is performed.\n// However, this graph is now 0-1 weighted so we need to use deque (or two-phase BFS).\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<string>\n#include<queue>\n#include<cassert>\n#define REP(i,n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\n// Part I: Expression Parser\nstruct ExprNode {\n  enum {A, STAR, OR, CONCAT};\n  int type, val;\n  ExprNode *l, *r;\n\n  ExprNode(int type, ExprNode* l, ExprNode* r, int val = -1):type(type),l(l),r(r),val(val){}\n  ~ExprNode() {\n     if(l) delete l;\n     if(r) delete r;\n   }\n};\n\nstruct Parser {  \n  char* s;\n  int p, n;\n\n  void Skip(char c) { p++; } // for debug purpose\n\n  // (u)*\n  ExprNode* Item() {\n    ExprNode* u;\n    if(s[p] == \'(\') { Skip(\'(\'); u = Expr(); Skip(\')\'); }\n    else u = new ExprNode(ExprNode::A, NULL, NULL, s[p++]);\n    while(s[p] == \'*\') {\n      Skip(\'*\');\n      u = new ExprNode(ExprNode::STAR, u, NULL);\n    }\n    return u;    \n  }\n\n  // u1u2u3...\n  ExprNode* Concat() {\n    ExprNode* u = Item();\n    while(s[p] && s[p] != \')\' && s[p] != \'|\')\n      u = new ExprNode(ExprNode::CONCAT, u, Item());\n    return u;\n  }\n\n  // u1|u2|u3\n  ExprNode* Expr() {\n    ExprNode* u = Concat();\n    while(s[p] == \'|\') {\n      Skip(\'|\');\n      u = new ExprNode(ExprNode::OR, u, Concat());\n    }\n    return u;\n  }\n\n  ExprNode* parse(char* str) {\n    s = str;\n    n = strlen(s);\n    p = 0;\n    return Expr();\n  }\n  \n};\n\n// Part II: NFA construction\nconst int maxs = 100 * 4 + 5;\n\nstruct NFA {\n  int n; // number of states\n\n  struct Transition {\n    int ch, next;\n    Transition(int ch = 0, int next = 0):ch(ch),next(next){}\n    bool operator < (const Transition& rhs) const {\n      if(ch != rhs.ch) return ch < rhs.ch;\n      return next < rhs.next;\n    }\n  };\n  vector<Transition> trans[maxs];\n\n  void add(int s, int t, int c) {\n    trans[s].push_back(Transition(c, t));\n  }\n\n  void process(ExprNode* u) {\n    int st = n++; // state \'start\'\n    if(u->type == ExprNode::A) add(st, n, u->val);\n    else if(u->type == ExprNode::STAR) {\n      process(u->l);\n      add(st, st+1, -1);\n      add(st, n, -1);\n      add(n-1, st, -1);\n    }\n    else if(u->type == ExprNode::OR) {\n      process(u->l);\n      int m = n;\n      process(u->r);\n      add(st, st+1, -1);\n      add(st, m, -1);\n      add(m-1, n, -1);\n      add(n-1, n, -1);\n    }\n    else if(u->type == ExprNode::CONCAT) {\n      add(st, st+1, -1);\n      process(u->l);\n      add(n-1, n, -1);\n      process(u->r);\n      add(n-1, n, -1);\n    }\n    n++; // state \'end\'\n  }\n\n  void init(char* s) {\n    Parser p;\n    ExprNode* root = p.parse(s);\n    n = 0;\n    for(int i = 0; i < maxs; i++) {\n      trans[i].clear();\n    }\n    process(root);\n    delete root;\n  }\n\n  vector<int> ss; // starting states\n\n  void remove_epsilon() {\n    // find epsilon-closure for each state\n    vector<int> reachable[maxs];\n    int vis[maxs];\n    for(int i = 0; i < n; i++) {\n      reachable[i].clear();\n      reachable[i].push_back(i);\n      queue<int> q;\n      q.push(i);\n      memset(vis, 0, sizeof(vis));\n      vis[i] = 1;\n      while(!q.empty()) {\n        int s = q.front(); q.pop();\n        for(int j = 0; j < trans[s].size(); j++)\n          if(trans[s][j].ch == -1) {\n            int s2 = trans[s][j].next;\n            if(!vis[s2]) {\n              reachable[i].push_back(s2);\n              vis[s2] = 1;\n              q.push(s2);\n            }\n          }\n      }\n    }\n    ss = reachable[0];\n\n    // merge transitions\n    for(int i = 0; i < n; i++) {\n      set<Transition> tr;\n      for(int j = 0; j < trans[i].size(); j++) {\n        if(trans[i][j].ch == -1) continue;\n        int s = trans[i][j].next;\n        for(int k = 0; k < reachable[s].size(); k++)\n          tr.insert(Transition(trans[i][j].ch, reachable[s][k]));\n      }\n      trans[i] = vector<Transition>(tr.begin(), tr.end());\n    }\n  }\n};\n\n// Part III: BFS to find the answer\n\nconst int maxn = 100 + 5;\nconst int maxq = 100 * 4 * 100 * 4 * 2 + 5; // case 26\nchar sa[maxn], sb[maxn];\n\nstruct State {\n  int s1, s2, fa, ch;\n} states[maxq];\nint ns;\n\nvoid print_solution(int s) {\n  if(states[s].fa == -1) return;\n  print_solution(states[s].fa);\n  printf("%c", states[s].ch);\n}\n\nvoid solve(const NFA& A, const NFA& B) {\n  queue<int> q;\n  int vis[maxs][maxs];\n  memset(vis, 0, sizeof(vis));\n  ns = 0;\n  REP(i, A.ss.size())\n    REP(j, B.ss.size()) {\n      int s1 = A.ss[i], s2 = B.ss[j];\n      states[ns].s1 = s1;\n      states[ns].s2 = s2;\n      states[ns].fa = -1;\n      q.push(ns++);\n    }\n\n  while(!q.empty()) {\n    int s = q.front(); q.pop();\n    int s1 = states[s].s1;\n    int s2 = states[s].s2;\n    if(s1 == A.n-1 && s2 == B.n-1 && states[s].fa != -1) {\n      printf("Wrong\\n");\n      print_solution(s);\n      printf("\\n");\n      return;\n    }\n    int n1 = A.trans[s1].size();\n    int n2 = B.trans[s2].size();\n\n    REP(i, n1) REP(j, n2)\n      if(A.trans[s1][i].ch == B.trans[s2][j].ch) {\n        int s1b = A.trans[s1][i].next;\n        int s2b = B.trans[s2][j].next;\n        int c = A.trans[s1][i].ch;\n        if(vis[s1b][s2b]) continue;\n        vis[s1b][s2b] = 1;\n        states[ns].s1 = s1b;\n        states[ns].s2 = s2b;\n        states[ns].fa = s;\n        states[ns].ch = c;\n        q.push(ns++);\n      }\n  }\n  printf("Correct\\n");  \n}\n\nNFA A, B;\nint main() {\n  while(scanf("%s%s", sa, sb) == 2) {\n    A.init(sa);\n    B.init(sb);\n    A.remove_epsilon();\n    B.remove_epsilon();\n    solve(A, B);\n  }\n  return 0;\n}\n'