b'{-# LANGUAGE DeriveTraversable, DeriveFoldable, DeriveFunctor #-}\n\nimport Control.Monad\nimport Data.Traversable\nimport Test.QuickCheck\n\ndata Pair a = P a a\n              deriving (Eq, Show, Functor, Foldable, Traversable)\n\ninstance Applicative Pair where\n  pure = return\n  (P f g) <*> (P x y) = P (f x) (g y)\ninstance Monad Pair where\n  return x = P x x\n  (P x y) >>= k = do\n    (P x2 _) <- k x\n    (P _ y2) <- k y\n    return $ P x2 y2\n\n\nnewtype Bad a = B {unB :: (Maybe (Pair a))}\n\n-- http://stackoverflow.com/questions/13034229/concrete-example-showing-that-monads-are-not-closed-under-composition-with-proo?lq=1\njoin2 :: (Monad m, Monad n, Traversable n) => m (n (m (n a))) -> m (n a)\njoin2 = fmap join  . join .  fmap sequence\n\ninstance Monad Bad where\n  return x = B $ Just (P x x)\n  (B x) >>= k = B $ join2 $ (fmap $ fmap $ unB . k) x\n\n-- monad laws\n-- (1) join (return x) = x\n-- (2) join (fmap return x) = x\n-- (3) join (join x) = join (fmap join x)\n\nmain :: IO ()\nmain = print $ P 4 2\n'