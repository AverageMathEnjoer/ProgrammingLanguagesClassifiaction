b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n\nmodule Cachix.Deploy.Activate where\n\nimport qualified Cachix.API.WebSocketSubprotocol as WSS\nimport qualified Cachix.Client.InstallationMode as InstallationMode\nimport qualified Cachix.Client.NetRc as NetRc\nimport Cachix.Client.URI (URI)\nimport qualified Cachix.Client.URI as URI\nimport qualified Cachix.Deploy.Log as Log\nimport qualified Cachix.Types.BinaryCache as BinaryCache\nimport Cachix.Types.Permission (Permission (..))\nimport qualified Data.Aeson as Aeson\n#if MIN_VERSION_aeson(2,0,0)\nimport qualified Data.Aeson.KeyMap as HM\n#else\nimport qualified Data.HashMap.Strict as HM\n#endif\nimport qualified Data.Conduit.Combinators as Conduit\nimport qualified Data.Conduit.Process as Conduit\nimport qualified Data.Vector as Vector\nimport Protolude hiding (log, toS)\nimport Protolude.Conv (toS)\nimport Servant.Auth.Client (Token (..))\nimport qualified System.Directory as Directory\nimport System.FilePath ((</>))\nimport System.IO.Temp (withSystemTempDirectory)\nimport System.Process\nimport Prelude (String)\n\ndata Status\n  = Success\n  | Failure FailureReason\n  | Rollback FailureReason\n  deriving (Show, Exception)\n\ndata FailureReason\n  = NetworkTestFailure\n  | RollbackScriptExitFailure\n  | RollbackScriptUnexpectedError IOException\n  | ShellCommandFailure {command :: String, exitCode :: Int}\n  | UnexpectedError SomeException\n  deriving (Show)\n\ninstance Exception FailureReason where\n  displayException = \\case\n    NetworkTestFailure -> "Cannot connect back to Cachix Deploy after activating the new deployment"\n    RollbackScriptExitFailure -> "The rollback script returned a non-zero exit code"\n    RollbackScriptUnexpectedError e -> "Cannot run rollback script: " <> displayException e\n    ShellCommandFailure {command, exitCode} ->\n      toS $\n        unwords\n          [ "Failed to run " <> toS command,\n            show exitCode\n          ]\n    UnexpectedError e ->\n      toS $\n        unwords\n          [ "The deployment failed with an unexpected error:",\n            toS (displayException e)\n          ]\n\ndownloadStorePaths ::\n  -- | Logging context\n  Log.LogStream ->\n  -- | Deployment details\n  WSS.DeploymentDetails ->\n  -- | Binary cache args\n  [String] ->\n  IO ()\ndownloadStorePaths logStream deploymentDetails cacheArgs = do\n  -- Download the store path from the binary cache\n  -- TODO: add GC root so it\'s preserved for the next command\n  runShell logStream "nix-store" (["-r", toS storePath] <> cacheArgs)\n\n  -- Download the rollback script, if provided\n  for_ (WSS.rollbackScript deploymentDetails) $ \\script ->\n    runShell logStream "nix-store" (["-r", toS script] <> cacheArgs)\n  where\n    storePath = WSS.storePath deploymentDetails\n\ntype RollbackAction = IO ()\n\n-- | Activate the profile and return a rollback action if available.\nactivate ::\n  -- | Logging context\n  Log.LogStream ->\n  -- | Profile name\n  Text ->\n  -- | Store path to activate\n  FilePath ->\n  -- | Returns a rollback action if available\n  IO (Maybe RollbackAction)\nactivate logStream profileName storePath = do\n  (profilePath, activationScripts) <- getActivationScript profileName storePath\n  previousProfilePath <- toStorePath profilePath\n\n  -- Activate the configuration\n  -- TODO: Check with Domen whether we can exit early here\n  forM_ activationScripts $ uncurry (runShell logStream)\n\n  pure $ Just rollback <*> previousProfilePath\n  where\n    toStorePath profilePath = do\n      profileExists <- Directory.doesPathExist profilePath\n      if profileExists\n        then Just <$> Directory.canonicalizePath profilePath\n        else pure Nothing\n\n    -- We can\'t use \'--rollback\' because it just selects the next generation\n    -- down from our deployment, which is not necessarily the generation that\n    -- was previously active.\n    rollback = void . activate logStream profileName\n\ntype Command = (String, [String])\n\ngetActivationScript :: Text -> FilePath -> IO (FilePath, [Command])\ngetActivationScript profile storePath = do\n  let checkPath p = Directory.doesPathExist $ toS storePath </> p\n  isNixOS <- checkPath "nixos-version"\n  isNixDarwin <- checkPath "darwin-version"\n  isHomeManager <- checkPath "hm-version"\n  user <- InstallationMode.getUser\n  let systemProfileDir = "/nix/var/nix/profiles"\n  let perUserProfileDir = systemProfileDir </> "per-user" </> toS user\n  let mkProfilePath profileBaseDir defaultProfile =\n        profileBaseDir </> if profile == "" then defaultProfile else toS profile\n  -- Sets the new profile. This is needed for NixOS and nix-darwin. The Home\n  -- Manager activation script does the profile setting by itself.\n  -- TODO: document what happens if the wrong user is used for the agent\n  let setNewProfile profilePath =\n        ("nix-env", ["-p", profilePath, "--set", storePath])\n  return $ case (isNixOS, isNixDarwin, isHomeManager) of\n    (True, _, _) ->\n      let profilePath = mkProfilePath systemProfileDir "system"\n       in ( profilePath,\n            [ setNewProfile profilePath,\n              (toS storePath </> "bin/switch-to-configuration", ["switch"])\n            ]\n          )\n    (_, True, _) ->\n      -- https://github.com/LnL7/nix-darwin/blob/master/pkgs/nix-tools/darwin-rebuild.sh\n      let profilePath = mkProfilePath systemProfileDir "system-profiles/system"\n       in ( profilePath,\n            [ ("mkdir", ["-p", "-m", "0755", "/nix/var/nix/profiles/system-profiles"]),\n              setNewProfile profilePath,\n              (toS storePath </> "activate-user", []),\n              (toS storePath </> "activate", [])\n            ]\n          )\n    (_, _, True) ->\n      ( mkProfilePath perUserProfileDir "home-manager",\n        [(toS storePath </> "activate", [])]\n      )\n    (_, _, _) ->\n      let profilePath = mkProfilePath systemProfileDir "system"\n       in (profilePath, [setNewProfile profilePath])\n\n-- TODO: send errors as well\n-- TODO: fix either/maybe types\ngetClosureSize :: [String] -> Text -> IO (Either Text (Maybe Int64))\ngetClosureSize cacheArgs storePath = do\n  (exitCode, pathInfoJSON, nixError) <- readProcessWithExitCode "nix" (cacheArgs <> ["--extra-experimental-features", "nix-command", "path-info", "-S", "--json", toS storePath]) ""\n  case exitCode of\n    ExitFailure _ -> pure $ Left (toS nixError)\n    ExitSuccess -> pure $ Right $ Aeson.decode (toS pathInfoJSON) >>= extractClosureSize\n\nextractClosureSize :: Aeson.Value -> Maybe Int64\nextractClosureSize (Aeson.Array vector) = case Vector.toList vector of\n  [Aeson.Object obj] -> case HM.lookup "closureSize" obj of\n    Just (Aeson.Number num) -> Just $ floor num\n    _ -> Nothing\n  _ -> Nothing\nextractClosureSize _ = Nothing\n\n-- TODO: don\'t create tmpfile for public caches\nwithCacheArgs :: URI -> WSS.AgentInformation -> Text -> ([String] -> IO a) -> IO a\nwithCacheArgs host agentInfo agentToken m =\n  withSystemTempDirectory "netrc" $ \\dir -> do\n    let filepath = dir </> "netrc"\n    args <- case WSS.cache agentInfo of\n      Just cache -> do\n        let cacheName = WSS.cacheName cache\n        let cacheURI = URI.appendSubdomain cacheName host\n        -- TODO: ugh\n        let bc =\n              BinaryCache.BinaryCache\n                { BinaryCache.name = "",\n                  BinaryCache.uri = URI.serialize cacheURI,\n                  BinaryCache.publicSigningKeys = [],\n                  BinaryCache.isPublic = WSS.isPublic cache,\n                  BinaryCache.githubUsername = "",\n                  BinaryCache.permission = Read,\n                  BinaryCache.preferredCompressionMethod = BinaryCache.XZ\n                }\n        NetRc.add (Token (toS agentToken)) [bc] filepath\n        return $ cachesArgs cache <> ["--option", "netrc-file", filepath]\n      Nothing ->\n        return []\n    m args\n  where\n    cachesArgs :: WSS.Cache -> [String]\n    cachesArgs cache =\n      let cacheName = WSS.cacheName cache\n          cacheURI = URI.appendSubdomain cacheName host\n          hostname = (URI.hostBS . URI.getHostname) cacheURI\n          officialCache = "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="\n          substituters = ["--option", "extra-substituters", URI.serialize cacheURI]\n          noNegativeCaching = ["--option", "narinfo-cache-negative-ttl", "0"]\n          sigs = ["--option", "trusted-public-keys", officialCache <> " " <> toS hostname <> "-1:" <> toS (WSS.publicKey cache)]\n       in substituters ++ sigs ++ noNegativeCaching\n\nrunShell :: Log.LogStream -> FilePath -> [String] -> IO ()\nrunShell logStream cmd args = runShellWithExitCode logStream cmd args >>= handleError\n  where\n    handleError (ExitFailure exitCode) = throwIO $ ShellCommandFailure {command = cmd, exitCode}\n    handleError ExitSuccess = pure ()\n\nrunShellWithExitCode :: Log.LogStream -> FilePath -> [String] -> IO ExitCode\nrunShellWithExitCode logStream cmd args = do\n  Log.streamLine logStream $ "$ " <> toS cmd <> " " <> toS (unwords $ fmap toS args)\n  (exitCode, _, _) <- Conduit.sourceProcessWithStreams (proc cmd args) Conduit.sinkNull logStream logStream\n  pure exitCode\n'