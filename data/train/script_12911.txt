b'{-# LANGUAGE ForeignFunctionInterface #-}\n\nimport Foreign\nimport Foreign.C.Types\nimport System.Environment (getArgs)\nimport System.Random\nimport Data.List\nimport System.CPUTime (getCPUTime)\nimport Text.Printf\n\ntype ElmT  = Word32\ntype CElmT = CUInt\n\nforeign import ccall unsafe "wrap_cilksort"\n  c_cilksort ::  Ptr CElmT -> Ptr CElmT -> CLong -> IO CLong\n\nforeign import ccall unsafe "run_cilksort"\n  c_run_cilksort :: CLong -> IO CLong \n\nmain :: IO ()\nmain = \n  do args <- getArgs \n     let (size,runs) = case args of\n           []    -> (300000, 1)\n           [m]   -> (read m, 1)\n           [m,n] -> (read m, read n)\n                \n     printf "Running cilksort with a size of %d (foreign array) \\\n        \\ (%d runs)\\n" (fromIntegral size :: Int) (runs :: Int)\n\n     runCilkSort size runs\n\n     printf "Running cilksort with a size of %d (Haskell array): \\ \n                \\ (%d runs).\\n" (fromIntegral size :: Int) (runs :: Int)\n\n     -- TODO: would like to do this\n     -- runCilkSort\' size runs\n\n     seed <- newStdGen\n     let a = randomList (fromIntegral size) seed\n         b = randomList (fromIntegral size) seed\n       in \n        withArray a $ \\pa ->\n        withArray b $ \\pb ->\n        runCilkSort\' (castPtr pa) (castPtr pb) size runs\n\nrunCilkSort :: CLong -> Int -> IO ()\nrunCilkSort _ 0 = return ()\nrunCilkSort  sz n = do\n  ticks <- c_run_cilksort sz\n  putStrLn $ "ran in " ++ show ticks ++ " ticks"\n  runCilkSort sz (n - 1)\n\nrunCilkSort\' :: Ptr CElmT -> Ptr CElmT -> CLong -> Int -> IO ()\nrunCilkSort\' _ _ _ 0 = return ()\nrunCilkSort\' xs ys sz n = do\n  ticks <- c_cilksort xs ys sz\n  putStrLn $ "ran in " ++ show ticks ++ " ticks"\n  runCilkSort\' xs ys sz (n - 1)\n\nrandomList :: Int -> StdGen -> [ElmT]\nrandomList n = take n . unfoldr (Just . random)\n\n'