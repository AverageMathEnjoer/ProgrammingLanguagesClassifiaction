b'{-# LANGUAGE ScopedTypeVariables, CPP, BangPatterns #-}\n{-# OPTIONS_GHC -fwarn-unused-imports #-}\n-- -Wall -fno-warn-name-shadowing\n\n-- | Experimental support for \'OpenList\'s, which are streams in\n-- the \'Par\' monad that support constant-time append.\n\nmodule Control.Monad.Par.OpenList\n (\n  OpenList(),\n  empty, singleton, cons, head, tail, length,\n  close, join,\n  toList, fromList, toLazyList, \n  parMapM, parBuild, parBuildM,  \n  openlist_tests, \n  chaintest, \n  async_test, lazy_chaintest\n\n-- , IList(..), newCell\n )\nwhere \n\nimport Control.Monad hiding (join)\nimport Control.DeepSeq\nimport Control.Concurrent.MVar\n-- import Control.Monad.Par hiding (parMapM)\nimport Control.Monad.Par.IList\nimport Control.Monad.Par.Scheds.Trace \nimport Control.Monad.Par.Scheds.TraceInternal\nimport qualified Control.Monad.Par.Combinator as C\n\nimport Prelude hiding (length,head,tail,drop,take,null)\nimport qualified Prelude as P\n-- import System.IO.Unsafe\nimport GHC.IO (unsafePerformIO, unsafeDupablePerformIO)\nimport Test.HUnit \nimport Debug.Trace\n\n-- -----------------------------------------------------------------------------\n-- Open Lists -- IVars at the tail.\n--\n-- These have some of the advantages of imperative lists, such as\n-- constant time appending, while retaining determinism and having\n-- O(1) access to the head of the list unlike tree-shaped lists\n-- (e.g. append-based rather than cons-based).\n\n\n-- An OpenList must be handled functionally.  Extending the list as\n-- an effect will not change its tail pointer.\ndata OpenList a = OpenList (IList a) (IList a)\n\n-- This is likewise a pretty meaningless NFData instance:\ninstance NFData a => NFData (OpenList a) where \n  rnf (OpenList hp tp) = rnf hp `seq` rnf tp \n\n\n-- | An empty open list.  Supports further extension.\nempty :: OpenList a\nempty = OpenList Null Null\n\nnull :: OpenList a -> Bool\nnull (OpenList Null Null) = True\nnull _                    = False\n\n-- | A single element open list.\nsingleton :: a -> Par (OpenList a)\nsingleton x = \n  do pv <- new \n     let cell = Cons x pv\n     return (OpenList cell cell)\n\n-- TODO/FIXME: Need to decide whether there should be closed and open empty lists!!\n\n-- | Terminate a non-empty open list so that it cannot be extended further.\nclose :: NFData a => OpenList a -> Par (OpenList a)\nclose orig@(OpenList Null _) = return orig\nclose orig@(OpenList _   tp) = do put (tl tp) Null; return orig\n\n\n-- This version ignores the tail pointer and seeks out the end of the\n-- list (at the present time).\n-- unsafeClose :: NFData a => OpenList a -> Par (OpenList a)\n-- unsafeClose orig@(OpenList Null _) = return orig\n\n\n\n-- | Destructive append operation.\njoin :: NFData a => OpenList a -> OpenList a -> Par (OpenList a)\njoin (OpenList Null _) right = return right\njoin left  (OpenList Null _) = return left \njoin (OpenList hp1 tp1) (OpenList hp2 tp2) =\n    do put (tl tp1) hp2\n       return (OpenList hp1 tp2)\n\n-- | Head of an OpenList.\nhead :: OpenList a -> a\nhead (OpenList Null _) = error "cannot take head of null OpenList"\nhead (OpenList hp _)   = hd hp\n\nheadCell (OpenList hp _) = OpenList hp hp \nlastCell (OpenList _ tp) = OpenList tp tp\n\n-- | Tail of an OpenList.  Beware, if the list contains only one\n--   element (e.g. the result of tail will be null), it must be CLOSED\n--   for tail to work.\ntail :: OpenList a -> Par (OpenList a)\n-- NOTE: We could fix this limitation by adding a length field to the OpenList.\ntail (OpenList Null _) = error "cannot take tail of null OpenList"\ntail (OpenList hp tp)  = \n  do nxt <- get (tl hp)\n     case nxt of\n       Null -> return empty\n       _    -> return (OpenList nxt tp)\n\n\ndrop :: NFData a => Int -> OpenList a -> Par (OpenList a)\ndrop 0 ls = return ls\ndrop n ls = do tl <- tail ls\n\t       drop (n-1) tl\n\n-- This copies a prefix and makes it open once again irrespective of\n-- whether the input list is open or closed.\ntake :: NFData a => Int -> OpenList a -> Par (OpenList a)\ntake 0 ls = return empty\ntake n ls = do tl   <- tail ls\n\t       rest <- take (n-1) tl\n\t       cons (head ls) rest\n\n-- Take the length of a closed OpenList.\n-- length :: OpenList a -> Par Int\nlength (OpenList Null _) = return 0\n-- length (OpenList (Cons a _) (Cons b _)) | a == b = return 1\nlength ls = do t   <- tail ls \n\t       len <- length t\n\t       return (len+1)\n\n-- | Add an element to the front of an OpenList.  Works irrespective\n-- | of whether the input is closed.\ncons :: NFData a => a -> OpenList a -> Par (OpenList a)\n-- Careful, consing should not close the openlist:\ncons car (OpenList Null _) = singleton car\ncons car (OpenList hp tp) = \n  do cdr <- newFull_ hp\n     return (OpenList (Cons car cdr) tp)\n\nnewCell x = do pv <-new; return (Cons x pv)\n\n-- | Convert a list to an OpenList, open to extension at the tail.\nfromList :: NFData a => [a] -> Par (OpenList a)\nfromList [] = return empty\nfromList (h:t) = \n  --   This function is inefficient and could be replaced with an additional IList data constructor.\n    do head <- newCell h\n       rest <- loop head t\n       return (OpenList head rest)\n where \n   loop last  []   = return last\n   loop last (h:t) = \n    do cell <- newCell h\n       put (tl last) cell\n       loop cell t\n\n-- | Convert a CLOSED OpenList to a list. \ntoList :: NFData a => (OpenList a) -> Par [a] \n-- Note: presently not tail-recursive:\ntoList (OpenList hp _) = loop hp\n where \n  loop Null = return []\n  loop (Cons head pv) = \n    do \n       rest <- get pv\n       converted <- loop rest\n       return (head : converted)\n\n-- Strict map over closed lists.\n-- \n-- parMap for OpenLists does not support a nice divide-and-conquer.\n-- (Well, it would support the appending if we were willing to scan ahead to find the length.)\n-- OpenLists are not Traversable... so we can\'t just use Par.parMap.\n--\n-- TODO: Perhaps this should use a strategy for each element:\n-- parMapM :: NFData b => (a -> Par b) -> OpenList a -> Par (OpenList b)\nparMapM _ (OpenList Null _) = return empty\n-- parMapM fn (OpenList (Cons a _) (Cons b _)) | a == b =  fn a >>= singleton \nparMapM fn ls = \n  do h <- spawn (fn (head ls))\n     t <- tail ls\n     h\' <- get h\n     t2 <- parMapM fn t\n     cons h\' t2\n\n-- maybe the following too?\n-- parMapM_ :: (a -> Par ()) -> OpenList a -> Par () \n\n-- | Build an OpenList with a divide-and-conquer parallel strategy.\nparBuild :: NFData a => C.InclusiveRange -> (Int -> a) -> Par (OpenList a)\nparBuild range fn =\n  C.parMapReduceRange range (singleton . fn) join empty\n\n-- | Build an OpenList with a divide-and-conquer parallel strategy,\n--   allowing nested parallelism in the per-element computation.\nparBuildM :: NFData a => C.InclusiveRange -> (Int -> Par a) -> Par (OpenList a)\nparBuildM range fn =\n  C.parMapReduceRange range ((>>= singleton) . fn) join empty\n\n\n-- | OpenLists can only be printed properly in the Par monad.  @show@\n--   on an open list will only give a hint -- what the first and last\n--   elements of the openlist are.\ninstance Show a => Show (OpenList a) where \n  show (OpenList Null _) = "OpenList []"\n  show (OpenList (Cons fst _) (Cons lst _)) = \n      "OpenList ["++show fst++".."++ show lst ++"]"\n\n       \n\ndebugshow (OpenList (Cons h1 _) (Cons h2 _)) = "Cons|Cons|eq/"++show(h1==h2)\ndebugshow (OpenList Null       Null)       = "Null|Null"\ndebugshow (OpenList Null       (Cons _ _)) = error$ "invalid Null|Cons openlist"\ndebugshow (OpenList (Cons _ _) Null)       = error$ "invalid Cons|Null openlist"\n\n-- Check the length of an openlist from head pointer to tail pointer\n-- (not including anything present beyond the tail pointer).\n-- WARNING: ASSUMES UNIQUE ELEMENTS:\ndebuglength :: Eq a => OpenList a -> Par Int\ndebuglength (OpenList Null Null) = return 0\ndebuglength orig@(OpenList (Cons hp1 tp1) (Cons hp2 tp2))\n  | hp1 == hp2 = return 1\n  | otherwise  = do rest <- tail orig\n    \t  \t    sum  <- debuglength rest\n\t\t    return (1 + sum)\n\n-- -----------------------------------------------------------------------------\n-- Synchronization using native Haskell IVars (e.g. MVars).\n\n-- The MList datatype is internal to the module.\n-- These MVars are only written once:\ndata MList a = MNull | MCons (a, MVar (MList a))\n\n_unsafe_io :: IO a -> Par a\n_unsafe_io io =  let x = unsafePerformIO io in\n\t\t x `seq` return x\n\n_unsafe_dupable :: IO a -> Par a\n_unsafe_dupable io = \n  let x = unsafeDupablePerformIO io in \n  x `seq` return x\n\n-- Return a lazy list:\nmListToList :: MList a -> [a]\nmListToList MNull = []\nmListToList (MCons(hd,tl)) = \n    let rest = unsafeDupablePerformIO$ \n\t       do tl\' <- readMVar tl  \n\t\t  return (mListToList tl\')\n    in  (hd : rest)\n\niListToMList :: IList a -> Par (MList a)\niListToMList Null = return MNull\niListToMList il = \n  do mv <- _unsafe_dupable newEmptyMVar\n     fork $ do t <- get (tl il)\n\t       r <- iListToMList t\n\t       _unsafe_io$ putMVar mv r\n     return (MCons (hd il, mv))\n\n-- | Asynchronously convert an OpenList to a lazy list.  Returns immediately.\ntoLazyList :: OpenList a -> Par [a]\ntoLazyList (OpenList head _) = iListToMList head >>= return . mListToList \n-- toLazyList ol = toMList ol >>= return . mListToList \n\n\n\n\n\n\n-- -----------------------------------------------------------------------------\n-- Testing\n-- -----------------------------------------------------------------------------\n\ntest_ol0 = runPar (cons \'a\' empty >>= cons \'b\' >>= close >>= tail >>= tail >>= length)\n\ntest_ol1 :: Int\ntest_ol1 = runPar$ do l :: OpenList Int <- join empty empty\n\t\t      length l\n\ntest_ol2 :: String\ntest_ol2 = show$ runPar$ do \n ls1 <- fromList [10,11,12]\n ls2 <- singleton (5::Int)\n join ls1 ls2\n\ntest_ol3 :: [Int]\ntest_ol3 = runPar$ do ol :: OpenList Int <- fromList [1..10]\n\t\t      close ol\n\t\t      toList ol\n\ntest_ol4 :: Int\ntest_ol4 = runPar$ do ol <- fromList [1..10]\t\t      \n\t\t      t1 <- tail ol\n\t\t      t2 <- tail t1\n\t\t      return (head t2)\n\ntest_ol5 :: Int\ntest_ol5 = runPar$ fromList ([1..10] :: [Int]) >>= close >>= length\n\ntest_ol6 :: [Int]\ntest_ol6 = runPar$ do\n  l1 <- fromList [1..10]\n  close l1\n  l2 <- parMapM (return . (+ 1)) l1\n  close l2\n  toList l2\n\n\ntest_ol7 :: [Int]\ntest_ol7 = runPar$ do \n  a <- singleton 1\n  b <- singleton 2\n  join a b\n  close b\n  toLazyList a\n\ntest_ol8 :: [Int]\ntest_ol8 = runPar$ do \n  a <- singleton 1\n  b <- singleton 2\n  c <- singleton 3\n  d <- singleton 4\n  join c d\n  join a b\n  join b c\n  close d\n  toLazyList a\n\ntest_ll :: [Int]\ntest_ll = runPar$\n   do l <- fromList [1..1000]\n      close l \n      toLazyList l\n\nchaintest :: Int -> Par (IList Int)\nchaintest 0   = error "must have chain length >= 1"\nchaintest len = loop 0 len \n where \n   loop i 1 = do tl <- if i == len-1 \n\t\t       then newFull_ Null \n\t\t       else new\n                 when (i == len-1) (print_$ " == GOT END: "++show i)\n\t\t return (Cons i tl)\n   loop i n =\n    do let half = n `quot` 2\n       ifst <- spawn_$ loop i half \n       fork $ do \n\t\t snd <- loop (i+half) half\n\t\t fst <- get ifst\n\t\t lastfst <- dropIList (half-1) fst \n\t\t put (tl lastfst) snd\n\t\t return ()     \n       get ifst\n\ndropIList :: NFData a => Int -> IList a -> Par (IList a)\ndropIList 0 ls = return ls\ndropIList n ls = do rest <- get (tl ls)\n\t            dropIList (n-1) rest\n\n-- lazy_chaintest i = chaintest i >>= toLazyList\nlazy_chaintest :: Int -> Par [Int]\nlazy_chaintest i = do il <- chaintest i \n\t\t      ml <- iListToMList il\n\t\t      return (mListToList ml)\n\n-- If we create a large, lazy chain, taking just the head should be quick.\nasync_test = \n  do putStrLn "BeginTest"\n--     let lazy = runParAsync$ lazy_chaintest 1048576\n--     let lazy = runParAsync$ lazy_chaintest 32768\n     let lazy = runParAsync$ lazy_chaintest 1024\n--     let lazy = runPar$ lazy_chaintest 1024\n     putStrLn$ "Resulting list "++ show lazy\n     putStrLn$ "Got head: "++ show (P.take 3 lazy)\n     putStrLn "EndTest"\n\n--------------------------------------------------------------------------------\n\nprint_ msg = trace msg $ return ()\n\ndbg0 = debugshow$ runPar$ singleton \'a\' >>= close \n\n-- This one is an error:\nerr1 = debugshow$ runPar$ singleton \'a\' >>= tail  >>= close \n-- But this will work:\ndbg1 = debugshow$ runPar$ fromList "ab" >>= tail  >>= close \n\ndbg2 = debugshow$ runPar$ singleton \'a\' >>= close >>= tail \n\n-- This is invalid:\nerr2 = debugshow$ runPar$ singleton \'a\' >>= tail \n\n-- TODO: HUnit These.\nopenlist_tests :: Test\nopenlist_tests = \n  TestList \n    [\n     -- First a few small, unnamed tests:\n     0                   ~=? runPar (length (empty :: OpenList Int)),\n     "a"                 ~=? runPar (singleton \'a\' >>= close >>= toList),\n     1                   ~=? runPar (singleton \'a\' >>= close >>= length),\n     1                   ~=? runPar (cons \'b\' empty >>= close >>= length),\n\n     TestLabel "singleton, close"          $ "Cons|Cons|eq/True" ~=? dbg0,\n     TestLabel "tail then close - SKETCHY" $ "Cons|Cons|eq/True" ~=? dbg1,\n     TestLabel "close then tail"           $ "Null|Null" ~=? dbg2,\n--     TestLabel "tail no close"   $ "" ~=? dbg3,\n\n     TestLabel "tail of singleton" $ \n     0                   ~=? runPar (singleton \'a\' >>= close >>= tail >>= length),\n     TestLabel "tail tail of cons cons" $ \n     0                   ~=? test_ol0,\n\n     TestLabel "join of two empty\'s still length zero" $ \n     0                   ~=? test_ol1,\n     TestLabel "test show instance" $ \n     "OpenList [10..5]"  ~=? test_ol2,\n\n     TestLabel "toList" $ \n     [1..10]             ~=? test_ol3,\n\n     TestLabel "head . tail . tail" $ \n     3                   ~=? test_ol4,\n\n     TestLabel "length . fromList" $ \n     10                  ~=? test_ol5,\n\n     TestLabel "test parMap" $ \n     [2..11]             ~=? test_ol6,\n\n     TestLabel "test 7" $ \n     [1,2]              ~=? test_ol7,\n\n     TestLabel "test 8" $ \n     [1..4]             ~=? test_ol8,\n\n     TestLabel "test lazy list conversion" $ \n     [1..1000]          ~=? test_ll,\n\n     TestLabel "chaintest" $\n     [0..511]           ~=? runPar (lazy_chaintest 512),\n\n     TestLabel "asynchronous chaintest" $\n     [0..511]           ~=? runParAsync (lazy_chaintest 512)\n\n    ]\n\n'