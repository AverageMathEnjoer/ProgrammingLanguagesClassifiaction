b'{-# LANGUAGE OverloadedStrings #-}\n\nmodule Database.Beam.Sqlite.Test.Select (tests) where\n\nimport Data.Int (Int32)\n\nimport Database.Beam\nimport Database.Beam.Sqlite\nimport Test.Tasty\nimport Test.Tasty.ExpectedFailure\nimport Test.Tasty.HUnit\n\nimport Database.Beam.Sqlite.Test\n\ntests :: TestTree\ntests = testGroup "Selection tests"\n  [ expectFail testExceptValues\n  , testInRowValues\n  , testInSelect\n  ]\n\ndata Pair f = Pair\n  { _left :: C f Bool\n  , _right :: C f Bool\n  } deriving (Generic, Beamable)\n\ntestInRowValues :: TestTree\ntestInRowValues = testCase "IN with row values works" $\n  withTestDb $ \\conn -> do\n    result <- runBeamSqlite conn $ runSelectReturningList $ select $ do\n      let p :: forall ctx s. Pair (QGenExpr ctx Sqlite s)\n          p = val_ $ Pair False False\n      return $ p `in_` [p, p]\n    assertEqual "result" [True] result\n\ntestInSelect :: TestTree\ntestInSelect = testCase "IN (SELECT ...) works" $\n  withTestDb $ \\conn -> do\n    result <- runBeamSqlite conn $ runSelectReturningList $ select $ do\n      let x  = as_ @Int32 (val_ 1)\n      return $ x `inQuery_` (pure (as_ @Int32 $ val_ 1))\n    assertEqual "result" [True] result\n\n    result <- runBeamSqlite conn $ runSelectReturningList $ select $ do\n      let x  = as_ @Int32 (val_ 1)\n      return $ x `inQuery_`  (pure (as_ @Int32 $ val_ 2))\n    assertEqual "result" [False] result\n\n-- | Regression test for <https://github.com/haskell-beam/beam/issues/326 #326>\ntestExceptValues :: TestTree\ntestExceptValues = testCase "EXCEPT with VALUES works" $\n  withTestDb $ \\conn -> do\n    result <- runBeamSqlite conn $ runSelectReturningList $ select $\n      values_ [as_ @Bool $ val_ True, val_ False] `except_` values_ [val_ False]\n    assertEqual "result" [True] result\n'