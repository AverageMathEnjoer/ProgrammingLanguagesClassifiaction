b'/*\n* Copyright 2014 Adnan A M.\n* Copyright 2015 Naman Dwivedi.\n\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n\n*   http://www.apache.org/licenses/LICENSE-2.0\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage com.naman14.timber.timely;\n\nimport android.animation.ObjectAnimator;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.util.AttributeSet;\nimport android.util.Property;\nimport android.view.View;\n\nimport com.naman14.timber.R;\nimport com.naman14.timber.timely.animation.TimelyEvaluator;\nimport com.naman14.timber.timely.model.NumberUtils;\n\npublic class TimelyView extends View {\n    private static final float RATIO = 1f;\n    private static final Property<TimelyView, float[][]> CONTROL_POINTS_PROPERTY = new Property<TimelyView, float[][]>(float[][].class, "controlPoints") {\n        @Override\n        public float[][] get(TimelyView object) {\n            return object.getControlPoints();\n        }\n\n        @Override\n        public void set(TimelyView object, float[][] value) {\n            object.setControlPoints(value);\n        }\n    };\n    private Paint mPaint = null;\n    private Path mPath = null;\n    private float[][] controlPoints = null;\n\n    private int textColor;\n\n    public TimelyView(Context context) {\n        super(context);\n        init();\n    }\n\n    public TimelyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TimelyView);\n        textColor = typedArray.getColor(R.styleable.TimelyView_text_color, Color.BLACK);\n        init();\n    }\n\n    public TimelyView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public float[][] getControlPoints() {\n        return controlPoints;\n    }\n\n    public void setControlPoints(float[][] controlPoints) {\n        this.controlPoints = controlPoints;\n        invalidate();\n    }\n\n    public ObjectAnimator animate(int start, int end) {\n        float[][] startPoints = NumberUtils.getControlPointsFor(start);\n        float[][] endPoints = NumberUtils.getControlPointsFor(end);\n\n        return ObjectAnimator.ofObject(this, CONTROL_POINTS_PROPERTY, new TimelyEvaluator(), startPoints, endPoints);\n    }\n\n    public ObjectAnimator animate(int end) {\n        float[][] startPoints = NumberUtils.getControlPointsFor(-1);\n        float[][] endPoints = NumberUtils.getControlPointsFor(end);\n\n        return ObjectAnimator.ofObject(this, CONTROL_POINTS_PROPERTY, new TimelyEvaluator(), startPoints, endPoints);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (controlPoints == null) return;\n\n        int length = controlPoints.length;\n\n        int height = getMeasuredHeight();\n        int width = getMeasuredWidth();\n\n        float minDimen = height > width ? width : height;\n\n        mPath.reset();\n        mPath.moveTo(minDimen * controlPoints[0][0], minDimen * controlPoints[0][1]);\n        for (int i = 1; i < length; i += 3) {\n            mPath.cubicTo(minDimen * controlPoints[i][0], minDimen * controlPoints[i][1],\n                    minDimen * controlPoints[i + 1][0], minDimen * controlPoints[i + 1][1],\n                    minDimen * controlPoints[i + 2][0], minDimen * controlPoints[i + 2][1]);\n        }\n        canvas.drawPath(mPath, mPaint);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        int width = getMeasuredWidth();\n        int height = getMeasuredHeight();\n        int widthWithoutPadding = width - getPaddingLeft() - getPaddingRight();\n        int heigthWithoutPadding = height - getPaddingTop() - getPaddingBottom();\n\n        int maxWidth = (int) (heigthWithoutPadding * RATIO);\n        int maxHeight = (int) (widthWithoutPadding / RATIO);\n\n        if (widthWithoutPadding > maxWidth) {\n            width = maxWidth + getPaddingLeft() + getPaddingRight();\n        } else {\n            height = maxHeight + getPaddingTop() + getPaddingBottom();\n        }\n\n        setMeasuredDimension(width, height);\n    }\n\n    private void init() {\n        // A new paint with the style as stroke.\n        mPaint = new Paint();\n        mPaint.setAntiAlias(true);\n        mPaint.setColor(textColor);\n        mPaint.setStrokeWidth(5.0f);\n        mPaint.setStyle(Paint.Style.STROKE);\n        mPath = new Path();\n    }\n}\n'