b'{-# LANGUAGE CPP #-}\nmodule Rest.Gen.Types\n  ( unModuleName\n  , overModuleName\n  , namedImport\n  , qualImport\n  , haskellStringType\n  , haskellByteStringType\n  , haskellUnitType\n  , haskellSimpleType\n  , haskellVoidType\n  , noLoc\n  , ModuleName (..)\n  , ImportDecl (..)\n  ) where\n\nimport Language.Haskell.Exts.SrcLoc (noLoc)\nimport Language.Haskell.Exts.Syntax (ImportDecl (..), ModuleName (..), Name (..), QName (..), SpecialCon (..), Type (..))\n\nimport qualified Rest.Gen.NoAnnotation as N\n\nunModuleName :: N.ModuleName -> String\nunModuleName (ModuleName _ name) = name\n\noverModuleName :: (String -> String) -> N.ModuleName -> N.ModuleName\noverModuleName f = ModuleName () . f . unModuleName\n\n-- | Create a simple named basic import, to be updated with other fields\n--   as needed.\nnamedImport :: String -> N.ImportDecl\nnamedImport name = ImportDecl\n  { importAnn       = ()\n  , importQualified = False\n  , importModule    = ModuleName () name\n  , importSrc       = False\n  , importSafe      = False\n  , importPkg       = Nothing\n  , importAs        = Nothing\n  , importSpecs     = Nothing\n  }\n\n-- | Qualified import with given name\nqualImport :: String -> N.ImportDecl\nqualImport name = (namedImport name) { importQualified = True }\n\nhaskellStringType :: N.Type\nhaskellStringType = haskellSimpleType "String"\n\nhaskellByteStringType :: N.Type\nhaskellByteStringType = haskellSimpleType "ByteString"\n\nhaskellSimpleType :: String -> N.Type\nhaskellSimpleType = TyCon () . UnQual () . Ident ()\n\nhaskellUnitType :: N.Type\nhaskellUnitType = TyCon () (Special () (UnitCon ()))\n\nhaskellVoidType :: N.Type\nhaskellVoidType = TyCon () (Qual () (ModuleName () "Rest.Types.Void") (Ident () "Void"))\n'