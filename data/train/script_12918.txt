b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | Utilities for internal use\n\nmodule Pdf.Document.Internal.Util\n(\n  ensureType,\n  dictionaryType,\n  decodeTextString,\n  decodeTextStringThrow\n)\nwhere\n\nimport Pdf.Core\nimport Pdf.Core.Exception\nimport qualified Pdf.Content.Encoding.PdfDoc as PdfDoc\n\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as ByteString\nimport Data.Text (Text)\nimport qualified Data.Text as Text\nimport qualified Data.Text.Encoding as Text\nimport qualified Data.Text.Encoding.Error as Text\nimport qualified Data.Map as Map\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Monad\nimport Control.Exception hiding (throw)\n\n-- | Check that the dictionary has the specified \\"Type\\" filed\nensureType :: Name -> Dict -> IO ()\nensureType name dict = do\n  n <- sure $ dictionaryType dict\n  unless (n == name) $\n    throwIO $ Corrupted ("Expected type: " ++ show name ++\n                       ", but found: " ++ show n) []\n\n-- | Get dictionary type, name at key \\"Type\\"\ndictionaryType :: Dict -> Either String Name\ndictionaryType dict =\n  case HashMap.lookup "Type" dict of\n    Just (Name n) -> Right n\n    Just _ -> Left "Type should be a name"\n    _ -> Left "Type is missing"\n\ndecodeTextStringThrow :: ByteString -> IO Text\ndecodeTextStringThrow bs = case decodeTextString bs of\n  Left err -> throwIO $ Corrupted err []\n  Right txt -> return txt\n\ndecodeTextString :: ByteString -> Either String Text\ndecodeTextString bs\n  | "\\254\\255" `ByteString.isPrefixOf` bs\n  = Right (Text.decodeUtf16BEWith Text.ignore (ByteString.drop 2 bs))\n  | otherwise\n  = do\n    chars <- forM (ByteString.unpack bs) $ \\c ->\n      maybe (Left "Unknow symbol") Right (Map.lookup c PdfDoc.encoding)\n    return (Text.concat chars)\n'