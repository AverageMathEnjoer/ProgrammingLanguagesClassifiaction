b'#\' Modify Keywords Used In Outputs\n#\'\n#\' As an alternative to \\code{\\link{use_custom_lang}}, this function allows\n#\' temporarily modifying the pre-defined terms in the outputs.\n#\'\n#\' @param \\dots One or more pairs of keywords and their new values see \n#\' \\emph{Details} for the complete list of existing keywords.\n#\' @param ask Logical. When `TRUE` (default), a dialog box comes up to ask\n#\'   whether to save the edited values in a csv file for later use.\n#\' @param file Character. Path and name of custom language file to be saved.\n#\'   This comma delimited file can be reused by calling\n#\'   \\code{\\link{use_custom_lang}}.\n#\'\n#\' @details On systems with GUI capabilities, a window will pop-up when calling \n#\' \\code{define_keywords()} without any parameters, allowing the modification \n#\' of the \\emph{custom} column. The changes will be active as long as the\n#\' package is loaded. When the edit window is closed, a dialog will pop up,\n#\' prompting the user to save the modified set of keywords in a custom csv\n#\' language file that can later be used with \\code{\\link{use_custom_lang}}.\n#\' \n#\' Here is the full list of modifiable keywords.\n#\'   \n#\' \\describe{\n#\'   \\item{title.freq}{main heading for \\code{freq()}}\n#\'   \\item{title.freq.weighted}{main heading for \\code{freq()} (weighted)}\n#\'   \\item{title.ctable}{main heading for \\code{ctable()}}\n#\'   \\item{title.ctable.weighted}{main heading \\code{ctable()} (weighted)}\n#\'   \\item{title.ctable.row}{indicates what proportions are displayed}\n#\'   \\item{title.ctable.col}{indicates what proportions are displayed}\n#\'   \\item{title.ctable.tot}{indicates what proportions are displayed}\n#\'   \\item{title.descr}{main heading for \\code{descr()}}\n#\'   \\item{title.descr.weighted}{main heading for \\code{descr()} (weighted)}\n#\'   \\item{title.dfSummary}{main heading for \\code{dfSummary()}}\n#\'   \\item{n}{heading item used in \\code{descr()}}\n#\'   \\item{dimensions}{heading item used in \\code{dfSummary()}}\n#\'   \\item{duplicates}{heading item used in \\code{dfSummary()}}\n#\'   \\item{data.frame}{heading item (all functions)}\n#\'   \\item{label}{heading item (all functions) & column name in \\code{dfSummary()}}\n#\'   \\item{variable}{heading item (all functions) & column name in \\code{dfSummary()}}\n#\'   \\item{group}{heading item (all functions when used with \\code{stby()}}\n#\'   \\item{by}{heading item for \\code{descr()} when used with stby()}\n#\'   \\item{weights}{heading item - \\code{descr()} & \\code{freq()}}\n#\'   \\item{type}{heading item for \\code{freq()}}\n#\'   \\item{logical}{heading item - type in \\code{freq()}}\n#\'   \\item{character}{heading item - type in \\code{freq()}}\n#\'   \\item{numeric}{heading item - type in \\code{freq()}}\n#\'   \\item{factor}{heading item - type in \\code{freq()}}\n#\'   \\item{factor.ordered}{heading item - type in \\code{freq()}}\n#\'   \\item{date}{heading item - type in \\code{freq()}}\n#\'   \\item{datetime}{heading item - type in \\code{freq()}}\n#\'   \\item{freq}{column name in \\code{freq()}}\n#\'   \\item{pct}{column name in \\code{freq()} when \\code{report.nas=FALSE}}\n#\'   \\item{pct.valid.f}{column name in \\code{freq()}}\n#\'   \\item{pct.valid.cum}{column name in \\code{freq()}}\n#\'   \\item{pct.total}{column name in \\code{freq()}}\n#\'   \\item{pct.total.cum}{column name in \\code{freq()}}\n#\'   \\item{pct.cum}{column name in \\code{freq()}}\n#\'   \\item{valid}{column name in \\code{freq()} and \\code{dfSummary()} & column content in \\code{dfSummary()}}\n#\'   \\item{invalid}{column content in \\code{dfSummary()} (emails)}\n#\'   \\item{total}{column grouping in \\code{freq()}, html version}\n#\'   \\item{mean}{row name in \\code{descr()}}\n#\'   \\item{sd.long}{row name in \\code{descr()}}\n#\'   \\item{sd}{cell content (dfSummary)}\n#\'   \\item{min}{row name in \\code{descr()}}\n#\'   \\item{q1}{row name in \\code{descr()} - 1st quartile}\n#\'   \\item{med}{row name in \\code{descr()}}\n#\'   \\item{q3}{row name in \\code{descr()} - 3rd quartile}\n#\'   \\item{max}{row name in \\code{descr()}}\n#\'   \\item{mad}{row name in \\code{descr()} - Median Absolute Deviation}\n#\'   \\item{iqr}{row name in \\code{descr()} - Inter-Quartile Range}\n#\'   \\item{cv}{row name in \\code{descr()} - Coefficient of Variation}\n#\'   \\item{skewness}{row name in \\code{descr()}}\n#\'   \\item{se.skewness}{row name in \\code{descr()} - Std. Error for Skewness}\n#\'   \\item{kurtosis}{row name in \\code{descr()}}\n#\'   \\item{n.valid}{row name in \\code{descr()} - Count of non-missing values}\n#\'   \\item{pct.valid}{row name in \\code{descr()} - pct. of non-missing values}\n#\'   \\item{no}{column name in \\code{dfSummary()} - position of column in the data frame}\n#\'   \\item{stats.values}{column name in \\code{dfSummary()}}\n#\'   \\item{freqs.pct.valid}{column name in \\code{dfSummary()}}\n#\'   \\item{graph}{column name in \\code{dfSummary()}}\n#\'   \\item{missing}{column name in \\code{dfSummary()}}\n#\'   \\item{distinct.value}{cell content in \\code{dfSummary()} - singular form}\n#\'   \\item{distinct.values}{cell content in \\code{dfSummary()} - plural form}\n#\'   \\item{all.nas}{cell content in \\code{dfSummary()} - column has only NAs}\n#\'   \\item{all.empty.str}{cell content in \\code{dfSummary()} - column has only empty strings}\n#\'   \\item{all.empty.str.nas}{cell content in \\code{dfSummary()} - col. has only NAs and empty strings}\n#\'   \\item{no.levels.defined}{cell content in \\code{dfSummary()} - factor has no levels defined}\n#\'   \\item{int.sequence}{cell content in \\code{dfSummary()}}\n#\'   \\item{rounded}{cell content in \\code{dfSummary()} - note appearing in Stats/Values}\n#\'   \\item{others}{cell content in \\code{dfSummary()} - nbr of values not displayed}\n#\'   \\item{codes}{cell content in \\code{dfSummary()} - When UPC codes are detected}\n#\'   \\item{mode}{cell content in \\code{dfSummary()} - mode = most frequent value}\n#\'   \\item{med.short}{cell content in \\code{dfSummary()} - median (shortened term)}\n#\'   \\item{start}{cell content in \\code{dfSummary()} - earliest date for date-type cols}\n#\'   \\item{end}{cell content in \\code{dfSummary()} - latest date for data-type cols}\n#\'   \\item{emails}{cell content in \\code{dfSummary()}}\n#\'   \\item{generated.by}{footnote content}\n#\'   \\item{version}{footnote content}\n#\'   \\item{date.fmt}{footnote - date format (see \\code{\\link{strptime}})}\n#\' }\n#\' \n#\' @note Setting a keyword starting with \\dQuote{title.} to NA or to empty\n#\' string causes the main title to disappear altogether, which might be\n#\' desired in some circumstances (when generating a table of contents, for\n#\' instance).\n#\' \n#\' @examples \n#\' \\dontrun{\n#\' define_keywords(n = "Nb. Obs.")\n#\' } \n#\' \n#\' @keywords utilities\n#\' @importFrom utils read.delim edit write.csv\n#\' @importFrom tcltk tclvalue tk_messageBox tkgetSaveFile\n#\' @importFrom checkmate check_path_for_output\n#\' @export\ndefine_keywords <- function(..., ask = TRUE, file = NA) {\n  mc <- match.call()\n  kw <- names(mc[setdiff(names(mc), names(formals()))])[-1]\n  if (length(kw) == 0 && !isTRUE(interactive())) {\n    stop("R session not interactive; use arguments to define keywords, ",\n         "or see ?use_custom_lang to use an external file to define all ",\n         "keywords at once")\n  }\n  if (length(kw) == 0 && isFALSE(capabilities("tcltk"))) {\n    message("Window dialogs not allowed; use arguments to ",\n            "redefine specific keywords (see ?define_keywords), or turn to the ",\n            "use_custom_lang() function which allows redefining all keywords at ",\n            "once using a csv file")\n    return(invisible())\n  }\n  \n  if (st_options("lang") == "custom") {\n    tr <- as.data.frame(t(.st_env$custom_lang), stringsAsFactors = FALSE)\n  } else {\n    tr <- as.data.frame(t(.translations[st_options("lang"),]), \n                        stringsAsFactors = FALSE)\n  }\n  \n  tr <- merge(tr, .keywords_context, by = 0, sort = FALSE)\n  class(tr$Row.names) <- "character"\n  tr$item <- tr$Row.names\n  tr$Row.names <- NULL\n  tr <- tr[,c(3,1,2)]\n  colnames(tr)[2] <- "custom"\n  \n  if (length(kw) == 0) {\n    message("Instructions: \\n  - Modify entries in the second column only \\n",\n            "  - leave column names unchanged\\n",\n            "  - expanding the window reveals context information stored in ",\n            "third column\\n",\n            "  - Close the editing window when finished")\n    tr.copy <- tr\n    tr <- try(edit(tr), silent = TRUE)\n    if (inherits(tr, "try-error")) {\n      stop("Window dialogs not allowed; use arguments to ",\n           "redefine specific keywords (see ?define_keywords), or turn to the ",\n           "use_custom_lang() function which allows redefining all keywords at ",\n           "once using a csv file")\n    }\n    if (identical(tr[[2]], tr.copy[[2]])) {\n      message("No changes were registered")\n      return(invisible())\n    }\n  } else {\n    for (it in kw) {\n      ind <- which(tr$item == it)\n      if (length(ind) == 0) {\n        message("\'", it, "\' is not a recognized keyword; see ?define_keywords ",\n                "for a list of valid keywords")\n        next\n      }\n      if (inherits(mc[[it]], c("call", "name"))) {\n       mc[[it]] <- eval(mc[[it]], parent.frame())\n      }\n      tr$custom[ind] <- mc[[it]]\n    }\n  }\n\n  use_custom_lang(tr)\n\n  if (!is.na(file)) {\n    filename <- normalizePath(file, mustWork = FALSE)\n    if (isTRUE(check_path_for_output(filename, overwrite = TRUE))) {\n    write.csv(x = tr,\n              file = filename,\n              row.names = FALSE, \n              fileEncoding = "utf-8")\n    message("Custom language file written: ", filename)\n    } else {\n      warning("file name or path invalid")\n    }\n  } else if (isTRUE(ask)) {\n    filename <- ""\n    filename_ok <- FALSE\n    \n    if (interactive() && length(kw) == 1) {\n      \n      if (isTRUE(capabilities("tcltk")) && isTRUE(ask)) {\n        # tcltk capabilities: yes\n        resp <- try(tk_messageBox(type = "yesno", \n                                  message = "Export language file for later use?",\n                                  caption = "Keywords Successfully Updated"),\n                    silent = TRUE)\n        if (inherits(resp, "try-error")) {\n          tcltk_error <- TRUE\n        } else {\n          if (resp == "yes") {\n            while (!filename_ok) {\n              filename <- tclvalue(\n                tkgetSaveFile(initialfile = "custom_lang.csv", \n                              initialdir = "~",\n                              filetypes = "{{csv files} {*.csv}}")\n              )\n              \n              if (filename != "") {\n                filename <- sub("(.csv)+$", "\\\\1", paste0(filename, ".csv"))\n                filename <- normalizePath(filename, mustWork = FALSE)\n                if (!isTRUE(check_path_for_output(filename, overwrite = TRUE))) {\n                  rv <- tk_messageBox(\n                    type = "okcancel", \n                    message = "Invalid file name or location"\n                  )\n                  if (rv == "cancel") {\n                    filename <- ""\n                    filename_ok <- TRUE\n                  }\n                } else {\n                  # Filename is valid\n                  filename_ok <- TRUE\n                }\n              } else {\n                # dialog "Save as..." was cancelled\n                filename_ok <- TRUE\n              }\n            }\n          }\n        }\n      }\n      \n      # tcltk capabilities: no, or attempt failed\n      if (isFALSE(capabilities("tcltk")) || exists("tcltk_error")) {\n        resp <- " "\n        while (!resp %in% c("Y", "N", "")) {\n          resp <- toupper(\n            readline(prompt = "Export language file for later use? [y/N] ")\n          )\n        }\n        \n        if (resp == "Y") {\n          while (!filename_ok) {\n            filename <- readline(prompt = "Full path to csv file (ESC to cancel): ")\n            # Remove surrounding quotes if any\n            filename <- sub(\'^"(.+)"$|^\\\'(.+)\\\'$\', "\\\\1\\\\2", filename)\n            if (filename != "" && \n                (!isTRUE(check_path_for_output(filename, overwrite = TRUE)) || \n                 !grepl("\\\\.csv$", filename))) {\n              message("Invalid file location or extension (must be .csv)")\n            } else {\n              filename_ok <- TRUE # filename either "" or valid\n            }\n          }\n        }\n      }\n    }\n    \n    if (filename != "") {\n      write.csv(x = tr, file = filename, row.names = FALSE, \n                fileEncoding = "utf-8")\n      message("Custom language file written: ", normalizePath(filename))\n    }\n  }\n}\n'