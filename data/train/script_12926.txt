b'#\' Apply a variance stabilizing transformation (VST) to the count data\n#\'\n#\' This function calculates a variance stabilizing transformation (VST) from the\n#\' fitted dispersion-mean relation(s) and then transforms the count data (normalized\n#\' by division by the size factors or normalization factors), yielding a matrix\n#\' of values which are now approximately homoskedastic (having constant variance along the range\n#\' of mean values). The transformation also normalizes with respect to library size.\n#\' The \\code{\\link{rlog}} is less sensitive\n#\' to size factors, which can be an issue when size factors vary widely.\n#\' These transformations are useful when checking for outliers or as input for\n#\' machine learning techniques such as clustering or linear discriminant analysis.\n#\' \n#\' @aliases varianceStabilizingTransformation getVarianceStabilizedData\n#\' \n#\' @param object a DESeqDataSet or matrix of counts\n#\' @param blind logical, whether to blind the transformation to the experimental\n#\' design. blind=TRUE should be used for comparing samples in a manner unbiased by\n#\' prior information on samples, for example to perform sample QA (quality assurance).\n#\' blind=FALSE should be used for transforming data for downstream analysis,\n#\' where the full use of the design information should be made.\n#\' blind=FALSE will skip re-estimation of the dispersion trend, if this has already been calculated.\n#\' If many of genes have large differences in counts due to\n#\' the experimental design, it is important to set blind=FALSE for downstream\n#\' analysis.\n#\' @param fitType in case dispersions have not yet been estimated for \\code{object},\n#\' this parameter is passed on to \\code{\\link{estimateDispersions}} (options described there).\n#\'\n#\' @details For each sample (i.e., column of \\code{counts(dds)}), the full variance function\n#\' is calculated from the raw variance (by scaling according to the size factor and adding \n#\' the shot noise). We recommend a blind estimation of the variance function, i.e.,\n#\' one ignoring conditions. This is performed by default, and can be modified using the\n#\' \'blind\' argument.\n#\'\n#\' Note that neither rlog transformation nor the VST are used by the\n#\' differential expression estimation in \\code{\\link{DESeq}}, which always\n#\' occurs on the raw count data, through generalized linear modeling which\n#\' incorporates knowledge of the variance-mean dependence. The rlog transformation\n#\' and VST are offered as separate functionality which can be used for visualization,\n#\' clustering or other machine learning tasks. See the transformation section of the\n#\' vignette for more details.\n#\'\n#\' The transformation does not require that one has already estimated size factors\n#\' and dispersions.\n#\'\n#\' A typical workflow is shown in Section \\emph{Variance stabilizing transformation}\n#\' in the package vignette.\n#\'\n#\' If \\code{\\link{estimateDispersions}} was called with:\n#\'\n#\' \\code{fitType="parametric"},\n#\' a closed-form expression for the variance stabilizing\n#\' transformation is used on the normalized\n#\' count data. The expression can be found in the file \\file{vst.pdf}\n#\' which is distributed with the vignette.\n#\'\n#\' \\code{fitType="local"},\n#\' the reciprocal of the square root of the variance of the normalized counts, as derived\n#\' from the dispersion fit, is then numerically\n#\' integrated, and the integral (approximated by a spline function) is evaluated for each\n#\' count value in the column, yielding a transformed value. \n#\'\n#\' \\code{fitType="mean"}, a VST is applied for Negative Binomial distributed counts, \'k\',\n#\' with a fixed dispersion, \'a\': ( 2 asinh(sqrt(a k)) - log(a) - log(4) )/log(2).\n#\' \n#\' In all cases, the transformation is scaled such that for large\n#\' counts, it becomes asymptotically (for large values) equal to the\n#\' logarithm to base 2 of normalized counts.\n#\'\n#\' The variance stabilizing transformation from a previous dataset\n#\' can be "frozen" and reapplied to new samples.\n#\' The frozen VST is accomplished by saving the dispersion function\n#\' accessible with \\code{\\link{dispersionFunction}}, assigning this\n#\' to the \\code{DESeqDataSet} with the new samples, and running\n#\' varianceStabilizingTransformation with \'blind\' set to FALSE.\n#\' Then the dispersion function from the previous dataset will be used\n#\' to transform the new sample(s).\n#\'  \n#\' Limitations: In order to preserve normalization, the same\n#\' transformation has to be used for all samples. This results in the\n#\' variance stabilizition to be only approximate. The more the size\n#\' factors differ, the more residual dependence of the variance on the\n#\' mean will be found in the transformed data. \\code{\\link{rlog}} is a\n#\' transformation which can perform better in these cases.\n#\' As shown in the vignette, the function \\code{meanSdPlot}\n#\' from the package \\pkg{vsn} can be used to see whether this is a problem.\n#\'\n#\' @return \\code{varianceStabilizingTransformation} returns a\n#\' \\code{\\link{DESeqTransform}} if a \\code{DESeqDataSet} was provided,\n#\' or returns a a matrix if a count matrix was provided.\n#\' Note that for \\code{\\link{DESeqTransform}} output, the matrix of\n#\' transformed values is stored in \\code{assay(vsd)}.\n#\' \\code{getVarianceStabilizedData} also returns a matrix.\n#\'\n#\' @references\n#\'\n#\' Reference for the variance stabilizing transformation for counts with a dispersion trend:\n#\' \n#\' Simon Anders, Wolfgang Huber: Differential expression analysis for sequence count data. Genome Biology 2010, 11:106. \\url{http://dx.doi.org/10.1186/gb-2010-11-10-r106}\n#\' \n#\' @author Simon Anders\n#\'\n#\' @seealso \\code{\\link{plotPCA}}, \\code{\\link{rlog}}, \\code{\\link{normTransform}}\n#\'\n#\' @examples\n#\'\n#\' dds <- makeExampleDESeqDataSet(m=6)\n#\' vsd <- varianceStabilizingTransformation(dds)\n#\' dists <- dist(t(assay(vsd)))\n#\' # plot(hclust(dists))\n#\'\n#\' @export\nvarianceStabilizingTransformation <- function (object, blind=TRUE, fitType="parametric") {\n  if (is.null(colnames(object))) {\n    colnames(object) <- seq_len(ncol(object))\n  }\n  if (is.matrix(object)) {\n    matrixIn <- TRUE\n    object <- DESeqDataSetFromMatrix(object, DataFrame(row.names=colnames(object)), ~1)\n  } else {\n    matrixIn <- FALSE\n  }\n  if (is.null(sizeFactors(object)) & is.null(normalizationFactors(object))) {\n    object <- estimateSizeFactors(object)\n  }\n  if (blind) {\n    design(object) <- ~ 1\n  }\n  if (blind | is.null(attr(dispersionFunction(object),"fitType"))) {\n    object <- estimateDispersionsGeneEst(object, quiet=TRUE)\n    object <- estimateDispersionsFit(object, quiet=TRUE, fitType)\n  }\n  vsd <- getVarianceStabilizedData(object)\n  if (matrixIn) {\n    return(vsd)\n  }\n  se <- SummarizedExperiment(\n    assays = vsd,\n    colData = colData(object),\n    rowRanges = rowRanges(object),\n    metadata = metadata(object))\n  DESeqTransform(se)\n}\n\n#\' @rdname varianceStabilizingTransformation\n#\' @export\ngetVarianceStabilizedData <- function(object) {\n  if (is.null(attr(dispersionFunction(object),"fitType"))) {\n    stop("call estimateDispersions before calling getVarianceStabilizedData")\n  }\n  ncounts <- counts(object, normalized=TRUE)\n  if( attr( dispersionFunction(object), "fitType" ) == "parametric" ) {\n    coefs <- attr( dispersionFunction(object), "coefficients" )\n    vst.fn <- function( q ) {\n      log( (1 + coefs["extraPois"] + 2 * coefs["asymptDisp"] * q + 2 * sqrt( coefs["asymptDisp"] * q * ( 1 + coefs["extraPois"] + coefs["asymptDisp"] * q ) ) ) / ( 4 * coefs["asymptDisp"] ) ) / log(2)\n    }\n    return(vst.fn(ncounts))\n  } else if ( attr( dispersionFunction(object), "fitType" ) == "local" ) {\n    # non-parametric fit -> numerical integration\n    if (is.null(sizeFactors(object))) {\n      stopifnot(!is.null(normalizationFactors(object)))\n      # approximate size factors from columns of NF\n      sf <- exp(colMeans(log(normalizationFactors(object))))\n    } else {\n      sf <- sizeFactors(object)\n    }\n    xg <- sinh( seq( asinh(0), asinh(max(ncounts)), length.out=1000 ) )[-1]\n    xim <- mean( 1/sf )\n    baseVarsAtGrid <- dispersionFunction(object)( xg ) * xg^2 + xim * xg\n    integrand <- 1 / sqrt( baseVarsAtGrid )\n    splf <- splinefun(\n      asinh( ( xg[-1] + xg[-length(xg)] )/2 ),\n      cumsum(\n        ( xg[-1] - xg[-length(xg)] ) *\n        ( integrand[-1] + integrand[-length(integrand)] )/2 ) )\n    h1 <- quantile( rowMeans(ncounts), .95 )\n    h2 <- quantile( rowMeans(ncounts), .999 )\n    eta <- ( log2(h2) - log2(h1) ) / ( splf(asinh(h2)) - splf(asinh(h1)) )\n    xi <- log2(h1) - eta * splf(asinh(h1))\n    tc <- sapply( colnames(counts(object)), function(clm) {\n      eta * splf( asinh( ncounts[,clm] ) ) + xi\n    })\n    rownames( tc ) <- rownames( counts(object) )\n    return(tc)\n  } else if ( attr( dispersionFunction(object), "fitType" ) == "mean" ) {\n    alpha <- attr( dispersionFunction(object), "mean" )\n    # the following stablizes NB counts with fixed dispersion alpha\n    # and converges to log2(q) as q => infinity\n    vst.fn <- function(q) ( 2 * asinh(sqrt(alpha * q)) - log(alpha) - log(4) ) / log(2)\n    return(vst.fn(ncounts))\n  } else {\n    stop( "fitType is not parametric, local or mean" )\n  }\n}\n\n#\' Quickly estimate dispersion trend and apply a variance stabilizing transformation\n#\'\n#\' This is a wrapper for the \\code{\\link{varianceStabilizingTransformation}} (VST)\n#\' that provides much faster estimation of the dispersion trend used to determine\n#\' the formula for the VST. The speed-up is accomplished by\n#\' subsetting to a smaller number of genes in order to estimate this dispersion trend.\n#\' The subset of genes is chosen deterministically, to span the range\n#\' of genes\' mean normalized count.\n#\' \n#\' @param object a DESeqDataSet or a matrix of counts\n#\' @param blind logical, whether to blind the transformation to the experimental\n#\' design (see \\code{\\link{varianceStabilizingTransformation}})\n#\' @param nsub the number of genes to subset to (default 1000)\n#\' @param fitType for estimation of dispersions: this parameter\n#\' is passed on to \\code{\\link{estimateDispersions}} (options described there)\n#\'\n#\' @return a DESeqTranform object or a matrix of transformed, normalized counts\n#\'\n#\' @examples\n#\'\n#\' dds <- makeExampleDESeqDataSet(n=2000, m=20)\n#\' vsd <- vst(dds)\n#\'\n#\' @export\nvst <- function(object, blind=TRUE, nsub=1000, fitType="parametric") {\n  if (nrow(object) < nsub) {\n    stop("less than \'nsub\' rows,\n  it is recommended to use varianceStabilizingTransformation directly")\n  }\n  if (is.null(colnames(object))) {\n    colnames(object) <- seq_len(ncol(object))\n  }\n  if (is.matrix(object)) {\n    matrixIn <- TRUE\n    object <- DESeqDataSetFromMatrix(object, DataFrame(row.names=colnames(object)), ~ 1)\n  } else {\n    if (blind) {\n      design(object) <- ~ 1\n    }\n    matrixIn <- FALSE\n  }\n  if (is.null(sizeFactors(object)) & is.null(normalizationFactors(object))) {\n    object <- estimateSizeFactors(object)\n  }\n  baseMean <- rowMeans(counts(object, normalized=TRUE))\n  if (sum(baseMean > 5) < nsub) {\n    stop("less than \'nsub\' rows with mean normalized count > 5, \n  it is recommended to use varianceStabilizingTransformation directly")\n  }\n\n  # subset to a specified number of genes with mean normalized count > 5\n  object.sub <- object[baseMean > 5,]\n  baseMean <- baseMean[baseMean > 5]\n  o <- order(baseMean)\n  idx <- o[round(seq(from=1, to=length(o), length=nsub))]\n  object.sub <- object.sub[idx,]\n\n  # estimate dispersion trend\n  object.sub <- estimateDispersionsGeneEst(object.sub, quiet=TRUE)\n  object.sub <- estimateDispersionsFit(object.sub, fitType=fitType, quiet=TRUE)\n\n  # assign to the full object\n  suppressMessages({dispersionFunction(object) <- dispersionFunction(object.sub)})\n\n  # calculate and apply the VST (note blinding is accomplished above,\n  # here blind=FALSE is used to avoid re-calculating dispersion)\n  vsd <- varianceStabilizingTransformation(object, blind=FALSE)\n  if (matrixIn) {\n    return(assay(vsd))\n  } else {\n    return(vsd)\n  }\n}\n'