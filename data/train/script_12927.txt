b'{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE FlexibleContexts #-}\nimport Data.Array.Accelerate as Acc\nimport Data.Array.Accelerate.Interpreter (run)\n\nimport qualified Data.Vector as V\nimport Prelude hiding (map, zipWith)\nimport qualified Prelude as P\n\n-- Hello \n\n-- foo arr = \n  \n\n-- runfoo = foo (fromIArray (V.replicate 10 10))\nfoo = do \n  putStrLn$ "indices0: " ++ show (run indices0)\n  putStrLn$ "samples0: " ++ show (run samples0)\n  putStrLn$ "vals0: "    ++ show (run vals0)\n  putStrLn$ "bools0: "   ++ show (run bools0)\n\n  putStrLn$ "indices1: " ++ show (run indices1)\n--   foldSeg (+) 0 (use arr) (use segs)\n  where \n\n    arr :: Acc (Array DIM1 Int)\n    arr  = use$ fromList ((Z :. 512) :: DIM1 ) [1..512::Int]\n--    arr = fromList ((Z :. 512) :: DIM1 ) (P.map (\\_->0::Int) [1..512::Int])\n    segs = fromList ((Z :. 2) :: DIM1 ) (P.replicate 2 (256::Int))\n\n--    indices0 = use$ fromList ((Z :. 2) :: DIM1 ) (P.replicate 2 (0::Int))\n    indices0 = use$ fromList ((Z :. 2) :: DIM1 ) [0,256::Int]\n    vals0    = gather indices0 arr\n    -- Pretend this is what we\'re looking for:\n    samples0 = use$ fromList ((Z :. 2) :: DIM1 ) [112,256::Int]\n\n    bools0   = zipWith (<*) vals0 samples0\n\n    indices1 = zipWith (maybeStride 128) bools0 indices0\n\n    maybeStride incr bool n = bool ? (n+incr, n)\n\n    -- Example of how to do a loop in the metaprogram to generate code\n    -- for 8 stages of binary searching:\n    _ = loop 256 indices0\n\n    loop 1 indices = undefined\n    loop stride indices = loop (stride `quot` 2) arr\n\n\n--    indices = fromList (index1 2) (P.replicate 2 (0::Int))\n\n-- gather\n--   :: (Shape ix, Shape ix1, Elt b) =>\n--      Acc (Array ix ix1) -> Acc (Array ix1 b) -> Acc (Array ix b)\n\n-- gather :: Acc (Array DIM1 Int) -> Acc (Array DIM1 a) -> Acc (Array DIM1 a)\ngather inds arr = \n   Acc.map (\\ i -> arr ! (index1 i)) inds\n'