b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.ModelAction.Select where\n\nimport Control.Lens (set, view)\nimport qualified Data.Algorithm.Diff as A\nimport qualified Data.Function as F (on)\nimport Data.Hoodle.BBox\n  ( BBox (..),\n    BBoxed (..),\n    GetBBoxable (getBBox),\n    IntersectBBox (Intersect, unIntersect),\n    ULMaybe (Bottom, Middle),\n    UnionBBox (Union),\n    bbox4All,\n    fromMaybe,\n    toMaybe,\n  )\nimport Data.Hoodle.Generic\n  ( GLayer (..),\n    gbuffer,\n    gdimension,\n    glayers,\n  )\nimport Data.Hoodle.Select\n  ( gselAll,\n    gselSelected,\n  )\nimport Data.Hoodle.Simple\n  ( Dimension (Dim),\n    Stroke (..),\n    color,\n    getXYtuples,\n  )\nimport qualified Data.IntMap as M\nimport qualified Data.Map as Map\nimport Data.Maybe (isJust)\nimport Data.Sequence (Seq)\nimport Data.Strict.Tuple (Pair ((:!:)))\nimport Data.Time.Clock\n  ( UTCTime,\n    diffUTCTime,\n    getCurrentTime,\n  )\nimport Graphics.Hoodle.Render (renderRItem)\nimport Graphics.Hoodle.Render.Type\n  ( CanvasId,\n    RItem (..),\n    RenderCache,\n    hPage2RPage,\n    mkHPage,\n    selectedLayer,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( Hitted (..),\n    TAlterHitted,\n    TEitherAlterHitted (..),\n    getA,\n    getB,\n    takeHitted,\n  )\nimport Graphics.Hoodle.Render.Util (clipBBox)\nimport Graphics.Hoodle.Render.Util.HitTest (isPointInBBox)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport Graphics.Rendering.Cairo.Matrix (invert, transformPoint)\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.HitTest (hitLassoPoint)\nimport Hoodle.ModelAction.Layer (getCurrentLayer)\nimport Hoodle.ModelAction.Pen\n  ( TempRender,\n    tempInfo,\n  )\nimport Hoodle.ModelAction.Select.Transform\n  ( changeItemBy,\n    offsetFunc,\n    rItmsInActiveLyr,\n  )\nimport Hoodle.Type.Alias\n  ( EditMode,\n    Hoodle,\n    Page,\n    SelectMode,\n  )\nimport Hoodle.Type.Enum\n  ( PenColor,\n    penColorNameMap,\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    UnitHoodle,\n    hoodleModeState,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasCoordinate (..),\n    CanvasDimension (..),\n    DesktopCoordinate (..),\n    PageCoordinate (..),\n    PageNum (..),\n    ViewPortBBox (..),\n  )\nimport Hoodle.Type.Predefined (dtimeBound)\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry\n      ( canvasDim,\n        canvasViewPort,\n        desktop2Canvas,\n        desktop2Page,\n        page2Desktop\n      ),\n  )\n\n-- |\ndata Handle\n  = HandleTL\n  | HandleTR\n  | HandleBL\n  | HandleBR\n  | HandleTM\n  | HandleBM\n  | HandleML\n  | HandleMR\n  deriving (Show, Eq)\n\n-- |\nscaleFromToBBox :: BBox -> BBox -> (Double, Double) -> (Double, Double)\nscaleFromToBBox (BBox (ox1, oy1) (ox2, oy2)) (BBox (nx1, ny1) (nx2, ny2)) (x, y) =\n  let sx = (nx2 - nx1) / (ox2 - ox1)\n      sy = (ny2 - ny1) / (oy2 - oy1)\n      nx = (x - ox1) * sx + nx1\n      ny = (y - oy1) * sy + ny1\n   in (nx, ny)\n\n-- |\nisBBoxDeltaSmallerThan :: Double -> PageNum -> CanvasGeometry -> BBox -> BBox -> Bool\nisBBoxDeltaSmallerThan\n  delta\n  pnum\n  geometry\n  (BBox (x11, y11) (x12, y12))\n  (BBox (x21, y21) (x22, y22)) =\n    let (x11\', y11\') = coordtrans (x11, y11)\n        (x12\', y12\') = coordtrans (x12, y12)\n        (x21\', y21\') = coordtrans (x21, y21)\n        (x22\', y22\') = coordtrans (x22, y22)\n     in (x11\' - x21\' > (-delta) && x11\' - x21\' < delta)\n          && (y11\' - y21\' > (-delta) && y11\' - y21\' < delta)\n          && (x12\' - x22\' > (-delta) && x12\' - x22\' < delta)\n          && (y11\' - y21\' > (-delta) && y12\' - y22\' < delta)\n    where\n      coordtrans (x, y) =\n        unCvsCoord . desktop2Canvas geometry . page2Desktop geometry $\n          (pnum, PageCoord (x, y))\n\n-- |\ngetSelectedItms :: Page SelectMode -> [RItem]\ngetSelectedItms = either (const []) (concatMap unHitted . getB) . rItmsInActiveLyr\n\n-- |\ngetSelectedItmsFromUnitHoodle :: UnitHoodle -> Maybe [RItem]\ngetSelectedItmsFromUnitHoodle uhdl =\n  case view hoodleModeState uhdl of\n    ViewAppendState _ -> Nothing\n    SelectState thdl -> fmap (getSelectedItms . Prelude.snd) (view gselSelected thdl)\n\n-- | start a select mode with alter list selection\nmakePageSelectMode ::\n  -- | base page\n  Page EditMode ->\n  -- | current selection layer (active layer will be replaced)\n  TAlterHitted RItem ->\n  -- | resultant select mode page\n  Page SelectMode\nmakePageSelectMode page alist =\n  let clyr = getCurrentLayer page\n      nlyr = GLayer (view gbuffer clyr) (TEitherAlterHitted (Right alist))\n   in set (glayers . selectedLayer) nlyr (mkHPage page)\n\n-- | get unselected part of page and make an ordinary page\ndeleteSelected :: Page SelectMode -> Page SelectMode\ndeleteSelected tpage =\n  let activelayer = rItmsInActiveLyr tpage\n      buf = view (glayers . selectedLayer . gbuffer) tpage\n   in case activelayer of\n        Left _ -> tpage\n        Right alist ->\n          let leftstrs = concat (getA alist)\n              layer\' = GLayer buf . TEitherAlterHitted . Left $ leftstrs\n           in set (glayers . selectedLayer) layer\' tpage\n\n-- |\nupdateTempHoodleSelect ::\n  Hoodle SelectMode ->\n  Page SelectMode ->\n  Int ->\n  Hoodle SelectMode\nupdateTempHoodleSelect thdl tpage pagenum =\n  let pgs = view gselAll thdl\n      pgs\' = M.adjust (const (hPage2RPage tpage)) pagenum pgs\n   in set gselAll pgs\' . set gselSelected (Just (pagenum, tpage)) $ thdl\n\n-- |\ncalculateWholeBBox :: [BBoxed Stroke] -> Maybe BBox\ncalculateWholeBBox = toMaybe . mconcat . map (Union . Middle . getBBox)\n\n-- |\nhitInSelection :: Page SelectMode -> (Double, Double) -> Bool\nhitInSelection tpage point =\n  case rItmsInActiveLyr tpage of\n    Left _ -> False\n    Right alist ->\n      let Union bboxall =\n            mconcat\n              . map (Union . Middle . getBBox)\n              . takeHitted\n              $ alist\n       in case bboxall of\n            Middle bbox -> isPointInBBox bbox point\n            _ -> False\n\n-- |\ngetULBBoxFromSelected :: Page SelectMode -> ULMaybe BBox\ngetULBBoxFromSelected tpage =\n  case rItmsInActiveLyr tpage of\n    Left _ -> Bottom\n    Right alist -> bbox4All . takeHitted $ alist\n\n-- |\nhitInHandle :: Page SelectMode -> (Double, Double) -> Bool\nhitInHandle tpage point =\n  case getULBBoxFromSelected tpage of\n    Middle bbox -> isJust (checkIfHandleGrasped bbox point)\n    _ -> False\n\n-- |\ntoggleCutCopyDelete :: Gtk.UIManager -> Bool -> IO ()\ntoggleCutCopyDelete ui b = do\n  agr <-\n    Gtk.uiManagerGetActionGroups ui >>= \\case\n      [] -> error "No action group?"\n      y : _ -> return y\n  Just deletea <- Gtk.actionGroupGetAction agr "DELETEA"\n  Just copya <- Gtk.actionGroupGetAction agr "COPYA"\n  Just cuta <- Gtk.actionGroupGetAction agr "CUTA"\n  let copycutdeletea = [copya, cuta, deletea]\n  mapM_ (`Gtk.actionSetSensitive` b) copycutdeletea\n\n-- |\ntogglePaste :: Gtk.UIManager -> Bool -> IO ()\ntogglePaste ui b = do\n  agr <-\n    Gtk.uiManagerGetActionGroups ui >>= \\case\n      [] -> error "No action group?"\n      y : _ -> return y\n  Just pastea <- Gtk.actionGroupGetAction agr "PASTEA"\n  Gtk.actionSetSensitive pastea b\n\n-- |\nchangeStrokeColor :: PenColor -> BBoxed Stroke -> BBoxed Stroke\nchangeStrokeColor pcolor str =\n  let Just cname = Map.lookup pcolor penColorNameMap\n      strsmpl = bbxed_content str\n   in str {bbxed_content = set color cname strsmpl}\n\n-- |\nchangeStrokeWidth :: Double -> BBoxed Stroke -> BBoxed Stroke\nchangeStrokeWidth pwidth str =\n  let nstrsmpl = case bbxed_content str of\n        Stroke t c _w d -> Stroke t c pwidth d\n        VWStroke t c d -> Stroke t c pwidth (map (\\(x, y, _z) -> x :!: y) d)\n   in -- Img b w h -> Img b w h\n      str {bbxed_content = nstrsmpl}\n\n-- |\nchangeItemStrokeWidth :: Double -> RItem -> RItem\nchangeItemStrokeWidth pwidth (RItemStroke strk) = RItemStroke (changeStrokeWidth pwidth strk)\nchangeItemStrokeWidth _ r = r\n\n-- |\nchangeItemStrokeColor :: PenColor -> RItem -> RItem\nchangeItemStrokeColor pcolor (RItemStroke strk) = RItemStroke (changeStrokeColor pcolor strk)\nchangeItemStrokeColor _ r = r\n\n-- |\nnewtype CmpBBox a = CmpBBox {unCmpBBox :: a}\n\n-- deriving Show\ninstance (GetBBoxable a) => Eq (CmpBBox a) where\n  CmpBBox s1 == CmpBBox s2 = getBBox s1 == getBBox s2\n\n-- |\nisSame :: A.Diff a -> Bool\nisSame (A.Both _ _) = True\nisSame _ = False\n\n-- |\nseparateFS :: [A.Diff a] -> ([a], [a])\nseparateFS = foldr f ([], [])\n  where\n    f (A.First x) (fs, ss) = (x : fs, ss)\n    f (A.Second x) (fs, ss) = (fs, x : ss)\n    f (A.Both _ _) (fs, ss) = (fs, ss)\n\n-- |\ngetDiffBBox :: (GetBBoxable a) => [a] -> [a] -> [A.Diff a]\ngetDiffBBox lst1 lst2 =\n  let -- nlst1 = fmap CmpBBox lst1\n      -- nlst2 = fmap CmpBBox lst2\n      diffresult = A.getDiffBy ((==) `F.on` CmpBBox) lst1 lst2\n   in diffresult -- map (\\(x,y)->(x,unCmpBBox y)) diffresult\n\n-- |\ncheckIfHandleGrasped :: BBox -> (Double, Double) -> Maybe Handle\ncheckIfHandleGrasped (BBox (ulx, uly) (lrx, lry)) (x, y)\n  | isPointInBBox (BBox (ulx - 5, uly - 5) (ulx + 5, uly + 5)) (x, y) = Just HandleTL\n  | isPointInBBox (BBox (lrx - 5, uly - 5) (lrx + 5, uly + 5)) (x, y) = Just HandleTR\n  | isPointInBBox (BBox (ulx - 5, lry - 5) (ulx + 5, lry + 5)) (x, y) = Just HandleBL\n  | isPointInBBox (BBox (lrx - 5, lry - 5) (lrx + 5, lry + 5)) (x, y) = Just HandleBR\n  | isPointInBBox (BBox (0.5 * (ulx + lrx) - 5, uly - 5) (0.5 * (ulx + lrx) + 5, uly + 5)) (x, y) = Just HandleTM\n  | isPointInBBox (BBox (0.5 * (ulx + lrx) - 5, lry - 5) (0.5 * (ulx + lrx) + 5, lry + 5)) (x, y) = Just HandleBM\n  | isPointInBBox (BBox (ulx - 5, 0.5 * (uly + lry) - 5) (ulx + 5, 0.5 * (uly + lry) + 5)) (x, y) = Just HandleML\n  | isPointInBBox (BBox (lrx - 5, 0.5 * (uly + lry) - 5) (lrx + 5, 0.5 * (uly + lry) + 5)) (x, y) = Just HandleMR\n  | otherwise = Nothing\n\ngetNewBBoxFromHandlePos :: Handle -> BBox -> (Double, Double) -> BBox\ngetNewBBoxFromHandlePos handle (BBox (ox1, oy1) (ox2, oy2)) (x, y) =\n  case handle of\n    HandleTL -> BBox (x, y) (ox2, oy2)\n    HandleTR -> BBox (ox1, y) (x, oy2)\n    HandleBL -> BBox (x, oy1) (ox2, y)\n    HandleBR -> BBox (ox1, oy1) (x, y)\n    HandleTM -> BBox (ox1, y) (ox2, oy2)\n    HandleBM -> BBox (ox1, oy1) (ox2, y)\n    HandleML -> BBox (x, oy1) (ox2, oy2)\n    HandleMR -> BBox (ox1, oy1) (x, oy2)\n\n-- |\nhitLassoStroke :: Seq (Double, Double) -> BBoxed Stroke -> Bool\nhitLassoStroke lst = all (hitLassoPoint lst) . getXYtuples . bbxed_content\n\n-- |\nhitLassoItem :: Seq (Double, Double) -> RItem -> Bool\nhitLassoItem lst (RItemStroke strk) = hitLassoStroke lst strk\nhitLassoItem lst (RItemImage img _) =\n  hitLassoPoint lst (x1, y1) && hitLassoPoint lst (x1, y2)\n    && hitLassoPoint lst (x2, y1)\n    && hitLassoPoint lst (x2, y2)\n  where\n    BBox (x1, y1) (x2, y2) = getBBox img\nhitLassoItem lst (RItemSVG svg _) =\n  hitLassoPoint lst (x1, y1) && hitLassoPoint lst (x1, y2)\n    && hitLassoPoint lst (x2, y1)\n    && hitLassoPoint lst (x2, y2)\n  where\n    BBox (x1, y1) (x2, y2) = getBBox svg\nhitLassoItem lst (RItemLink lnk _) =\n  hitLassoPoint lst (x1, y1) && hitLassoPoint lst (x1, y2)\n    && hitLassoPoint lst (x2, y1)\n    && hitLassoPoint lst (x2, y2)\n  where\n    BBox (x1, y1) (x2, y2) = getBBox lnk\nhitLassoItem lst (RItemAnchor anc _) =\n  hitLassoPoint lst (x1, y1) && hitLassoPoint lst (x1, y2)\n    && hitLassoPoint lst (x2, y1)\n    && hitLassoPoint lst (x2, y2)\n  where\n    BBox (x1, y1) (x2, y2) = getBBox anc\n\ntype TempSelection = TempRender [RItem]\n\ndata ItmsNImg = ItmsNImg\n  { itmNimg_itms :: [RItem],\n    itmNimg_mbbx :: Maybe BBox,\n    imageSurface :: Cairo.Surface\n  }\n\n-- |\nmkItmsNImg :: RenderCache -> CanvasId -> Page SelectMode -> IO ItmsNImg\nmkItmsNImg cache cid tpage = do\n  let itms = getSelectedItms tpage\n      drawselection = mapM_ (renderRItem cache cid) itms\n      Dim cw ch = view gdimension tpage\n      mbbox = case getULBBoxFromSelected tpage of\n        Middle bbox -> Just bbox\n        _ -> Nothing\n  sfc <- Cairo.createImageSurface Cairo.FormatARGB32 (floor cw) (floor ch)\n  Cairo.renderWith sfc $ do\n    Cairo.setSourceRGBA 1 1 1 0\n    Cairo.rectangle 0 0 cw ch\n    Cairo.fill\n    Cairo.setSourceRGBA 0 0 0 1\n    drawselection\n  return $ ItmsNImg itms mbbox sfc\n\n-- |\ndrawTempSelectImage ::\n  CanvasGeometry ->\n  TempRender ItmsNImg ->\n  -- | transformation matrix\n  Cairo.Matrix ->\n  Cairo.Render ()\ndrawTempSelectImage geometry tempselection xformmat = do\n  let sfc = imageSurface (tempInfo tempselection)\n      CanvasDimension (Dim cw ch) = canvasDim geometry\n      invxformmat = invert xformmat\n      newvbbox =\n        BBox\n          (transformPoint invxformmat (0, 0))\n          (transformPoint invxformmat (cw, ch))\n      mbbox = itmNimg_mbbx (tempInfo tempselection)\n      newmbbox = case unIntersect (Intersect (Middle newvbbox) `mappend` fromMaybe mbbox) of\n        Middle bbox -> Just bbox\n        _ -> Just newvbbox\n  Cairo.setMatrix xformmat\n  clipBBox newmbbox\n  Cairo.setSourceSurface sfc 0 0\n  Cairo.setOperator Cairo.OperatorOver\n  Cairo.paint\n\n-- |\ngetNewCoordTime ::\n  ((Double, Double), UTCTime) ->\n  (Double, Double) ->\n  IO (Bool, ((Double, Double), UTCTime))\ngetNewCoordTime (prev, otime) (x, y) = do\n  ntime <- getCurrentTime\n  let dtime = diffUTCTime ntime otime\n      willUpdate = dtime > dtimeBound\n      (nprev, nntime) =\n        if dtime > dtimeBound\n          then ((x, y), ntime)\n          else (prev, otime)\n  return (willUpdate, (nprev, nntime))\n\n-- |\nadjustItemPosition4Paste :: CanvasGeometry -> PageNum -> [RItem] -> [RItem]\nadjustItemPosition4Paste geometry pgn itms =\n  case bbox of\n    Middle (BBox (xs0, ys0) _) -> fmap (changeItemBy (offsetFunc (x0 - xs0, y0 - ys0))) itms\n    _ -> itms\n  where\n    bbox = bbox4All itms\n    ViewPortBBox (BBox (xv0, yv0) _) = canvasViewPort geometry\n    (x0, y0) =\n      maybe\n        (0, 0)\n        (\\(pgn\', norigin) -> if pgn == pgn\' then unPageCoord norigin else (0, 0))\n        $ desktop2Page geometry (DeskCoord (xv0, yv0))\n'