b'#include "stdafx.h"\n#include "../AssetsTools/AssetsReplacer.h"\n#include "InternalAssetsReplacer.h"\n\nGenericReplacer::~GenericReplacer()\n{\n}\n\n#pragma region AssetsReplacerBase\nAssetsEntryReplacerBase::AssetsEntryReplacerBase()\n{\n\tthis->fileID = 0;\n\tthis->pathID = 0;\n\tthis->classID = 0;\n\tthis->monoScriptIndex = 0;\n}\nAssetsEntryReplacerBase::AssetsEntryReplacerBase(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex)\n{\n\tthis->fileID = fileID;\n\tthis->pathID = pathID;\n\tthis->classID = classID;\n\tthis->monoScriptIndex = monoScriptIndex;\n}\nuint32_t AssetsEntryReplacerBase::GetFileID() const {return this->fileID;}\nQWORD AssetsEntryReplacerBase::GetPathID() const {return this->pathID;}\nint AssetsEntryReplacerBase::GetClassID() const {return this->classID;}\nuint16_t AssetsEntryReplacerBase::GetMonoScriptID() const {return this->monoScriptIndex;}\nvoid AssetsEntryReplacerBase::SetMonoScriptID(uint16_t scriptID) {this->monoScriptIndex = scriptID;}\nbool AssetsEntryReplacerBase::GetPropertiesHash(Hash128 &propertiesHash) { propertiesHash = Hash128(); return false; }\nbool AssetsEntryReplacerBase::SetPropertiesHash(const Hash128 &propertiesHash) { return false; }\nbool AssetsEntryReplacerBase::GetScriptIDHash(Hash128 &scriptIDHash) { scriptIDHash = Hash128(); return false; }\nbool AssetsEntryReplacerBase::SetScriptIDHash(const Hash128 &scriptIDHash) { return false; }\nbool AssetsEntryReplacerBase::GetTypeInfo(std::shared_ptr<ClassDatabaseFile> &pFile, ClassDatabaseType *&pType)\n{\n\tpFile.reset(); pType = nullptr;\n\treturn false;\n}\nbool AssetsEntryReplacerBase::SetTypeInfo(std::shared_ptr<ClassDatabaseFile> pFile, ClassDatabaseType *pType)\n{\n\treturn false;\n}\n\nQWORD AssetsEntryReplacerBase::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n{\n\tuint8_t fileVersion = 1;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\tuint32_t writeFileID = 0;\n\tpos += pWriter->Write(pos, 4, &writeFileID);\n\tpos += pWriter->Write(pos, 8, &this->pathID);\n\tpos += pWriter->Write(pos, 4, &this->classID);\n\tpos += pWriter->Write(pos, 2, &this->monoScriptIndex);\n\n\tuint32_t preloadDepCount = (this->preloadDependencies.size() > 0xFFFFFFFFULL) ? 0xFFFFFFFF : (uint32_t)this->preloadDependencies.size();\n\tpos += pWriter->Write(pos, 4, &preloadDepCount);\n\tfor (uint32_t i = 0; i < preloadDepCount; i++)\n\t{\n\t\tpos += pWriter->Write(pos, 4, &this->preloadDependencies[i].fileID);\n\t\tpos += pWriter->Write(pos, 8, &this->preloadDependencies[i].pathID);\n\t}\n\treturn pos;\n}\nbool AssetsEntryReplacerBase::GetPreloadDependencies(const AssetPPtr *&pPreloadList, size_t &preloadListSize)\n{\n\tpreloadListSize = this->preloadDependencies.size();\n\tpPreloadList = this->preloadDependencies.data();\n\treturn true;\n}\nbool AssetsEntryReplacerBase::SetPreloadDependencies(const AssetPPtr *pPreloadList, size_t preloadListSize)\n{\n\tthis->preloadDependencies.clear();\n\tthis->preloadDependencies.resize(preloadListSize);\n\tmemcpy(this->preloadDependencies.data(), pPreloadList, sizeof(AssetPPtr) * preloadListSize);\n\treturn true;\n}\nbool AssetsEntryReplacerBase::AddPreloadDependency(const AssetPPtr &dependency)\n{\n\tthis->preloadDependencies.push_back(dependency);\n\treturn true;\n}\n#pragma endregion\n\n#pragma region AssetModifierBase\nAssetEntryModifierBase::AssetEntryModifierBase()\n{\n\tthis->hasPropertiesHash = false;\n\tthis->hasScriptIDHash = false;\n\tthis->pClassFile = nullptr;\n\tthis->pClassType = nullptr;\n}\nAssetEntryModifierBase::AssetEntryModifierBase(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex)\n\t: AssetsEntryReplacerBase(fileID, pathID, classID, monoScriptIndex)\n{\n\tthis->hasPropertiesHash = false;\n\tthis->hasScriptIDHash = false;\n\tthis->pClassFile = nullptr;\n\tthis->pClassType = nullptr;\n}\nAssetEntryModifierBase::~AssetEntryModifierBase()\n{}\nbool AssetEntryModifierBase::GetPropertiesHash(Hash128 &propertiesHash)\n{\n\tpropertiesHash = this->hasPropertiesHash ? this->propertiesHash : Hash128();\n\treturn this->hasPropertiesHash;\n}\nbool AssetEntryModifierBase::SetPropertiesHash(const Hash128 &propertiesHash)\n{\n\tthis->propertiesHash = propertiesHash;\n\tthis->hasPropertiesHash = true;\n\treturn true;\n}\nbool AssetEntryModifierBase::GetScriptIDHash(Hash128 &scriptIDHash)\n{\n\tscriptIDHash = this->hasScriptIDHash ? this->scriptIDHash : Hash128();\n\treturn this->hasScriptIDHash;\n}\nbool AssetEntryModifierBase::SetScriptIDHash(const Hash128 &scriptIDHash)\n{\n\tthis->scriptIDHash = scriptIDHash;\n\tthis->hasScriptIDHash = true;\n\treturn true;\n}\nbool AssetEntryModifierBase::SetTypeInfo(std::shared_ptr<ClassDatabaseFile> pFile, ClassDatabaseType *pType)\n{\n\tif ((pFile != nullptr) ^ (pType != nullptr)) //Exactly one of the two parameters is null, which is not allowed.\n\t\treturn false;\n\tthis->pClassFile = pFile;\n\tthis->pClassType = pType;\n\treturn true;\n}\nbool AssetEntryModifierBase::GetTypeInfo(std::shared_ptr<ClassDatabaseFile> &pFile, ClassDatabaseType *&pType)\n{\n\tif (this->pClassFile && this->pClassType)\n\t{\n\t\tpFile = this->pClassFile;\n\t\tpType = this->pClassType;\n\t\treturn true;\n\t}\n\tpFile.reset();\n\tpType = nullptr;\n\treturn false;\n}\nQWORD AssetEntryModifierBase::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n{\n\tpos = AssetsEntryReplacerBase::WriteReplacer(pos, pWriter);\n\tuint8_t fileVersion = 0;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\n\tuint8_t hasPropertiesHash = this->hasPropertiesHash ? 1 : 0;\n\tpos += pWriter->Write(pos, 1, &hasPropertiesHash);\n\tif (hasPropertiesHash)\n\t\tpos += pWriter->Write(pos, 16, this->propertiesHash.bValue);\n\n\tuint8_t hasScriptIDHash = this->hasScriptIDHash ? 1 : 0;\n\tpos += pWriter->Write(pos, 1, &hasScriptIDHash);\n\tif (hasScriptIDHash)\n\t\tpos += pWriter->Write(pos, 16, this->scriptIDHash.bValue);\n\n\tuint8_t hasTypeInfo = 0;\n\tif (this->pClassFile && this->pClassType)\n\t{\n\t\thasTypeInfo = 1;\n\t\tClassDatabaseFile tempFile;\n\t\tClassDatabaseFile *pWriteFile = this->pClassFile.get();\n\t\tif (this->pClassFile->classes.size() > 1)\n\t\t{\n\t\t\tif (tempFile.InsertFrom(this->pClassFile.get(), this->pClassType) && tempFile.classes.size() == 1)\n\t\t\t\tpWriteFile = &tempFile;\n\t\t\telse\n\t\t\t\thasTypeInfo = 0;\n\t\t}\n\t\tpos += pWriter->Write(pos, 1, &hasTypeInfo);\n\t\tif (hasTypeInfo)\n\t\t\tpos = pWriteFile->Write(pWriter, pos);\n\t}\n\telse\n\t\tpos += pWriter->Write(pos, 1, &hasTypeInfo);\n\treturn pos;\n}\n#pragma endregion\n\n#pragma region AssetRemover\nAssetRemover::AssetRemover(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex)\n\t: AssetsEntryReplacerBase(fileID, pathID, classID, monoScriptIndex)\n{\n}\nAssetRemover::~AssetRemover()\n{\n}\nAssetsReplacementType AssetRemover::GetType() const\n{\n\treturn AssetsReplacement_Remove;\n}\n\n\nQWORD AssetRemover::GetSize() const{return 0;}\nQWORD AssetRemover::Write(QWORD pos, IAssetsWriter *pWriter){return pos;}\nQWORD AssetRemover::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n{\n\tuint16_t replacerType = AssetsReplacer_AssetRemover;\n\tpos += pWriter->Write(pos, 2, &replacerType);\n\tuint8_t fileVersion = 1;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\tpos = AssetsEntryReplacerBase::WriteReplacer(pos, pWriter);\n\treturn pos;\n}\n#pragma endregion\n#pragma region AssetModifierFromReader\nAssetModifierFromReader::AssetModifierFromReader()\n{\n\tthis->pReader = nullptr;\n\tthis->size = 0;\n\tthis->readerPos = 0;\n\tthis->copyBufferLen = 0;\n\tthis->freeReader = false;\n}\nAssetModifierFromReader::AssetModifierFromReader(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex, \n\tIAssetsReader *pReader, QWORD size, QWORD readerPos, \n\tsize_t copyBufferLen, bool freeReader,\n\tstd::shared_ptr<IAssetsReader> ref_pReader)\n\t: AssetEntryModifierBase(fileID, pathID, classID, monoScriptIndex)\n{\n\tthis->pReader = pReader;\n\tthis->size = size;\n\tthis->readerPos = readerPos;\n\tthis->copyBufferLen = copyBufferLen;\n\tthis->freeReader = freeReader;\n\tthis->ref_pReader = std::move(ref_pReader);\n}\nAssetModifierFromReader::~AssetModifierFromReader()\n{\n\tif (this->freeReader && this->pReader)\n\t{\n\t\tFree_AssetsReader(this->pReader);\n\t\tthis->pReader = nullptr;\n\t}\n}\nAssetsReplacementType AssetModifierFromReader::GetType() const\n{\n\treturn AssetsReplacement_AddOrModify;\n}\n\nQWORD AssetModifierFromReader::GetSize() const{return size;}\nQWORD AssetModifierFromReader::Write(QWORD pos, IAssetsWriter *pWriter)\n{\n\tif (size == 0 || pReader == nullptr)\n\t\treturn pos;\n\tuint8_t stackBuffer[512];\n\tvoid *copyBuffer = stackBuffer;\n\tsize_t curBufferLen = 512;\n\tif (copyBufferLen > 512)\n\t{\n\t\tcopyBuffer = malloc(copyBufferLen);\n\t\tif (copyBuffer == NULL)\n\t\t\tcopyBuffer = stackBuffer;\n\t\telse\n\t\t\tcurBufferLen = copyBufferLen;\n\t}\n\tQWORD remainingBytes = size; QWORD curReaderPos = readerPos;\n\twhile (remainingBytes > curBufferLen)\n\t{\t\t\n\t\tQWORD curRead = pReader->Read(curReaderPos, curBufferLen, copyBuffer);\n\t\tif (!curRead)\n\t\t{\n\t\t\tremainingBytes = 0;\n\t\t\tbreak;\n\t\t}\n\t\tQWORD curWritten = pWriter->Write(pos, curRead, copyBuffer);\n\t\tremainingBytes -= curWritten;\n\t\tcurReaderPos += curWritten;\n\t\tpos += curWritten;\n\t\tif (curWritten == 0)\n\t\t\tbreak;\n\t}\n\tif (remainingBytes > 0)\n\t{\n\t\tQWORD curRead = pReader->Read(curReaderPos, remainingBytes, copyBuffer);\n\t\tQWORD curWritten = pWriter->Write(pos, curRead, copyBuffer);\n\t\tpos += curWritten;\n\t}\n\tif (curBufferLen > 512)\n\t\tfree(copyBuffer);\n\treturn pos;\n}\nQWORD AssetModifierFromReader::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n{\n\t//store it the as a modifier from memory (no difference)\n\tuint16_t replacerType = AssetsReplacer_AssetModifierFromMemory;\n\tpos += pWriter->Write(pos, 2, &replacerType);\n\tuint8_t fileVersion = 1;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\tpos = AssetEntryModifierBase::WriteReplacer(pos, pWriter);\n\tpos += pWriter->Write(pos, 8, &this->size);\n\tpos = Write(pos, pWriter);\n\treturn pos;\n}\n#pragma endregion\n#pragma region AssetModifierFromMemory\nAssetModifierFromMemory::AssetModifierFromMemory(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex,\n\tvoid *buffer, size_t size, cbFreeMemoryResource freeMemCallback)\n\t: AssetEntryModifierBase(fileID, pathID, classID, monoScriptIndex)\n{\n\tthis->buffer = buffer;\n\tthis->size = size;\n\tthis->freeMemCallback = freeMemCallback;\n}\nAssetModifierFromMemory::~AssetModifierFromMemory()\n{\n\tif (freeMemCallback != NULL)\n\t\tfreeMemCallback(this->buffer);\n}\nAssetsReplacementType AssetModifierFromMemory::GetType() const\n{\n\treturn AssetsReplacement_AddOrModify;\n}\n\nQWORD AssetModifierFromMemory::GetSize() const{return size;}\nQWORD AssetModifierFromMemory::Write(QWORD pos, IAssetsWriter *pWriter)\n{\n\tif (!size)\n\t\treturn pos;\n\treturn pos + pWriter->Write(pos, size, buffer);\n}\nQWORD AssetModifierFromMemory::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n{\n\tuint16_t replacerType = AssetsReplacer_AssetModifierFromMemory;\n\tpos += pWriter->Write(pos, 2, &replacerType);\n\tuint8_t fileVersion = 1;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\tpos = AssetEntryModifierBase::WriteReplacer(pos, pWriter);\n\tQWORD ullSize = this->size;\n\tpos += pWriter->Write(pos, 8, &ullSize);\n\tpos = Write(pos, pWriter);\n\treturn pos;\n}\n#pragma endregion\n#pragma region AssetModifierFromFile\n\nAssetModifierFromFile::AssetModifierFromFile(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex,\n\tFILE *pFile, QWORD offs, QWORD size, size_t copyBufferLen, bool freeFile)\n\t: AssetEntryModifierBase(fileID, pathID, classID, monoScriptIndex)\n{\n\tthis->pFile = pFile;\n\tthis->offs = offs;\n\tthis->size = size;\n\tthis->copyBufferLen = copyBufferLen;\n\tthis->freeFile = freeFile;\n}\nAssetModifierFromFile::~AssetModifierFromFile()\n{\n\tif (freeFile)\n\t\tfclose(this->pFile);\n}\nAssetsReplacementType AssetModifierFromFile::GetType() const\n{\n\treturn AssetsReplacement_AddOrModify;\n}\n\nQWORD AssetModifierFromFile::GetSize() const{return size;}\nQWORD AssetModifierFromFile::Write(QWORD pos, IAssetsWriter *pWriter)\n{\n\tif (!size)\n\t\treturn pos;\n\tuint8_t stackBuffer[256];\n\tvoid *copyBuffer = stackBuffer;\n\tsize_t curBufferLen = 256;\n\tif (copyBufferLen > 256)\n\t{\n\t\tcopyBuffer = malloc(copyBufferLen);\n\t\tif (copyBuffer == NULL)\n\t\t\tcopyBuffer = stackBuffer;\n\t\telse\n\t\t\tcurBufferLen = copyBufferLen;\n\t}\n\tQWORD remainingBytes = size; fseek(pFile, (long)this->offs, SEEK_SET);\n\twhile (remainingBytes > curBufferLen)\n\t{\n\t\tfread(copyBuffer, curBufferLen, 1, pFile);\n\t\tremainingBytes -= curBufferLen;\n\t\tpWriter->Write(pos, curBufferLen, copyBuffer);\n\t\tpos += curBufferLen;\n\t}\n\tif (remainingBytes > 0)\n\t{\n\t\tfread(copyBuffer, (size_t)remainingBytes, 1, pFile);\n\t\tpWriter->Write(pos, remainingBytes, copyBuffer);\n\t\tpos += remainingBytes;\n\t}\n\tif (curBufferLen > 256)\n\t\tfree(copyBuffer);\n\treturn pos;\n}\nQWORD AssetModifierFromFile::WriteReplacer(QWORD pos, IAssetsWriter *pWriter)\n{\n\t//store it the as a modifier from memory (no difference)\n\tuint16_t replacerType = AssetsReplacer_AssetModifierFromMemory;\n\tpos += pWriter->Write(pos, 2, &replacerType);\n\tuint8_t fileVersion = 1;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\tpos = AssetEntryModifierBase::WriteReplacer(pos, pWriter);\n\tpos += pWriter->Write(pos, 8, &this->size);\n\tpos = Write(pos, pWriter);\n\treturn pos;\n}\n#pragma endregion\n#pragma region AssetsDependenciesReplacerImpl\nAssetsDependenciesReplacerImpl::AssetsDependenciesReplacerImpl(uint32_t fileID, std::vector<AssetsFileDependency> _dependencies)\n\t: fileID(fileID), dependencies(std::move(_dependencies))\n{}\nAssetsReplacementType AssetsDependenciesReplacerImpl::GetType() const\n{\n\treturn AssetsReplacement_Dependencies;\n}\nuint32_t AssetsDependenciesReplacerImpl::GetFileID() const\n{\n\treturn fileID;\n}\nconst std::vector<AssetsFileDependency>& AssetsDependenciesReplacerImpl::GetDependencies() const\n{\n\treturn dependencies;\n}\nQWORD AssetsDependenciesReplacerImpl::WriteReplacer(QWORD pos, IAssetsWriter* pWriter)\n{\n\t//store it the as a modifier from memory (no difference)\n\tuint16_t replacerType = AssetsReplacer_Dependencies;\n\tpos += pWriter->Write(pos, 2, &replacerType);\n\tuint8_t fileVersion = 0;\n\tpos += pWriter->Write(pos, 1, &fileVersion);\n\tuint32_t writeFileID = 0;\n\tpos += pWriter->Write(pos, 4, &writeFileID);\n\n\tuint32_t dependenciesCount = (uint32_t)dependencies.size();\n\tpos += pWriter->Write(pos, 4, &dependenciesCount);\n\tfor (uint32_t i = 0; i < dependenciesCount; ++i)\n\t{\n\t\tpos = dependencies[i].Write(pos, pWriter, 13, false);\n\t}\n\treturn pos;\n}\n#pragma endregion\n\nvoid FreeMemoryResource_ReadAssetsReplacer(void *pResource)\n{\n\tif (pResource)\n\t\tfree(pResource);\n}\nstatic AssetsReplacer *ReadAssetsEntryReplacer(QWORD& pos, IAssetsReader* pReader, std::shared_ptr<IAssetsReader> ref_pReader, bool prefReplacerInMemory,\n\tuint16_t replacerType)\n{\n\tuint8_t replacerFileVersion = 0;\n\tpos += pReader->Read(pos, 1, &replacerFileVersion);\n\n\tuint8_t replacerBaseVersion = 0;\n\tif (replacerFileVersion >= 1)\n\t{\n\t\t//See AssetsReplacerBase::WriteReplacer\n\t\tpos += pReader->Read(pos, 1, &replacerBaseVersion);\n\t\tif (replacerBaseVersion > 1)\n\t\t\treturn NULL;\n\t}\n\tuint32_t fileID = 0; QWORD pathID = 0; int classID = 0; uint16_t monoScriptIndex = 0;\n\tstd::vector<AssetPPtr> preloadDependencies;\n\tpos += pReader->Read(pos, 4, &fileID);\n\tpos += pReader->Read(pos, 8, &pathID);\n\tpos += pReader->Read(pos, 4, &classID);\n\tpos += pReader->Read(pos, 2, &monoScriptIndex);\n\tif (replacerBaseVersion >= 1)\n\t{\n\t\tuint32_t count = 0;\n\t\tpos += pReader->Read(pos, 4, &count);\n\t\tpreloadDependencies.resize(count);\n\t\tfor (uint32_t i = 0; i < count; i++)\n\t\t{\n\t\t\tpos += pReader->Read(pos, 4, &preloadDependencies[i].fileID);\n\t\t\tpos += pReader->Read(pos, 8, &preloadDependencies[i].pathID);\n\t\t}\n\t}\n\tswitch (replacerType)\n\t{\n\tcase AssetsReplacer_AssetRemover:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\t\t\tAssetsEntryReplacer *pReplacer = new AssetRemover(fileID, pathID, classID, monoScriptIndex);\n\t\t\tpReplacer->SetPreloadDependencies(preloadDependencies.data(), (uint32_t)preloadDependencies.size());\n\t\t\treturn pReplacer;\n\t\t}\n\tcase AssetsReplacer_AssetModifierFromReader:\n\tcase AssetsReplacer_AssetModifierFromMemory:\n\tcase AssetsReplacer_AssetModifierFromFile:\n\t\t{\n\t\t\tif (replacerFileVersion > 1)\n\t\t\t\treturn NULL;\n\n\t\t\tHash128 propertiesHash = Hash128(); uint8_t hasPropertiesHash = 0;\n\t\t\tHash128 scriptIDHash = Hash128(); uint8_t hasScriptIDHash = 0;\n\t\t\tuint8_t hasTypeInfo = 0;\n\t\t\tstd::shared_ptr<ClassDatabaseFile> pClassFile; ClassDatabaseType *pClassType = nullptr;\n\t\t\tif (replacerFileVersion >= 1)\n\t\t\t{\n\t\t\t\t//See AssetModifierBase::WriteReplacer\n\t\t\t\tuint8_t modifierBaseVersion = 0;\n\t\t\t\tpos += pReader->Read(pos, 1, &modifierBaseVersion);\n\t\t\t\tif (modifierBaseVersion > 0)\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tpos += pReader->Read(pos, 1, &hasPropertiesHash);\n\t\t\t\tif (hasPropertiesHash)\n\t\t\t\t\tpos += pReader->Read(pos, 16, propertiesHash.bValue);\n\n\t\t\t\tpos += pReader->Read(pos, 1, &hasScriptIDHash);\n\t\t\t\tif (hasScriptIDHash)\n\t\t\t\t\tpos += pReader->Read(pos, 16, scriptIDHash.bValue);\n\t\t\t\t\n\t\t\t\tpos += pReader->Read(pos, 1, &hasTypeInfo);\n\t\t\t\tif (hasTypeInfo)\n\t\t\t\t{\n\t\t\t\t\tpClassFile = std::make_shared<ClassDatabaseFile>();\n\t\t\t\t\tpos = pClassFile->Read(pReader, pos);\n\t\t\t\t\tif (pClassFile->IsValid() && pClassFile->classes.size() == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tpClassType = &pClassFile->classes[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpClassFile.reset();\n\t\t\t\t\t\thasTypeInfo = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQWORD size = 0;\n\t\t\tpos += pReader->Read(pos, 8, &size);\n\t\t\tAssetsEntryReplacer *pReplacer = NULL;\n\t\t\tif (prefReplacerInMemory)\n\t\t\t{\n\t\t\t\tvoid *pMem = malloc(size);\n\t\t\t\tif (pMem)\n\t\t\t\t{\n\t\t\t\t\tQWORD actualRead = pReader->Read(pos, size, pMem);\n\t\t\t\t\tmemset(&((uint8_t*)pMem)[actualRead], 0, size - actualRead);\n\t\t\t\t\tpReplacer = new AssetModifierFromMemory(fileID, pathID, classID, monoScriptIndex, pMem, size, \n\t\t\t\t\t\tFreeMemoryResource_ReadAssetsReplacer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pReplacer)\n\t\t\t\tpReplacer =\n\t\t\t\t\tnew AssetModifierFromReader(fileID, pathID, classID, monoScriptIndex, pReader, size, pos, 0, false, ref_pReader);\n\t\t\tif (hasPropertiesHash)\n\t\t\t\tpReplacer->SetPropertiesHash(propertiesHash);\n\t\t\tif (hasScriptIDHash)\n\t\t\t\tpReplacer->SetScriptIDHash(scriptIDHash);\n\t\t\tif (pClassFile && pClassType)\n\t\t\t\tpReplacer->SetTypeInfo(std::move(pClassFile), pClassType);\n\t\t\tpReplacer->SetPreloadDependencies(preloadDependencies.data(), (uint32_t)preloadDependencies.size());\n\t\t\tpos += size;\n\t\t\treturn pReplacer;\n\t\t}\n\t}\n\treturn nullptr;\n}\nstatic AssetsReplacer *ReadAssetsReplacer(QWORD &pos, IAssetsReader *pReader, std::shared_ptr<IAssetsReader> ref_pReader, bool prefReplacerInMemory)\n{\n\tuint16_t replacerType = 0xFFFF;\n\tpos += pReader->Read(pos, 2, &replacerType);\n\tswitch (replacerType)\n\t{\n\tcase AssetsReplacer_AssetRemover:\n\tcase AssetsReplacer_AssetModifierFromReader:\n\tcase AssetsReplacer_AssetModifierFromMemory:\n\tcase AssetsReplacer_AssetModifierFromFile:\n\t\treturn ReadAssetsEntryReplacer(pos, pReader, std::move(ref_pReader), prefReplacerInMemory, replacerType);\n\tcase AssetsReplacer_Dependencies:\n\t\t{\n\t\t\tuint8_t fileVersion = 0;\n\t\t\tpos += pReader->Read(pos, 1, &fileVersion);\n\t\t\tif (fileVersion > 0)\n\t\t\t\treturn nullptr; //Unsupported\n\t\t\tuint32_t fileID = 0;\n\t\t\tpos += pReader->Read(pos, 4, &fileID);\n\n\t\t\tuint32_t dependenciesCount = 0;\n\t\t\tpos += pReader->Read(pos, 4, &dependenciesCount);\n\t\t\tstd::vector<AssetsFileDependency> dependencies(dependenciesCount);\n\t\t\tfor (uint32_t i = 0; i < dependenciesCount; ++i)\n\t\t\t{\n\t\t\t\tpos = dependencies[i].Read(pos, pReader, 13, false);\n\t\t\t}\n\t\t\treturn new AssetsDependenciesReplacerImpl(fileID, std::move(dependencies));\n\t\t}\n\t}\n\treturn nullptr;\n}\nASSETSTOOLS_API AssetsReplacer *ReadAssetsReplacer(QWORD &pos, IAssetsReader *pReader, bool prefReplacerInMemory)\n{\n\treturn ReadAssetsReplacer(pos, pReader, nullptr, prefReplacerInMemory);\n}\nASSETSTOOLS_API AssetsReplacer *ReadAssetsReplacer(QWORD &pos, std::shared_ptr<IAssetsReader> pReader, bool prefReplacerInMemory)\n{\n\tIAssetsReader *_pReader = pReader.get();\n\treturn ReadAssetsReplacer(pos, _pReader, std::move(pReader), prefReplacerInMemory);\n}\nASSETSTOOLS_API AssetsEntryReplacer *MakeAssetRemover(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex)\n{\n\treturn new AssetRemover(fileID, pathID, classID, monoScriptIndex);\n}\n\nASSETSTOOLS_API AssetsEntryReplacer *MakeAssetModifierFromReader(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex, \n\t\tIAssetsReader *pReader, QWORD size, QWORD readerPos, \n\t\tsize_t copyBufferLen, bool freeReader)\n{\n\treturn new AssetModifierFromReader(fileID, pathID, classID, monoScriptIndex, pReader, size, readerPos, copyBufferLen, freeReader);\n}\nASSETSTOOLS_API AssetsEntryReplacer *MakeAssetModifierFromMemory(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex, \n\t\tvoid *buffer, size_t size, cbFreeMemoryResource freeResourceCallback)\n{\n\treturn new AssetModifierFromMemory(fileID, pathID, classID, monoScriptIndex, buffer, size, freeResourceCallback);\n}\nASSETSTOOLS_API AssetsEntryReplacer *MakeAssetModifierFromFile(uint32_t fileID, QWORD pathID, int classID, uint16_t monoScriptIndex,\n\t\tFILE *pFile, QWORD offs, QWORD size, size_t copyBufferLen, bool freeFile)\n{\n\treturn new AssetModifierFromFile(fileID, pathID, classID, monoScriptIndex, pFile, offs, size, copyBufferLen, freeFile);\n}\nASSETSTOOLS_API AssetsDependenciesReplacer *MakeAssetsDependenciesReplacer(uint32_t fileID, std::vector<AssetsFileDependency> dependencies)\n{\n\treturn new AssetsDependenciesReplacerImpl(fileID, std::move(dependencies));\n}\nASSETSTOOLS_API void FreeAssetsReplacer(AssetsReplacer *pReplacer)\n{\n\tdelete pReplacer;\n}'