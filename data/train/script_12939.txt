b'{-# LANGUAGE CPP #-}\nimport Control.Applicative (Const(..))\nimport Data.Bits ((.&.), popCount)\nimport Data.Word (Word)\nimport Data.IntSet\nimport Data.List (nub,sort)\nimport qualified Data.List as List\nimport Data.Monoid (mempty)\nimport qualified Data.Set as Set\nimport IntSetValidity (valid)\nimport Prelude hiding (lookup, null, map, filter, foldr, foldl)\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck hiding ((.&.))\n\nmain :: IO ()\nmain = defaultMain $ testGroup "intset-properties"\n                   [ testCase "lookupLT" test_lookupLT\n                   , testCase "lookupGT" test_lookupGT\n                   , testCase "lookupLE" test_lookupLE\n                   , testCase "lookupGE" test_lookupGE\n                   , testCase "split" test_split\n                   , testProperty "prop_Valid" prop_Valid\n                   , testProperty "prop_EmptyValid" prop_EmptyValid\n                   , testProperty "prop_SingletonValid" prop_SingletonValid\n                   , testProperty "prop_InsertIntoEmptyValid" prop_InsertIntoEmptyValid\n                   , testProperty "prop_instanceEqIntSet" prop_instanceEqIntSet\n                   , testProperty "prop_instanceOrdIntSet" prop_instanceOrdIntSet\n                   , testProperty "prop_Single" prop_Single\n                   , testProperty "prop_Member" prop_Member\n                   , testProperty "prop_NotMember" prop_NotMember\n                   , testProperty "prop_LookupLT" prop_LookupLT\n                   , testProperty "prop_LookupGT" prop_LookupGT\n                   , testProperty "prop_LookupLE" prop_LookupLE\n                   , testProperty "prop_LookupGE" prop_LookupGE\n                   , testProperty "prop_InsertDelete" prop_InsertDelete\n                   , testProperty "prop_MemberFromList" prop_MemberFromList\n                   , testProperty "prop_UnionInsert" prop_UnionInsert\n                   , testProperty "prop_UnionAssoc" prop_UnionAssoc\n                   , testProperty "prop_UnionComm" prop_UnionComm\n                   , testProperty "prop_Diff" prop_Diff\n                   , testProperty "prop_Int" prop_Int\n                   , testProperty "prop_Ordered" prop_Ordered\n                   , testProperty "prop_List" prop_List\n                   , testProperty "prop_DescList" prop_DescList\n                   , testProperty "prop_AscDescList" prop_AscDescList\n                   , testProperty "prop_fromList" prop_fromList\n                   , testProperty "prop_MaskPow2" prop_MaskPow2\n                   , testProperty "prop_Prefix" prop_Prefix\n                   , testProperty "prop_LeftRight" prop_LeftRight\n                   , testProperty "prop_isProperSubsetOf" prop_isProperSubsetOf\n                   , testProperty "prop_isProperSubsetOf2" prop_isProperSubsetOf2\n                   , testProperty "prop_isSubsetOf" prop_isSubsetOf\n                   , testProperty "prop_isSubsetOf2" prop_isSubsetOf2\n                   , testProperty "prop_disjoint" prop_disjoint\n                   , testProperty "prop_size" prop_size\n                   , testProperty "prop_findMax" prop_findMax\n                   , testProperty "prop_findMin" prop_findMin\n                   , testProperty "prop_ord" prop_ord\n                   , testProperty "prop_readShow" prop_readShow\n                   , testProperty "prop_foldR" prop_foldR\n                   , testProperty "prop_foldR\'" prop_foldR\'\n                   , testProperty "prop_foldL" prop_foldL\n                   , testProperty "prop_foldL\'" prop_foldL\'\n                   , testProperty "prop_map" prop_map\n                   , testProperty "prop_maxView" prop_maxView\n                   , testProperty "prop_minView" prop_minView\n                   , testProperty "prop_split" prop_split\n                   , testProperty "prop_splitMember" prop_splitMember\n                   , testProperty "prop_splitRoot" prop_splitRoot\n                   , testProperty "prop_partition" prop_partition\n                   , testProperty "prop_filter" prop_filter\n                   , testProperty "takeWhileAntitone" prop_takeWhileAntitone\n                   , testProperty "dropWhileAntitone" prop_dropWhileAntitone\n                   , testProperty "spanAntitone" prop_spanAntitone\n                   , testProperty "prop_bitcount" prop_bitcount\n                   , testProperty "prop_alterF_list" prop_alterF_list\n                   , testProperty "prop_alterF_const" prop_alterF_const\n                   ]\n\n----------------------------------------------------------------\n-- Unit tests\n----------------------------------------------------------------\n\ntest_lookupLT :: Assertion\ntest_lookupLT = do\n    lookupLT 3 (fromList [3, 5]) @?= Nothing\n    lookupLT 5 (fromList [3, 5]) @?= Just 3\n\ntest_lookupGT :: Assertion\ntest_lookupGT = do\n   lookupGT 4 (fromList [3, 5]) @?= Just 5\n   lookupGT 5 (fromList [3, 5]) @?= Nothing\n\ntest_lookupLE :: Assertion\ntest_lookupLE = do\n   lookupLE 2 (fromList [3, 5]) @?= Nothing\n   lookupLE 4 (fromList [3, 5]) @?= Just 3\n   lookupLE 5 (fromList [3, 5]) @?= Just 5\n\ntest_lookupGE :: Assertion\ntest_lookupGE = do\n   lookupGE 3 (fromList [3, 5]) @?= Just 3\n   lookupGE 4 (fromList [3, 5]) @?= Just 5\n   lookupGE 6 (fromList [3, 5]) @?= Nothing\n\ntest_split :: Assertion\ntest_split = do\n   split 3 (fromList [1..5]) @?= (fromList [1,2], fromList [4,5])\n\n{--------------------------------------------------------------------\n  Arbitrary, reasonably balanced trees\n--------------------------------------------------------------------}\ninstance Arbitrary IntSet where\n  arbitrary = do{ xs <- arbitrary\n                ; return (fromList xs)\n                }\n\n{--------------------------------------------------------------------\n  Valid IntMaps\n--------------------------------------------------------------------}\nforValid :: Testable a => (IntSet -> a) -> Property\nforValid f = forAll arbitrary $ \\t ->\n    classify (size t == 0) "empty" $\n    classify (size t > 0 && size t <= 10) "small" $\n    classify (size t > 10 && size t <= 64) "medium" $\n    classify (size t > 64) "large" $ f t\n\nforValidUnitTree :: Testable a => (IntSet -> a) -> Property\nforValidUnitTree f = forValid f\n\nprop_Valid :: Property\nprop_Valid = forValidUnitTree $ \\t -> valid t\n\n{--------------------------------------------------------------------\n  Construction validity\n--------------------------------------------------------------------}\n\nprop_EmptyValid :: Property\nprop_EmptyValid =\n    valid empty\n\nprop_SingletonValid :: Int -> Property\nprop_SingletonValid x =\n    valid (singleton x)\n\nprop_InsertIntoEmptyValid :: Int -> Property\nprop_InsertIntoEmptyValid x =\n    valid (insert x empty)\n\n{--------------------------------------------------------------------\n  Instances for Eq and Ord\n--------------------------------------------------------------------}\n\nprop_instanceEqIntSet :: IntSet -> IntSet -> Bool\nprop_instanceEqIntSet x y = (x == y) == (toAscList x == toAscList y)\n\nprop_instanceOrdIntSet :: IntSet -> IntSet -> Bool\nprop_instanceOrdIntSet x y = (compare x y) == (compare (toAscList x) (toAscList y))\n\n{--------------------------------------------------------------------\n  Single, Member, Insert, Delete, Member, FromList\n--------------------------------------------------------------------}\nprop_Single :: Int -> Bool\nprop_Single x\n  = (insert x empty == singleton x)\n\nprop_Member :: [Int] -> Int -> Bool\nprop_Member xs n =\n  let m  = fromList xs\n  in all (\\k -> k `member` m == (k `elem` xs)) (n : xs)\n\nprop_NotMember :: [Int] -> Int -> Bool\nprop_NotMember xs n =\n  let m  = fromList xs\n  in all (\\k -> k `notMember` m == (k `notElem` xs)) (n : xs)\n\ntest_LookupSomething :: (Int -> IntSet -> Maybe Int) -> (Int -> Int -> Bool) -> [Int] -> Bool\ntest_LookupSomething lookup\' cmp xs =\n  let odd_sorted_xs = filter_odd $ nub $ sort xs\n      t = fromList odd_sorted_xs\n      test x = case List.filter (`cmp` x) odd_sorted_xs of\n                 []             -> lookup\' x t == Nothing\n                 cs | 0 `cmp` 1 -> lookup\' x t == Just (last cs) -- we want largest such element\n                    | otherwise -> lookup\' x t == Just (head cs) -- we want smallest such element\n  in all test xs\n\n  where filter_odd [] = []\n        filter_odd [_] = []\n        filter_odd (_ : o : xs) = o : filter_odd xs\n\nprop_LookupLT :: [Int] -> Bool\nprop_LookupLT = test_LookupSomething lookupLT (<)\n\nprop_LookupGT :: [Int] -> Bool\nprop_LookupGT = test_LookupSomething lookupGT (>)\n\nprop_LookupLE :: [Int] -> Bool\nprop_LookupLE = test_LookupSomething lookupLE (<=)\n\nprop_LookupGE :: [Int] -> Bool\nprop_LookupGE = test_LookupSomething lookupGE (>=)\n\nprop_InsertDelete :: Int -> IntSet -> Property\nprop_InsertDelete k t\n  = not (member k t) ==>\n      case delete k (insert k t) of\n        t\' -> valid t\' .&&. t\' === t\n\nprop_MemberFromList :: [Int] -> Bool\nprop_MemberFromList xs\n  = all (`member` t) abs_xs && all ((`notMember` t) . negate) abs_xs\n  where abs_xs = [abs x | x <- xs, x /= 0]\n        t = fromList abs_xs\n\n{--------------------------------------------------------------------\n  Union, Difference and Intersection\n--------------------------------------------------------------------}\nprop_UnionInsert :: Int -> IntSet -> Property\nprop_UnionInsert x t =\n  case union t (singleton x) of\n    t\' ->\n      valid t\' .&&.\n      t\' === insert x t\n\nprop_UnionAssoc :: IntSet -> IntSet -> IntSet -> Bool\nprop_UnionAssoc t1 t2 t3\n  = union t1 (union t2 t3) == union (union t1 t2) t3\n\nprop_UnionComm :: IntSet -> IntSet -> Bool\nprop_UnionComm t1 t2\n  = (union t1 t2 == union t2 t1)\n\nprop_Diff :: [Int] -> [Int] -> Property\nprop_Diff xs ys =\n  case difference (fromList xs) (fromList ys) of\n    t ->\n      valid t .&&.\n      toAscList t === List.sort ((List.\\\\) (nub xs)  (nub ys))\n\nprop_Int :: [Int] -> [Int] -> Property\nprop_Int xs ys =\n  case intersection (fromList xs) (fromList ys) of\n    t ->\n      valid t .&&.\n      toAscList t === List.sort (nub ((List.intersect) (xs)  (ys)))\n\nprop_disjoint :: IntSet -> IntSet -> Bool\nprop_disjoint a b = a `disjoint` b == null (a `intersection` b)\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\nprop_Ordered\n  = forAll (choose (5,100)) $ \\n ->\n    let xs = concat [[i-n,i-n]|i<-[0..2*n :: Int]]\n    in fromAscList xs == fromList xs\n\nprop_List :: [Int] -> Bool\nprop_List xs\n  = (sort (nub xs) == toAscList (fromList xs))\n\nprop_DescList :: [Int] -> Bool\nprop_DescList xs = (reverse (sort (nub xs)) == toDescList (fromList xs))\n\nprop_AscDescList :: [Int] -> Bool\nprop_AscDescList xs = toAscList s == reverse (toDescList s)\n  where s = fromList xs\n\nprop_fromList :: [Int] -> Property\nprop_fromList xs\n  = case fromList xs of\n      t -> valid t .&&.\n           t === fromAscList sort_xs .&&.\n           t === fromDistinctAscList nub_sort_xs .&&.\n           t === List.foldr insert empty xs\n  where sort_xs = sort xs\n        nub_sort_xs = List.map List.head $ List.group sort_xs\n\n{--------------------------------------------------------------------\n  Bin invariants\n--------------------------------------------------------------------}\npowersOf2 :: IntSet\npowersOf2 = fromList [2^i | i <- [0..63]]\n\n-- Check the invariant that the mask is a power of 2.\nprop_MaskPow2 :: IntSet -> Bool\nprop_MaskPow2 (Bin _ msk left right) = member msk powersOf2 && prop_MaskPow2 left && prop_MaskPow2 right\nprop_MaskPow2 _ = True\n\n-- Check that the prefix satisfies its invariant.\nprop_Prefix :: IntSet -> Bool\nprop_Prefix s@(Bin prefix msk left right) = all (\\elem -> match elem prefix msk) (toList s) && prop_Prefix left && prop_Prefix right\nprop_Prefix _ = True\n\n-- Check that the left elements don\'t have the mask bit set, and the right\n-- ones do.\nprop_LeftRight :: IntSet -> Bool\nprop_LeftRight (Bin _ msk left right) = and [x .&. msk == 0 | x <- toList left] && and [x .&. msk == msk | x <- toList right]\nprop_LeftRight _ = True\n\n{--------------------------------------------------------------------\n  IntSet operations are like Set operations\n--------------------------------------------------------------------}\ntoSet :: IntSet -> Set.Set Int\ntoSet = Set.fromList . toList\n\n-- Check that IntSet.isProperSubsetOf is the same as Set.isProperSubsetOf.\nprop_isProperSubsetOf :: IntSet -> IntSet -> Bool\nprop_isProperSubsetOf a b = isProperSubsetOf a b == Set.isProperSubsetOf (toSet a) (toSet b)\n\n-- In the above test, isProperSubsetOf almost always returns False (since a\n-- random set is almost never a subset of another random set).  So this second\n-- test checks the True case.\nprop_isProperSubsetOf2 :: IntSet -> IntSet -> Bool\nprop_isProperSubsetOf2 a b = isProperSubsetOf a c == (a /= c) where\n  c = union a b\n\nprop_isSubsetOf :: IntSet -> IntSet -> Bool\nprop_isSubsetOf a b = isSubsetOf a b == Set.isSubsetOf (toSet a) (toSet b)\n\nprop_isSubsetOf2 :: IntSet -> IntSet -> Bool\nprop_isSubsetOf2 a b = isSubsetOf a (union a b)\n\nprop_size :: IntSet -> Property\nprop_size s = sz === foldl\' (\\i _ -> i + 1) (0 :: Int) s .&&.\n              sz === List.length (toList s)\n  where sz = size s\n\nprop_findMax :: IntSet -> Property\nprop_findMax s = not (null s) ==> findMax s == maximum (toList s)\n\nprop_findMin :: IntSet -> Property\nprop_findMin s = not (null s) ==> findMin s == minimum (toList s)\n\nprop_ord :: IntSet -> IntSet -> Bool\nprop_ord s1 s2 = s1 `compare` s2 == toList s1 `compare` toList s2\n\nprop_readShow :: IntSet -> Bool\nprop_readShow s = s == read (show s)\n\nprop_foldR :: IntSet -> Bool\nprop_foldR s = foldr (:) [] s == toList s\n\nprop_foldR\' :: IntSet -> Bool\nprop_foldR\' s = foldr\' (:) [] s == toList s\n\nprop_foldL :: IntSet -> Bool\nprop_foldL s = foldl (flip (:)) [] s == List.foldl (flip (:)) [] (toList s)\n\nprop_foldL\' :: IntSet -> Bool\nprop_foldL\' s = foldl\' (flip (:)) [] s == List.foldl\' (flip (:)) [] (toList s)\n\nprop_map :: IntSet -> Bool\nprop_map s = map id s == s\n\n-- Note: we could generate an arbitrary strictly monotonic function by\n-- restricting f using @\\x y -> x < y ==> f x < f y@\n-- but this will be inefficient given the probability of actually finding\n-- a function that meets the criteria.\n-- For now we settle on identity function and arbitrary linear functions\n-- f x = a*x + b (with a being positive).\n-- This might be insufficient to support any fancier implementation.\nprop_mapMonotonicId :: IntSet -> Property\nprop_mapMonotonicId s = mapMonotonic id s === map id s\n\nprop_mapMonotonicLinear :: Positive Int -> Int -> IntSet -> Property\nprop_mapMonotonicLinear (Positive a) b s = mapMonotonic f s === map f s\n  where\n    f x = a*x + b\n\nprop_maxView :: IntSet -> Bool\nprop_maxView s = case maxView s of\n    Nothing -> null s\n    Just (m,s\') -> m == maximum (toList s) && s == insert m s\' && m `notMember` s\'\n\nprop_minView :: IntSet -> Bool\nprop_minView s = case minView s of\n    Nothing -> null s\n    Just (m,s\') -> m == minimum (toList s) && s == insert m s\' && m `notMember` s\'\n\nprop_split :: IntSet -> Int -> Property\nprop_split s i = case split i s of\n    (s1,s2) -> valid s1 .&&.\n               valid s2 .&&.\n               all (<i) (toList s1) .&&.\n               all (>i) (toList s2) .&&.\n               i `delete` s === union s1 s2\n\nprop_splitMember :: IntSet -> Int -> Property\nprop_splitMember s i = case splitMember i s of\n    (s1,t,s2) -> valid s1 .&&.\n                 valid s2 .&&.\n                 all (<i) (toList s1) .&&.\n                 all (>i) (toList s2) .&&.\n                 t === i `member` s .&&.\n                 i `delete` s === union s1 s2\n\nprop_splitRoot :: IntSet -> Bool\nprop_splitRoot s = loop ls && (s == unions ls)\n where\n  ls = splitRoot s\n  loop [] = True\n  loop (s1:rst) = List.null\n                  [ (x,y) | x <- toList s1\n                          , y <- toList (unions rst)\n                          , x > y ]\n\nprop_partition :: IntSet -> Int -> Property\nprop_partition s i = case partition odd s of\n    (s1,s2) -> valid s1 .&&.\n               valid s2 .&&.\n               all odd (toList s1) .&&.\n               all even (toList s2) .&&.\n               s === s1 `union` s2\n\nprop_filter :: IntSet -> Int -> Property\nprop_filter s i =\n  let parts = partition odd s\n      odds = filter odd s\n      evens = filter even s\n  in valid odds .&&.\n     valid evens .&&.\n     parts === (odds, evens)\n\nprop_takeWhileAntitone :: Int -> [Int] -> Property\nprop_takeWhileAntitone x ys =\n  let l = takeWhileAntitone (<x) (fromList ys)\n  in  valid l .&&.\n      l === fromList (List.filter (<x) ys)\n\nprop_dropWhileAntitone :: Int -> [Int] -> Property\nprop_dropWhileAntitone x ys =\n  let r = dropWhileAntitone (<x) (fromList ys)\n  in  valid r .&&.\n      r === fromList (List.filter (>=x) ys)\n\nprop_spanAntitone :: Int -> [Int] -> Property\nprop_spanAntitone x ys =\n  let (l, r) = spanAntitone (<x) (fromList ys)\n  in  valid l .&&.\n      valid r .&&.\n      l === fromList (List.filter (<x) ys) .&&.\n      r === fromList (List.filter (>=x) ys)\n\nprop_bitcount :: Int -> Word -> Bool\nprop_bitcount a w = bitcount_orig a w == bitcount_new a w\n  where\n    bitcount_orig a0 x0 = go a0 x0\n      where go a 0 = a\n            go a x = go (a + 1) (x .&. (x-1))\n    bitcount_new a x = a + popCount x\n\nprop_alterF_list\n    :: Fun Bool [Bool]\n    -> Int\n    -> IntSet\n    -> Property\nprop_alterF_list f k s =\n        fmap toSet (alterF     (applyFun f) k s)\n    ===             Set.alterF (applyFun f) k (toSet s)\n\nprop_alterF_const\n    :: Fun Bool Bool\n    -> Int\n    -> IntSet\n    -> Property\nprop_alterF_const f k s =\n        getConst (alterF     (Const . applyFun f) k s        )\n    === getConst (Set.alterF (Const . applyFun f) k (toSet s))\n'