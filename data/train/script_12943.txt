b'{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-unused-matches #-}\n\nmodule Graphics.Hoodle.Render.Engine\n  ( pdfRendererMain,\n    genRendererMain,\n    transparentClear,\n  )\nwhere\n\nimport Control.Concurrent.STM\n  ( TVar,\n    atomically,\n    putTMVar,\n    readTVar,\n    retry,\n    writeTVar,\n  )\nimport Control.Monad (forever)\nimport qualified Data.HashMap.Strict as HM\nimport Data.Hoodle.Simple (Background (..), Dimension (..))\nimport Data.Sequence (ViewL (..), viewl)\nimport Graphics.Hoodle.Render (renderRItem)\nimport Graphics.Hoodle.Render.Background\n  ( -- popplerGetDocFromDataURI,\n    -- popplerGetDocFromFile,\n    -- popplerGetPageFromDoc,\n    renderBkg,\n  )\nimport Graphics.Hoodle.Render.Type\n  ( GenCommand\n      ( BkgSmplScaled,\n        LayerInit,\n        LayerRedraw,\n        LayerScaled\n      ),\n    GenCommandQueue,\n    PDFCommand\n      ( GetDocFromDataURI,\n        GetDocFromFile,\n        GetNPages,\n        GetPageFromDoc,\n        RenderPageScaled\n      ),\n    PDFCommandQueue,\n    RenderCache,\n    RendererEvent\n      ( FinishCommandFor,\n        SurfaceUpdate\n      ),\n  )\nimport qualified Graphics.Rendering.Cairo as Cairo\n\n-- import qualified Graphics.UI.Gtk.Poppler.Document as Poppler\n-- import qualified Graphics.UI.Gtk.Poppler.Page as Poppler\n\n-- | main pdf renderer engine. need to be in a single thread\npdfRendererMain :: (RendererEvent -> IO ()) -> PDFCommandQueue -> IO ()\npdfRendererMain handler tvar = forever $ do\n  p <- atomically $ do\n    lst\' <- readTVar tvar\n    case viewl lst\' of\n      EmptyL -> retry\n      p :< ps -> do\n        writeTVar tvar ps\n        return p\n  pdfWorker handler (snd p)\n\npdfWorker :: (RendererEvent -> IO ()) -> PDFCommand -> IO ()\npdfWorker _handler (GetDocFromFile fp tmvar) = do\n  -- mdoc <- popplerGetDocFromFile fp\n  let mdoc = Just ()\n  atomically $ putTMVar tmvar mdoc\npdfWorker _handler (GetDocFromDataURI str tmvar) = do\n  -- mdoc <- popplerGetDocFromDataURI str\n  let mdoc = Just ()\n  atomically $ putTMVar tmvar mdoc\npdfWorker _handler (GetPageFromDoc doc pn tmvar) = do\n  -- mpg <- popplerGetPageFromDoc doc pn\n  let mpg = Just ()\n  atomically $ putTMVar tmvar mpg\npdfWorker _handler (GetNPages doc tmvar) = do\n  -- n <- Poppler.documentGetNPages doc\n  let n = 0\n  atomically $ putTMVar tmvar n\npdfWorker handler (RenderPageScaled sfcid page (Dim ow _oh) (Dim w h)) = do\n  let s = w / ow\n  sfc <- Cairo.createImageSurface Cairo.FormatARGB32 (floor w) (floor h)\n  Cairo.renderWith sfc $ do\n    Cairo.setSourceRGBA 1 1 1 1\n    Cairo.rectangle 0 0 w h\n    Cairo.fill\n    Cairo.scale s s\n    -- Poppler.pageRender page\n    pure ()\n  handler (SurfaceUpdate (sfcid, (s, sfc)))\n\n-- | generic renderer engine\ngenRendererMain ::\n  TVar RenderCache ->\n  (RendererEvent -> IO ()) ->\n  GenCommandQueue ->\n  IO ()\ngenRendererMain cachevar handler tvar = forever $ do\n  (p, cache) <- atomically $ do\n    cache <- readTVar cachevar\n    lst\' <- readTVar tvar\n    case viewl lst\' of\n      EmptyL -> retry\n      p :< ps -> do\n        writeTVar tvar ps\n        return (p, cache)\n  genWorker cache handler (snd p)\n\ngenWorker :: RenderCache -> (RendererEvent -> IO ()) -> GenCommand -> IO ()\ngenWorker _cache handler (BkgSmplScaled sfcid col sty dim@(Dim ow _oh) (Dim w h)) = do\n  let s = w / ow\n      bkg = Background "solid" col sty\n  sfc <- Cairo.createImageSurface Cairo.FormatARGB32 (floor w) (floor h)\n  Cairo.renderWith sfc $ do\n    Cairo.setSourceRGBA 1 1 1 1\n    Cairo.rectangle 0 0 w h\n    Cairo.fill\n    Cairo.scale s s\n    renderBkg (bkg, dim)\n  handler (SurfaceUpdate (sfcid, (s, sfc)))\ngenWorker _cache handler (LayerInit sfcid ritms) = do\n  sfc <- Cairo.createImageSurface Cairo.FormatARGB32 612 792 -- (floor w) (floor h) -- for the time being\n  Cairo.renderWith sfc $ do\n    Cairo.setSourceRGBA 0 0 0 0\n    Cairo.setOperator Cairo.OperatorSource\n    Cairo.paint\n    Cairo.setOperator Cairo.OperatorOver\n    mapM_ (renderRItem undefined undefined) ritms\n  handler (SurfaceUpdate (sfcid, (1.0, sfc)))\ngenWorker cache handler (LayerRedraw sfcid ritms) = do\n  case HM.lookup sfcid cache of\n    Nothing -> genWorker cache handler (LayerInit sfcid ritms)\n    Just (s, sfc) -> do\n      Cairo.renderWith sfc $ do\n        Cairo.setSourceRGBA 0 0 0 0\n        Cairo.setOperator Cairo.OperatorSource\n        Cairo.paint\n        Cairo.setOperator Cairo.OperatorOver\n        Cairo.scale s s\n        mapM_ (renderRItem undefined undefined) ritms\n      handler (SurfaceUpdate (sfcid, (s, sfc)))\n      handler (FinishCommandFor sfcid)\ngenWorker _cache handler (LayerScaled sfcid ritms (Dim ow _) (Dim w h)) = do\n  let s = w / ow\n  sfc <- Cairo.createImageSurface Cairo.FormatARGB32 (floor w) (floor h)\n  Cairo.renderWith sfc $ do\n    Cairo.setSourceRGBA 0 0 0 0\n    Cairo.setOperator Cairo.OperatorSource\n    Cairo.paint\n    Cairo.setOperator Cairo.OperatorOver\n    Cairo.scale s s\n    mapM_ (renderRItem undefined undefined) ritms\n  handler (SurfaceUpdate (sfcid, (s, sfc)))\n\ntransparentClear :: Cairo.Render ()\ntransparentClear = do\n  Cairo.setSourceRGBA 0 0 0 0\n  Cairo.setOperator Cairo.OperatorSource\n  Cairo.paint\n  Cairo.setOperator Cairo.OperatorOver\n'