b'{- HLINT ignore -}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Publish.PDF where\n\n{-\nimport Control.Applicative ((<|>))\nimport Control.Exception (SomeException (..), catch)\nimport Control.Lens (view, _1, _2, _3, _4)\nimport Control.Monad (forM, forM_, unless, void, when, (<=<))\nimport Control.Monad.Trans (lift, liftIO)\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Control.Monad.Trans.State (StateT (..), evalStateT, get, gets, modify, put)\nimport Data.Attoparsec.ByteString.Char8\n  ( anyChar,\n    endOfInput,\n    inClass,\n    manyTill,\n    parseOnly,\n    satisfy,\n    string,\n    try,\n  )\nimport qualified Data.ByteString.Char8 as B\nimport qualified Data.ByteString.Lazy as BSL\nimport Data.Either (isLeft)\nimport Data.Functor (($>))\nimport qualified Data.Hoodle.Simple as S\nimport Data.Int (Int64)\nimport Data.Maybe (catMaybes)\nimport Data.UUID (UUID, fromString)\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render\n  ( initRenderContext,\n    renderPageStateT,\n  )\nimport Graphics.Rendering.Cairo\n  ( pdfSurfaceSetSize,\n    renderWith,\n    showPage,\n    withPDFSurface,\n  )\nimport Network.HTTP.Base (urlEncode)\nimport Network.URI (unEscapeString)\nimport Pdf.Core\n  ( Array (..),\n    Dict (..),\n    Object (..),\n    -- PdfWriter,\n    Ref (..),\n    -- Str (..),\n    Stream (..),\n    -- deleteObject,\n    -- rawStreamContent,\n    -- runPdfWriter,\n    -- writeObject,\n    -- writePdfHeader,\n    -- writeXRefTable,\n  )\nimport Pdf.Document\n  ( Pdf,\n    catalogPageNode,\n    defaultUserPassword,\n    deref,\n    document,\n    documentCatalog,\n    -- fromObject,\n    -- getRIS,\n    -- intValue,\n    isEncrypted,\n    -- knownFilters,\n    -- lookupDict,\n    lookupObject,\n    -- mapObject,\n    pageContents,\n    pageNodeNKids,\n    pageNodePageByNum,\n    -- runPdfWithHandle,\n    setUserPassword,\n    -- toStream,\n  )\nimport Pdf.Document.Internal.Types (Page (..))\nimport System.Directory\n  ( canonicalizePath,\n    doesDirectoryExist,\n    doesFileExist,\n    getModificationTime,\n    getTemporaryDirectory,\n    removeFile,\n  )\nimport System.Directory.Tree (DirTree (..))\nimport System.FilePath\n  ( makeRelative,\n    splitExtension,\n    splitFileName,\n    takeExtension,\n    (<.>),\n    (</>),\n  )\nimport System.IO\n  ( IOMode (ReadMode),\n    hClose,\n    openBinaryFile,\n  )\nimport qualified System.IO.Streams as Streams\nimport System.Process (readProcessWithExitCode, system)\nimport Text.Hoodle.Parse.Attoparsec (hoodle)\n\ndata UrlPath = FileUrl FilePath | HttpUrl String\n  deriving (Show, Eq)\n\ndata T = N | F | H | HS deriving (Show, Eq)\n\n-- |\nurlParse :: String -> Maybe UrlPath\nurlParse str =\n  if length str < 7\n    then Just (FileUrl str)\n    else\n      let p = do\n            b <-\n              try (string "file://" $> F)\n                <|> try (string "http://" $> H)\n                <|> try (string "https://" $> HS)\n                <|> return N\n            remain <- manyTill anyChar ((satisfy (inClass "\\r\\n") $> ()) <|> endOfInput)\n            return (b, remain)\n          r = parseOnly p (B.pack str)\n       in case r of\n            Left _ -> Nothing\n            Right (b, f) -> case b of\n              N -> Just (FileUrl f)\n              F -> Just (FileUrl (unEscapeString f))\n              H -> Just (HttpUrl ("http://" ++ f))\n              HS -> Just (HttpUrl ("https://" ++ f))\n\nisFile :: DirTree a -> Bool\nisFile (File _ _) = True\nisFile _ = False\n\ntakeFile :: DirTree a -> Maybe a\ntakeFile x\n  | isFile x = (Just . file) x\n  | otherwise = Nothing\n\ndata Annot = Annot\n  { annot_rect :: (Int, Int, Int, Int),\n    annot_border :: (Int, Int, Int),\n    annot_act :: AnnotActions\n  }\n\ndata AnnotActions = OpenURI String | OpenApp String\n\ndata AppState = AppState\n  { stNextFree :: Int,\n    stPageRefs :: [Ref],\n    stRootNode :: Ref\n  }\n\ninitialAppState :: AppState\ninitialAppState =\n  AppState\n    { stNextFree = 1,\n      stPageRefs = [],\n      stRootNode = error "stRootNode"\n    }\n\nnextFreeIndex :: Monad m => StateT AppState m Int\nnextFreeIndex = do\n  st <- get\n  let index = stNextFree st\n  put $ st {stNextFree = index + 1}\n  return index\n\nputPageRef :: Monad m => Ref -> StateT AppState m ()\nputPageRef ref = modify $ \\st -> st {stPageRefs = ref : stPageRefs st}\n\nwriteTrailer :: StateT AppState (PdfWriter IO) ()\nwriteTrailer = do\n  pageRefs <- gets stPageRefs\n  rootRef <- gets stRootNode\n  lift $\n    writeObject rootRef $\n      ODict $\n        Dict\n          [ ("Type", OName "Pages"),\n            ("Count", ONumber $ NumInt $ length pageRefs),\n            ("Kids", OArray $ Array $ map ORef $ reverse pageRefs)\n          ]\n  catalogIndex <- nextFreeIndex\n  let catalogRef = Ref catalogIndex 0\n  lift $ writeObject catalogRef $ ODict $ Dict [("Type", OName "Catalog"), ("Pages", ORef rootRef)]\n  n <- gets stNextFree\n  lift $ writeXRefTable 0 (Dict [("Size", (ONumber . NumInt) (n - 1)), ("Root", ORef catalogRef)])\n\nwriteObjectChildren :: Object () -> Pdf (StateT AppState (PdfWriter IO)) (Object ())\nwriteObjectChildren (ORef r) = do\n  o <- lookupObject r\n  case o of\n    OStream s -> do\n      ref <- writeStream s\n      return $ ORef ref\n    _ -> do\n      let o\' = mapObject (error "impossible") o\n      o\'\' <- writeObjectChildren o\'\n      index <- (lift . lift) nextFreeIndex\n      let ref = Ref index 0\n      (lift . lift . lift) $ writeObject ref $ mapObject (error "impossible") o\'\'\n      return $ ORef ref\nwriteObjectChildren (ODict (Dict vals)) = do\n  vals\' <- forM vals $ \\(key, val) -> do\n    val\' <- writeObjectChildren val\n    return (key, val\')\n  return $ ODict $ Dict vals\'\nwriteObjectChildren (OArray (Array vals)) = do\n  vals\' <- forM vals writeObjectChildren\n  return $ OArray $ Array vals\'\nwriteObjectChildren o = return o\n\n-- |\nwriteStream :: Stream Int64 -> Pdf (StateT AppState (PdfWriter IO)) Ref\nwriteStream s@(Stream dict _) = do\n  len <- lookupDict "Length" dict >>= deref >>= fromObject >>= intValue\n  ris <- getRIS\n  Stream _ is <- rawStreamContent ris len s\n  content <- liftIO $ BSL.fromChunks `fmap` Streams.toList is\n  index <- (lift . lift) nextFreeIndex\n  let ref = Ref index 0\n  dict\' <- writeObjectChildren (ODict dict) >>= fromObject\n  lift . lift . lift $ writeObject ref $ OStream $ Stream dict\' content\n  return ref\n\n-- |\nwriteAnnot :: Annot -> Pdf (StateT AppState (PdfWriter IO)) Ref\nwriteAnnot Annot {..} = do\n  annotIndex <- (lift . lift) nextFreeIndex\n  actionIndex <- (lift . lift) nextFreeIndex\n  let annotRef = Ref annotIndex 0\n      actionRef = Ref actionIndex 0\n  let annotDict =\n        Dict\n          [ ("Type", OName "Annot"),\n            ("Subtype", OName "Link"),\n            ( "Rect",\n              OArray $\n                Array\n                  [ ONumber (NumInt (view _1 annot_rect)),\n                    ONumber (NumInt (view _2 annot_rect)),\n                    ONumber (NumInt (view _3 annot_rect)),\n                    ONumber (NumInt (view _4 annot_rect))\n                  ]\n            ),\n            ( "Border",\n              OArray $\n                Array\n                  [ ONumber (NumInt (view _1 annot_border)),\n                    ONumber (NumInt (view _2 annot_border)),\n                    ONumber (NumInt (view _3 annot_border))\n                  ]\n            ),\n            ("A", ORef actionRef)\n          ]\n      actionDict = case annot_act of\n        OpenURI uri ->\n          Dict\n            [ ("S", OName "URI"),\n              ("URI", OStr (Str (B.pack uri)))\n            ]\n        OpenApp str ->\n          Dict\n            [ ("S", OName "Launch"),\n              ("F", OStr (Str (B.pack str)))\n            ]\n  lift . lift . lift $ writeObject annotRef $ ODict annotDict\n  lift . lift . lift $ writeObject actionRef $ ODict actionDict\n  return annotRef\n\n-- |\nwritePdfPageWithAnnot ::\n  S.Dimension ->\n  Maybe [Annot] ->\n  Page ->\n  Pdf (StateT AppState (PdfWriter IO)) ()\nwritePdfPageWithAnnot (S.Dim w h) mannots pg@(Page _ pageDict) = do\n  parentRef <- lift . lift $ gets stRootNode\n  pageIndex <- (lift . lift) nextFreeIndex\n  let pageRef = Ref pageIndex 0\n  lift . lift $ putPageRef pageRef\n  contentRefs <- pageContents pg\n  contentRefs\' <- forM contentRefs $ \\r -> do\n    s <- lookupObject r >>= toStream\n    writeStream s\n  resources <- lookupDict "Resources" pageDict >>= deref >>= writeObjectChildren\n  case mannots of\n    Nothing ->\n      lift . lift . lift $\n        writeObject pageRef $\n          ODict $\n            Dict\n              [ ("Type", OName "Page"),\n                ("Contents", OArray $ Array $ map ORef contentRefs\'),\n                ("MediaBox", OArray $ Array $ map (ONumber . NumInt) [0, 0, floor w, floor h]),\n                ("Resources", resources),\n                ("Parent", ORef parentRef)\n              ]\n    Just anns -> do\n      annrefs <- mapM writeAnnot anns\n      lift . lift . lift $\n        writeObject pageRef $\n          ODict $\n            Dict\n              [ ("Type", OName "Page"),\n                ("Contents", OArray $ Array $ map ORef contentRefs\'),\n                ("MediaBox", OArray $ Array $ map (ONumber . NumInt) [0, 0, floor w, floor h]),\n                ("Resources", resources),\n                ("Parent", ORef parentRef),\n                ("Annots", (OArray . Array . map ORef) annrefs)\n              ]\n\n-- |\nmakeAnnot ::\n  S.Dimension ->\n  String ->\n  (FilePath, FilePath) ->\n  S.Link ->\n  IO (Maybe Annot)\nmakeAnnot (S.Dim _pw ph) urlbase (rootpath, _currpath) lnk = do\n  let (x, y) = S.link_pos lnk\n      S.Dim w h = S.link_dim lnk\n      -- pwi = floor pw\n      phi = floor ph\n      xi = floor x\n      yi = floor y\n      wi = floor w\n      hi = floor h\n      linkpath = (B.unpack . S.link_location) lnk\n  case urlParse linkpath of\n    Nothing -> return Nothing\n    Just urlpath -> do\n      case urlpath of\n        HttpUrl url ->\n          return\n            ( Just\n                Annot\n                  { annot_rect = (xi, phi - yi, xi + wi, phi - (yi + hi)),\n                    annot_border = (16, 16, 1),\n                    annot_act = OpenURI url\n                  }\n            )\n        FileUrl _path -> do\n          b <- doesFileExist linkpath\n          if b\n            then do\n              fp <- canonicalizePath linkpath\n              let (dir, fn) = splitFileName fp\n                  rdir = makeRelative rootpath dir\n                  (fb, _ext) = splitExtension fn\n              return\n                ( Just\n                    Annot\n                      { annot_rect = (xi, phi - yi, xi + wi, phi - (yi + hi)),\n                        annot_border = (16, 16, 1),\n                        annot_act = OpenURI (urlbase </> rdir </> urlEncode fb <.> "pdf")\n                      }\n                )\n            else return Nothing\n\n-- |\nwritePdfFile ::\n  -- | hoodle file path\n  FilePath ->\n  S.Dimension ->\n  -- | (url base, special url base (for executing an app))\n  (String, String) ->\n  -- | (root path, curr path)\n  (FilePath, FilePath) ->\n  -- | pdf file\n  FilePath ->\n  [(Int, [S.Link])] ->\n  Maybe UUID ->\n  StateT AppState (PdfWriter IO) ()\nwritePdfFile _hdlfp dim (urlbase, specialurlbase) (rootpath, currpath) path nlnks muuid = do\n  handle <- liftIO $ openBinaryFile path ReadMode\n  res <- runPdfWithHandle handle knownFilters $ do\n    encrypted <- isEncrypted\n    when encrypted $ void $ setUserPassword defaultUserPassword\n    root <- document >>= documentCatalog >>= catalogPageNode\n    count <- pageNodeNKids root\n    forM_ [0 .. count - 1] $ \\i -> do\n      page <- pageNodePageByNum root i\n      mannots <- runMaybeT $ do\n        lnks <- MaybeT . return $ lookup (i + 1) nlnks\n        fmap catMaybes . mapM (liftIO . makeAnnot dim urlbase (rootpath, currpath)) $ lnks\n      -- hdlfp\' <- liftIO $ canonicalizePath hdlfp\n      let special =\n            if i == 0\n              then\n                let S.Dim _w h = dim\n                 in [ Annot\n                        { annot_rect = (0, floor h, 100, floor h - 100),\n                          annot_border = (16, 16, 1),\n                          annot_act = specialURIFunction specialurlbase muuid\n                        }\n                    ]\n              else []\n      let mannots\' = case mannots of\n            Nothing -> Just special\n            Just anns -> Just (anns ++ special)\n      writePdfPageWithAnnot dim mannots\' page\n  when (isLeft res) $ error $ show res\n  liftIO $ hClose handle\n\nspecialURIFunction ::\n  FilePath ->\n  Maybe UUID ->\n  AnnotActions\nspecialURIFunction baseurl muuid =\n  case muuid of\n    Nothing -> error "muuid = Nothing?" -- OpenURI baseurl\n    Just uuid -> OpenURI (baseurl </> urlEncode (show uuid))\n\ngetLinks :: S.Page -> [S.Link]\ngetLinks pg = do\n  l <- view S.layers pg\n  S.ItemLink lnk <- view S.items l\n  return lnk\n\nisHdl :: FilePath -> Bool\nisHdl = (== ".hdl") <$> takeExtension\n\nisPdf :: FilePath -> Bool\nisPdf = (== ".pdf") <$> takeExtension\n\n-- | interleaving a monadic action between each pair of subsequent actions\nsequence1_ :: (Monad m) => m () -> [m ()] -> m ()\nsequence1_ _ [] = return ()\nsequence1_ _ [a] = a\nsequence1_ i (a : as) = a >> i >> sequence1_ i as\n\n-- | render a hoodle file to PDF simply\nrenderHoodleToPDF :: S.Hoodle -> FilePath -> IO ()\nrenderHoodleToPDF hdl ofp = do\n  let p = head (view S.pages hdl)\n  let S.Dim width height = view S.dimension p\n  tdir <- getTemporaryDirectory\n  uuid <- nextRandom\n  let tempfile = tdir </> show uuid <.> "pdf"\n  ctxt <- initRenderContext hdl\n  let setsize sfc pg =\n        let S.Dim w h = view S.dimension pg\n         in pdfSurfaceSetSize sfc w h >> return pg\n  _ <- withPDFSurface tempfile width height $ \\s ->\n    renderWith s . flip runStateT ctxt $\n      sequence1_ (lift showPage) . map (renderPageStateT <=< setsize s) . view S.pages $\n        hdl\n  void $ readProcessWithExitCode "pdftk" [tempfile, "cat", "output", ofp] ""\n\nisUpdated :: (FilePath, FilePath) -> IO Bool\nisUpdated (ofp, nfp) = do\n  b <- doesFileExist nfp\n  if not b\n    then return True\n    else do\n      otime <- getModificationTime ofp\n      ntime <- getModificationTime nfp\n      return (otime > ntime)\n\n-- | create pdf file with appropriate links\ncreatePdf ::\n  (String, String) ->\n  FilePath ->\n  (FilePath, FilePath) ->\n  IO ()\ncreatePdf (urlbase, specialurlbase) rootpath (fn, ofn) = catch action (\\(e :: SomeException) -> print e)\n  where\n    action = do\n      putStrLn fn\n      let (odir, _) = splitFileName ofn\n      b <- doesDirectoryExist odir\n      unless b $ void $ system ("mkdir -p " ++ odir)\n      let (currpath, _) = splitFileName fn\n      Streams.withFileAsOutput ofn $ \\ostr -> do\n        bstr <- B.readFile fn\n        case parseOnly hoodle bstr of\n          Left str -> error str\n          Right hdl -> do\n            let npgs = zip [1 ..] (view S.pages hdl)\n                npglnks = map ((,) <$> fst <*> getLinks . snd) npgs\n                dim = (view S.dimension . snd . head) npgs\n                muuid = (fromString . B.unpack . view S.hoodleID) hdl\n            tempfile <- (</>) <$> getTemporaryDirectory <*> fmap show nextRandom\n            renderHoodleToPDF hdl tempfile\n            --\n            runPdfWriter ostr $ do\n              writePdfHeader\n              deleteObject (Ref 0 65535) 0\n              flip evalStateT initialAppState $ do\n                index <- nextFreeIndex\n                modify $ \\st -> st {stRootNode = Ref index 0}\n                writePdfFile fn dim (urlbase, specialurlbase) (rootpath, currpath) tempfile npglnks muuid\n                writeTrailer\n            removeFile tempfile\n-}\n'