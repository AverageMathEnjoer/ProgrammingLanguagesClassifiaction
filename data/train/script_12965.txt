b'{-# LANGUAGE ScopedTypeVariables #-}\nmodule Rest.Gen.Ruby (mkRbApi) where\n\nimport Prelude hiding ((.))\n\nimport Control.Category ((.))\nimport Data.Char\nimport Data.List\nimport Data.List.Split (splitOn)\nimport Data.Maybe\nimport qualified Data.Label.Total             as L\nimport qualified Data.List.NonEmpty           as NList\n\nimport Code.Build\nimport Code.Build.Ruby\nimport Rest.Api (Router, Version)\nimport Rest.Gen.Base\nimport Rest.Gen.Types\nimport Rest.Gen.Utils\nimport qualified Rest.Gen.NoAnnotation as N\n\nmkRbApi :: N.ModuleName -> Bool -> Version -> Router m s -> IO String\nmkRbApi ns priv ver r =\n  do rawPrelude <- readContent "Ruby/base.rb"\n     let prelude = replace "SilkApi" (unModuleName ns) rawPrelude\n     let cod = showCode . mkRb (unModuleName ns) ver . sortTree . (if priv then id else noPrivate) . apiSubtrees $ r\n     return $ cod ++ "\\n" ++ prelude\n\nreplace :: String -> String -> String -> String\nreplace from to = intercalate to . splitOn from\n\nmkRb :: String -> Version -> ApiResource -> Code\nmkRb ns ver node =\n  rbModule ns $ mkStack\n        [ "@version" .=. string (show ver)\n        , apiConstructor ver node\n        , foldTreeChildren mkStack (\\i ls -> mkStack $ mkRes i : ls) node\n        ]\n\napiConstructor :: Version -> ApiResource -> Code\napiConstructor ver node =\n  rbClass "BaseApi"\n    [ function "initialize" ["resUrl"] $ mkStack\n        [ "@url" .=. ("resUrl + \'/v" ++ show ver ++ "/\'")\n        , "@api" .=. "self"\n        ]\n    , mkStack . map resGetter . subResources $ node\n    ]\n\nmkRes :: ApiResource -> Code\nmkRes node = mkResAcc node <-> mkResObj node\n\nmkResAcc :: ApiResource -> Code\nmkResAcc node =\n  rbClass (accessorName $ resId node)\n    [ accInitializer\n    , mkPreFuncs node\n    , mkStack . map resGetter . filter (not . hasAccessor) . subResources $ node\n    ]\n\nmkResObj :: ApiResource -> Code\nmkResObj node =\n  rbClass (className $ resId node)\n    [ objInitializer\n    , if hasAccessor node then get else noCode\n    , mkPostFuncs node\n    , mkStack . map resGetter . subResources $ node\n    ]\n\nmkPostFuncs :: ApiResource -> Code\nmkPostFuncs = mkStack . map mkFunction . filter (postAction . itemInfo) . resItems\n\nmkPreFuncs :: ApiResource -> Code\nmkPreFuncs node =\n  let (acs, funcs) = partition (isAccessor . itemInfo) . filter (not . postAction . itemInfo) $ resItems node\n  in mkStack (map mkAccessor acs) <-> mkStack (map mkFunction funcs)\n\nmkAccessor :: ApiAction -> Code\nmkAccessor node@(ApiAction rid _ ai) =\n  let fParams  = maybeToList mIdent\n      urlPart  = (if resDir ai == "" then "" else resDir ai ++ "/")\n              ++ maybe "" (\\i -> "\' + " ++ i ++ " + \'/") mIdent\n      datType  = maybe ":data" ((\':\':) . fst3 . mkType . L.get (dataType . desc) . chooseType)\n               . NList.nonEmpty . outputs $ ai\n      mIdent   = rbName . cleanName . description <$> ident ai\n  in function (rbName $ mkFuncParts node) fParams $ ret $\n        new (className rid) ["@url + \'" ++ urlPart ++ "\'", "@api", datType]\n\nmkFunction :: ApiAction -> Code\nmkFunction node@(ApiAction _ _ ai) =\n  let fParams   = maybeToList mIdent\n              ++ maybeToList (fmap fst3 mInp)\n              ++ ["params = {}", "headers = {}"]\n      mInp     = fmap (mkType . L.get (dataType . desc) . chooseType) . NList.nonEmpty . inputs $ ai\n      -- TODO Other clients call responseAcceptType here\n      mOut     = fmap (mkType . L.get (dataType . desc) . chooseType) . NList.nonEmpty . outputs $ ai\n      urlPart  = (if resDir ai == "" then "" else resDir ai ++ "/")\n              ++ maybe "" (\\i -> "\' + " ++ i ++ " + \'/") mIdent\n      mIdent   = rbName . cleanName . description <$> ident ai\n  in function (rbName $ mkFuncParts node) fParams $\n        call "internalSilkRequest"\n          [ code "@api"\n          , code $ \':\' : map toLower (show $ method ai)\n          , code $ "@url + \'" ++ urlPart ++ "\'"\n          , code "params"\n          , string $ maybe "text/plain" snd3 mInp\n          , code $ maybe ":data" ((\':\':) . fst3) mOut\n          , maybe (code "nil") (\\(p, _, f) -> f (code p)) mInp\n          , code "headers"\n          ]\n\naccInitializer :: Code\naccInitializer =\n  function "initialize" ["resUrl", "myApi"]\n     [ "@url"      .=. "resUrl"\n     , "@api"      .=. "myApi"\n     ]\n\nobjInitializer :: Code\nobjInitializer =\n  function "initialize" ["resUrl", "myApi", "retData = :data"]\n     [ "@url"      .=. "resUrl"\n     , "@dataType" .=. "retData"\n     , "@api"      .=. "myApi"\n     ]\n\nresGetter :: ApiResource -> Code\nresGetter node =\n  function (className [resName node]) [] $\n    ret $ new (accessorName $ resId node) ["@url + \'" ++ resName node ++ "/\'", "@api"]\n\nget :: Code\nget =\n  function "get" ["params = {}", "headers = {}"] $\n    call "internalSilkRequest" ["@api", ":get", "@url", "params", "\'text/plain\'", "@dataType", "headers"]\n\nrbName :: [String] -> String\nrbName []       = ""\nrbName (x : xs) = downFirst x ++ concatMap upFirst xs\n\nclassName :: ResourceId -> String\nclassName = concatMap upFirst . concatMap cleanName\n\naccessorName :: ResourceId -> String\naccessorName = concatMap upFirst . ("Access":) . concatMap cleanName\n\nmkType :: DataType -> (String, String, Code -> Code)\nmkType dt =\n  case dt of\n    String -> ("data", "text/plain", id)\n    XML    -> ("xml" , "text/xml", (<+> ".to_s"))\n    JSON   -> ("json", "text/json", call "mkJson")\n    File   -> ("file", "application/octet-stream", id)\n    Other  -> ("data", "text/plain", id)\n'