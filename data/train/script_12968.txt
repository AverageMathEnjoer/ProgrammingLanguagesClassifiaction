b'##################################################################\n# getPoly: generate poly terms of a data matrix / data frame\n##################################################################\n\n#\' @export\ngetPoly <- function(xdata = NULL, deg = 1, maxInteractDeg = deg,\n                    Xy = NULL, \n                    standardize = FALSE,\n                    noisy = TRUE, intercept = FALSE, \n                    returnDF = TRUE, \n                    modelFormula = NULL, retainedNames = NULL,\n                    ...)\n{\n\n  # maxInteractDeg <- maxInteractDeg + 1\n\n  if(sum(is.null(xdata) + is.null(Xy)) != 1)\n    stop("please provide getPoly() xdata or Xy (but not both).")\n \n  if (!is.null(xdata) && is.vector(xdata))\n     stop(\'xdata must be a matrix or data frame\')\n\n  W <- if(is.null(xdata)) Xy else xdata\n  nX <- if(is.null(xdata)) ncol(Xy)-1 else ncol(xdata)  # NM, 11/13/2020\n  if(noisy && !(is.matrix(W) || is.data.frame(W))){\n    cat(\'getPoly() expects a matrix or a data.frame.\\n\')\n    cat(\'The input will be coerced to a data.frame \\n\')\n  }\n  W <- as.data.frame(W, stringsAsFactors=TRUE)\n  namesW <- names(W)\n  W <- complete(W, noisy=noisy)\n  colnames(W) <- namesW\n  \n  if(standardize){\n    to_z <- which(unlist(lapply(W, is_continuous)))\n    W[,to_z] <- scale(W[,to_z])\n  }\n  \n  RHS <- NULL # initialize\n\n  if(is.null(modelFormula)){\n    \n    x_cols <- 1:(ncol(W) - is.null(xdata))\n    y_name <- if(is.null(xdata)) colnames(Xy)[ncol(Xy)] else NULL\n\n    remove(xdata)\n    remove(Xy)\n\n    # coerce binary or character variables into factors\n    W_distincts <- N_distinct(W)\n    to_factor <- which((W_distincts == 2) | unlist(lapply(W, is.character)))\n    #x_factors <- vector("logical", length(x_cols))\n    for(i in to_factor)\n      W[,i] <- as.factor(W[,i])\n    x_factors <- if(ncol(W) > 1) unlist(lapply(W[,x_cols], is.factor)) else is.factor(W[[1]])\n    P_factor <- sum(x_factors)\n\n    factor_features <- c()\n    # stores individual levels of factor variables, omitting one as reference\n    # e.g. for a variable "sex" coded as binary, just "male" will be stored\n    # this enables the appropriate formula to be written that handles interactions\n    # suppose the variable party had three levels the strings\n    # \'party == GOP\' and \'party == independent\' are stored\n    # and democrat is the reference...\n\n    for(i in which(x_factors)){\n\n      #if(W_distincts[i] == 2){\n        tmp <- paste(colnames(W)[i], "==",\n                     paste0("\\\'", levels(W[,i])[-1], "\\\'"))\n        tmp <- paste0("(", tmp, ")")\n        factor_features <- c(factor_features, tmp)\n      #}else{\n      #  factor_features <- c(factor_features, colnames(W)[i])\n      #}\n    }\n\n    features <- factor_features\n    P <- P_factor\n\n    if(sum(x_factors) != ncol(W)){ # at least some continuous x variables\n      \n      # names of continuous variables\n      cf <- colnames(W)[x_cols][!x_factors]\n      P_continuous <- length(cf)\n      P <- P_continuous + P_factor\n      # P does not reflect intercept, interactions, or polynomial terms\n      continuous_features <- c()\n     for(i in 1:deg)\n       continuous_features <- \n          c(continuous_features, paste0("I(", cf, "^", i, ")"))\n      # generate "I(x^1)", "I(x^2)", "I(x^3)", and so on\n      # the string above will be used to make the appropriate formula\n      # y ~ I(x^1) + I(x^2) + I(x^3)\n      # "I(x^1)" is overkill but aids with debugging ... \n      features <- c(continuous_features, factor_features)\n    } else cf <- NULL  # added by NM, 12/12/20\n    \n    # if (ncol(W) > 1)\n    features <- get_interactions(features, maxInteractDeg,\n                                 c(cf, names(x_factors[x_factors])),\n                                 maxDeg = deg)\n    # get_interactions now returns original features too by default\n    if(noisy && (length(features) > nrow(W)))\n      message("P > N. With polynomial terms and interactions, P is ",\n              length(features), ".\\n\\n", sep="")\n    \n    RHS <- paste0("~",  paste(features, collapse=" + "))\n    modelFormula <- as.formula(paste0(y_name, RHS))\n    # intercept handled by logical passed to model_matrix\n    \n  }\n \n  ## if (ncol(W) == 1) names(W)[1] <- \'V1\'  # bad kludge, NM, 11/12/20\n  X <- model_matrix(modelFormula, W, intercept, noisy, ...)\n  # if (!is.matrix(X)) X <- matrix(X,ncol=nX)\n  if (is.vector(X)) {\n     nms <- names(X)\n     X <- matrix(X,nrow=nrow(W))\n     colnames(X) <- nms\n  }\n  \n  if(is.null(retainedNames))\n    retainedNames <- colnames(X)\n  \n  polyMat <- polyMatrix(xdata = X, \n                        modelFormula = modelFormula, \n                        XtestFormula = if(is.null(RHS)) modelFormula else as.formula(RHS), \n                        retainedNames = retainedNames)\n\n  if(returnDF) return(polyDF(polyMat)) else return(polyMat)\n\n}\n\ngtPoly <- getPoly\n\n##################################################################\n# polyMatrix: the class of polyMatrix from getPoly\n##################################################################\n# helper function so that getPoly() can also be called in parallel\n# make polyMatrix <- function(...) so that it can be more flexible?\npolyMatrix <- function(xdata, modelFormula, XtestFormula, retainedNames)\n{\n  \n  if(!is.matrix(xdata)){\n    xdata <- matrix(t(xdata), nrow=1)\n    colnames(xdata) <- retainedNames\n  }\n  out <- list(xdata = xdata,\n              modelFormula = modelFormula,\n              XtestFormula = XtestFormula,\n              retainedNames = retainedNames)\n  class(out) <- "polyMatrix"\n  return(out)\n\n}\n\n# helper function to coerce a polyMatrix to a polyDataFrame\npolyDF <- function(polyMat)\n{\n\n  stopifnot(class(polyMat) == "polyMatrix")\n  polyMat$xdata <- as.data.frame(polyMat$xdata, stringsAsFactors=polyMat$stringsAsFactors)\n  if(length(polyMat$retainedNames) != length(colnames(polyMat$xdata))){\n    warning("xdata contains", length(colnames(polyMat$xdata)), \n        "columns but retainedNames has", length(polyMat$retainedNames), "items")\n  }\n  class(polyMat) <- c("polyMatrix", "polyDataFrame")\n  return(polyMat)\n  \n}\n\n\n# parallel version of getPoly()\n# needs updating\n# or to be absorbed into model_matrix()\n#\n#getPolyPar <- function(cls, xdata)\n#{\n#  distribsplit(cls,\'xdata\')\n#  cmd <- paste0(\'clusterEvalQ(cls, getPoly(xdata,\',\n#                deg,\',\',\n##                maxInteractDeg,\'))\')\n#  clusterEvalQ(cls,library(polyreg))\n#  res <- eval(parse(text=cmd))\n#  xd <- NULL\n#  for (i in 1:length(cls)) {\n#    xd <- rbind(xd,res[[i]]$xdata)\n#  }\n#  return (polyMatrix(xd, res[[1]]$endCols))\n#}\n\npolyAllVsAll <- function(plm.xy, classes, stringsAsFactors=TRUE)\n{\n  plm.xy <- as.data.frame(plm.xy, stringsAsFactors=TRUE)\n  len <- length(classes)\n  ft <- list()\n  for (i in 1:len) {\n    ft[[i]] <- list()\n    for (j in 1:len) {\n      if (i == j) # same class\n        next\n      newxy <- plm.xy[plm.xy$y == classes[i] | plm.xy$y == classes[j],]\n      newxy$y <- ifelse(newxy$y == classes[i], 1, 0)\n      ft[[i]][[j]] <- glm(y~., family = binomial(link = "logit"), data = newxy)\n    } # for j\n  } # for i\n  return(ft)\n}\n\npolyOneVsAll <- function(plm.xy, classes, cls=NULL) \n{\n  plm.xy <- as.data.frame(plm.xy, stringsAsFactors=TRUE)\n  ft <- list()\n  predClassi <- function(i)\n  {\n    oneclass <- plm.xy[plm.xy$y == classes[i],]\n    oneclass$y <- 1\n    allclass <- plm.xy[plm.xy$y != classes[i],]\n    allclass$y <- 0\n    new_xy <- rbind(oneclass, allclass)\n    glm(y~., family = binomial(link = "logit"), data = new_xy)\n  }\n  if (is.null(cls)) {\n    for (i in 1:length(classes)) {\n      #     oneclass <- plm.xy[plm.xy$y == classes[i],]\n      #     oneclass$y <- 1\n      #     allclass <- plm.xy[plm.xy$y != classes[i],]\n      #     allclass$y <- 0\n      #     new_xy <- rbind(oneclass, allclass)\n      #     ft[[i]] <- glm(y~., family = binomial(link = "logit"), data = new_xy)\n      ft[[i]] <- predClassi(i)\n    }\n  } else {\n    clusterExport(cls,c(\'plm.xy\',\'predClassi\'),envir=environment())\n    ft <- clusterApply(cls,1:length(classes),predClassi)\n  }\n  return(ft)\n}\n'