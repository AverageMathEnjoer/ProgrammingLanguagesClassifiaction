b'#define SQLITE_OS_WIN\nusing u32 = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 16\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    ******************************************************************************\n    **\n    ** This header file (together with is companion C source-code file\n    ** "os.c") attempt to abstract the underlying operating system so that\n    ** the SQLite library will work on both POSIX and windows systems.\n    **\n    ** This header file is #include-ed by sqliteInt.h and thus ends up\n    ** being included by every source file.\n    **\n    ** $Id: os.h,v 1.108 2009/02/05 16:31:46 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n#if !_SQLITE_OS_H_\n    //#define _SQLITE_OS_H_\n\n    /*\n    ** Figure out if we are dealing with Unix, Windows, or some other\n    ** operating system.  After the following block of preprocess macros,\n    ** all of SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, and SQLITE_OS_OTHER\n    ** will defined to either 1 or 0.  One of the four will be 1.  The other\n    ** three will be 0.\n    */\n    //#if defined(SQLITE_OS_OTHER)\n    //# if SQLITE_OS_OTHER==1\n    //#   undef SQLITE_OS_UNIX\n    //#   define SQLITE_OS_UNIX 0\n    //#   undef SQLITE_OS_WIN\n    //#   define SQLITE_OS_WIN 0\n    //#   undef SQLITE_OS_OS2\n    //#   define SQLITE_OS_OS2 0\n    //# else\n    //#   undef SQLITE_OS_OTHER\n    //# endif\n    //#endif\n    //#if !(SQLITE_OS_UNIX) && !SQLITE_OS_OTHER)\n    //# define SQLITE_OS_OTHER 0\n    //# ifndef SQLITE_OS_WIN\n    //#   if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)\n    //#     define SQLITE_OS_WIN 1\n    //#     define SQLITE_OS_UNIX 0\n    //#     define SQLITE_OS_OS2 0\n    //#   elif defined(__EMX__) || defined(_OS2) || defined(OS2) || defined(_OS2_) || defined(__OS2__)\n    //#     define SQLITE_OS_WIN 0\n    //#     define SQLITE_OS_UNIX 0\n    //#     define SQLITE_OS_OS2 1\n    //#   else\n    //#     define SQLITE_OS_WIN 0\n    //#     define SQLITE_OS_UNIX 1\n    //#     define SQLITE_OS_OS2 0\n    //#  endif\n    //# else\n    //#  define SQLITE_OS_UNIX 0\n    //#  define SQLITE_OS_OS2 0\n    //# endif\n    //#else\n    //# ifndef SQLITE_OS_WIN\n    //#  define SQLITE_OS_WIN 0\n    //# endif\n    //#endif\n\n    const bool SQLITE_OS_WIN = true;\n    const bool SQLITE_OS_UNIX = false;\n    const bool SQLITE_OS_OS2 = false;\n\n    /*\n    ** Determine if we are dealing with WindowsCE - which has a much\n    ** reduced API.\n    */\n    //#if defined(_WIN32_WCE)\n    //# define SQLITE_OS_WINCE 1\n    //#else\n    //# define SQLITE_OS_WINCE 0\n    //#endif\n\n    /*\n    ** Define the maximum size of a temporary filename\n    */\n#if SQLITE_OS_WIN\n    //# include <windows.h>\n    const int MAX_PATH = 260;\n    const int SQLITE_TEMPNAME_SIZE = ( MAX_PATH + 50 ); //# define SQLITE_TEMPNAME_SIZE (MAX_PATH+50)\n#elif SQLITE_OS_OS2\n# if FALSE //(__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 3) && OS2_HIGH_MEMORY)\n//#  include <os2safe.h> /* has to be included before os2.h for linking to work */\n# endif\n//# define INCL_DOSDATETIME\n//# define INCL_DOSFILEMGR\n//# define INCL_DOSERRORS\n//# define INCL_DOSMISC\n//# define INCL_DOSPROCESS\n//# define INCL_DOSMODULEMGR\n//# define INCL_DOSSEMAPHORES\n//# include <os2.h>\n//# include <uconv.h>\n//# define SQLITE_TEMPNAME_SIZE (CCHMAXPATHCOMP)\n//#else\n//# define SQLITE_TEMPNAME_SIZE 200\n#endif\n\n    /* If the SET_FULLSYNC macro is not defined above, then make it\n** a no-op\n*/\n    //#if !SET_FULLSYNC\n    //# define SET_FULLSYNC(x,y)\n    //#endif\n\n    /*\n    ** The default size of a disk sector\n    */\n#if !SQLITE_DEFAULT_SECTOR_SIZE\n    const int SQLITE_DEFAULT_SECTOR_SIZE = 512;//# define SQLITE_DEFAULT_SECTOR_SIZE 512\n#endif\n\n    /*\n** Temporary files are named starting with this prefix followed by 16 random\n** alphanumeric characters, and no file extension. They are stored in the\n** OS\'s standard temporary file directory, and are deleted prior to exit.\n** If sqlite is being embedded in another program, you may wish to change the\n** prefix to reflect your program\'s name, so that if your program exits\n** prematurely, old temporary files can be easily identified. This can be done\n** using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.\n**\n** 2006-10-31:  The default prefix used to be "sqlite_".  But then\n** Mcafee started using SQLite in their anti-virus product and it\n** started putting files with the "sqlite" name in the c:/temp folder.\n** This annoyed many windows users.  Those users would then do a\n** Google search for "sqlite", find the telephone numbers of the\n** developers and call to wake them up at night and complain.\n** For this reason, the default name prefix is changed to be "sqlite"\n** spelled backwards.  So the temp files are still identified, but\n** anybody smart enough to figure out the code is also likely smart\n** enough to know that calling the developer will not help get rid\n** of the file.\n*/\n#if !SQLITE_TEMP_FILE_PREFIX\n    const string SQLITE_TEMP_FILE_PREFIX = "etilqs_"; //# define SQLITE_TEMP_FILE_PREFIX "etilqs_"\n#endif\n\n    /*\n** The following values may be passed as the second argument to\n** sqlite3OsLock(). The various locks exhibit the following semantics:\n**\n** SHARED:    Any number of processes may hold a SHARED lock simultaneously.\n** RESERVED:  A single process may hold a RESERVED lock on a file at\n**            any time. Other processes may hold and obtain new SHARED locks.\n** PENDING:   A single process may hold a PENDING lock on a file at\n**            any one time. Existing SHARED locks may persist, but no new\n**            SHARED locks may be obtained by other processes.\n** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.\n**\n** PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, a\n** process that requests an EXCLUSIVE lock may actually obtain a PENDING\n** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to\n** sqlite3OsLock().\n*/\n    const int NO_LOCK = 0;\n    const int SHARED_LOCK = 1;\n    const int RESERVED_LOCK = 2;\n    const int PENDING_LOCK = 3;\n    const int EXCLUSIVE_LOCK = 4;\n\n    /*\n    ** File Locking Notes:  (Mostly about windows but also some info for Unix)\n    **\n    ** We cannot use LockFileEx() or UnlockFileEx() on Win95/98/ME because\n    ** those functions are not available.  So we use only LockFile() and\n    ** UnlockFile().\n    **\n    ** LockFile() prevents not just writing but also reading by other processes.\n    ** A SHARED_LOCK is obtained by locking a single randomly-chosen\n    ** byte out of a specific range of bytes. The lock byte is obtained at\n    ** random so two separate readers can probably access the file at the\n    ** same time, unless they are unlucky and choose the same lock byte.\n    ** An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.\n    ** There can only be one writer.  A RESERVED_LOCK is obtained by locking\n    ** a single byte of the file that is designated as the reserved lock byte.\n    ** A PENDING_LOCK is obtained by locking a designated byte different from\n    ** the RESERVED_LOCK byte.\n    **\n    ** On WinNT/2K/XP systems, LockFileEx() and UnlockFileEx() are available,\n    ** which means we can use reader/writer locks.  When reader/writer locks\n    ** are used, the lock is placed on the same range of bytes that is used\n    ** for probabilistic locking in Win95/98/ME.  Hence, the locking scheme\n    ** will support two or more Win95 readers or two or more WinNT readers.\n    ** But a single Win95 reader will lock out all WinNT readers and a single\n    ** WinNT reader will lock out all other Win95 readers.\n    **\n    ** The following #defines specify the range of bytes used for locking.\n    ** SHARED_SIZE is the number of bytes available in the pool from which\n    ** a random byte is selected for a shared lock.  The pool of bytes for\n    ** shared locks begins at SHARED_FIRST.\n    **\n    ** The same locking strategy and\n    ** byte ranges are used for Unix.  This leaves open the possiblity of having\n    ** clients on win95, winNT, and unix all talking to the same shared file\n    ** and all locking correctly.  To do so would require that samba (or whatever\n    ** tool is being used for file sharing) implements locks correctly between\n    ** windows and unix.  I\'m guessing that isn\'t likely to happen, but by\n    ** using the same locking range we are at least open to the possibility.\n    **\n    ** Locking in windows is manditory.  For this reason, we cannot store\n    ** actual data in the bytes used for locking.  The pager never allocates\n    ** the pages involved in locking therefore.  SHARED_SIZE is selected so\n    ** that all locks will fit on a single page even at the minimum page size.\n    ** PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTE\n    ** is set high so that we don\'t have to allocate an unused page except\n    ** for very large databases.  But one should test the page skipping logic\n    ** by setting PENDING_BYTE low and running the entire regression suite.\n    **\n    ** Changing the value of PENDING_BYTE results in a subtly incompatible\n    ** file format.  Depending on how it is changed, you might not notice\n    ** the incompatibility right away, even running a full regression test.\n    ** The default location of PENDING_BYTE is the first byte past the\n    ** 1GB boundary.\n    **\n    */\n    static int PENDING_BYTE = 0x40000000; //sqlite3PendingByte;\n\n    static int RESERVED_BYTE = ( PENDING_BYTE + 1 );\n    static int SHARED_FIRST = ( PENDING_BYTE + 2 );\n    static int SHARED_SIZE = 510;\n\n    /*\n    ** Functions for accessing sqlite3_file methods\n    */\n    //int sqlite3OsClose(sqlite3_file*);\n    //int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);\n    //int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);\n    //int sqlite3OsTruncate(sqlite3_file*, i64 size);\n    //int sqlite3OsSync(sqlite3_file*, int);\n    //int sqlite3OsFileSize(sqlite3_file*, i64 pSize);\n    //int sqlite3OsLock(sqlite3_file*, int);\n    //int sqlite3OsUnlock(sqlite3_file*, int);\n    //int sqlite3OsCheckReservedLock(sqlite3_file *id, int pResOut);\n    //int sqlite3OsFileControl(sqlite3_file*,int,void*);\n    //#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0\n    const u32 SQLITE_FCNTL_DB_UNCHANGED = 0xca093fa0;\n\n    //int sqlite3OsSectorSize(sqlite3_file *id);\n    //int sqlite3OsDeviceCharacteristics(sqlite3_file *id);\n\n    /*\n    ** Functions for accessing sqlite3_vfs methods\n    */\n    //int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);\n    //int sqlite3OsDelete(sqlite3_vfs *, const char *, int);\n    //int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int pResOut);\n    //int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);\n#if !SQLITE_OMIT_LOAD_EXTENSION\n    //void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);\n    //void sqlite3OsDlError(sqlite3_vfs *, int, char *);\n    //void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);\n    //void sqlite3OsDlClose(sqlite3_vfs *, void *);\n#endif\n    //int sqlite3OsRandomness(sqlite3_vfs *, int, char *);\n    //int sqlite3OsSleep(sqlite3_vfs *, int);\n    //int sqlite3OsCurrentTime(sqlite3_vfs *, double*);\n\n    /*\n    ** Convenience functions for opening and closing files using\n    ** sqlite3Malloc() to obtain space for the file-handle structure.\n    */\n    //int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);\n    //int sqlite3OsCloseFree(sqlite3_file *);\n#endif // * _SQLITE_OS_H_ */\n\n  }\n}\n'