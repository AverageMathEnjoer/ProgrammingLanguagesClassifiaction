b'package com.github.razir.progressbutton\n\nimport android.content.Context\nimport android.graphics.drawable.Animatable\nimport android.graphics.drawable.Drawable\nimport android.text.SpannableString\nimport android.text.Spanned\nimport android.util.TypedValue\nimport android.widget.TextView\nimport androidx.annotation.StringRes\nimport androidx.appcompat.text.AllCapsTransformationMethod\nimport androidx.core.content.ContextCompat\nimport androidx.swiperefreshlayout.widget.CircularProgressDrawable\n\n/**\n *   Shows progress on the button with defined params.\n *   If params are not defined uses the default one.\n *\n *   The example of usage\n *\n *   button.showProgress { buttonText = "Loading", progressColor = Color.WHITE }\n *\n *   If you want to continue using your button after showing the progress,\n *   please hide the progress and clean up resources by calling:\n *   @see TextView.hideProgress\n *\n *   @receiver button to show the progress\n *   @param params use to set the text,position and customize the progress look\n */\n@JvmOverloads\nfun TextView.showProgress(params: ProgressParams.() -> Unit = {}) {\n    val paramValues = ProgressParams()\n    paramValues.params()\n    showProgress(paramValues)\n}\n\n/**\n *   Shows your animated drawable on the button with defined params.\n *   Important: drawable bounds should be defined already (eg. drawable.setBounds)\n *   If params are not defined uses the default one.\n *\n *   The example of usage:\n *\n *   button.showDrawable(yourDrawable) { buttonText = "Done" }\n *\n *   If you want to continue using your button after showing the drawable,\n *   please hide the drawable and clean up resources by calling:\n *   @see TextView.hideDrawable\n *\n *   @receiver button to show the drawable\n *   @param drawable your animated drawable. Will be played automatically\n *   @param params use to set the text,position and margin\n */\n@JvmOverloads\nfun TextView.showDrawable(\n    drawable: Drawable,\n    params: DrawableParams.() -> Unit = {}\n) {\n    val paramValues = DrawableParams()\n    paramValues.params()\n    showDrawable(drawable, paramValues)\n}\n\n/**\n * @return true if progress is currently showing and false if not\n */\nfun TextView.isProgressActive() = isDrawableActive()\n\n/**\n * @return true if drawable is currently showing and false if not\n */\nfun TextView.isDrawableActive(): Boolean {\n    return activeViews.contains(this)\n}\n\n/**\n * Hides the progress and clean up internal references\n * This method is required to call if you want to continue using your button\n * @param newText String value to show after hiding the progress\n */\n@JvmOverloads\nfun TextView.hideProgress(newText: String? = null) = hideDrawable(newText)\n\n/**\n * Hides the progress and clean up internal references\n * This method is required to call if you want to continue using your button\n * @param newTextRes String resource to show after hiding the progress\n */\nfun TextView.hideProgress(@StringRes newTextRes: Int) = hideDrawable(newTextRes)\n\n/**\n * Hides the progress and clean up internal references\n * This method is required to call if you want to continue using your button\n * @param newText String value to show after hiding the progress\n */\n@JvmOverloads\nfun TextView.hideDrawable(newText: String? = null) {\n    cleanUpDrawable()\n    if (isAnimatorAttached()) {\n        animateTextChange(newText)\n    } else {\n        this.text = newText\n    }\n}\n\n/**\n * Hides the drawable and clean up internal references\n * This method is required to call if you want to continue using your button\n * @param newTextRes String resource to show after hiding the progress\n */\nfun TextView.hideDrawable(@StringRes newTextRes: Int) {\n    hideDrawable(context.getString(newTextRes))\n}\n\n\n/**\n *   Shows progress on button.\n *   [Java back support version]\n */\ninternal fun TextView.showProgress(params: ProgressParams) {\n    params.apply {\n        val res = context.resources\n        val progressStrokeValue = progressStrokeRes?.let { res.getDimensionPixelSize(it) } ?: progressStrokePx\n        val progressRadiusValue = progressRadiusRes?.let { res.getDimensionPixelSize(it) } ?: progressRadiusPx\n        val colors = when {\n            progressColorRes != null -> intArrayOf(ContextCompat.getColor(context, progressColorRes!!))\n            progressColor != null -> intArrayOf(progressColor!!)\n            progressColors != null -> progressColors!!\n            else -> intArrayOf()\n        }\n        val progressDrawable = generateProgressDrawable(context, colors, progressRadiusValue, progressStrokeValue)\n        showDrawable(progressDrawable, params)\n    }\n}\n\n/*\n    Shows any animated drawable on button.\n    [Java back support version]\n */\ninternal fun TextView.showDrawable(\n    drawable: Drawable,\n    paramValues: DrawableParams\n) {\n    paramValues.apply {\n        val res = context.resources\n        val buttonTextValue = buttonTextRes?.let { context.getString(it) } ?: buttonText\n        val textMarginValue = textMarginRes?.let { res.getDimensionPixelSize(it) } ?: textMarginPx\n        showDrawable(drawable, buttonTextValue, gravity, textMarginValue)\n    }\n}\n\nprivate fun TextView.showDrawable(\n    drawable: Drawable,\n    text: String?,\n    gravity: Int,\n    textMarginPx: Int\n) {\n    if (isDrawableActive()) {\n        cleanUpDrawable()\n    }\n    // Workaround to check if textAllCaps==true on any android api version\n    if (transformationMethod?.javaClass?.name == "android.text.method.AllCapsTransformationMethod" ||\n        transformationMethod is AllCapsTransformationMethod\n    ) {\n        transformationMethod = AllCapsSpannedTransformationMethod(context)\n    }\n\n    val drawableMargin = if (textMarginPx == DrawableButton.DEFAULT) {\n        context.dpToPixels(DEFAULT_DRAWABLE_MARGIN_DP)\n    } else {\n        textMarginPx\n    }\n    val animatorAttached = isAnimatorAttached()\n    val newText = getDrawableSpannable(drawable, text, gravity, drawableMargin, animatorAttached)\n    if (animatorAttached) {\n        animateTextChange(newText)\n    } else {\n        this.text = newText\n    }\n\n    addDrawableAttachViewListener()\n    setupDrawableCallback(this, drawable)\n    if (drawable is Animatable) {\n        drawable.start()\n    }\n}\n\nprivate fun setupDrawableCallback(textView: TextView, drawable: Drawable) {\n    val callback = object : Drawable.Callback {\n        override fun unscheduleDrawable(who: Drawable, what: Runnable) {\n        }\n\n        override fun invalidateDrawable(who: Drawable) {\n            textView.invalidate()\n        }\n\n        override fun scheduleDrawable(who: Drawable, what: Runnable, `when`: Long) {\n        }\n    }\n    activeViews[textView] = DrawableViewData(drawable, callback)\n    drawable.callback = callback\n    if (drawable is Animatable) {\n        drawable.start()\n    }\n}\n\nprivate fun generateProgressDrawable(\n    context: Context,\n    progressColors: IntArray,\n    progressRadiusPx: Int,\n    progressStrokePx: Int\n\n): CircularProgressDrawable {\n    return CircularProgressDrawable(context).apply {\n        setStyle(CircularProgressDrawable.DEFAULT)\n\n        if (progressColors.isNotEmpty()) {\n            setColorSchemeColors(*progressColors)\n        }\n        if (progressRadiusPx != DrawableButton.DEFAULT) {\n            centerRadius = progressRadiusPx.toFloat()\n        }\n        if (progressStrokePx != DrawableButton.DEFAULT) {\n            strokeWidth = progressStrokePx.toFloat()\n        }\n        val size = (centerRadius + strokeWidth).toInt() * 2\n        setBounds(0, 0, size, size)\n    }\n}\n\nprivate fun getDrawableSpannable(\n    drawable: Drawable,\n    text: String?,\n    gravity: Int,\n    drawableMarginPx: Int,\n    useTextAlpha: Boolean\n): SpannableString {\n    val drawableSpan = DrawableSpan(drawable, useTextAlpha = useTextAlpha)\n    return when (gravity) {\n        DrawableButton.GRAVITY_TEXT_START -> {\n            drawableSpan.paddingEnd = drawableMarginPx\n            SpannableString(" ${text ?: ""}").apply {\n                setSpan(drawableSpan, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)\n            }\n        }\n        DrawableButton.GRAVITY_TEXT_END -> {\n            drawableSpan.paddingStart = drawableMarginPx\n            SpannableString("${text ?: ""} ").apply {\n                setSpan(drawableSpan, length - 1, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)\n            }\n        }\n        DrawableButton.GRAVITY_CENTER -> {\n            SpannableString(" ").apply {\n                setSpan(drawableSpan, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)\n            }\n        }\n        else -> throw IllegalArgumentException("Please set the correct gravity")\n    }\n}\n\ninternal data class DrawableViewData(var drawable: Drawable, val callback: Drawable.Callback)\n\nprivate const val DEFAULT_DRAWABLE_MARGIN_DP = 10f\n\nprivate fun Context.dpToPixels(dpValue: Float) =\n    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, resources.displayMetrics).toInt()'