b'#include "AsyncTask.h"\n#include <chrono>\n#include <cassert>\n\nITask::ITask()\n{}\nITask::~ITask()\n{}\nvoid ITask::onEnqueue(TaskProgressManager &progressManager)\n{}\nbool ITask::isReady()\n{\n\treturn true;\n}\n\nTaskProgressCallback::TaskProgressCallback() {}\nTaskProgressCallback::~TaskProgressCallback() {}\nvoid TaskProgressCallback::OnAdd(std::shared_ptr<ITask> &pTask){}\nvoid TaskProgressCallback::OnProgress(std::shared_ptr<ITask> &pTask, unsigned int progress, unsigned int range){}\nvoid TaskProgressCallback::OnProgressDesc(std::shared_ptr<ITask> &pTask, const std::string &desc){}\nvoid TaskProgressCallback::OnLogMessage(std::shared_ptr<ITask> &pTask, const std::string &msg){}\nvoid TaskProgressCallback::OnCompletion(std::shared_ptr<ITask> &pTask, TaskResult result){}\nvoid TaskProgressCallback::OnCancelableChange(std::shared_ptr<ITask>& pTask, bool cancelable) {}\n\nTaskProgressManager::TaskProgressManager(TaskManager *pManager, std::shared_ptr<ITask> _pTask)\n\t: pManager(pManager), pTask(std::move(_pTask)), cancelable(false), canceled(false)\n{}\n\nstd::shared_ptr<ITask> &TaskProgressManager::getTask()\n{\n\treturn this->pTask;\n}\nvoid TaskProgressManager::setProgress(unsigned int progress, unsigned int range)\n{\n\tthis->pManager->LockCallbacksDelete();\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->pManager->taskListMutex);\n\tstd::vector<TaskProgressCallback*> tempCallbacks(this->pManager->callbacks);\n\ttaskListLock.unlock();\n\n\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\ttempCallbacks[i]->OnProgress(this->pTask, progress, range);\n\n\tthis->pManager->UnlockCallbacksDelete();\n}\nvoid TaskProgressManager::setProgressDesc(const std::string &desc)\n{\n\tthis->pManager->LockCallbacksDelete();\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->pManager->taskListMutex);\n\tstd::vector<TaskProgressCallback*> tempCallbacks(this->pManager->callbacks);\n\ttaskListLock.unlock();\n\n\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\ttempCallbacks[i]->OnProgressDesc(this->pTask, desc);\n\n\tthis->pManager->UnlockCallbacksDelete();\n}\nvoid TaskProgressManager::logMessage(const std::string &msg)\n{\n\tthis->pManager->LockCallbacksDelete();\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->pManager->taskListMutex);\n\tstd::vector<TaskProgressCallback*> tempCallbacks(this->pManager->callbacks);\n\ttaskListLock.unlock();\n\n\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\ttempCallbacks[i]->OnLogMessage(this->pTask, msg);\n\n\tthis->pManager->UnlockCallbacksDelete();\n}\nvoid TaskProgressManager::setCancelable()\n{\n\tbool prevCancelable = this->cancelable.exchange(true);\n\tif (prevCancelable)\n\t\treturn;\n\tthis->pManager->LockCallbacksDelete();\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->pManager->taskListMutex);\n\tstd::vector<TaskProgressCallback*> tempCallbacks(this->pManager->callbacks);\n\ttaskListLock.unlock();\n\n\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\ttempCallbacks[i]->OnCancelableChange(this->pTask, true);\n\n\tthis->pManager->UnlockCallbacksDelete();\n}\nbool TaskProgressManager::isCanceled()\n{\n\treturn this->canceled.load();\n}\n\nstruct TaskThreadParam\n{\n\tTaskManager *pThis;\n\tunsigned int threadIdx;\n};\nvoid TaskManager::TaskThread(void *param)\n{\n\tTaskManager *pThis;\n\tunsigned int threadIdx;\n\t{\n\t\tTaskThreadParam *pParam = (TaskThreadParam*)param;\n\t\tpThis = pParam->pThis;\n\t\tthreadIdx = pParam->threadIdx;\n\t\tdelete pParam;\n\t}\n\t++pThis->nThreadsReady;\n\tbool lastHadTask = false;\n\t//HANDLE waitHandles[2] = {pThis->hNewTaskEvent, pThis->hThreadCloseEvent};\n\twhile (true)\n\t{\n\t\tstd::unique_lock<std::mutex> threadEventLock(pThis->threadEventMutex);\n\t\tif (!lastHadTask)\n\t\t{\n\t\t\tpThis->threadEventVar.wait(threadEventLock, [pThis]() {return pThis->newTaskEvent || pThis->threadCloseEvent; });\n\t\t}\n\t\t//if (lastHadTask || WaitForMultipleObjects(2, waitHandles, FALSE, INFINITE) == WAIT_OBJECT_0)\n\t\tif (lastHadTask || pThis->newTaskEvent)\n\t\t{\n\t\t\t//Have to unlock threadEventLock here to prevent deadlocks\n\t\t\t// if the owner of taskListMutex waits for threadEventMutex.\n\t\t\tthreadEventLock.unlock();\n\t\t\tstd::unique_lock<std::recursive_mutex> taskListLock(pThis->taskListMutex);\n\t\t\tif (pThis->tasks.size() < 1)\n\t\t\t{\n\t\t\t\t//newTaskEvent is always set within \n\t\t\t\tpThis->newTaskEvent = false;\n\t\t\t\ttaskListLock.unlock();\n\t\t\t\tlastHadTask = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//New tasks are always pushed to the front.\n\t\t\t\t//std::list has persistent iterators, i.e. the iterator stays valid until the element is removed.\n\t\t\t\tauto elemIterator = pThis->tasks.begin();\n\t\t\t\twhile (!elemIterator->taken && !elemIterator->pTask->isReady()) {\n\t\t\t\t\telemIterator++;\n\t\t\t\t}\n\t\t\t\tbool taken = (elemIterator == pThis->tasks.end()) || (elemIterator->taken);\n\t\t\t\tstd::shared_ptr<ITask> pCurTask;\n\t\t\t\tTaskProgressManager *pCurProgMgr;\n\t\t\t\tif (!taken)\n\t\t\t\t{\n\t\t\t\t\tTaskDesc &curTaskDesc = *elemIterator;\n\t\t\t\t\tpCurTask = curTaskDesc.pTask;\n\t\t\t\t\tpCurProgMgr = curTaskDesc.pProgMgr;\n\t\t\t\t\t//Take this task and move it to the back.\n\t\t\t\t\tcurTaskDesc.taken = true;\n\n\t\t\t\t\tTaskDesc curTaskDescCopy = curTaskDesc;\n\t\t\t\t\tpThis->tasks.erase(elemIterator);\n\t\t\t\t\tpThis->tasks.push_back(curTaskDescCopy);\n\t\t\t\t\telemIterator = pThis->tasks.end();\n\t\t\t\t\t--elemIterator;\n\n\t\t\t\t\t--pThis->nThreadsReady;\n\t\t\t\t\t++pThis->nThreadsWorking;\n\t\t\t\t\t//Reset the new task event if no more tasks are waiting.\n\t\t\t\t\tif (pThis->tasks.size() >= 1 && pThis->tasks.front().taken)\n\t\t\t\t\t\tpThis->newTaskEvent = false;\n\t\t\t\t}\n\t\t\t\ttaskListLock.unlock();\n\t\t\t\tif (!taken)\n\t\t\t\t{\n\t\t\t\t\tpThis->LockCallbacksDelete();\n\t\t\t\t\ttaskListLock.lock();\n\t\t\t\t\tstd::vector<TaskProgressCallback*> tempCallbacks(pThis->callbacks);\n\t\t\t\t\ttaskListLock.unlock();\n\n\t\t\t\t\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\t\t\t\t\ttempCallbacks[i]->OnCancelableChange(pCurTask, false);\n\t\t\t\t\ttempCallbacks.clear();\n\t\t\t\t\tpThis->UnlockCallbacksDelete();\n\n\t\t\t\t\t//Execute the task.\n\t\t\t\t\tTaskResult result = pCurTask->execute(*pCurProgMgr);\n\n\t\t\t\t\tpThis->LockCallbacksDelete();\n\t\t\t\t\ttaskListLock.lock();\n\t\t\t\t\ttempCallbacks = pThis->callbacks;\n\t\t\t\t\t//Remove the task from the list.\n\t\t\t\t\tpThis->tasks.erase(elemIterator);\n\t\t\t\t\ttaskListLock.unlock();\n\n\t\t\t\t\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\t\t\t\t\ttempCallbacks[i]->OnCompletion(pCurTask, result);\n\t\t\t\t\tpThis->UnlockCallbacksDelete();\n\n\n\t\t\t\t\tdelete pCurProgMgr;\n\n\t\t\t\t\t--pThis->nThreadsWorking;\n\t\t\t\t\t++pThis->nThreadsReady;\n\t\t\t\t\tlastHadTask = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlastHadTask = false;\n\t\t\t}\n\t\t}\n\t\telse if (threadIdx >= pThis->nMaxThreads)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tthreadEventLock.unlock();\n\t\t\tusing namespace std::chrono_literals;\n\t\t\tstd::this_thread::sleep_for(10ms);\n\t\t}\n\t}\n\t--pThis->nThreadsReady;\n\t--pThis->nThreads;\n\t{\n\t\tstd::scoped_lock<std::mutex> lock(pThis->threadEventMutex);\n\t\tpThis->threadClosedEvent = true;\n\t}\n\tpThis->threadClosedEventVar.notify_all();\n\t--pThis->nThreadsCommit;\n\treturn;\n}\nvoid TaskManager::LockCallbacksDelete()\n{\n\t//Make sure no callbacks are being removed while we operate. Busy waiting.\n\twhile (true) {\n\t\t++this->nThreadsProcessingCallbacks;\n\t\t//Alternative : Surround increment and if condition in critical section (also see removeCallback).\n\t\tstd::atomic_thread_fence(std::memory_order::seq_cst);\n\t\tif (this->nCallbackRemovalsInProgress)\n\t\t{\n\t\t\t--this->nThreadsProcessingCallbacks;\n\t\t\twhile (this->nCallbackRemovalsInProgress) {std::this_thread::yield();}\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n}\nvoid TaskManager::UnlockCallbacksDelete()\n{\n\t--this->nThreadsProcessingCallbacks;\n}\n\nTaskManager::TaskManager(unsigned int nMaxThreads)\n{\n\tthis->newTaskEvent = false;\n\tthis->threadCloseEvent = false;\n\tthis->threadClosedEvent = false;\n\tthis->nMaxThreads = nMaxThreads;\n\tthis->nThreads = 0;\n\tthis->nThreadsCommit = 0;\n\tthis->nThreadsReady = 0;\n\tthis->nThreadsProcessingCallbacks = 0;\n\tthis->nCallbackRemovalsInProgress = 0;\n}\nTaskManager::~TaskManager()\n{\n\tsetMaxThreads(0);\n\t//Make sure we don\'t delete hThreadClosedEvent before the last SetEvent call has been processed.\n\twhile (this->nThreadsCommit > 0){}\n\tauto taskIterator = this->tasks.cbegin();\n\tfor (; taskIterator != this->tasks.cend(); ++taskIterator) {delete taskIterator->pProgMgr;}\n\tthis->tasks.clear();\n}\nbool TaskManager::setMaxThreads(unsigned int nMaxThreads, bool allowRequiredWait, bool waitClose)\n{\n\tauto waitThreadsClosed = [this]()\n\t{\n\t\t{\n\t\t\tstd::scoped_lock<std::mutex> lock(this->threadEventMutex);\n\t\t\tthis->threadCloseEvent = true;\n\t\t}\n\t\tthis->threadEventVar.notify_all();\n\t\twhile (this->nThreads > this->nMaxThreads)\n\t\t{\n\t\t\tstd::unique_lock<std::mutex> lock(this->threadEventMutex);\n\t\t\tthis->threadClosedEventVar.wait(lock, [this]() {return this->threadClosedEvent; });\n\t\t\tthis->threadClosedEvent = false;\n\t\t}\n\t\tthreads.erase(threads.begin() + nThreads, threads.end());\n\t};\n\tif (this->nThreads > this->nMaxThreads && nMaxThreads > this->nMaxThreads)\n\t{\n\t\t//Still waiting for some threads to close after having reduced nMaxThreads.\n\t\t//Raising nMaxThreads again could otherwise cause gaps in the thread ID assignment.\n\t\tif (allowRequiredWait)\n\t\t{\n\t\t\twaitThreadsClosed();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Make sure the value is updated if setMaxThreads is called again.\n\t\t\tstd::atomic_thread_fence(std::memory_order::seq_cst);\n\t\t\treturn false;\n\t\t}\n\t}\n\tthis->nMaxThreads = nMaxThreads;\n\twaitThreadsClosed();\n\t//ResetEvent(this->hThreadCloseEvent);\n\treturn true;\n}\nbool TaskManager::enqueue(std::shared_ptr<ITask> pTask)\n{\n\tTaskDesc taskDesc;\n\ttaskDesc.pProgMgr = new TaskProgressManager(this, pTask);\n\ttaskDesc.pTask = pTask; taskDesc.taken = false;\n\tpTask->onEnqueue(*taskDesc.pProgMgr);\n\n\tbool startNewThread = false;\n\tunsigned int newThreadIdx;\n\n\t//callbacks is only modified by the main thread.\n\tfor (size_t i = 0; i < this->callbacks.size(); i++)\n\t{\n\t\tthis->callbacks[i]->OnAdd(pTask);\n\t\tthis->callbacks[i]->OnCancelableChange(pTask, true);\n\t}\n\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->taskListMutex);\n\tauto taskIterator = this->tasks.cbegin();\n\tfor (; taskIterator != this->tasks.cend() && !taskIterator->taken; ++taskIterator) {}\n\tthis->tasks.emplace(taskIterator, taskDesc);\n\tif (this->nThreadsReady == 0 && this->nThreads < this->nMaxThreads)\n\t{\n\t\tnewThreadIdx = this->nThreads;\n\t\t++this->nThreads;\n\t\tstartNewThread = true;\n\t}\n\t{\n\t\tstd::scoped_lock<std::mutex> threadEventLock(threadEventMutex);\n\t\tnewTaskEvent = true;\n\t}\n\t//notify_one would probably be more performant since each Task can only be run by one thread.\n\tthreadEventVar.notify_all();\n\ttaskListLock.unlock();\n\n\tif (startNewThread)\n\t{\n\t\tTaskThreadParam *pParam = new TaskThreadParam;\n\t\tpParam->pThis = this;\n\t\tpParam->threadIdx = newThreadIdx;\n\t\t++this->nThreadsCommit;\n\t\tassert(newThreadIdx == threads.size());\n\t\tthreads.emplace_back(&TaskThread, (void*)pParam);\n\t}\n\treturn true;\n}\nbool TaskManager::cancel(ITask *pTask, bool *out_taskRunning)\n{\n\tbool ret = false, taskRunning = false;\n\tif (out_taskRunning)\n\t\t*out_taskRunning = false;\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->taskListMutex);\n\t//callbacks is only modified by the main thread.\n\tstd::vector<TaskProgressCallback*> tempCallbacks = this->callbacks;\n\tauto taskIterator = this->tasks.cbegin();\n\tstd::shared_ptr<ITask> taskRef;\n\tfor (; taskIterator != this->tasks.cend() && taskIterator->pTask.get() != pTask; ++taskIterator) {}\n\tif (taskIterator != this->tasks.cend())\n\t{\n\t\ttaskRef = taskIterator->pTask;\n\t\tif (taskIterator->taken)\n\t\t{\n\t\t\tif (taskIterator->pProgMgr->cancelable)\n\t\t\t{\n\t\t\t\ttaskIterator->pProgMgr->canceled.store(true);\n\t\t\t\tret = true;\n\t\t\t\ttaskRunning = true;\n\t\t\t\tif (out_taskRunning)\n\t\t\t\t\t*out_taskRunning = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete taskIterator->pProgMgr;\n\t\t\tthis->tasks.erase(taskIterator);\n\t\t\tret = true;\n\t\t}\n\t}\n\ttaskListLock.unlock();\n\tif (ret)\n\t{\n\t\tfor (size_t i = 0; i < tempCallbacks.size(); i++)\n\t\t{\n\t\t\tif (taskRunning)\n\t\t\t\ttempCallbacks[i]->OnCancelableChange(taskRef, false);\n\t\t\telse\n\t\t\t\ttempCallbacks[i]->OnCompletion(taskRef, TaskResult_Canceled);\n\t\t}\n\t}\n\treturn ret;\n}\nvoid TaskManager::addCallback(TaskProgressCallback *pCallback)\n{\n\tstd::scoped_lock<std::recursive_mutex> taskListLock(this->taskListMutex);\n\tthis->callbacks.push_back(pCallback);\n}\nvoid TaskManager::removeCallback(TaskProgressCallback *pCallback)\n{\n\t//Custom critical section : no thread may use callbacks while the main thread removes one to prevent use-after-free conditions.\n\t++this->nCallbackRemovalsInProgress;\n\t//Alternative : Surround "...=true;" and first condition check in critical section (also see TaskThread).\n\tstd::atomic_thread_fence(std::memory_order::seq_cst);\n\twhile (this->nThreadsProcessingCallbacks > 0) {std::this_thread::yield();}\n\t\n\t//Inner critical section specifically for callbacks.\n\tstd::unique_lock<std::recursive_mutex> taskListLock(this->taskListMutex);\n\tfor (size_t _i = this->callbacks.size(); _i > 0; _i--)\n\t{\n\t\tsize_t i = _i - 1;\n\t\tif (this->callbacks[i] == pCallback)\n\t\t{\n\t\t\tthis->callbacks.erase(this->callbacks.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttaskListLock.unlock();\n\t--this->nCallbackRemovalsInProgress;\n}'