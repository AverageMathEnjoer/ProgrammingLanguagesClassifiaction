b"\n-- | Buffer abstracts from file IO\n\nmodule Pdf.Core.IO.Buffer\n(\n  Buffer(..),\n  toInputStream,\n  fromHandle,\n  fromBytes,\n  dropExactly\n)\nwhere\n\nimport Prelude hiding (read)\nimport Data.Int\nimport Data.IORef\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as ByteString\nimport Control.Monad\nimport System.IO\nimport qualified System.IO.Streams as Streams\nimport System.IO.Streams.Internal (InputStream(..))\nimport qualified System.IO.Streams.Internal as Streams\n\n-- | Interface to file\ndata Buffer = Buffer\n  { read :: IO (Maybe ByteString)\n  , size :: IO Int64\n  , seek :: Int64 -> IO ()\n  , back :: Int64 -> IO ()\n  , tell :: IO Int64\n  }\n\n-- | Convert buffer to 'InputStream'\ntoInputStream :: Buffer -> InputStream ByteString\ntoInputStream buf = InputStream\n  { Streams._read = read buf\n  , Streams._unRead = back buf . fromIntegral . ByteString.length\n  }\n\n-- | Make buffer from handle\n--\n-- Don't touch the handle while using buffer\nfromHandle :: Handle -> IO Buffer\n-- it is in IO in case we'll need to store intermediate state\nfromHandle h = return $ Buffer\n  { read = do\n      bs <- ByteString.hGetSome h defaultSize\n      if ByteString.null bs\n        then return Nothing\n        else return (Just bs)\n  , size = fromIntegral <$> hFileSize h\n  , seek = hSeek h AbsoluteSeek . fromIntegral\n  , back = hSeek h RelativeSeek . negate . fromIntegral\n  , tell = fromIntegral <$> hTell h\n  }\n\n-- | Buffer from strict 'ByteString'\n--\n-- That is mostly for testing\nfromBytes :: ByteString -> IO Buffer\nfromBytes bs = do\n  ref <- newIORef 0\n  return Buffer\n    { read = do\n        pos <- readIORef ref\n        let chunk = ByteString.drop pos bs\n        modifyIORef ref (+ ByteString.length chunk)\n        if ByteString.null chunk\n          then return Nothing\n          else return (Just chunk)\n    , seek = writeIORef ref . fromIntegral\n    , size = return $ fromIntegral (ByteString.length bs)\n    , back = modifyIORef ref . flip (-) . fromIntegral\n    , tell = fromIntegral <$> readIORef ref\n    }\n\n-- | Drop specified number of bytes from input stream\ndropExactly :: Int -> InputStream ByteString -> IO ()\ndropExactly n = void . Streams.readExactly n\n\ndefaultSize :: Int\ndefaultSize = 32752\n"