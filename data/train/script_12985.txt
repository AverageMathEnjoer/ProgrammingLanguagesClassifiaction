b'{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-record-updates #-}\n\nmodule Hoodle.Type.Canvas\n  ( -- * data types\n    CanvasId,\n    PenDraw (..),\n    emptyPenDraw,\n    ViewInfo (..),\n    CanvasInfo (..),\n    CanvasInfoBox (..),\n    CanvasInfoMap,\n    MyScrollWindow (..),\n    PenHighlighterEraserSet,\n    PenInfo,\n    WidthColorStyle,\n\n    -- * default constructor\n    defaultViewInfoSinglePage,\n    defaultCvsInfoSinglePage,\n    defaultCanvasWidgets,\n    defaultPenWCS,\n    defaultEraserWCS,\n    defaultTextWCS,\n    defaultHighligherWCS,\n    defaultPenInfo,\n\n    -- * lenses\n    points,\n    zoomMode,\n    pageArrangement,\n    canvasId,\n    drawArea,\n    mDrawSurface,\n    scrolledWindow,\n    viewInfo,\n    currentPageNum,\n    -- , currentPage\n    horizAdjustment,\n    vertAdjustment,\n    horizAdjConnId,\n    vertAdjConnId,\n    adjustments,\n    canvasWidgets,\n    notifiedItem,\n    -- , panZoomWidgetPosition\n    currentTool,\n    penWidth,\n    penColor,\n    currPen,\n    currHighlighter,\n    currEraser,\n    currText,\n    currVerticalSpace,\n    penType,\n    penSet,\n    variableWidthPen,\n\n    -- * for box\n    xfrmCvsInfo,\n    xfrmViewInfo,\n    getDrawAreaFromBox,\n    unboxLens,\n    unboxBiAct,\n    unboxBiXform,\n    forBoth,\n    forBoth\',\n\n    -- * others\n    updateCanvasDimForSingle,\n    updateCanvasDimForContSingle,\n  )\nwhere\n\nimport Control.Lens (Lens\', lens, set, view)\nimport Data.Hoodle.BBox (BBox (..))\nimport Data.Hoodle.Predefined\n  ( predefinedEraserMedium,\n    predefinedHighlighterMedium,\n    predefinedMedium,\n  )\nimport Data.Hoodle.Simple (Dimension (..))\nimport qualified Data.IntMap as M\nimport Data.Sequence (Seq, empty)\nimport Graphics.Hoodle.Render.Type.Item (RItem)\nimport Graphics.Hoodle.Render.Type.Renderer (CanvasId)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Type.Enum\n  ( PenColor (..),\n    PenType (..),\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasDimension (..),\n    PageArrangement (..),\n    PageDimension (..),\n    PageNum (..),\n    ViewMode (..),\n    ViewPortBBox (..),\n    ZoomMode (..),\n    getRatioPageCanvas,\n  )\nimport Hoodle.Type.Widget\n  ( CanvasWidgets,\n    defaultCanvasWidgets,\n  )\n\n-- |\nnewtype PenDraw = PenDraw {_points :: Seq (Double, Double)}\n  deriving (Show)\n\n-- | lens for zoomMode\npoints :: Lens\' PenDraw (Seq (Double, Double))\npoints = lens _points (\\f a -> f {_points = a})\n\n-- |\ndata ViewInfo (a :: ViewMode) = ViewInfo\n  { _zoomMode :: ZoomMode,\n    _pageArrangement :: PageArrangement a\n  }\n\nxfrmViewInfo ::\n  (PageArrangement a -> PageArrangement b) ->\n  ViewInfo a ->\n  ViewInfo b\nxfrmViewInfo f ViewInfo {..} =\n  ViewInfo\n    { _zoomMode = _zoomMode,\n      _pageArrangement = f _pageArrangement\n    }\n\n-- |\nemptyPenDraw :: PenDraw\nemptyPenDraw = PenDraw empty\n\n-- | default view info with single page mode\ndefaultViewInfoSinglePage :: ViewInfo \'SinglePage\ndefaultViewInfoSinglePage =\n  ViewInfo\n    { _zoomMode = Original,\n      _pageArrangement =\n        SingleArrangement\n          (CanvasDimension (Dim 100 100))\n          (PageDimension (Dim 100 100))\n          (ViewPortBBox (BBox (0, 0) (100, 100)))\n    }\n\n-- | lens for zoomMode\nzoomMode :: Lens\' (ViewInfo a) ZoomMode\nzoomMode = lens _zoomMode (\\f a -> f {_zoomMode = a})\n\n-- |\npageArrangement :: Lens\' (ViewInfo a) (PageArrangement a)\npageArrangement = lens _pageArrangement (\\f a -> f {_pageArrangement = a})\n\ndata MyScrollWindow = MyScrollWindow\n  { _scrollCanvas :: Gtk.VBox,\n    _scrollHScrollbar :: Gtk.HScrollbar,\n    _scrollVScrollbar :: Gtk.VScrollbar\n  }\n\n-- |\ndata CanvasInfo (a :: ViewMode) = CanvasInfo\n  { _canvasId :: CanvasId,\n    _drawArea :: Gtk.DrawingArea,\n    _mDrawSurface :: Maybe Cairo.Surface,\n    _scrolledWindow :: MyScrollWindow, -- Gtk.ScrolledWindow\n    _viewInfo :: ViewInfo a,\n    _currentPageNum :: Int,\n    _horizAdjustment :: Gtk.Adjustment,\n    _vertAdjustment :: Gtk.Adjustment,\n    _horizAdjConnId :: Maybe (Gtk.ConnectId Gtk.Adjustment),\n    _vertAdjConnId :: Maybe (Gtk.ConnectId Gtk.Adjustment),\n    _canvasWidgets :: CanvasWidgets,\n    _notifiedItem :: Maybe (PageNum, BBox, RItem)\n  }\n\n-- |\nxfrmCvsInfo ::\n  (ViewInfo a -> ViewInfo b) ->\n  CanvasInfo a ->\n  CanvasInfo b\nxfrmCvsInfo f CanvasInfo {..} =\n  CanvasInfo\n    { _canvasId = _canvasId,\n      _drawArea = _drawArea,\n      _mDrawSurface = _mDrawSurface,\n      _scrolledWindow = _scrolledWindow,\n      _viewInfo = f _viewInfo,\n      _currentPageNum = _currentPageNum,\n      _horizAdjustment = _horizAdjustment,\n      _vertAdjustment = _vertAdjustment,\n      _horizAdjConnId = _horizAdjConnId,\n      _vertAdjConnId = _vertAdjConnId,\n      _canvasWidgets = _canvasWidgets,\n      _notifiedItem = _notifiedItem\n    }\n\n-- |\ndefaultCvsInfoSinglePage :: CanvasInfo \'SinglePage\ndefaultCvsInfoSinglePage =\n  CanvasInfo\n    { _canvasId = error "defaultCvsInfoSinglePage cvsid",\n      _drawArea = error "defaultCvsInfoSinglePage DrawingArea",\n      _mDrawSurface = Nothing,\n      _scrolledWindow = error "ScrolledWindow",\n      _viewInfo = defaultViewInfoSinglePage,\n      _currentPageNum = 0,\n      _horizAdjustment = error "adjustment",\n      _vertAdjustment = error "vadjust",\n      _horizAdjConnId = Nothing,\n      _vertAdjConnId = Nothing,\n      _canvasWidgets = defaultCanvasWidgets,\n      _notifiedItem = Nothing\n    }\n\n-- |\ncanvasId :: Lens\' (CanvasInfo a) CanvasId\ncanvasId = lens _canvasId (\\f a -> f {_canvasId = a})\n\n-- |\ndrawArea :: Lens\' (CanvasInfo a) Gtk.DrawingArea\ndrawArea = lens _drawArea (\\f a -> f {_drawArea = a})\n\n-- |\nmDrawSurface :: Lens\' (CanvasInfo a) (Maybe Cairo.Surface)\nmDrawSurface = lens _mDrawSurface (\\f a -> f {_mDrawSurface = a})\n\n-- |\nscrolledWindow :: Lens\' (CanvasInfo a) MyScrollWindow\nscrolledWindow = lens _scrolledWindow (\\f a -> f {_scrolledWindow = a})\n\n-- |\nviewInfo :: Lens\' (CanvasInfo a) (ViewInfo a)\nviewInfo = lens _viewInfo (\\f a -> f {_viewInfo = a})\n\n-- |\ncurrentPageNum :: Lens\' (CanvasInfo a) Int\ncurrentPageNum = lens _currentPageNum (\\f a -> f {_currentPageNum = a})\n\n-- |\nhorizAdjustment :: Lens\' (CanvasInfo a) Gtk.Adjustment\nhorizAdjustment = lens _horizAdjustment (\\f a -> f {_horizAdjustment = a})\n\n-- |\nvertAdjustment :: Lens\' (CanvasInfo a) Gtk.Adjustment\nvertAdjustment = lens _vertAdjustment (\\f a -> f {_vertAdjustment = a})\n\n-- | ConnectId for horizontal scrollbar value change event\nhorizAdjConnId :: Lens\' (CanvasInfo a) (Maybe (Gtk.ConnectId Gtk.Adjustment))\nhorizAdjConnId = lens _horizAdjConnId (\\f a -> f {_horizAdjConnId = a})\n\n-- | ConnectId for vertical scrollbar value change event\nvertAdjConnId :: Lens\' (CanvasInfo a) (Maybe (Gtk.ConnectId Gtk.Adjustment))\nvertAdjConnId = lens _vertAdjConnId (\\f a -> f {_vertAdjConnId = a})\n\n-- | composition lens\nadjustments :: Lens\' (CanvasInfo a) (Gtk.Adjustment, Gtk.Adjustment)\nadjustments = lens getter setter\n  where\n    getter = (,) <$> view horizAdjustment <*> view vertAdjustment\n    setter f (h, v) = set horizAdjustment h . set vertAdjustment v $ f\n\n-- | lens for canavs widgets\ncanvasWidgets :: Lens\' (CanvasInfo a) CanvasWidgets\ncanvasWidgets = lens _canvasWidgets (\\f a -> f {_canvasWidgets = a})\n\n-- | lens for notified item\nnotifiedItem :: Lens\' (CanvasInfo a) (Maybe (PageNum, BBox, RItem))\nnotifiedItem = lens _notifiedItem (\\f a -> f {_notifiedItem = a})\n\n-- |\ndata CanvasInfoBox where\n  CanvasSinglePage :: CanvasInfo \'SinglePage -> CanvasInfoBox\n  CanvasContPage :: CanvasInfo \'ContinuousPage -> CanvasInfoBox\n\nforBoth ::\n  ( (CanvasInfo \'SinglePage -> f (CanvasInfo \'SinglePage)) ->\n    (CanvasInfo \'ContinuousPage -> f (CanvasInfo \'ContinuousPage)) ->\n    (CanvasInfoBox -> f CanvasInfoBox)\n  ) ->\n  (forall a. CanvasInfo a -> f (CanvasInfo a)) ->\n  CanvasInfoBox ->\n  f CanvasInfoBox\nforBoth m f = m f f\n\nforBoth\' ::\n  ( (CanvasInfo \'SinglePage -> r) ->\n    (CanvasInfo \'ContinuousPage -> r) ->\n    (CanvasInfoBox -> r)\n  ) ->\n  (forall a. CanvasInfo a -> r) ->\n  CanvasInfoBox ->\n  r\nforBoth\' m f = m f f\n\n-- | single page action and continuous page act\nunboxBiXform ::\n  (Functor f) =>\n  (CanvasInfo \'SinglePage -> f (CanvasInfo \'SinglePage)) ->\n  (CanvasInfo \'ContinuousPage -> f (CanvasInfo \'ContinuousPage)) ->\n  CanvasInfoBox ->\n  f CanvasInfoBox\nunboxBiXform fsingle _fcont (CanvasSinglePage cinfo) = fmap CanvasSinglePage (fsingle cinfo)\nunboxBiXform _fsingle fcont (CanvasContPage cinfo) = fmap CanvasContPage (fcont cinfo)\n\n-- | single page action and continuous page act\nunboxBiAct ::\n  (CanvasInfo \'SinglePage -> r) ->\n  (CanvasInfo \'ContinuousPage -> r) ->\n  CanvasInfoBox ->\n  r\nunboxBiAct fsingle _fcont (CanvasSinglePage cinfo) = fsingle cinfo\nunboxBiAct _fsingle fcont (CanvasContPage cinfo) = fcont cinfo\n\n-- |\nunboxGet :: (forall a. Lens\' (CanvasInfo a) b) -> CanvasInfoBox -> b\nunboxGet f = forBoth\' unboxBiAct (view f)\n\n-- |\nunboxSet :: (forall a. Lens\' (CanvasInfo a) b) -> b -> CanvasInfoBox -> CanvasInfoBox\nunboxSet l b (CanvasSinglePage a) = CanvasSinglePage (set l b a)\nunboxSet l b (CanvasContPage a) = CanvasContPage (set l b a)\n\nunboxLens :: (forall a. Lens\' (CanvasInfo a) b) -> Lens\' CanvasInfoBox b\nunboxLens l = lens (unboxGet l) (flip (unboxSet l))\n\n-- |\ngetDrawAreaFromBox :: CanvasInfoBox -> Gtk.DrawingArea\ngetDrawAreaFromBox = view (unboxLens drawArea)\n\n-- |\ntype CanvasInfoMap = M.IntMap CanvasInfoBox\n\n-- |\ndata WidthColorStyle\n  = WidthColorStyle\n      { _penWidth :: Double,\n        _penColor :: PenColor\n      }\n  | NoWidthColorStyle\n  deriving (Show)\n\n-- | lens for penWidth\npenWidth :: Lens\' WidthColorStyle Double\npenWidth = lens _penWidth (\\f a -> f {_penWidth = a})\n\n-- | lens for penColor\npenColor :: Lens\' WidthColorStyle PenColor\npenColor = lens _penColor (\\f a -> f {_penColor = a})\n\n-- |\ndata PenHighlighterEraserSet = PenHighlighterEraserSet\n  { _currPen :: WidthColorStyle,\n    _currHighlighter :: WidthColorStyle,\n    _currEraser :: WidthColorStyle,\n    _currText :: WidthColorStyle,\n    _currVerticalSpace :: WidthColorStyle\n  }\n  deriving (Show)\n\n-- | lens for currPen\ncurrPen :: Lens\' PenHighlighterEraserSet WidthColorStyle\ncurrPen = lens _currPen (\\f a -> f {_currPen = a})\n\n-- | lens for currHighlighter\ncurrHighlighter :: Lens\' PenHighlighterEraserSet WidthColorStyle\ncurrHighlighter = lens _currHighlighter (\\f a -> f {_currHighlighter = a})\n\n-- | lens for currEraser\ncurrEraser :: Lens\' PenHighlighterEraserSet WidthColorStyle\ncurrEraser = lens _currEraser (\\f a -> f {_currEraser = a})\n\n-- | lens for currText\ncurrText :: Lens\' PenHighlighterEraserSet WidthColorStyle\ncurrText = lens _currText (\\f a -> f {_currText = a})\n\n-- | lens for currText\ncurrVerticalSpace :: Lens\' PenHighlighterEraserSet WidthColorStyle\ncurrVerticalSpace =\n  lens\n    _currVerticalSpace\n    (\\f a -> f {_currVerticalSpace = a})\n\n-- |\ndata PenInfo = PenInfo\n  { _penType :: PenType,\n    _penSet :: PenHighlighterEraserSet,\n    _variableWidthPen :: Bool\n  }\n  deriving (Show)\n\n-- | lens for penType\npenType :: Lens\' PenInfo PenType\npenType = lens _penType (\\f a -> f {_penType = a})\n\n-- | lens for penSet\npenSet :: Lens\' PenInfo PenHighlighterEraserSet\npenSet = lens _penSet (\\f a -> f {_penSet = a})\n\n-- | lens for variableWidthPen\nvariableWidthPen :: Lens\' PenInfo Bool\nvariableWidthPen = lens _variableWidthPen (\\f a -> f {_variableWidthPen = a})\n\n-- |\ncurrentTool :: Lens\' PenInfo WidthColorStyle\ncurrentTool = lens chooser setter\n  where\n    chooser pinfo = case _penType pinfo of\n      PenWork -> _currPen . _penSet $ pinfo\n      HighlighterWork -> _currHighlighter . _penSet $ pinfo\n      EraserWork -> _currEraser . _penSet $ pinfo\n      VerticalSpaceWork -> NoWidthColorStyle\n    setter pinfo wcs =\n      let pset = _penSet pinfo\n          psetnew = case _penType pinfo of\n            PenWork -> pset {_currPen = wcs}\n            HighlighterWork -> pset {_currHighlighter = wcs}\n            EraserWork -> pset {_currEraser = wcs}\n            VerticalSpaceWork -> pset\n       in pinfo {_penSet = psetnew}\n\n-- |\ndefaultPenWCS :: WidthColorStyle\ndefaultPenWCS = WidthColorStyle predefinedMedium ColorBlack\n\n-- |\ndefaultEraserWCS :: WidthColorStyle\ndefaultEraserWCS = WidthColorStyle predefinedEraserMedium ColorWhite\n\n-- |\ndefaultTextWCS :: WidthColorStyle\ndefaultTextWCS = defaultPenWCS\n\n-- |\ndefaultHighligherWCS :: WidthColorStyle\ndefaultHighligherWCS = WidthColorStyle predefinedHighlighterMedium ColorYellow\n\n-- |\ndefaultPenInfo :: PenInfo\ndefaultPenInfo =\n  PenInfo\n    { _penType = PenWork,\n      _penSet =\n        PenHighlighterEraserSet\n          { _currPen = defaultPenWCS,\n            _currHighlighter = defaultHighligherWCS,\n            _currEraser = defaultEraserWCS,\n            _currText = defaultTextWCS,\n            _currVerticalSpace = NoWidthColorStyle\n          },\n      _variableWidthPen = False\n    }\n\n-- |\nupdateCanvasDimForSingle ::\n  CanvasDimension ->\n  CanvasInfo \'SinglePage ->\n  IO (CanvasInfo \'SinglePage)\nupdateCanvasDimForSingle cdim@(CanvasDimension (Dim w\' h\')) cinfo = do\n  let zmode = view (viewInfo . zoomMode) cinfo\n      SingleArrangement _ pdim (ViewPortBBox bbox) =\n        view (viewInfo . pageArrangement) cinfo\n      (x, y) = bbox_upperleft bbox\n      (sinvx, sinvy) = getRatioPageCanvas zmode pdim cdim\n      nbbox = BBox (x, y) (x + w\' / sinvx, y + h\' / sinvy)\n      arr\' = SingleArrangement cdim pdim (ViewPortBBox nbbox)\n  maybe (return ()) Cairo.surfaceFinish $ view mDrawSurface cinfo\n  msfc <- fmap Just $ do\n    sfc <-\n      Cairo.createImageSurface\n        Cairo.FormatARGB32\n        (floor w\')\n        (floor h\')\n    Cairo.renderWith sfc $ do\n      Cairo.setSourceRGBA 0.5 0.5 0.5 1\n      Cairo.rectangle 0 0 w\' h\'\n      Cairo.fill\n    return sfc\n  return $ (set (viewInfo . pageArrangement) arr\' . set mDrawSurface msfc) cinfo\n\n-- |\nupdateCanvasDimForContSingle ::\n  PageDimension ->\n  CanvasDimension ->\n  CanvasInfo \'ContinuousPage ->\n  IO (CanvasInfo \'ContinuousPage)\nupdateCanvasDimForContSingle pdim cdim@(CanvasDimension (Dim w\' h\')) cinfo = do\n  let zmode = view (viewInfo . zoomMode) cinfo\n      ContinuousArrangement _ ddim func (ViewPortBBox bbox) =\n        view (viewInfo . pageArrangement) cinfo\n      (x, y) = bbox_upperleft bbox\n      (sinvx, sinvy) = getRatioPageCanvas zmode pdim cdim\n      nbbox = BBox (x, y) (x + w\' / sinvx, y + h\' / sinvy)\n      arr\' = ContinuousArrangement cdim ddim func (ViewPortBBox nbbox)\n  maybe (return ()) Cairo.surfaceFinish $ view mDrawSurface cinfo\n  msfc <- fmap Just $ do\n    sfc <-\n      Cairo.createImageSurface\n        Cairo.FormatARGB32\n        (floor w\')\n        (floor h\')\n    Cairo.renderWith sfc $ do\n      Cairo.setSourceRGBA 0.5 0.5 0.5 1\n      Cairo.rectangle 0 0 w\' h\'\n      Cairo.fill\n    return sfc\n  return $ (set (viewInfo . pageArrangement) arr\' . set mDrawSurface msfc) cinfo\n'