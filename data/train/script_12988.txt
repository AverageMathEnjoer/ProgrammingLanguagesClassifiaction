b'{-# LANGUAGE BangPatterns #-}\n{-|\n    A collection of useful parallel combinators based on top of a \'Par\' monad.\n\n    In particular, this module provides higher order functions for\n     traversing data structures in parallel.\n\n-}\n\nmodule Control.Monad.Par.Combinator\n  (\n    parMap, parMapM,\n    parMapReduceRangeThresh, parMapReduceRange,\n    InclusiveRange(..),\n    parFor\n  )\nwhere\n\nimport Control.DeepSeq\nimport Data.Traversable\nimport Control.Monad as M hiding (mapM, sequence, join)\nimport Prelude hiding (mapM, sequence, head, tail, min, max, init)\nimport GHC.Conc (numCapabilities)\n\nimport Control.Monad.Par.Class\n\n-- -----------------------------------------------------------------------------\n-- Parallel maps over Traversable data structures\n\n-- | Applies the given function to each element of a data structure\n-- in parallel (fully evaluating the results), and returns a new data\n-- structure containing the results.\n--\n-- > parMap f xs = mapM (spawnP . f) xs >>= mapM get\n--\n-- @parMap@ is commonly used for lists, where it has this specialised type:\n--\n-- > parMap :: NFData b => (a -> b) -> [a] -> Par [b]\n--\nparMap :: (Traversable t, NFData b, ParFuture iv p) => (a -> b) -> t a -> p (t b)\nparMap f xs = mapM (spawnP . f) xs >>= mapM get\n\n-- | Like \'parMap\', but the function is a @Par@ monad operation.\n--\n-- > parMapM f xs = mapM (spawn . f) xs >>= mapM get\n--\nparMapM :: (Traversable t, NFData b, ParFuture iv p) => (a -> p b) -> t a -> p (t b)\nparMapM f xs = mapM (spawn . f) xs >>= mapM get\n\n-- TODO: parBuffer\n\n\n\n-- --------------------------------------------------------------------------------\n\n-- TODO: Perhaps should introduce a class for the "splittable range" concept.\ndata InclusiveRange = InclusiveRange Int Int\n\n-- | Computes a binary map\\/reduce over a finite range.  The range is\n-- recursively split into two, the result for each half is computed in\n-- parallel, and then the two results are combined.  When the range\n-- reaches the threshold size, the remaining elements of the range are\n-- computed sequentially.\n--\n-- For example, the following is a parallel implementation of\n--\n-- >  foldl (+) 0 (map (^2) [1..10^6])\n--\n-- > parMapReduceRangeThresh 100 (InclusiveRange 1 (10^6))\n-- >        (\\x -> return (x^2))\n-- >        (\\x y -> return (x+y))\n-- >        0\n--\nparMapReduceRangeThresh\n   :: (NFData a, ParFuture iv p)\n      => Int                            -- ^ threshold\n      -> InclusiveRange                 -- ^ range over which to calculate\n      -> (Int -> p a)                 -- ^ compute one result\n      -> (a -> a -> p a)              -- ^ combine two results (associative)\n      -> a                              -- ^ initial result\n      -> p a\n\nparMapReduceRangeThresh threshold (InclusiveRange min\' max\') fn binop init\n = loop min\' max\'\n where\n  loop min max\n    | max - min <= threshold =\n        let mapred a b = do x <- fn b;\n                            result <- a `binop` x\n                            return result\n        in foldM mapred init [min..max]\n\n    | otherwise  = do\n        let mid = min + ((max - min) `quot` 2)\n        rght <- spawn $ loop (mid+1) max\n        l  <- loop  min    mid\n        r  <- get rght\n        l `binop` r\n\n-- How many tasks per process should we aim for?  Higher numbers\n-- improve load balance but put more pressure on the scheduler.\nauto_partition_factor :: Int\nauto_partition_factor = 4\n\n-- | \\"Auto-partitioning\\" version of \'parMapReduceRangeThresh\' that chooses the threshold based on\n--    the size of the range and the number of processors..\nparMapReduceRange :: (NFData a, ParFuture iv p) =>\n                     InclusiveRange -> (Int -> p a) -> (a -> a -> p a) -> a -> p a\nparMapReduceRange (InclusiveRange start end) fn binop init =\n   loop (length segs) segs\n where\n  segs = splitInclusiveRange (auto_partition_factor * numCapabilities) (start,end)\n  loop 1 [(st,en)] =\n     let mapred a b = do x <- fn b;\n                         result <- a `binop` x\n                         return result\n     in foldM mapred init [st..en]\n  loop n segs\' =\n     let half = n `quot` 2\n         (left,right) = splitAt half segs\' in\n     do l  <- spawn$ loop half left\n        r  <- loop (n-half) right\n        l\' <- get l\n        l\' `binop` r\n\n\n-- TODO: A version that works for any splittable input domain.  In this case\n-- the "threshold" is a predicate on inputs.\n-- parMapReduceRangeGeneric :: (inp -> Bool) -> (inp -> Maybe (inp,inp)) -> inp ->\n\n\n-- Experimental:\n\n-- | Parallel for-loop over an inclusive range.  Semantically equivalent\n-- to\n--\n-- > parFor (InclusiveRange n m) f = forM_ [n..m] f\n--\n-- except that the implementation will split the work into an\n-- unspecified number of subtasks in an attempt to gain parallelism.\n-- The exact number of subtasks is chosen at runtime, and is probably\n-- a small multiple of the available number of processors.\n--\n-- Strictly speaking the semantics of \'parFor\' depends on the\n-- number of processors, and its behaviour is therefore not\n-- deterministic.  However, a good rule of thumb is to not have any\n-- interdependencies between the elements; if this rule is followed\n-- then @parFor@ has deterministic semantics.  One easy way to follow\n-- this rule is to only use \'put\' or \'put_\' in @f@, never \'get\'.\n\nparFor :: (ParFuture iv p) => InclusiveRange -> (Int -> p ()) -> p ()\nparFor (InclusiveRange start end) body =\n do\n    let run (x,y) = for_ x (y+1) body\n        range_segments = splitInclusiveRange (4*numCapabilities) (start,end)\n\n    vars <- M.forM range_segments (\\ pr -> spawn_ (run pr))\n    M.mapM_ get vars\n    return ()\n\nsplitInclusiveRange :: Int -> (Int, Int) -> [(Int, Int)]\nsplitInclusiveRange pieces (start,end) =\n  map largepiece [0..remain-1] ++\n  map smallpiece [remain..pieces-1]\n where\n   len = end - start + 1 -- inclusive [start,end]\n   (portion, remain) = len `quotRem` pieces\n   largepiece i =\n       let offset = start + (i * (portion + 1))\n       in (offset, offset + portion)\n   smallpiece i =\n       let offset = start + (i * portion) + remain\n       in (offset, offset + portion - 1)\n\n-- My own forM for numeric ranges (not requiring deforestation optimizations).\n-- Inclusive start, exclusive end.\n{-# INLINE for_ #-}\nfor_ :: Monad m => Int -> Int -> (Int -> m ()) -> m ()\nfor_ start end _fn | start > end = error "for_: start is greater than end"\nfor_ start end fn = loop start\n  where\n   loop !i | i == end  = return ()\n           | otherwise = do fn i; loop (i+1)\n'