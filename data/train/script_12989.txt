b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE CPP #-}\n\nmodule Database.Beam.Query.Combinators\n    ( -- * Various SQL functions and constructs\n      coalesce_, fromMaybe_, position_\n    , charLength_, octetLength_, bitLength_\n    , currentTimestamp_\n    , lower_, upper_\n    , trim_\n\n    -- ** @IF-THEN-ELSE@ support\n    , if_, then_, else_\n    , then_\'\n    , ifThenElse_, bool_\n\n    -- * SQL @UPDATE@ assignments\n    , (<-.), current_\n\n    -- * Project Haskell values to \'QGenExpr\'s\n    , HaskellLiteralForQExpr\n    , SqlValable(..), SqlValableTable\n    , default_\n\n    -- * General query combinators\n\n    , all_, values_\n    , allFromView_, join_, join_\'\n    , guard_, guard_\', filter_, filter_\'\n    , related_, relatedBy_, relatedBy_\'\n    , leftJoin_, leftJoin_\'\n    , perhaps_, outerJoin_, outerJoin_\'\n    , subselect_, references_, references_\'\n\n    , nub_\n\n    , SqlJustable(..)\n    , SqlDeconstructMaybe(..)\n    , SqlOrderable\n    , QIfCond, QIfElse\n    , (<|>.)\n\n    , limit_, offset_\n\n    , as_\n\n    -- ** Subqueries\n    , exists_, unique_, distinct_, subquery_\n\n    -- ** Set operations\n    -- |  \'Q\' values can be combined using a variety of set operations. See the\n    --    <https://haskell-beam.github.io/beam/user-guide/queries/combining-queries manual section>.\n    , union_, unionAll_\n    , intersect_, intersectAll_\n    , except_, exceptAll_\n\n    -- * Window functions\n    -- | See the corresponding\n    --   <https://haskell-beam.github.io/beam/user-guide/queries/window-functions manual section> for more.\n    , over_, frame_, bounds_, unbounded_, nrows_, fromBound_\n    , noBounds_, noOrder_, noPartition_\n    , partitionBy_, orderPartitionBy_, withWindow_\n\n    -- * Ordering primitives\n    , orderBy_, asc_, desc_, nullsFirst_, nullsLast_\n    ) where\n\nimport Database.Beam.Backend.Types\nimport Database.Beam.Backend.SQL\n\nimport Database.Beam.Query.Internal\nimport Database.Beam.Query.Ord\nimport Database.Beam.Query.Operator\nimport Database.Beam.Query.Types\n\nimport Database.Beam.Schema.Tables\n\nimport Control.Monad.Identity\nimport Control.Monad.Free\nimport Control.Applicative\n\nimport Data.Maybe\nimport Data.Proxy\nimport Data.Time (LocalTime)\n\nimport GHC.TypeLits (TypeError, ErrorMessage(Text))\n\n-- | Introduce all entries of a table into the \'Q\' monad\nall_ :: ( Database be db, BeamSqlBackend be )\n       => DatabaseEntity be db (TableEntity table)\n       -> Q be db s (table (QExpr be s))\nall_ (DatabaseEntity dt@(DatabaseTable {})) =\n    Q $ liftF (QAll (\\_ -> fromTable (tableNamed (tableName (dbTableSchema dt) (dbTableCurrentName dt))) . Just . (,Nothing))\n                    (tableFieldsToExpressions (dbTableSettings dt))\n                    (\\_ -> Nothing) snd)\n\n-- | Introduce all entries of a view into the \'Q\' monad\nallFromView_ :: ( Database be db, Beamable table\n                , BeamSqlBackend be )\n               => DatabaseEntity be db (ViewEntity table)\n               -> Q be db s (table (QExpr be s))\nallFromView_ (DatabaseEntity vw) =\n    Q $ liftF (QAll (\\_ -> fromTable (tableNamed (tableName (dbViewSchema vw) (dbViewCurrentName vw))) . Just . (,Nothing))\n                    (tableFieldsToExpressions (dbViewSettings vw))\n                    (\\_ -> Nothing) snd)\n\n-- | SQL @VALUES@ clause. Introduce the elements of the given list as\n-- rows in a joined table.\nvalues_ :: forall be db s a\n         . ( Projectible be a\n           , BeamSqlBackend be )\n        => [ a ] -> Q be db s a\nvalues_ rows =\n    Q $ liftF (QAll (\\tblPfx -> fromTable (tableFromValues (map (\\row -> project (Proxy @be) row tblPfx) rows)) . Just . (,Just fieldNames))\n                    (\\tblNm\' -> fst $ mkFieldNames (qualifiedField tblNm\'))\n                    (\\_ -> Nothing) snd)\n    where\n      fieldNames = snd $ mkFieldNames @be @a unqualifiedField\n\n-- | Introduce all entries of a table into the \'Q\' monad based on the\n--   given QExpr. The join condition is expected to return a\n--   \'Bool\'. For a version that takes \'SqlBool\' (a possibly @UNKNOWN@\n--   boolean, that maps more closely to the SQL standard), see\n--   \'join_\'\'.\njoin_ :: ( Database be db, Table table, BeamSqlBackend be )\n      => DatabaseEntity be db (TableEntity table)\n      -> (table (QExpr be s) -> QExpr be s Bool)\n      -> Q be db s (table (QExpr be s))\njoin_ tbl mkOn = join_\' tbl (sqlBool_ . mkOn)\n\n-- | Like \'join_\', but accepting an @ON@ condition that returns\n-- \'SqlBool\'\njoin_\' :: ( Database be db, Table table, BeamSqlBackend be )\n       => DatabaseEntity be db (TableEntity table)\n       -> (table (QExpr be s) -> QExpr be s SqlBool)\n       -> Q be db s (table (QExpr be s))\njoin_\' (DatabaseEntity tbl@(DatabaseTable {})) mkOn =\n    Q $ liftF (QAll (\\_ -> fromTable (tableNamed (tableName (dbTableSchema tbl) (dbTableCurrentName tbl))) . Just . (, Nothing))\n                    (tableFieldsToExpressions (dbTableSettings tbl))\n                    (\\tbl\' -> let QExpr on = mkOn tbl\' in Just on) snd)\n\n-- | Introduce a table using a left join with no ON clause. Because this is not\n--   an inner join, the resulting table is made nullable. This means that each\n--   field that would normally have type \'QExpr x\' will now have type \'QExpr\n--   (Maybe x)\'.\nperhaps_ :: forall s r be db.\n          ( Projectible be r, BeamSqlBackend be\n          , ThreadRewritable (QNested s) r\n          , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s r) )\n         => Q be db (QNested s) r\n         -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s r))\nperhaps_ (Q sub) =\n  Q $ liftF (QArbitraryJoin\n              sub "" leftJoin\n              (\\_ -> Nothing)\n              (\\r -> retag (\\(Columnar\' (QExpr e) :: Columnar\' (QExpr be s) a) ->\n                                            Columnar\' (QExpr e) :: Columnar\' (Nullable (QExpr be s)) a) $\n                                  rewriteThread (Proxy @s) r))\n\n-- | Outer join. every row of each table, returning @NULL@ for any row\n-- of either table for which the join condition finds no related rows.\n--\n-- This expects a join expression returning \'Bool\', for a version that\n-- accepts a \'SqlBool\' (a possibly @UNKNOWN@ boolean, that maps more\n-- closely to the SQL standard), see \'outerJoin_\'\'\nouterJoin_ :: forall s a b be db.\n              ( BeamSqlBackend be, BeamSqlBackendSupportsOuterJoin be\n              , Projectible be a, Projectible be b\n              , ThreadRewritable (QNested s) a, ThreadRewritable (QNested s) b\n              , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s a)\n              , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s b)\n              )\n           => Q be db (QNested s) a\n           -> Q be db (QNested s) b\n           -> ( (WithRewrittenThread (QNested s) s a, WithRewrittenThread (QNested s) s b) -> QExpr be s Bool )\n           -> Q be db s ( Retag Nullable (WithRewrittenThread (QNested s) s a)\n                        , Retag Nullable (WithRewrittenThread (QNested s) s b) )\nouterJoin_ a b on_ = outerJoin_\' a b (sqlBool_ . on_)\n\n-- | Like \'outerJoin_\', but accepting \'SqlBool\'. Pairs of rows for\n-- which the join condition is unknown are considered to be unrelated,\n-- by SQL compliant databases at least.\nouterJoin_\' :: forall s a b be db.\n               ( BeamSqlBackend be, BeamSqlBackendSupportsOuterJoin be\n               , Projectible be a, Projectible be b\n               , ThreadRewritable (QNested s) a, ThreadRewritable (QNested s) b\n               , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s a)\n               , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s b)\n               )\n            => Q be db (QNested s) a\n            -> Q be db (QNested s) b\n            -> ( (WithRewrittenThread (QNested s) s a, WithRewrittenThread (QNested s) s b) -> QExpr be s SqlBool )\n            -> Q be db s ( Retag Nullable (WithRewrittenThread (QNested s) s a)\n                         , Retag Nullable (WithRewrittenThread (QNested s) s b) )\nouterJoin_\' (Q a) (Q b) on_ =\n  Q $ liftF (QTwoWayJoin a b outerJoin\n              (\\(a\', b\') ->\n                 let QExpr e = on_ (rewriteThread (Proxy @s) a\', rewriteThread (Proxy @s) b\')\n                 in Just e)\n              (\\(a\', b\') ->\n                 let retag\' :: (ThreadRewritable (QNested s) x, Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s x))\n                            => x -> Retag Nullable (WithRewrittenThread (QNested s) s x)\n                     retag\' = retag (\\(Columnar\' (QExpr e) :: Columnar\' (QExpr be s) x) ->\n                                        Columnar\' (QExpr e) :: Columnar\' (Nullable (QExpr be s)) x) .\n                              rewriteThread (Proxy @s)\n                 in ( retag\' a\', retag\' b\' )))\n\n-- | Introduce a table using a left join. The ON clause is required here.Because\n--   this is not an inner join, the resulting table is made nullable. This means\n--   that each field that would normally have type \'QExpr x\' will now have type\n--   \'QExpr (Maybe x)\'.\n--\n--   The @ON@ condition given must return \'Bool\'. For a version that\n--   accepts an @ON@ condition returning \'SqlBool\', see \'leftJoin_\'\'.\nleftJoin_ :: forall s r be db.\n           ( BeamSqlBackend be, Projectible be r\n           , ThreadRewritable (QNested s) r\n           , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s r) )\n          => Q be db (QNested s) r\n          -> (WithRewrittenThread (QNested s) s r -> QExpr be s Bool)\n          -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s r))\nleftJoin_ sub on_ = leftJoin_\' sub (sqlBool_ . on_)\n\n-- | Like \'leftJoin_\', but accepts an @ON@ clause returning \'SqlBool\'.\nleftJoin_\' :: forall s r be db.\n            ( BeamSqlBackend be, Projectible be r\n            , ThreadRewritable (QNested s) r\n            , Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s r) )\n           => Q be db (QNested s) r\n           -> (WithRewrittenThread (QNested s) s r -> QExpr be s SqlBool)\n           -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s r))\nleftJoin_\' (Q sub) on_ =\n  Q $ liftF (QArbitraryJoin\n               sub "" leftJoin\n               (\\r -> let QExpr e = on_ (rewriteThread (Proxy @s) r) in Just e)\n               (\\r -> retag (\\(Columnar\' (QExpr e) :: Columnar\' (QExpr be s) a) ->\n                                Columnar\' (QExpr e) :: Columnar\' (Nullable (QExpr be s)) a) $\n                      rewriteThread (Proxy @s) r))\n\nsubselect_ :: forall s r be db.\n            ( ThreadRewritable (QNested s) r\n            , Projectible be r )\n           => Q be db (QNested s) r\n           -> Q be db s (WithRewrittenThread (QNested s) s r)\nsubselect_ (Q q\') =\n  Q (liftF (QSubSelect q\' (rewriteThread (Proxy @s))))\n\n-- | Only allow results for which the \'QExpr\' yields \'True\'. For a\n-- version that operates over possibly @NULL@ \'SqlBool\'s, see\n-- \'guard_\'\'.\nguard_ :: forall be db s\n        . BeamSqlBackend be\n       => QExpr be s Bool -> Q be db s ()\nguard_ = guard_\' . sqlBool_\n\n-- | Only allow results for which the \'QExpr\' yields @TRUE@.\n--\n-- This function operates over \'SqlBool\', which are like haskell\n-- \'Bool\'s, except for the special @UNKNOWN@ value that occurs when\n-- comparisons include @NULL@. For a version that operates over known\n-- non-@NULL@ booleans, see \'guard_\'.\nguard_\' :: forall be db s\n         . BeamSqlBackend be\n        => QExpr be s SqlBool -> Q be db s ()\nguard_\' (QExpr guardE\') = Q (liftF (QGuard guardE\' ()))\n\n-- | Synonym for @clause >>= \\\\x -> guard_ (mkExpr x)>> pure x@. Use \'filter_\'\' for comparisons with \'SqlBool\'\nfilter_ :: forall r be db s\n         . BeamSqlBackend be\n        => (r -> QExpr be s Bool)\n        -> Q be db s r -> Q be db s r\nfilter_ mkExpr clause = clause >>= \\x -> guard_ (mkExpr x) >> pure x\n\n-- | Synonym for @clause >>= \\\\x -> guard_\' (mkExpr x)>> pure x@. Use \'filter_\' for comparisons with \'Bool\'\nfilter_\' :: forall r be db s\n          . BeamSqlBackend be\n        => (r -> QExpr be s SqlBool)\n        -> Q be db s r -> Q be db s r\nfilter_\' mkExpr clause = clause >>= \\x -> guard_\' (mkExpr x) >> pure x\n\n-- | Introduce all entries of the given table which are referenced by the given \'PrimaryKey\'\nrelated_ :: forall be db rel s\n          . ( Database be db, Table rel, BeamSqlBackend be\n            , HasTableEquality be (PrimaryKey rel)\n            )\n         => DatabaseEntity be db (TableEntity rel)\n         -> PrimaryKey rel (QExpr be s)\n         -> Q be db s (rel (QExpr be s))\nrelated_ relTbl relKey =\n  join_ relTbl (\\rel -> relKey ==. primaryKey rel)\n\n-- | Introduce all entries of the given table for which the expression (which can depend on the queried table returns true)\nrelatedBy_ :: forall be db rel s\n            . ( Database be db, Table rel, BeamSqlBackend be )\n           => DatabaseEntity be db (TableEntity rel)\n           -> (rel (QExpr be s) -> QExpr be s Bool)\n           -> Q be db s (rel (QExpr be s))\nrelatedBy_ = join_\n\n-- | Introduce all entries of the given table for which the expression (which can depend on the queried table returns true)\nrelatedBy_\' :: forall be db rel s\n             . ( Database be db, Table rel, BeamSqlBackend be )\n            => DatabaseEntity be db (TableEntity rel)\n            -> (rel (QExpr be s) -> QExpr be s SqlBool)\n            -> Q be db s (rel (QExpr be s))\nrelatedBy_\' = join_\'\n\n-- | Generate an appropriate boolean \'QGenExpr\' comparing the given foreign key\n--   to the given table. Useful for creating join conditions.\n--   Use \'references_\'\' for a \'SqlBool\' comparison.\nreferences_ :: ( Table t, BeamSqlBackend be\n               , HasTableEquality be (PrimaryKey t) )\n            => PrimaryKey t (QGenExpr ctxt be s) -> t (QGenExpr ctxt be s) -> QGenExpr ctxt be s Bool\nreferences_ fk tbl = fk ==. pk tbl\n\n-- | Generate an appropriate boolean \'QGenExpr\' comparing the given foreign key\n--   to the given table. Useful for creating join conditions.\n--   Use \'references_\' for a \'Bool\' comparison.\nreferences_\' :: ( Table t, BeamSqlBackend be\n                , HasTableEquality be (PrimaryKey t) )\n             => PrimaryKey t (QGenExpr ctxt be s) -> t (QGenExpr ctxt be s) -> QGenExpr ctxt be s SqlBool\nreferences_\' fk tbl = fk ==?. pk tbl\n\n-- | Only return distinct values from a query\nnub_ :: ( BeamSqlBackend be, Projectible be r )\n     => Q be db s r -> Q be db s r\nnub_ (Q sub) = Q $ liftF (QDistinct (\\_ _ -> setQuantifierDistinct) sub id)\n\n-- | Limit the number of results returned by a query.\nlimit_ :: forall s a be db\n        . ( Projectible be a\n          , ThreadRewritable (QNested s) a )\n        => Integer -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)\nlimit_ limit\' (Q q) =\n  Q (liftF (QLimit limit\' q (rewriteThread (Proxy @s))))\n\n-- | Drop the first `offset\'` results.\noffset_ :: forall s a be db\n         . ( Projectible be a\n           , ThreadRewritable (QNested s) a )\n        => Integer -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)\noffset_ offset\' (Q q) =\n  Q (liftF (QOffset offset\' q (rewriteThread (Proxy @s))))\n\n-- | Use the SQL @EXISTS@ operator to determine if the given query returns any results\nexists_ :: ( BeamSqlBackend be, HasQBuilder be, Projectible be a)\n        => Q be db s a -> QExpr be s Bool\nexists_ q = QExpr (\\tbl -> existsE (buildSqlQuery tbl q))\n\n-- | Use the SQL @UNIQUE@ operator to determine if the given query produces a unique result\nunique_ :: ( BeamSqlBackend be, HasQBuilder be, Projectible be a)\n        => Q be db s a -> QExpr be s Bool\nunique_ q = QExpr (\\tbl -> uniqueE (buildSqlQuery tbl q))\n\n-- | Use the SQL99 @DISTINCT@ operator to determine if the given query produces a distinct result\ndistinct_ :: ( BeamSqlBackend be, BeamSql99ExpressionBackend be, HasQBuilder be, Projectible be a)\n          => Q be db s a -> QExpr be s Bool\ndistinct_ q = QExpr (\\tbl -> distinctE (buildSqlQuery tbl q))\n\n-- | Project the (presumably) singular result of the given query as an expression\nsubquery_ :: ( BeamSqlBackend be, HasQBuilder be, Projectible be (QExpr be s a) )\n          => Q be db s (QExpr be s a)\n          -> QGenExpr ctxt be s a\nsubquery_ q =\n  QExpr (\\tbl -> subqueryE (buildSqlQuery tbl q))\n\n-- | SQL @CHAR_LENGTH@ function\ncharLength_ :: ( BeamSqlBackend be, BeamSqlBackendIsString be text, Integral a )\n            => QGenExpr context be s text -> QGenExpr context be s a\ncharLength_ (QExpr s) = QExpr (charLengthE <$> s)\n\n-- | SQL @OCTET_LENGTH@ function\noctetLength_ :: ( BeamSqlBackend be, BeamSqlBackendIsString be text, Integral a )\n             => QGenExpr context be s text -> QGenExpr context be s a\noctetLength_ (QExpr s) = QExpr (octetLengthE <$> s)\n\n-- | SQL @BIT_LENGTH@ function\nbitLength_ :: ( BeamSqlBackend be, Integral a )\n           => QGenExpr context be s SqlBitString -> QGenExpr context be s a\nbitLength_ (QExpr x) = QExpr (bitLengthE <$> x)\n\n-- | SQL @CURRENT_TIMESTAMP@ function\ncurrentTimestamp_ :: BeamSqlBackend be => QGenExpr ctxt be s LocalTime\ncurrentTimestamp_ = QExpr (pure currentTimestampE)\n\n-- | SQL @POSITION(.. IN ..)@ function\nposition_ :: ( BeamSqlBackendIsString be text\n             , BeamSqlBackend be, Integral b )\n          => QExpr be s text -> QExpr be s text -> QExpr be s b\nposition_ (QExpr needle) (QExpr haystack) =\n  QExpr (liftA2 likeE needle haystack)\n\n-- | SQL @LOWER@ function\nlower_ ::  ( BeamSqlBackendIsString be text\n           , BeamSqlBackend be )\n       => QGenExpr context be s text -> QGenExpr context be s text\nlower_ (QExpr s) = QExpr (lowerE <$> s)\n\n-- | SQL @UPPER@ function\nupper_ :: ( BeamSqlBackendIsString be text\n          , BeamSqlBackend be )\n       => QGenExpr context be s text -> QGenExpr context be s text\nupper_ (QExpr s) = QExpr (upperE <$> s)\n\n-- | SQL @TRIM@ function\ntrim_ :: ( BeamSqlBackendIsString be text\n         , BeamSqlBackend be )\n       => QGenExpr context be s text -> QGenExpr context be s text\ntrim_ (QExpr s) = QExpr (trimE <$> s)\n\n-- | Combine all the given boolean value \'QGenExpr\'s with the \'&&.\' operator.\nallE :: BeamSqlBackend be\n     => [ QGenExpr context be s Bool ] -> QGenExpr context be s Bool\nallE es = fromMaybe (QExpr (pure (valueE (sqlValueSyntax True)))) $\n          foldl (\\expr x ->\n                   Just $ maybe x (\\e -> e &&. x) expr)\n                Nothing es\n\n-- * UPDATE operators\n\n-- | Extract an expression representing the current (non-UPDATEd) value of a \'QField\'\ncurrent_ :: BeamSqlBackend be => QField s ty -> QExpr be s ty\ncurrent_ (QField False _ nm) = QExpr (pure (fieldE (unqualifiedField nm)))\ncurrent_ (QField True tbl nm) = QExpr (pure (fieldE (qualifiedField tbl nm)))\n\ninfix 4 <-.\nclass BeamSqlBackend be =>\n  SqlUpdatable be s lhs rhs | rhs -> be, lhs -> s\n                            , rhs -> s, lhs s be -> rhs\n                            , rhs -> lhs where\n\n\n  -- | Update a \'QField\' or \'Beamable\' type containing \'QField\'s with the given\n  --   \'QExpr\' or \'Beamable\' type containing \'QExpr\'\n  (<-.) :: lhs\n        -> rhs\n        -> QAssignment be s\n\ninstance BeamSqlBackend be => SqlUpdatable be s (QField s a) (QExpr be s a) where\n  QField _ _ nm <-. QExpr expr =\n    QAssignment [(unqualifiedField nm, expr "t")]\n\ninstance (BeamSqlBackend be, Beamable tbl) => SqlUpdatable be s (tbl (QField s)) (tbl (QExpr be s)) where\n  lhs <-. rhs =\n    QAssignment $\n    allBeamValues (\\(Columnar\' (Const assignments)) -> assignments) $\n    runIdentity $\n    zipBeamFieldsM (\\(Columnar\' (QField _ _ f) :: Columnar\' (QField s) t) (Columnar\' (QExpr e)) ->\n                       pure (Columnar\' (Const (unqualifiedField f, e "t")) :: Columnar\' (Const (BeamSqlBackendFieldNameSyntax be, BeamSqlBackendExpressionSyntax be)) t)) lhs rhs\n\ninstance (BeamSqlBackend be, Beamable tbl) => SqlUpdatable be s (tbl (Nullable (QField s))) (tbl (Nullable (QExpr be s))) where\n  lhs <-. rhs =\n    let lhs\' = changeBeamRep (\\(Columnar\' (QField q tblName fieldName\') :: Columnar\' (Nullable (QField s)) a) ->\n                                Columnar\' (QField q tblName fieldName\') :: Columnar\' (QField s)  a) lhs\n        rhs\' = changeBeamRep (\\(Columnar\' (QExpr e) :: Columnar\' (Nullable (QExpr be s)) a) ->\n                                Columnar\' (QExpr e) :: Columnar\' (QExpr be s) a) rhs\n    in lhs\' <-. rhs\'\n\n-- | SQL @UNION@ operator\nunion_ :: forall be db s a\n        . ( BeamSqlBackend be, Projectible be a\n          , ThreadRewritable (QNested s) a )\n       => Q be db (QNested s) a -> Q be db (QNested s) a\n       -> Q be db s (WithRewrittenThread (QNested s) s a)\nunion_ (Q a) (Q b) = Q (liftF (QSetOp (unionTables False) a b (rewriteThread (Proxy @s))))\n\n-- | SQL @UNION ALL@ operator\nunionAll_ :: forall be db s a.\n             ( BeamSqlBackend be, Projectible be a\n             , ThreadRewritable (QNested s) a)\n          => Q be db (QNested s) a -> Q be db (QNested s) a\n          -> Q be db s (WithRewrittenThread (QNested s) s a)\nunionAll_ (Q a) (Q b) = Q (liftF (QSetOp (unionTables True) a b (rewriteThread (Proxy @s))))\n\n-- | SQL @INTERSECT@ operator\nintersect_ :: forall be db s a.\n              ( BeamSqlBackend be, Projectible be a\n              , ThreadRewritable (QNested s) a)\n           => Q be db (QNested s) a -> Q be db (QNested s) a\n           -> Q be db s (WithRewrittenThread (QNested s) s a)\nintersect_ (Q a) (Q b) = Q (liftF (QSetOp (intersectTables False) a b (rewriteThread (Proxy @s))))\n\n-- | SQL @INTERSECT ALL@ operator\nintersectAll_ :: forall be db s a.\n                 ( BeamSqlBackend be, Projectible be a\n                 , ThreadRewritable (QNested s) a)\n              => Q be db (QNested s) a -> Q be db (QNested s) a\n              -> Q be db s (WithRewrittenThread (QNested s) s a)\nintersectAll_ (Q a) (Q b) = Q (liftF (QSetOp (intersectTables True) a b (rewriteThread (Proxy @s))))\n\n-- | SQL @EXCEPT@ operator\nexcept_ :: forall be db s a.\n           ( BeamSqlBackend be, Projectible be a\n           , ThreadRewritable (QNested s) a)\n        => Q be db (QNested s) a -> Q be db (QNested s) a\n        -> Q be db s (WithRewrittenThread (QNested s) s a)\nexcept_ (Q a) (Q b) = Q (liftF (QSetOp (exceptTable False) a b (rewriteThread (Proxy @s))))\n\n-- | SQL @EXCEPT ALL@ operator\nexceptAll_ :: forall be db s a.\n              ( BeamSqlBackend be, Projectible be a\n              , ThreadRewritable (QNested s) a)\n           => Q be db (QNested s) a -> Q be db (QNested s) a\n           -> Q be db s (WithRewrittenThread (QNested s) s a)\nexceptAll_ (Q a) (Q b) = Q (liftF (QSetOp (exceptTable True) a b (rewriteThread (Proxy @s))))\n\n-- | Convenience function that allows you to use type applications to specify\n--   the result of a \'QGenExpr\'.\n--\n--   Useful to disambiguate the types of \'QGenExpr\'s without having to provide a\n--   complete type signature. As an example, the \'countAll_\' aggregate can\n--   return a result of any \'Integral\' type. Without further constraints, the\n--   type is ambiguous. You can use \'as_\' to disambiguate the return type.\n--\n--   For example, this is ambiguous\n--\n-- > aggregate_ (\\_ -> countAll_) ..\n--\n--   But this is not\n--\n-- > aggregate_ (\\_ -> as_ @Int32 countAll_) ..\n--\nas_ :: forall a ctxt be s. QGenExpr ctxt be s a -> QGenExpr ctxt be s a\nas_ = id\n\n-- * Marshalling between Haskell literals and QExprs\n\ntype family HaskellLiteralForQExpr x = a\ntype instance HaskellLiteralForQExpr (QGenExpr context be s a) = a\ntype instance HaskellLiteralForQExpr (table (QGenExpr context be s)) = table Identity\ntype instance HaskellLiteralForQExpr (table (Nullable f)) = HaskellLiteralForQExpr_AddNullable (HaskellLiteralForQExpr (table f))\n\ntype family HaskellLiteralForQExpr_AddNullable x = a\ntype instance HaskellLiteralForQExpr_AddNullable (tbl f) = tbl (Nullable f)\n\ntype SqlValableTable be table =\n   ( Beamable table\n   , FieldsFulfillConstraint (HasSqlValueSyntax (BeamSqlBackendValueSyntax be)) table )\n\nclass SqlValable a where\n    val_ :: HaskellLiteralForQExpr a -> a\n\ninstance ( BeamSqlBackendCanSerialize be a, BeamSqlBackend be ) =>\n  SqlValable (QGenExpr ctxt be s a) where\n\n  val_ = QExpr . pure . valueE . sqlValueSyntax\ninstance ( Beamable table, BeamSqlBackend be\n         , FieldsFulfillConstraint (BeamSqlBackendCanSerialize be) table ) =>\n  SqlValable (table (QGenExpr ctxt be s)) where\n  val_ tbl =\n    let fields :: table (WithConstraint (BeamSqlBackendCanSerialize be))\n        fields = withConstrainedFields tbl\n    in changeBeamRep (\\(Columnar\' (WithConstraint x :: WithConstraint (BeamSqlBackendCanSerialize be) x)) ->\n                         Columnar\' (QExpr (pure (valueE (sqlValueSyntax x))))) fields\ninstance ( Beamable table, BeamSqlBackend be\n         , FieldsFulfillConstraintNullable (BeamSqlBackendCanSerialize be) table ) =>\n\n         SqlValable (table (Nullable (QGenExpr ctxt be s))) where\n\n  val_ tbl =\n    let fields :: table (Nullable (WithConstraint (BeamSqlBackendCanSerialize be)))\n        fields = withNullableConstrainedFields tbl\n    in changeBeamRep (\\(Columnar\' (WithConstraint x :: WithConstraint (BeamSqlBackendCanSerialize be) (Maybe x))) ->\n                         Columnar\' (QExpr (pure (valueE (sqlValueSyntax x))))) fields\n\ndefault_ :: BeamSqlBackend be => QGenExpr ctxt be s a\ndefault_ = QExpr (pure defaultE)\n\n-- * Window functions\n\nnoBounds_ :: QFrameBounds be\nnoBounds_ = QFrameBounds Nothing\n\nfromBound_ :: BeamSql2003ExpressionBackend be\n           => QFrameBound be -> QFrameBounds be\nfromBound_ start = bounds_ start Nothing\n\nbounds_ :: BeamSql2003ExpressionBackend be\n        => QFrameBound be\n        -> Maybe (QFrameBound be)\n        -> QFrameBounds be\nbounds_ (QFrameBound start) end =\n    QFrameBounds . Just $\n    fromToBoundSyntax start\n      (fmap (\\(QFrameBound end\') -> end\') end)\n\nunbounded_ :: BeamSql2003ExpressionBackend be => QFrameBound be\nunbounded_ = QFrameBound unboundedSyntax\n\nnrows_ :: BeamSql2003ExpressionBackend be\n       => Int -> QFrameBound be\nnrows_ x = QFrameBound (nrowsBoundSyntax x)\n\nnoPartition_ :: Integral a => Maybe (QExpr be s a)\nnoPartition_ = Nothing\n\nnoOrder_ :: Integral a => Maybe (QOrd be s a)\nnoOrder_ = Nothing\n\npartitionBy_, orderPartitionBy_ :: partition -> Maybe partition\npartitionBy_  = Just\norderPartitionBy_ = Just\n\n-- | Specify a window frame with all the options\nframe_ :: forall be ordering partition s\n        . ( BeamSql2003ExpressionBackend be\n          , SqlOrderable be ordering\n          , Projectible be partition )\n       => Maybe partition {-^ PARTITION BY -}\n       -> Maybe ordering  {-^ ORDER BY -}\n       -> QFrameBounds be {-^ RANGE / ROWS -}\n       -> QWindow be s\nframe_ partition_ ordering_ (QFrameBounds bounds) =\n    QWindow $ \\tblPfx ->\n    frameSyntax (case maybe [] (flip (project (Proxy @be)) tblPfx) partition_ of\n                   [] -> Nothing\n                   xs -> Just xs)\n                (case fmap (makeSQLOrdering (Proxy @be)) ordering_ of\n                   Nothing -> Nothing\n                   Just [] -> Nothing\n                   Just xs -> Just (sequenceA xs tblPfx))\n                bounds\n\n-- | Produce a window expression given an aggregate function and a window.\nover_ :: BeamSql2003ExpressionBackend be\n      => QAgg be s a -> QWindow be s -> QWindowExpr be s a\nover_ (QExpr a) (QWindow frame) = QExpr (overE <$> a <*> frame)\n\n-- | Compute a query over windows.\n--\n--   The first function builds window frames using the \'frame_\', \'partitionBy_\',\n--   etc functions. The return type can be a single frame, tuples of frame, or\n--   any arbitrarily nested tuple of the above. Instances up to 8-tuples are\n--   provided.\n--\n--   The second function builds the resulting projection using the result of the\n--   subquery as well as the window frames built in the first function. In this\n--   function, window expressions can be included in the output using the\n--   \'over_\' function.\n--\nwithWindow_ :: forall window a s r be db\n             . ( ProjectibleWithPredicate WindowFrameContext be (WithExprContext (BeamSqlBackendWindowFrameSyntax\' be)) window\n               , Projectible be r, Projectible be a\n               , ContextRewritable a\n               , ThreadRewritable (QNested s) (WithRewrittenContext a QValueContext) )\n            => (r -> window)      -- ^ Window builder function\n            -> (r -> window -> a) -- ^ Projection builder function. Has access to the windows generated above\n            -> Q be db (QNested s) r -- ^ Query to window over\n            -> Q be db s (WithRewrittenThread (QNested s) s (WithRewrittenContext a QValueContext))\nwithWindow_ mkWindow mkProjection (Q windowOver)=\n  Q (liftF (QWindowOver mkWindow mkProjection windowOver (rewriteThread (Proxy @s) . rewriteContext (Proxy @QValueContext))))\n\n-- * Order bys\n\nclass SqlOrderable be a | a -> be where\n    makeSQLOrdering :: Proxy be -> a -> [ WithExprContext (BeamSqlBackendOrderingSyntax be) ]\ninstance SqlOrderable be (QOrd be s a) where\n    makeSQLOrdering _ (QOrd x) = [x]\ninstance TypeError (\'Text "Missing mandatory sorting order. Use either \'asc_\' or \'desc_\' to specify sorting order.") =>\n    SqlOrderable be (QGenExpr ctx be s a) where\n        makeSQLOrdering = error "unreachable SqlOrderable QGenExpr instance"\ninstance SqlOrderable be a => SqlOrderable be [a] where\n    makeSQLOrdering be = concatMap (makeSQLOrdering be)\ninstance ( SqlOrderable be a, SqlOrderable be b ) => SqlOrderable be (a, b) where\n    makeSQLOrdering be (a, b) =\n      makeSQLOrdering be a <> makeSQLOrdering be b\ninstance ( SqlOrderable be a, SqlOrderable be b\n         , SqlOrderable be c ) => SqlOrderable be (a, b, c) where\n    makeSQLOrdering be (a, b, c) =\n      makeSQLOrdering be a <> makeSQLOrdering be b <> makeSQLOrdering be c\ninstance ( SqlOrderable be a, SqlOrderable be b\n         , SqlOrderable be c, SqlOrderable be d ) => SqlOrderable be (a, b, c, d) where\n    makeSQLOrdering be (a, b, c, d) =\n      makeSQLOrdering be a <> makeSQLOrdering be b <> makeSQLOrdering be c <> makeSQLOrdering be d\ninstance ( SqlOrderable be a, SqlOrderable be b\n         , SqlOrderable be c, SqlOrderable be d\n         , SqlOrderable be e ) => SqlOrderable be (a, b, c, d, e) where\n    makeSQLOrdering be (a, b, c, d, e) =\n      makeSQLOrdering be a <> makeSQLOrdering be b <> makeSQLOrdering be c <> makeSQLOrdering be d <>\n      makeSQLOrdering be e\ninstance ( SqlOrderable be a, SqlOrderable be b\n         , SqlOrderable be c, SqlOrderable be d\n         , SqlOrderable be e, SqlOrderable be f ) => SqlOrderable be (a, b, c, d, e, f) where\n    makeSQLOrdering be (a, b, c, d, e, f) =\n      makeSQLOrdering be a <> makeSQLOrdering be b <> makeSQLOrdering be c <> makeSQLOrdering be d <>\n      makeSQLOrdering be e <> makeSQLOrdering be f\ninstance ( SqlOrderable be a, SqlOrderable be b\n         , SqlOrderable be c, SqlOrderable be d\n         , SqlOrderable be e, SqlOrderable be f\n         , SqlOrderable be g ) => SqlOrderable be (a, b, c, d, e, f, g) where\n    makeSQLOrdering be (a, b, c, d, e, f, g) =\n      makeSQLOrdering be a <> makeSQLOrdering be b <> makeSQLOrdering be c <> makeSQLOrdering be d <>\n      makeSQLOrdering be e <> makeSQLOrdering be f <> makeSQLOrdering be g\ninstance ( SqlOrderable be a, SqlOrderable be b\n         , SqlOrderable be c, SqlOrderable be d\n         , SqlOrderable be e, SqlOrderable be f\n         , SqlOrderable be g, SqlOrderable be h ) => SqlOrderable be (a, b, c, d, e, f, g, h) where\n    makeSQLOrdering be (a, b, c, d, e, f, g, h) =\n      makeSQLOrdering be a <> makeSQLOrdering be b <> makeSQLOrdering be c <> makeSQLOrdering be d <>\n      makeSQLOrdering be e <> makeSQLOrdering be f <> makeSQLOrdering be g <> makeSQLOrdering be h\n\n-- | Order by the given expressions. The return type of the ordering key should\n--   either be the result of \'asc_\' or \'desc_\' (or another ordering \'QOrd\'\n--   generated by a backend-specific ordering) or an (possibly nested) tuple of\n--   results of the former.\n--\n--   The <https://haskell-beam.github.io/beam/user-guide/queries/ordering manual section>\n--   has more information.\norderBy_ :: forall s a ordering be db\n          . ( Projectible be a, SqlOrderable be ordering\n            , ThreadRewritable (QNested s) a )\n         => (a -> ordering) -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)\norderBy_ orderer (Q q) =\n    Q (liftF (QOrderBy (sequenceA . makeSQLOrdering (Proxy @be) . orderer) q (rewriteThread (Proxy @s))))\n\nnullsFirst_ :: IsSql2003OrderingElementaryOLAPOperationsSyntax (BeamSqlBackendOrderingSyntax be)\n            => QOrd be s a -> QOrd be s a\nnullsFirst_ (QOrd e) = QOrd (nullsFirstOrdering <$> e)\n\nnullsLast_ :: IsSql2003OrderingElementaryOLAPOperationsSyntax (BeamSqlBackendOrderingSyntax be)\n           => QOrd be s a -> QOrd be s a\nnullsLast_ (QOrd e) = QOrd (nullsLastOrdering <$> e)\n\n-- | Produce a \'QOrd\' corresponding to a SQL @ASC@ ordering\nasc_ :: forall be s a\n      . BeamSqlBackend be\n     => QExpr be s a -> QOrd be s a\nasc_ (QExpr e) = QOrd (ascOrdering <$> e)\n\n-- | Produce a \'QOrd\' corresponding to a SQL @DESC@ ordering\ndesc_ :: forall be s a\n       . BeamSqlBackend be\n      => QExpr be s a -> QOrd be s a\ndesc_ (QExpr e) = QOrd (descOrdering <$> e)\n\n-- * Subqueries\n\n-- * Nullable conversions\n\n-- | Type class for things that can be nullable. This includes \'QExpr (Maybe a)\', \'tbl (Nullable\n-- QExpr)\', and \'PrimaryKey tbl (Nullable QExpr)\'\nclass SqlJustable a b | b -> a where\n\n    -- | Given something of type \'QExpr a\', \'tbl QExpr\', or \'PrimaryKey tbl\n    --   QExpr\', turn it into a \'QExpr (Maybe a)\', \'tbl (Nullable QExpr)\', or\n    --   \'PrimaryKey t (Nullable QExpr)\' respectively that contains the same\n    --   values.\n    just_ :: a -> b\n\n    -- | Return either a \'QExpr (Maybe x)\' representing \'Nothing\' or a nullable \'Table\' or\n    --   \'PrimaryKey\' filled with \'Nothing\'.\n    nothing_ :: b\n\ninstance BeamSqlBackend be =>\n    SqlJustable (QExpr be s a) (QExpr be s (Maybe a)) where\n\n    just_ (QExpr e) = QExpr e\n    nothing_ = QExpr (pure (valueE (sqlValueSyntax SqlNull)))\n\ninstance {-# OVERLAPPING #-} ( Table t, BeamSqlBackend be ) =>\n    SqlJustable (PrimaryKey t (QExpr be s)) (PrimaryKey t (Nullable (QExpr be s))) where\n    just_ = changeBeamRep (\\(Columnar\' q) -> Columnar\' (just_ q))\n    nothing_ = changeBeamRep (\\(Columnar\' _) -> Columnar\' nothing_) (primaryKey (tblSkeleton :: TableSkeleton t))\n\ninstance {-# OVERLAPPING #-} ( Table t, BeamSqlBackend be ) =>\n    SqlJustable (t (QExpr be s)) (t (Nullable (QExpr be s))) where\n    just_ = changeBeamRep (\\(Columnar\' q) -> Columnar\' (just_ q))\n    nothing_ = changeBeamRep (\\(Columnar\' _) -> Columnar\' nothing_) (tblSkeleton :: TableSkeleton t)\n\ninstance {-# OVERLAPPING #-} Table t => SqlJustable (PrimaryKey t Identity) (PrimaryKey t (Nullable Identity)) where\n    just_ = changeBeamRep (\\(Columnar\' q) -> Columnar\' (Just q))\n    nothing_ = changeBeamRep (\\(Columnar\' _) -> Columnar\' Nothing) (primaryKey (tblSkeleton :: TableSkeleton t))\n\ninstance {-# OVERLAPPING #-} Table t => SqlJustable (t Identity) (t (Nullable Identity)) where\n    just_ = changeBeamRep (\\(Columnar\' q) -> Columnar\' (Just q))\n    nothing_ = changeBeamRep (\\(Columnar\' _) -> Columnar\' Nothing) (tblSkeleton :: TableSkeleton t)\n\n-- * Nullable checking\n\ndata QIfCond context be s a = QIfCond (QGenExpr context be s SqlBool) (QGenExpr context be s a)\nnewtype QIfElse context be s a = QIfElse (QGenExpr context be s a)\n\nthen_ :: QGenExpr context be s Bool -> QGenExpr context be s a -> QIfCond context be s a\nthen_ cond res = QIfCond (sqlBool_ cond) res\n\nthen_\' :: QGenExpr context be s SqlBool -> QGenExpr context be s a -> QIfCond context be s a\nthen_\' cond res = QIfCond cond res\n\nelse_ :: QGenExpr context be s a -> QIfElse context be s a\nelse_ = QIfElse\n\nif_ :: BeamSqlBackend be\n    => [ QIfCond context be s a ]\n    -> QIfElse context be s a\n    -> QGenExpr context be s a\nif_ conds (QIfElse (QExpr elseExpr)) =\n  QExpr (\\tbl -> caseE (map (\\(QIfCond (QExpr cond) (QExpr res)) -> (cond tbl, res tbl)) conds) (elseExpr tbl))\n\nifThenElse_\n  :: BeamSqlBackend be\n  => QGenExpr context be s Bool\n  -> QGenExpr context be s a\n  -> QGenExpr context be s a\n  -> QGenExpr context be s a\nifThenElse_ c t f = if_ [c `then_` t] (else_ f)\n\nbool_\n  :: BeamSqlBackend be\n  => QGenExpr context be s a\n  -> QGenExpr context be s a\n  -> QGenExpr context be s Bool\n  -> QGenExpr context be s a\nbool_ f t c = ifThenElse_ c t f\n\n-- | SQL @COALESCE@ support\ncoalesce_ :: BeamSqlBackend be\n          => [ QGenExpr ctxt be s (Maybe a) ] -> QGenExpr ctxt be s a -> QGenExpr ctxt be s a\ncoalesce_ qs (QExpr onNull) =\n  QExpr $ do\n    onNull\' <- onNull\n    coalesceE . (<> [onNull\']) <$> mapM (\\(QExpr q) -> q) qs\n\n-- | Convert a \'Maybe\' value to a concrete value, by suppling a default\nfromMaybe_ :: BeamSqlBackend be\n           => QGenExpr ctxt be s a -> QGenExpr ctxt be s (Maybe a) -> QGenExpr ctxt be s a\nfromMaybe_ onNull q = coalesce_ [q] onNull\n\n-- | Type class for anything which can be checked for null-ness. This includes \'QExpr (Maybe a)\' as\n-- well as \'Table\'s or \'PrimaryKey\'s over \'Nullable QExpr\'.\nclass BeamSqlBackend be => SqlDeconstructMaybe be a nonNullA s | a s -> be, a -> nonNullA, a -> s, nonNullA -> s where\n    -- | Returns a \'QExpr\' that evaluates to true when the first argument is not null\n    isJust_ :: a -> QGenExpr ctxt be s Bool\n\n    -- | Returns a \'QExpr\' that evaluates to true when the first argument is null\n    isNothing_ :: a -> QGenExpr ctxt be s Bool\n\n    -- | Given an object (third argument) which may or may not be null, return the default value if\n    -- null (first argument), or transform the value that could be null to yield the result of the\n    -- expression (second argument)\n    maybe_ :: QGenExpr ctxt be s y -> (nonNullA -> QGenExpr ctxt be s y) -> a -> QGenExpr ctxt be s y\n\ninstance BeamSqlBackend be => SqlDeconstructMaybe be (QGenExpr ctxt be s (Maybe x)) (QGenExpr ctxt be s x) s where\n    isJust_ (QExpr x) = QExpr (isNotNullE <$> x)\n    isNothing_ (QExpr x) = QExpr (isNullE <$> x)\n\n    maybe_ (QExpr onNothing) onJust (QExpr e) =\n        let QExpr onJust\' = onJust (QExpr e)\n        in QExpr (\\tbl -> caseE [(isNotNullE (e tbl), onJust\' tbl)] (onNothing tbl))\n\ninstance ( BeamSqlBackend be, Beamable t)\n    => SqlDeconstructMaybe be (t (Nullable (QGenExpr ctxt be s))) (t (QGenExpr ctxt be s)) s where\n    isJust_ t = allE (allBeamValues (\\(Columnar\' e) -> isJust_ e) t)\n    isNothing_ t = allE (allBeamValues (\\(Columnar\' e) -> isNothing_ e) t)\n    maybe_ (QExpr onNothing) onJust tbl =\n      let QExpr onJust\' = onJust (changeBeamRep (\\(Columnar\' (QExpr e)) -> Columnar\' (QExpr e)) tbl)\n          QExpr cond = isJust_ @be tbl\n      in QExpr (\\tblPfx -> caseE [(cond tblPfx, onJust\' tblPfx)] (onNothing tblPfx))\n\ninfixl 3 <|>.\n(<|>.) :: ( SqlJustable a (QGenExpr ctxt syntax s y)\n          , SqlDeconstructMaybe syntax (QGenExpr ctxt syntax s y) a s\n          )\n       => QGenExpr ctxt syntax s y\n       -> QGenExpr ctxt syntax s y\n       -> QGenExpr ctxt syntax s y\nl <|>. r = maybe_ r just_ l\n'