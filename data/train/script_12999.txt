b'{-# LANGUAGE BangPatterns #-}\n\n-- | Note: this module is re-exported as a whole from "Test.Tasty.Runners"\nmodule Test.Tasty.Runners.Utils where\n\nimport Control.Exception\nimport Control.Applicative\nimport Control.Concurrent (mkWeakThreadId, myThreadId)\nimport Control.Monad (forM_)\nimport Data.Typeable (Typeable)\nimport Prelude  -- Silence AMP import warnings\nimport Text.Printf\nimport Foreign.C (CInt)\n\n#if MIN_VERSION_base(4,11,0)\nimport GHC.Clock (getMonotonicTime)\n#else\nimport Data.Time.Clock.POSIX (getPOSIXTime)\n#endif\n\n#ifdef VERSION_unix\n#include "HsUnixConfig.h"\n#ifdef HAVE_SIGNAL_H\n#define INSTALL_HANDLERS 1\n#else\n#define INSTALL_HANDLERS 0\n#endif\n#else\n#define INSTALL_HANDLERS 0\n#endif\n\n#if INSTALL_HANDLERS\nimport System.Posix.Signals\nimport System.Mem.Weak (deRefWeak)\n#endif\n\nimport Test.Tasty.Core (Time)\n\n-- | Catch possible exceptions that may arise when evaluating a string.\n-- For normal (total) strings, this is a no-op.\n--\n-- This function should be used to display messages generated by the test\n-- suite (such as test result descriptions).\n--\n-- See e.g. <https://github.com/UnkindPartition/tasty/issues/25>.\n--\n-- @since 0.10.1\nformatMessage :: String -> IO String\nformatMessage = go 3\n  where\n    -- to avoid infinite recursion, we introduce the recursion limit\n    go :: Int -> String -> IO String\n    go 0        _ = return "exceptions keep throwing other exceptions!"\n    go recLimit msg = do\n      mbStr <- try $ evaluate $ forceElements msg\n      case mbStr of\n        Right () -> return msg\n        Left e\' -> printf "message threw an exception: %s" <$> go (recLimit-1) (show (e\' :: SomeException))\n\n-- | Force elements of a list\n-- (<https://ro-che.info/articles/2015-05-28-force-list>).\n--\n-- @since 1.0.1\nforceElements :: [a] -> ()\nforceElements = foldr seq ()\n\n-- from https://ro-che.info/articles/2014-07-30-bracket\n-- | Install signal handlers so that e.g. the cursor is restored if the test\n-- suite is killed by SIGTERM. Upon a signal, a \'SignalException\' will be\n-- thrown to the thread that has executed this action.\n--\n-- This function is called automatically from the @defaultMain*@ family of\n-- functions. You only need to call it explicitly if you call\n-- \'Test.Tasty.Runners.tryIngredients\' yourself.\n--\n-- This function does nothing when POSIX signals are not supported.\n--\n-- @since 1.2.1\ninstallSignalHandlers :: IO ()\ninstallSignalHandlers = do\n#if INSTALL_HANDLERS\n  main_thread_id <- myThreadId\n  weak_tid <- mkWeakThreadId main_thread_id\n  forM_ [ sigHUP, sigTERM, sigUSR1, sigUSR2, sigXCPU, sigXFSZ ] $ \\sig ->\n    installHandler sig (Catch $ send_exception weak_tid sig) Nothing\n  where\n    send_exception weak_tid sig = do\n      m <- deRefWeak weak_tid\n      case m of\n        Nothing  -> return ()\n        Just tid -> throwTo tid (toException $ SignalException sig)\n#else\n  return ()\n#endif\n\n-- | This exception is thrown when the program receives a signal, assuming\n-- \'installSignalHandlers\' was called.\n--\n-- The \'CInt\' field contains the signal number, as in\n-- \'System.Posix.Signals.Signal\'. We don\'t use that type synonym, however,\n-- because it\'s not available on non-UNIXes.\n--\n-- @since 1.2.1\nnewtype SignalException = SignalException CInt\n  deriving (Show, Typeable)\ninstance Exception SignalException\n\n-- | Measure the time taken by an \'IO\' action to run.\n--\n-- @since 1.2.2\ntimed :: IO a -> IO (Time, a)\ntimed t = do\n  start <- getTime\n  !r    <- t\n  end   <- getTime\n  return (end-start, r)\n\n#if MIN_VERSION_base(4,11,0)\n-- | Get monotonic time.\n--\n-- Warning: This is not the system time, but a monotonically increasing time\n-- that facilitates reliable measurement of time differences.\n--\n-- @since 1.2.2\ngetTime :: IO Time\ngetTime = getMonotonicTime\n#else\n-- | Get system time.\n--\n-- @since 1.2.2\ngetTime :: IO Time\ngetTime = realToFrac <$> getPOSIXTime\n#endif\n'