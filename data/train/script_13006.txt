b'using System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing sqlite_int64 = System.Int64;\nusing unsigned = System.Int32;\n\nusing i16 = System.Int16;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\nusing u64 = System.UInt64;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** Main file for the SQLite library.  The routines in this file\n    ** implement the programmer interface to the library.  Routines in\n    ** other files are for internal use by SQLite and should not be\n    ** accessed by users of the library.\n    **\n    ** $Id: main.c,v 1.562 2009/07/20 11:32:03 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n#if  SQLITE_ENABLE_FTS3\n//# include "fts3.h"\n#endif\n#if SQLITE_ENABLE_RTREE\n//# include "rtree.h"\n#endif\n#if SQLITE_ENABLE_ICU\n//# include "sqliteicu.h"\n#endif\n\n    /*\n** The version of the library\n*/\n#if !SQLITE_AMALGAMATION\n    public static string sqlite3_version = SQLITE_VERSION;\n#endif\n    public static string sqlite3_libversion() { return sqlite3_version; }\n    public static int sqlite3_libversion_number() { return SQLITE_VERSION_NUMBER; }\n    public static int sqlite3_threadsafe() { return SQLITE_THREADSAFE; }\n\n#if !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE\n/*\n** If the following function pointer is not NULL and if\n** SQLITE_ENABLE_IOTRACE is enabled, then messages describing\n** I/O active are written using this function.  These messages\n** are intended for debugging activity only.\n*/\n//void (*sqlite3IoTrace)(const char*, ...) = 0;\nstatic void sqlite3IoTrace( string X, params object[] ap ) {  }\n#endif\n\n    /*\n** If the following global variable points to a string which is the\n** name of a directory, then that directory will be used to store\n** temporary files.\n**\n** See also the "PRAGMA temp_store_directory" SQL command.\n*/\n    static string sqlite3_temp_directory = "";//char *sqlite3_temp_directory = 0;\n\n    /*\n    ** Initialize SQLite.\n    **\n    ** This routine must be called to initialize the memory allocation,\n    ** VFS, and mutex subsystems prior to doing any serious work with\n    ** SQLite.  But as long as you do not compile with SQLITE_OMIT_AUTOINIT\n    ** this routine will be called automatically by key routines such as\n    ** sqlite3_open().\n    **\n    ** This routine is a no-op except on its very first call for the process,\n    ** or for the first call after a call to sqlite3_shutdown.\n    **\n    ** The first thread to call this routine runs the initialization to\n    ** completion.  If subsequent threads call this routine before the first\n    ** thread has finished the initialization process, then the subsequent\n    ** threads must block until the first thread finishes with the initialization.\n    **\n    ** The first thread might call this routine recursively.  Recursive\n    ** calls to this routine should not block, of course.  Otherwise the\n    ** initialization process would never complete.\n    **\n    ** Let X be the first thread to enter this routine.  Let Y be some other\n    ** thread.  Then while the initial invocation of this routine by X is\n    ** incomplete, it is required that:\n    **\n    **    *  Calls to this routine from Y must block until the outer-most\n    **       call by X completes.\n    **\n    **    *  Recursive calls to this routine from thread X return immediately\n    **       without blocking.\n    */\n    static int sqlite3_initialize()\n    {\n      //--------------------------------------------------------------------\n      // Under C#, Need to initialize some global structures\n      //\n      if ( opcodeProperty == null ) opcodeProperty = OPFLG_INITIALIZER;\n      if ( sqlite3GlobalConfig == null ) sqlite3GlobalConfig = sqlite3Config;\n      if ( UpperToLower == null ) UpperToLower = sqlite3UpperToLower;\n      //--------------------------------------------------------------------\n\n\n      sqlite3_mutex pMaster;            /* The main static mutex */\n      int rc;                           /* Result code */\n\n#if SQLITE_OMIT_WSD\nrc = sqlite3_wsd_init(4096, 24);\nif( rc!=SQLITE_OK ){\nreturn rc;\n}\n#endif\n      /* If SQLite is already completely initialized, then this call\n** to sqlite3_initialize() should be a no-op.  But the initialization\n** must be complete.  So isInit must not be set until the very end\n** of this routine.\n*/\n      if ( sqlite3GlobalConfig.isInit != 0 ) return SQLITE_OK;\n\n      /* Make sure the mutex subsystem is initialized.  If unable to\n      ** initialize the mutex subsystem, return early with the error.\n      ** If the system is so sick that we are unable to allocate a mutex,\n      ** there is not much SQLite is going to be able to do.\n      **\n      ** The mutex subsystem must take care of serializing its own\n      ** initialization.\n      */\n      rc = sqlite3MutexInit();\n      if ( rc != 0 ) return rc;\n\n      /* Initialize the malloc() system and the recursive pInitMutex mutex.\n      ** This operation is protected by the STATIC_MASTER mutex.  Note that\n      ** MutexAlloc() is called for a static mutex prior to initializing the\n      ** malloc subsystem - this implies that the allocation of a static\n      ** mutex must not require support from the malloc subsystem.\n      */\n      pMaster = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER );\n      sqlite3_mutex_enter( pMaster );\n      if ( sqlite3GlobalConfig.isMallocInit == 0 )\n      {\n        //rc = sqlite3MallocInit();\n      }\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3GlobalConfig.isMallocInit = 1;\n        if ( sqlite3GlobalConfig.pInitMutex == null )\n        {\n          sqlite3GlobalConfig.pInitMutex = sqlite3MutexAlloc( SQLITE_MUTEX_RECURSIVE );\n          if ( sqlite3GlobalConfig.bCoreMutex && sqlite3GlobalConfig.pInitMutex == null )\n          {\n            rc = SQLITE_NOMEM;\n          }\n        }\n      }\n      if ( rc == SQLITE_OK )\n      {\n        sqlite3GlobalConfig.nRefInitMutex++;\n      }\n      sqlite3_mutex_leave( pMaster );\n      /* If unable to initialize the malloc subsystem, then return early.\n      ** There is little hope of getting SQLite to run if the malloc\n      ** subsystem cannot be initialized.\n      */\n      if ( rc != SQLITE_OK )\n      {\n        return rc;\n      }\n\n      /* Do the rest of the initialization under the recursive mutex so\n      ** that we will be able to handle recursive calls into\n      ** sqlite3_initialize().  The recursive calls normally come through\n      ** sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other\n      ** recursive calls might also be possible.\n      */\n      sqlite3_mutex_enter( sqlite3GlobalConfig.pInitMutex );\n      if ( sqlite3GlobalConfig.isInit == 0 && sqlite3GlobalConfig.inProgress == 0 )\n      {\n        sqlite3GlobalConfig.inProgress = 1;\n#if SQLITE_OMIT_WSD\nFuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions);\nmemset( pHash, 0, sizeof( sqlite3GlobalFunctions ) );\n#else\n        sqlite3GlobalFunctions = new FuncDefHash();\n        FuncDefHash pHash = sqlite3GlobalFunctions;\n#endif\n        sqlite3RegisterGlobalFunctions();\n        rc = sqlite3PcacheInitialize();\n        if ( rc == SQLITE_OK )\n        {\n          rc = sqlite3_os_init();\n        }\n        if ( rc == SQLITE_OK )\n        {\n          sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage,\n          sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage );\n          sqlite3GlobalConfig.isInit = 1;\n        }\n        sqlite3GlobalConfig.inProgress = 0;\n      }\n      sqlite3_mutex_leave( sqlite3GlobalConfig.pInitMutex );\n      /* Go back under the static mutex and clean up the recursive\n      ** mutex to prevent a resource leak.\n      */\n      sqlite3_mutex_enter( pMaster );\n      sqlite3GlobalConfig.nRefInitMutex--;\n      if ( sqlite3GlobalConfig.nRefInitMutex <= 0 )\n      {\n        Debug.Assert( sqlite3GlobalConfig.nRefInitMutex == 0 );\n        sqlite3_mutex_free( ref  sqlite3GlobalConfig.pInitMutex );\n        sqlite3GlobalConfig.pInitMutex = null;\n      }\n      sqlite3_mutex_leave( pMaster );\n\n      /* The following is just a sanity check to make sure SQLite has\n      ** been compiled correctly.  It is important to run this code, but\n      ** we don\'t want to run it too often and soak up CPU cycles for no\n      ** reason.  So we run it once during initialization.\n      */\n#if !NDEBUG\n#if !SQLITE_OMIT_FLOATING_POINT\n      /* This section of code\'s only "output" is via Debug.Assert() statements. */\n      if ( rc == SQLITE_OK )\n      {\n        //u64 x = ( ( (u64)1 ) << 63 ) - 1;\n        //double y;\n        //Debug.Assert( sizeof( u64 ) == 8 );\n        //Debug.Assert( sizeof( u64 ) == sizeof( double ) );\n        //memcpy( &y, x, 8 );\n        //Debug.Assert( sqlite3IsNaN( y ) );\n      }\n#endif\n#endif\n\n      return rc;\n    }\n\n    /*\n    ** Undo the effects of sqlite3_initialize().  Must not be called while\n    ** there are outstanding database connections or memory allocations or\n    ** while any part of SQLite is otherwise in use in any thread.  This\n    ** routine is not threadsafe.  But it is safe to invoke this routine\n    ** on when SQLite is already shut down.  If SQLite is already shut down\n    ** when this routine is invoked, then this routine is a harmless no-op.\n    */\n    static int sqlite3_shutdown()\n    {\n      if ( sqlite3GlobalConfig.isInit != 0 )\n      {\n        sqlite3GlobalConfig.isMallocInit = 0;\n        sqlite3PcacheShutdown();\n        sqlite3_os_end();\n        sqlite3_reset_auto_extension();\n        //sqlite3MallocEnd();\n        sqlite3MutexEnd();\n        sqlite3GlobalConfig.isInit = 0;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** This API allows applications to modify the global configuration of\n    ** the SQLite library at run-time.\n    **\n    ** This routine should only be called when there are no outstanding\n    ** database connections or memory allocations.  This routine is not\n    ** threadsafe.  Failure to heed these warnings can lead to unpredictable\n    ** behavior.\n    */\n    // Overloads for ap assignments\n    static int sqlite3_config( int op, sqlite3_pcache_methods ap )\n    {      //  va_list ap;\n      int rc = SQLITE_OK;\n      switch ( op )\n      {\n        case SQLITE_CONFIG_PCACHE:\n          {\n            /* Specify an alternative malloc implementation */\n            sqlite3GlobalConfig.pcache = ap; //sqlite3GlobalConfig.pcache = (sqlite3_pcache_methods)va_arg(ap, "sqlite3_pcache_methods");\n            break;\n          }\n      }\n      return rc;\n    }\n\n    static int sqlite3_config( int op, ref sqlite3_pcache_methods ap )\n    {      //  va_list ap;\n      int rc = SQLITE_OK;\n      switch ( op )\n      {\n        case SQLITE_CONFIG_GETPCACHE:\n          {\n            if ( sqlite3GlobalConfig.pcache.xInit == null )\n            {\n              sqlite3PCacheSetDefault();\n            }\n            ap = sqlite3GlobalConfig.pcache;//va_arg(ap, sqlite3_pcache_methods*) = sqlite3GlobalConfig.pcache;\n            break;\n          }\n      }\n      return rc;\n    }\n\n    static int sqlite3_config( int op, sqlite3_mem_methods ap )\n    {      //  va_list ap;\n      int rc = SQLITE_OK;\n      switch ( op )\n      {\n        case SQLITE_CONFIG_MALLOC:\n          {\n            /* Specify an alternative malloc implementation */\n            sqlite3GlobalConfig.m = ap;// (sqlite3_mem_methods)va_arg( ap, "sqlite3_mem_methods" );\n            break;\n          }\n      }\n      return rc;\n    }\n\n    static int sqlite3_config( int op, ref sqlite3_mem_methods ap )\n    {      //  va_list ap;\n      int rc = SQLITE_OK;\n      switch ( op )\n      {\n        case SQLITE_CONFIG_GETMALLOC:\n          {\n            /* Retrieve the current malloc() implementation */\n            //if ( sqlite3GlobalConfig.m.xMalloc == null ) sqlite3MemSetDefault();\n            ap = sqlite3GlobalConfig.m;//va_arg(ap, sqlite3_mem_methods*) =  sqlite3GlobalConfig.m;\n            break;\n          }\n      }\n      return rc;\n    }\n\n#if SQLITE_THREADSAFE\nstatic int sqlite3_config( int op,  sqlite3_mutex_methods ap )\n{\n//  va_list ap;\nint rc = SQLITE_OK;\nswitch ( op )\n{\ncase SQLITE_CONFIG_MUTEX:\n{\n/* Specify an alternative mutex implementation */\nsqlite3GlobalConfig.mutex = ap;// (sqlite3_mutex_methods)va_arg( ap, "sqlite3_mutex_methods" );\nbreak;\n}\n}\nreturn rc;\n}\n\nstatic int sqlite3_config( int op, ref sqlite3_mutex_methods ap )\n{\n//  va_list ap;\nint rc = SQLITE_OK;\nswitch ( op )\n{\ncase SQLITE_CONFIG_GETMUTEX:\n{\n/* Retrieve the current mutex implementation */\nap =  sqlite3GlobalConfig.mutex;// *va_arg(ap, sqlite3_mutex_methods*) =  sqlite3GlobalConfig.mutex;\nbreak;\n}\n}\nreturn rc;\n}\n#endif\n\n    static int sqlite3_config( int op, params object[] ap )\n    {\n      //  va_list ap;\n      int rc = SQLITE_OK;\n\n      /* sqlite3_config() shall return SQLITE_MISUSE if it is invoked while\n      ** the SQLite library is in use. */\n      if ( sqlite3GlobalConfig.isInit != 0 ) return SQLITE_MISUSE;\n\n      va_start( ap, null );\n      switch ( op )\n      {\n\n        /* Mutex configuration options are only available in a threadsafe\n        ** compile.\n        */\n#if SQLITE_THREADSAFE\ncase SQLITE_CONFIG_SINGLETHREAD:\n{\n/* Disable all mutexing */\nsqlite3GlobalConfig.bCoreMutex = false;\nsqlite3GlobalConfig.bFullMutex = false;\nbreak;\n}\ncase SQLITE_CONFIG_MULTITHREAD:\n{\n/* Disable mutexing of database connections */\n/* Enable mutexing of core data structures */\nsqlite3GlobalConfig.bCoreMutex = true;\nsqlite3GlobalConfig.bFullMutex = false;\nbreak;\n}\ncase SQLITE_CONFIG_SERIALIZED:\n{\n/* Enable all mutexing */\nsqlite3GlobalConfig.bCoreMutex = true;\nsqlite3GlobalConfig.bFullMutex = true;\nbreak;\n}\ncase SQLITE_CONFIG_MUTEX: {\n/* Specify an alternative mutex implementation */\nsqlite3GlobalConfig.mutex = *va_arg(ap, sqlite3_mutex_methods*);\nbreak;\n}\ncase SQLITE_CONFIG_GETMUTEX: {\n/* Retrieve the current mutex implementation */\n*va_arg(ap, sqlite3_mutex_methods*) = sqlite3GlobalConfig.mutex;\nbreak;\n}\n#endif\n        case SQLITE_CONFIG_MALLOC:\n          {\n            Debugger.Break(); // TODO --\n            /* Specify an alternative malloc implementation */\n            sqlite3GlobalConfig.m = (sqlite3_mem_methods)va_arg( ap, "sqlite3_mem_methods" );\n            break;\n          }\n        case SQLITE_CONFIG_GETMALLOC:\n          {\n            /* Retrieve the current malloc() implementation */\n            //if ( sqlite3GlobalConfig.m.xMalloc == null ) sqlite3MemSetDefault();\n            //Debugger.Break(); // TODO --//va_arg(ap, sqlite3_mem_methods*) =  sqlite3GlobalConfig.m;\n            break;\n          }\n        case SQLITE_CONFIG_MEMSTATUS:\n          {\n            /* Enable or disable the malloc status collection */\n            sqlite3GlobalConfig.bMemstat = (int)va_arg( ap, "int" ) != 0;\n            break;\n          }\n        case SQLITE_CONFIG_SCRATCH:\n          {\n            /* Designate a buffer for scratch memory space */\n            sqlite3GlobalConfig.pScratch = (byte[])va_arg( ap, "byte[]" );\n            sqlite3GlobalConfig.szScratch = (int)va_arg( ap, "int" );\n            sqlite3GlobalConfig.nScratch = (int)va_arg( ap, "int" );\n            break;\n          }\n\n        case SQLITE_CONFIG_PAGECACHE:\n          {\n            /* Designate a buffer for page cache memory space */\n            sqlite3GlobalConfig.pPage = (MemPage)va_arg( ap, "MemPage" );\n            sqlite3GlobalConfig.szPage = (int)va_arg( ap, "int" );\n            sqlite3GlobalConfig.nPage = (int)va_arg( ap, "int" );\n            break;\n          }\n\n        case SQLITE_CONFIG_PCACHE:\n          {\n            /* Specify an alternative page cache implementation */\n            Debugger.Break(); // TODO --sqlite3GlobalConfig.pcache = (sqlite3_pcache_methods)va_arg(ap, "sqlite3_pcache_methods");\n            break;\n          }\n\n        case SQLITE_CONFIG_GETPCACHE:\n          {\n            if ( sqlite3GlobalConfig.pcache.xInit == null )\n            {\n              sqlite3PCacheSetDefault();\n            }\n            Debugger.Break(); // TODO -- *va_arg(ap, sqlite3_pcache_methods*) = sqlite3GlobalConfig.pcache;\n            break;\n          }\n\n#if SQLITE_ENABLE_MEMSYS3 || SQLITE_ENABLE_MEMSYS5\ncase SQLITE_CONFIG_HEAP: {\n/* Designate a buffer for heap memory space */\nsqlite3GlobalConfig.pHeap = va_arg(ap, void*);\nsqlite3GlobalConfig.nHeap = va_arg(ap, int);\nsqlite3GlobalConfig.mnReq = va_arg(ap, int);\n\nif(  sqlite3GlobalConfig.pHeap==0 ){\n/* If the heap pointer is NULL, then restore the malloc implementation\n** back to NULL pointers too.  This will cause the malloc to go\n** back to its default implementation when sqlite3_initialize() is\n** run.\n*/\nmemset(& sqlite3GlobalConfig.m, 0, sizeof( sqlite3GlobalConfig.m));\n}else{\n/* The heap pointer is not NULL, then install one of the\n** mem5.c/mem3.c methods. If neither ENABLE_MEMSYS3 nor\n** ENABLE_MEMSYS5 is defined, return an error.\n*/\n#if SQLITE_ENABLE_MEMSYS3\nsqlite3GlobalConfig.m = *sqlite3MemGetMemsys3();\n#endif\n#if SQLITE_ENABLE_MEMSYS5\nsqlite3GlobalConfig.m = *sqlite3MemGetMemsys5();\n#endif\n}\nbreak;\n}\n#endif\n\n        case SQLITE_CONFIG_LOOKASIDE:\n          {\n            sqlite3GlobalConfig.szLookaside = (int)va_arg( ap, "int" );\n            sqlite3GlobalConfig.nLookaside = (int)va_arg( ap, "int" );\n            break;\n          }\n\n        default:\n          {\n            rc = SQLITE_ERROR;\n            break;\n          }\n      }\n      va_end( ap );\n      return rc;\n    }\n\n    /*\n    ** Set up the lookaside buffers for a database connection.\n    ** Return SQLITE_OK on success.\n    ** If lookaside is already active, return SQLITE_BUSY.\n    **\n    ** The sz parameter is the number of bytes in each lookaside slot.\n    ** The cnt parameter is the number of slots.  If pStart is NULL the\n    ** space for the lookaside memory is obtained from sqlite3_malloc().\n    ** If pStart is not NULL then it is sz*cnt bytes of memory to use for\n    ** the lookaside memory.\n    */\n    static int setupLookaside( sqlite3 db, byte[] pBuf, int sz, int cnt )\n    {\n      //void* pStart;\n      //if ( db.lookaside.nOut )\n      //{\n      //  return SQLITE_BUSY;\n      //}\n      ///* Free any existing lookaside buffer for this handle before\n      //** allocating a new one so we don\'t have to have space for\n      //** both at the same time.\n      //*/\n      //if ( db.lookaside.bMalloced )\n      //{\n      //  //sqlite3_free( db.lookaside.pStart );\n      //}\n      ///* The size of a lookaside slot needs to be larger than a pointer\n      //** to be useful.\n      //*/\n      //if ( sz <= (int)sizeof( LookasideSlot* ) ) sz = 0;\n      //if ( cnt < 0 ) cnt = 0;\n      //if ( sz == 0 || cnt == 0 )\n      //{\n      //  sz = 0;\n      //  pStart = 0;\n      //}\n      //else if ( pBuf == 0 )\n      //{\n      //   sz = ROUND8(sz);\n      //  sqlite3BeginBenignMalloc();\n      //  pStart = sqlite3Malloc( sz * cnt );\n      //  sqlite3EndBenignMalloc();\n      //}\n      //else\n      //{\n      //  ROUNDDOWN8(sz);\n      //  pStart = pBuf;\n      //}\n      //db.lookaside.pStart = pStart;\n      //db.lookaside.pFree = 0;\n      //db.lookaside.sz = (u16)sz;\n      //if ( pStart )\n      //{\n      //  int i;\n      //  LookasideSlot* p;\n      //  Debug.Assert( sz > sizeof( LookasideSlot* ) );\n      //  p = (LookasideSlot*)pStart;\n      //  for ( i = cnt - 1 ; i >= 0 ; i-- )\n      //  {\n      //    p.pNext = db.lookaside.pFree;\n      //    db.lookaside.pFree = p;\n      //    p = (LookasideSlot*)&( (u8*)p )[sz];\n      //  }\n      //  db.lookaside.pEnd = p;\n      //  db.lookaside.bEnabled = 1;\n      //  db.lookaside.bMalloced = pBuf == 0 ? 1 : 0;\n      //}\n      //else\n      //{\n      //  db.lookaside.pEnd = 0;\n      //  db.lookaside.bEnabled = 0;\n      //  db.lookaside.bMalloced = 0;\n      //}\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Return the mutex associated with a database connection.\n    */\n    sqlite3_mutex sqlite3_db_mutex( sqlite3 db )\n    {\n      return db.mutex;\n    }\n\n    /*\n    ** Configuration settings for an individual database connection\n    */\n    static int sqlite3_db_config( sqlite3 db, int op, params object[] ap )\n    {\n      //va_list ap;\n      int rc;\n      va_start( ap, "" );\n      switch ( op )\n      {\n        case SQLITE_DBCONFIG_LOOKASIDE:\n          {\n            byte[] pBuf = (byte[])va_arg( ap, "byte[]" );\n            int sz = (int)va_arg( ap, "int" );\n            int cnt = (int)va_arg( ap, "int" );\n            rc = setupLookaside( db, pBuf, sz, cnt );\n            break;\n          }\n        default:\n          {\n            rc = SQLITE_ERROR;\n            break;\n          }\n      }\n      va_end( ap );\n      return rc;\n    }\n\n\n    /*\n    ** Return true if the buffer z[0..n-1] contains all spaces.\n    */\n    static bool allSpaces( string z, int iStart, int n )\n    {\n      while ( n > 0 && z[iStart + n - 1] == \' \' ) { n--; }\n      return n == 0;\n    }\n\n    /*\n    ** This is the default collating function named "BINARY" which is always\n    ** available.\n    **\n    ** If the padFlag argument is not NULL then space padding at the end\n    ** of strings is ignored.  This implements the RTRIM collation.\n    */\n    static int binCollFunc(\n    object padFlag,\n    int nKey1, string pKey1,\n    int nKey2, string pKey2\n    )\n    {\n      int rc, n;\n      n = nKey1 < nKey2 ? nKey1 : nKey2;\n      rc = memcmp( pKey1, pKey2, n );\n      if ( rc == 0 )\n      {\n        if ( (int)padFlag != 0 && allSpaces( pKey1, n, nKey1 - n ) && allSpaces( pKey2, n, nKey2 - n ) )\n        {\n          /* Leave rc unchanged at 0 */\n        }\n        else\n        {\n          rc = nKey1 - nKey2;\n        }\n      }\n      return rc;\n    }\n\n    /*\n    ** Another built-in collating sequence: NOCASE.\n    **\n    ** This collating sequence is intended to be used for "case independant\n    ** comparison". SQLite\'s knowledge of upper and lower case equivalents\n    ** extends only to the 26 characters used in the English language.\n    **\n    ** At the moment there is only a UTF-8 implementation.\n    */\n    static int nocaseCollatingFunc(\n    object NotUsed,\n    int nKey1, string pKey1,\n    int nKey2, string pKey2\n    )\n    {\n      int n = ( nKey1 < nKey2 ) ? nKey1 : nKey2;\n      int r = sqlite3StrNICmp( pKey1, pKey2, ( nKey1 < nKey2 ) ? nKey1 : nKey2 );\n      UNUSED_PARAMETER( NotUsed );\n      if ( 0 == r )\n      {\n        r = nKey1 - nKey2;\n      }\n      return r;\n    }\n\n    /*\n    ** Return the ROWID of the most recent insert\n    */\n    public static sqlite_int64 sqlite3_last_insert_rowid( sqlite3 db )\n    {\n      return db.lastRowid;\n    }\n\n    /*\n    ** Return the number of changes in the most recent call to sqlite3_exec().\n    */\n    public static int sqlite3_changes( sqlite3 db )\n    {\n      return db.nChange;\n    }\n\n    /*\n    ** Return the number of changes since the database handle was opened.\n    */\n    public static int sqlite3_total_changes( sqlite3 db )\n    {\n      return db.nTotalChange;\n    }\n\n    /*\n    ** Close all open savepoints. This function only manipulates fields of the\n    ** database handle object, it does not close any savepoints that may be open\n    ** at the b-tree/pager level.\n    */\n    static void sqlite3CloseSavepoints( sqlite3 db )\n    {\n      while ( db.pSavepoint != null )\n      {\n        Savepoint pTmp = db.pSavepoint;\n        db.pSavepoint = pTmp.pNext;\n        //sqlite3DbFree( db, ref pTmp );\n      }\n      db.nSavepoint = 0;\n      db.nStatement = 0;\n      db.isTransactionSavepoint = 0;\n    }\n\n    /*\n    ** Close an existing SQLite database\n    */\n    public static int sqlite3_close( sqlite3 db )\n    {\n      HashElem i;\n      int j;\n\n      if ( db == null )\n      {\n        return SQLITE_OK;\n      }\n      if ( !sqlite3SafetyCheckSickOrOk( db ) )\n      {\n        return SQLITE_MISUSE;\n      }\n      sqlite3_mutex_enter( db.mutex );\n\n      sqlite3ResetInternalSchema( db, 0 );\n\n      /* Tell the code in notify.c that the connection no longer holds any\n      ** locks and does not require any further unlock-notify callbacks.\n      */\n      sqlite3ConnectionClosed( db );\n\n      /* If a transaction is open, the ResetInternalSchema() call above\n      ** will not have called the xDisconnect() method on any virtual\n      ** tables in the db.aVTrans[] array. The following sqlite3VtabRollback()\n      ** call will do so. We need to do this before the check for active\n      ** SQL statements below, as the v-table implementation may be storing\n      ** some prepared statements internally.\n      */\n\n      sqlite3VtabRollback( db );\n\n      /* If there are any outstanding VMs, return SQLITE_BUSY. */\n      if ( db.pVdbe != null )\n      {\n        sqlite3Error( db, SQLITE_BUSY,\n        "unable to close due to unfinalised statements" );\n        sqlite3_mutex_leave( db.mutex );\n        return SQLITE_BUSY;\n      }\n      Debug.Assert( sqlite3SafetyCheckSickOrOk( db ) );\n\n      for ( j = 0 ; j < db.nDb ; j++ )\n      {\n        Btree pBt = db.aDb[j].pBt;\n        if ( pBt != null && sqlite3BtreeIsInBackup( pBt ) )\n        {\n          sqlite3Error( db, SQLITE_BUSY,\n          "unable to close due to unfinished backup operation" );\n          sqlite3_mutex_leave( db.mutex );\n          return SQLITE_BUSY;\n        }\n      }\n\n      /* Free any outstanding Savepoint structures. */\n      sqlite3CloseSavepoints( db );\n\n      for ( j = 0 ; j < db.nDb ; j++ )\n      {\n        Db pDb = db.aDb[j];\n        if ( pDb.pBt != null )\n        {\n          sqlite3BtreeClose( ref pDb.pBt );\n          pDb.pBt = null;\n          if ( j != 1 )\n          {\n            pDb.pSchema = null;\n          }\n        }\n      }\n      sqlite3ResetInternalSchema( db, 0 );\n      Debug.Assert( db.nDb <= 2 );\n      Debug.Assert( db.aDb[0].Equals( db.aDbStatic[0] ) );\n      for ( j = 0 ; j < ArraySize( db.aFunc.a ) ; j++ )\n      {\n        FuncDef pNext, pHash, p;\n        for ( p = db.aFunc.a[j] ; p != null ; p = pHash )\n        {\n          pHash = p.pHash;\n          while ( p != null )\n          {\n            pNext = p.pNext;\n            //sqlite3DbFree( db, p );\n            p = pNext;\n          }\n\n        }\n      }\n\n      for ( i = db.aCollSeq.first ; i != null ; i = i.next )\n      {//sqliteHashFirst(db.aCollSeq); i!=null; i=sqliteHashNext(i)){\n        CollSeq[] pColl = (CollSeq[])i.data;// sqliteHashData(i);\n        /* Invoke any destructors registered for collation sequence user data. */\n        for ( j = 0 ; j < 3 ; j++ )\n        {\n          if ( pColl[j].xDel != null )\n          {\n            pColl[j].xDel( ref  pColl[j].pUser );\n          }\n        }\n        //sqlite3DbFree( db, ref pColl );\n      }\n      sqlite3HashClear( db.aCollSeq );\n#if !SQLITE_OMIT_VIRTUALTABLE\nfor(i=sqliteHashFirst(&db.aModule); i; i=sqliteHashNext(i)){\nModule pMod = (Module *)sqliteHashData(i);\nif( pMod.xDestroy ){\npMod.xDestroy(pMod.pAux);\n}\n//sqlite3DbFree(db,ref pMod);\n}\nsqlite3HashClear(&db.aModule);\n#endif\n\n      sqlite3Error( db, SQLITE_OK, 0 ); /* Deallocates any cached error strings. */\n      if ( db.pErr != null )\n      {\n        sqlite3ValueFree( ref db.pErr );\n      }\n#if !SQLITE_OMIT_LOAD_EXTENSION\n      sqlite3CloseExtensions( db );\n#endif\n\n      db.magic = SQLITE_MAGIC_ERROR;\n\n      /* The temp.database schema is allocated differently from the other schema\n      ** objects (using sqliteMalloc() directly, instead of sqlite3BtreeSchema()).\n      ** So it needs to be freed here. Todo: Why not roll the temp schema into\n      ** the same sqliteMalloc() as the one that allocates the database\n      ** structure?\n      */\n      //sqlite3DbFree( db, ref db.aDb[1].pSchema );\n      sqlite3_mutex_leave( db.mutex );\n      db.magic = SQLITE_MAGIC_CLOSED;\n      sqlite3_mutex_free( ref db.mutex );\n      Debug.Assert( db.lookaside.nOut == 0 );  /* Fails on a lookaside memory leak */\n      if ( db.lookaside.bMalloced )\n      {\n        ////sqlite3_free( ref db.lookaside.pStart );\n      }\n      //sqlite3_free( ref db );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Rollback all database files.\n    */\n    static void sqlite3RollbackAll( sqlite3 db )\n    {\n      int i;\n      int inTrans = 0;\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      sqlite3BeginBenignMalloc();\n      for ( i = 0 ; i < db.nDb ; i++ )\n      {\n        if ( db.aDb[i].pBt != null )\n        {\n          if ( sqlite3BtreeIsInTrans( db.aDb[i].pBt ) )\n          {\n            inTrans = 1;\n          }\n          sqlite3BtreeRollback( db.aDb[i].pBt );\n          db.aDb[i].inTrans = 0;\n        }\n      }\n\n      sqlite3VtabRollback( db );\n      sqlite3EndBenignMalloc();\n      if ( ( db.flags & SQLITE_InternChanges ) != 0 )\n      {\n        sqlite3ExpirePreparedStatements( db );\n        sqlite3ResetInternalSchema( db, 0 );\n      }\n\n      /* If one has been configured, invoke the rollback-hook callback */\n      if ( db.xRollbackCallback != null && ( inTrans != 0 || 0 == db.autoCommit ) )\n      {\n        db.xRollbackCallback( db.pRollbackArg );\n      }\n    }\n\n    /*\n    ** Return a static string that describes the kind of error specified in the\n    ** argument.\n    */\n    static string sqlite3ErrStr( int rc )\n    {\n      string[] aMsg = new string[]{\n/* SQLITE_OK          */ "not an error",\n/* SQLITE_ERROR       */ "SQL logic error or missing database",\n/* SQLITE_INTERNAL    */ "",\n/* SQLITE_PERM        */ "access permission denied",\n/* SQLITE_ABORT       */ "callback requested query abort",\n/* SQLITE_BUSY        */ "database is locked",\n/* SQLITE_LOCKED      */ "database table is locked",\n/* SQLITE_NOMEM       */ "out of memory",\n/* SQLITE_READONLY    */ "attempt to write a readonly database",\n/* SQLITE_INTERRUPT   */ "interrupted",\n/* SQLITE_IOERR       */ "disk I/O error",\n/* SQLITE_CORRUPT     */ "database disk image is malformed",\n/* SQLITE_NOTFOUND    */ "",\n/* SQLITE_FULL        */ "database or disk is full",\n/* SQLITE_CANTOPEN    */ "unable to open database file",\n/* SQLITE_PROTOCOL    */ "",\n/* SQLITE_EMPTY       */ "table contains no data",\n/* SQLITE_SCHEMA      */ "database schema has changed",\n/* SQLITE_TOOBIG      */ "string or blob too big",\n/* SQLITE_CONSTRAINT  */ "constraint failed",\n/* SQLITE_MISMATCH    */ "datatype mismatch",\n/* SQLITE_MISUSE      */ "library routine called out of sequence",\n/* SQLITE_NOLFS       */ "large file support is disabled",\n/* SQLITE_AUTH        */ "authorization denied",\n/* SQLITE_FORMAT      */ "auxiliary database format error",\n/* SQLITE_RANGE       */ "bind or column index out of range",\n/* SQLITE_NOTADB      */ "file is encrypted or is not a database",\n};\n      rc &= 0xff;\n      if ( ALWAYS( rc >= 0 ) && rc < aMsg.Length && aMsg[rc] != "" )//(int)(sizeof(aMsg)/sizeof(aMsg[0]))\n      {\n        return aMsg[rc];\n      }\n      else\n      {\n        return "unknown error";\n      }\n    }\n\n    /*\n    ** This routine implements a busy callback that sleeps and tries\n    ** again until a timeout value is reached.  The timeout value is\n    ** an integer number of milliseconds passed in as the first\n    ** argument.\n    */\n    static int sqliteDefaultBusyCallback(\n    object ptr,               /* Database connection */\n    int count                /* Number of times table has been busy */\n    )\n    {\n#if SQLITE_OS_WIN || HAVE_USLEEP\n      u8[] delays = new u8[] { 1, 2, 5, 10, 15, 20, 25, 25, 25, 50, 50, 100 };\n      u8[] totals = new u8[] { 0, 1, 3, 8, 18, 33, 53, 78, 103, 128, 178, 228 };\n      //# define NDELAY (delays.Length/sizeof(delays[0]))\n      int NDELAY = delays.Length;\n      sqlite3 db = (sqlite3)ptr;\n      int timeout = db.busyTimeout;\n      int delay, prior;\n\n      Debug.Assert( count >= 0 );\n      if ( count < NDELAY )\n      {\n        delay = delays[count];\n        prior = totals[count];\n      }\n      else\n      {\n        delay = delays[NDELAY - 1];\n        prior = totals[NDELAY - 1] + delay * ( count - ( NDELAY - 1 ) );\n      }\n      if ( prior + delay > timeout )\n      {\n        delay = timeout - prior;\n        if ( delay <= 0 ) return 0;\n      }\n      sqlite3OsSleep( db.pVfs, delay * 1000 );\n      return 1;\n#else\nsqlite3 db = (sqlite3)ptr;\nint timeout = ( (sqlite3)ptr ).busyTimeout;\nif ( ( count + 1 ) * 1000 > timeout )\n{\nreturn 0;\n}\nsqlite3OsSleep( db.pVfs, 1000000 );\nreturn 1;\n#endif\n    }\n\n    /*\n    ** Invoke the given busy handler.\n    **\n    ** This routine is called when an operation failed with a lock.\n    ** If this routine returns non-zero, the lock is retried.  If it\n    ** returns 0, the operation aborts with an SQLITE_BUSY error.\n    */\n    static int sqlite3InvokeBusyHandler( BusyHandler p )\n    {\n      int rc;\n      if ( NEVER( p == null ) || p.xFunc == null || p.nBusy < 0 ) return 0;\n      rc = p.xFunc( p.pArg, p.nBusy );\n      if ( rc == 0 )\n      {\n        p.nBusy = -1;\n      }\n      else\n      {\n        p.nBusy++;\n      }\n      return rc;\n    }\n\n    /*\n    ** This routine sets the busy callback for an Sqlite database to the\n    ** given callback function with the given argument.\n    */\n    static int sqlite3_busy_handler(\n    sqlite3 db,\n    dxBusy xBusy,\n    object pArg\n    )\n    {\n      sqlite3_mutex_enter( db.mutex );\n      db.busyHandler.xFunc = xBusy;\n      db.busyHandler.pArg = pArg;\n      db.busyHandler.nBusy = 0;\n      sqlite3_mutex_leave( db.mutex );\n      return SQLITE_OK;\n    }\n\n#if !SQLITE_OMIT_PROGRESS_CALLBACK\n    /*\n** This routine sets the progress callback for an Sqlite database to the\n** given callback function with the given argument. The progress callback will\n** be invoked every nOps opcodes.\n*/\n    static void sqlite3_progress_handler(\n    sqlite3 db,\n    int nOps,\n    dxProgress xProgress, //int (xProgress)(void*),\n    object pArg\n    )\n    {\n      sqlite3_mutex_enter( db.mutex );\n      if ( nOps > 0 )\n      {\n        db.xProgress = xProgress;\n        db.nProgressOps = nOps;\n        db.pProgressArg = pArg;\n      }\n      else\n      {\n        db.xProgress = null;\n        db.nProgressOps = 0;\n        db.pProgressArg = null;\n      }\n      sqlite3_mutex_leave( db.mutex );\n    }\n#endif\n\n\n    /*\n** This routine installs a default busy handler that waits for the\n** specified number of milliseconds before returning 0.\n*/\n    public static int sqlite3_busy_timeout( sqlite3 db, int ms )\n    {\n      if ( ms > 0 )\n      {\n        db.busyTimeout = ms;\n        sqlite3_busy_handler( db, sqliteDefaultBusyCallback, db );\n      }\n      else\n      {\n        sqlite3_busy_handler( db, null, null );\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Cause any pending operation to stop at its earliest opportunity.\n    */\n    static void sqlite3_interrupt( sqlite3 db )\n    {\n      db.u1.isInterrupted = true;\n    }\n\n\n    /*\n    ** This function is exactly the same as sqlite3_create_function(), except\n    ** that it is designed to be called by internal code. The difference is\n    ** that if a malloc() fails in sqlite3_create_function(), an error code\n    ** is returned and the mallocFailed flag cleared.\n    */\n    static int sqlite3CreateFunc(\n    sqlite3 db,\n    string zFunctionName,\n    int nArg,\n    u8 enc,\n    object pUserData,\n    dxFunc xFunc, //)(sqlite3_context*,int,sqlite3_value **),\n    dxStep xStep,//)(sqlite3_context*,int,sqlite3_value **),\n    dxFinal xFinal//)(sqlite3_context*)\n    )\n    {\n      FuncDef p;\n      int nName;\n\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      if ( zFunctionName == null ||\n      ( xFunc != null && ( xFinal != null || xStep != null ) ) ||\n      ( xFunc == null && ( xFinal != null && xStep == null ) ) ||\n      ( xFunc == null && ( xFinal == null && xStep != null ) ) ||\n      ( nArg < -1 || nArg > SQLITE_MAX_FUNCTION_ARG ) ||\n      ( 255 < ( nName = sqlite3Strlen30( zFunctionName ) ) ) )\n      {\n        return SQLITE_MISUSE;\n      }\n\n#if !SQLITE_OMIT_UTF16\n/* If SQLITE_UTF16 is specified as the encoding type, transform this\n** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the\n** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.\n**\n** If SQLITE_ANY is specified, add three versions of the function\n** to the hash table.\n*/\nif( enc==SQLITE_UTF16 ){\nenc = SQLITE_UTF16NATIVE;\n}else if( enc==SQLITE_ANY ){\nint rc;\nrc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF8,\npUserData, xFunc, xStep, xFinal);\nif( rc==SQLITE_OK ){\nrc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF16LE,\npUserData, xFunc, xStep, xFinal);\n}\nif( rc!=SQLITE_OK ){\nreturn rc;\n}\nenc = SQLITE_UTF16BE;\n}\n#else\n      enc = SQLITE_UTF8;\n#endif\n\n      /* Check if an existing function is being overridden or deleted. If so,\n** and there are active VMs, then return SQLITE_BUSY. If a function\n** is being overridden/deleted but there are no active VMs, allow the\n** operation to continue but invalidate all precompiled statements.\n*/\n      p = sqlite3FindFunction( db, zFunctionName, nName, nArg, enc, 0 );\n      if ( p != null && p.iPrefEnc == enc && p.nArg == nArg )\n      {\n        if ( db.activeVdbeCnt != 0 )\n        {\n          sqlite3Error( db, SQLITE_BUSY,\n          "unable to delete/modify user-function due to active statements" );\n          //Debug.Assert( 0 == db.mallocFailed );\n          return SQLITE_BUSY;\n        }\n        else\n        {\n          sqlite3ExpirePreparedStatements( db );\n        }\n      }\n\n      p = sqlite3FindFunction( db, zFunctionName, nName, nArg, enc, 1 );\n      Debug.Assert( p != null /*|| db.mallocFailed != 0 */ );\n      if ( p == null )\n      {\n        return SQLITE_NOMEM;\n      }\n      p.flags = 0;\n      p.xFunc = xFunc;\n      p.xStep = xStep;\n      p.xFinalize = xFinal;\n      p.pUserData = pUserData;\n      p.nArg = (i16)nArg;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Create new user functions.\n    */\n    public static int sqlite3_create_function(\n    sqlite3 db,\n    string zFunctionName,\n    int nArg,\n    u8 enc,\n    object p,\n    dxFunc xFunc, //)(sqlite3_context*,int,sqlite3_value **),\n    dxStep xStep,//)(sqlite3_context*,int,sqlite3_value **),\n    dxFinal xFinal//)(sqlite3_context*)\n    )\n    {\n      int rc;\n      sqlite3_mutex_enter( db.mutex );\n      rc = sqlite3CreateFunc( db, zFunctionName, nArg, enc, p, xFunc, xStep, xFinal );\n      rc = sqlite3ApiExit( db, rc );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n#if !SQLITE_OMIT_UTF16\nstatic int sqlite3_create_function16(\nsqlite3 db,\nstring zFunctionName,\nint nArg,\nint eTextRep,\nobject p,\ndxFunc xFunc,   //)(sqlite3_context*,int,sqlite3_value**),\ndxStep xStep,   //)(sqlite3_context*,int,sqlite3_value**),\ndxFinal xFinal  //)(sqlite3_context*)\n){\nint rc;\nstring zFunc8;\nsqlite3_mutex_enter(db.mutex);\nDebug.Assert( 0==db.mallocFailed );\nzFunc8 = sqlite3Utf16to8(db, zFunctionName, -1);\nrc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal);\n//sqlite3DbFree(db,ref zFunc8);\nrc = sqlite3ApiExit(db, rc);\nsqlite3_mutex_leave(db.mutex);\nreturn rc;\n}\n#endif\n\n\n    /*\n** Declare that a function has been overloaded by a virtual table.\n**\n** If the function already exists as a regular global function, then\n** this routine is a no-op.  If the function does not exist, then create\n** a new one that always throws a run-time error.\n**\n** When virtual tables intend to provide an overloaded function, they\n** should call this routine to make sure the global function exists.\n** A global function must exist in order for name resolution to work\n** properly.\n*/\n    static int sqlite3_overload_function(\n    sqlite3 db,\n    string zName,\n    int nArg\n    )\n    {\n      int nName = sqlite3Strlen30( zName );\n      int rc;\n      sqlite3_mutex_enter( db.mutex );\n      if ( sqlite3FindFunction( db, zName, nName, nArg, SQLITE_UTF8, 0 ) == null )\n      {\n        sqlite3CreateFunc( db, zName, nArg, SQLITE_UTF8,\n        0, (dxFunc)sqlite3InvalidFunction, null, null );\n      }\n      rc = sqlite3ApiExit( db, SQLITE_OK );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n#if !SQLITE_OMIT_TRACE\n    /*\n** Register a trace function.  The pArg from the previously registered trace\n** is returned.\n**\n** A NULL trace function means that no tracing is executes.  A non-NULL\n** trace is a pointer to a function that is invoked at the start of each\n** SQL statement.\n*/\n    static object sqlite3_trace( sqlite3 db, dxTrace xTrace, object pArg )\n    {// (*xTrace)(void*,const char*), object pArg){\n      object pOld;\n      sqlite3_mutex_enter( db.mutex );\n      pOld = db.pTraceArg;\n      db.xTrace = xTrace;\n      db.pTraceArg = pArg;\n      sqlite3_mutex_leave( db.mutex );\n      return pOld;\n    }\n    /*\n    ** Register a profile function.  The pArg from the previously registered\n    ** profile function is returned.\n    **\n    ** A NULL profile function means that no profiling is executes.  A non-NULL\n    ** profile is a pointer to a function that is invoked at the conclusion of\n    ** each SQL statement that is run.\n    */\n    static object sqlite3_profile(\n    sqlite3 db,\n    dxProfile xProfile,//void (*xProfile)(void*,const char*,sqlite_u3264),\n    object pArg\n    )\n    {\n      object pOld;\n      sqlite3_mutex_enter( db.mutex );\n      pOld = db.pProfileArg;\n      db.xProfile = xProfile;\n      db.pProfileArg = pArg;\n      sqlite3_mutex_leave( db.mutex );\n      return pOld;\n    }\n#endif // * SQLITE_OMIT_TRACE */\n\n    /*** EXPERIMENTAL ***\n**\n** Register a function to be invoked when a transaction comments.\n** If the invoked function returns non-zero, then the commit becomes a\n** rollback.\n*/\n    static object sqlite3_commit_hook(\n    sqlite3 db,             /* Attach the hook to this database */\n    dxCommitCallback xCallback,   //int (*xCallback)(void*),  /* Function to invoke on each commit */\n    object pArg             /* Argument to the function */\n    )\n    {\n      object pOld;\n      sqlite3_mutex_enter( db.mutex );\n      pOld = db.pCommitArg;\n      db.xCommitCallback = xCallback;\n      db.pCommitArg = pArg;\n      sqlite3_mutex_leave( db.mutex );\n      return pOld;\n    }\n\n    /*\n    ** Register a callback to be invoked each time a row is updated,\n    ** inserted or deleted using this database connection.\n    */\n    static object sqlite3_update_hook(\n    sqlite3 db,             /* Attach the hook to this database */\n    dxUpdateCallback xCallback,   //void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),\n    object pArg             /* Argument to the function */\n    )\n    {\n      object pRet;\n      sqlite3_mutex_enter( db.mutex );\n      pRet = db.pUpdateArg;\n      db.xUpdateCallback = xCallback;\n      db.pUpdateArg = pArg;\n      sqlite3_mutex_leave( db.mutex );\n      return pRet;\n    }\n\n    /*\n    ** Register a callback to be invoked each time a transaction is rolled\n    ** back by this database connection.\n    */\n    static object sqlite3_rollback_hook(\n    sqlite3 db,             /* Attach the hook to this database */\n    dxRollbackCallback xCallback,   //void (*xCallback)(void*), /* Callback function */\n    object pArg             /* Argument to the function */\n    )\n    {\n      object pRet;\n      sqlite3_mutex_enter( db.mutex );\n      pRet = db.pRollbackArg;\n      db.xRollbackCallback = xCallback;\n      db.pRollbackArg = pArg;\n      sqlite3_mutex_leave( db.mutex );\n      return pRet;\n    }\n\n    /*\n    ** This function returns true if main-memory should be used instead of\n    ** a temporary file for transient pager files and statement journals.\n    ** The value returned depends on the value of db->temp_store (runtime\n    ** parameter) and the compile time value of SQLITE_TEMP_STORE. The\n    ** following table describes the relationship between these two values\n    ** and this functions return value.\n    **\n    **   SQLITE_TEMP_STORE     db->temp_store     Location of temporary database\n    **   -----------------     --------------     ------------------------------\n    **   0                     any                file      (return 0)\n    **   1                     1                  file      (return 0)\n    **   1                     2                  memory    (return 1)\n    **   1                     0                  file      (return 0)\n    **   2                     1                  file      (return 0)\n    **   2                     2                  memory    (return 1)\n    **   2                     0                  memory    (return 1)\n    **   3                     any                memory    (return 1)\n    */\n    static bool sqlite3TempInMemory( sqlite3 db )\n    {\n      //#if SQLITE_TEMP_STORE==1\n      if ( SQLITE_TEMP_STORE == 1 )\n        return ( db.temp_store == 2 );\n      //#endif\n      //#if SQLITE_TEMP_STORE==2\n      if ( SQLITE_TEMP_STORE == 2 )\n        return ( db.temp_store != 1 );\n      //#endif\n      //#if SQLITE_TEMP_STORE==3\n      if ( SQLITE_TEMP_STORE == 3 )\n        return true;\n      //#endif\n      //#if SQLITE_TEMP_STORE<1 || SQLITE_TEMP_STORE>3\n      if ( SQLITE_TEMP_STORE < 1 || SQLITE_TEMP_STORE > 3 )\n        return false;\n      //#endif\n      return false;\n    }\n\n    /*\n    ** This routine is called to create a connection to a database BTree\n    ** driver.  If zFilename is the name of a file, then that file is\n    ** opened and used.  If zFilename is the magic name ":memory:" then\n    ** the database is stored in memory (and is thus forgotten as soon as\n    ** the connection is closed.)  If zFilename is NULL then the database\n    ** is a "virtual" database for transient use only and is deleted as\n    ** soon as the connection is closed.\n    **\n    ** A virtual database can be either a disk file (that is automatically\n    ** deleted when the file is closed) or it an be held entirely in memory.\n    ** The sqlite3TempInMemory() function is used to determine which.\n    */\n    static int sqlite3BtreeFactory(\n    sqlite3 db,           /* Main database when opening aux otherwise 0 */\n    string zFilename,     /* Name of the file containing the BTree database */\n    bool omitJournal,     /* if TRUE then do not journal this file */\n    int nCache,           /* How many pages in the page cache */\n    int vfsFlags,         /* Flags passed through to vfsOpen */\n    ref Btree ppBtree     /* Pointer to new Btree object written here */\n    )\n    {\n      int btFlags = 0;\n      int rc;\n\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n      //Debug.Assert( ppBtree != null);\n      if ( omitJournal )\n      {\n        btFlags |= BTREE_OMIT_JOURNAL;\n      }\n      if ( ( db.flags & SQLITE_NoReadlock ) != 0 )\n      {\n        btFlags |= BTREE_NO_READLOCK;\n      }\n#if !SQLITE_OMIT_MEMORYDB\n      if ( String.IsNullOrEmpty( zFilename ) && sqlite3TempInMemory( db ) )\n      {\n\n        zFilename = ":memory:";\n      }\n#endif // * SQLITE_OMIT_MEMORYDB */\n\n      if ( ( vfsFlags & SQLITE_OPEN_MAIN_DB ) != 0 && ( zFilename == null ) )\n      {// || *zFilename==0) ){\n        vfsFlags = ( vfsFlags & ~SQLITE_OPEN_MAIN_DB ) | SQLITE_OPEN_TEMP_DB;\n      }\n      rc = sqlite3BtreeOpen( zFilename, db, ref ppBtree, btFlags, vfsFlags );\n      /* If the B-Tree was successfully opened, set the pager-cache size to the\n      ** default value. Except, if the call to BtreeOpen() returned a handle\n      ** open on an existing shared pager-cache, do not change the pager-cache\n      ** size.\n      */\n      if ( rc == SQLITE_OK && null == sqlite3BtreeSchema( ppBtree, 0, null ) )\n      {\n        sqlite3BtreeSetCacheSize( ppBtree, nCache );\n      }\n      return rc;\n    }\n\n    /*\n    ** Return UTF-8 encoded English language explanation of the most recent\n    ** error.\n    */\n    public static string sqlite3_errmsg( sqlite3 db )\n    {\n      string z;\n      if ( db == null )\n      {\n        return sqlite3ErrStr( SQLITE_NOMEM );\n      }\n      if ( !sqlite3SafetyCheckSickOrOk( db ) )\n      {\n        return sqlite3ErrStr( SQLITE_MISUSE );\n      }\n      sqlite3_mutex_enter( db.mutex );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  z = sqlite3ErrStr( SQLITE_NOMEM );\n      //}\n      //else\n      {\n        z = sqlite3_value_text( db.pErr );\n        //Debug.Assert( 0 == db.mallocFailed );\n        if ( String.IsNullOrEmpty( z ))\n        {\n          z = sqlite3ErrStr( db.errCode );\n        }\n      }\n      sqlite3_mutex_leave( db.mutex );\n      return z;\n    }\n\n#if !SQLITE_OMIT_UTF16\n/*\n** Return UTF-16 encoded English language explanation of the most recent\n** error.\n*/\nconst void *sqlite3_errmsg16(sqlite3 *db){\nstatic const u16 outOfMem[] = {\n\'o\', \'u\', \'t\', \' \', \'o\', \'f\', \' \', \'m\', \'e\', \'m\', \'o\', \'r\', \'y\', 0\n};\nstatic const u16 misuse[] = {\n\'l\', \'i\', \'b\', \'r\', \'a\', \'r\', \'y\', \' \',\n\'r\', \'o\', \'u\', \'t\', \'i\', \'n\', \'e\', \' \',\n\'c\', \'a\', \'l\', \'l\', \'e\', \'d\', \' \',\n\'o\', \'u\', \'t\', \' \',\n\'o\', \'f\', \' \',\n\'s\', \'e\', \'q\', \'u\', \'e\', \'n\', \'c\', \'e\', 0\n};\n\nconst void *z;\nif( !db ){\nreturn (void *)outOfMem;\n}\nif( !sqlite3SafetyCheckSickOrOk(db) ){\nreturn (void *)misuse;\n}\nsqlite3_mutex_enter(db->mutex);\nif( db->mallocFailed ){\nz = (void *)outOfMem;\n}else{\nz = sqlite3_value_text16(db->pErr);\nif( z==0 ){\nsqlite3ValueSetStr(db->pErr, -1, sqlite3ErrStr(db->errCode),\nSQLITE_UTF8, SQLITE_STATIC);\nz = sqlite3_value_text16(db->pErr);\n}\n/* A malloc() may have failed within the call to sqlite3_value_text16()\n** above. If this is the case, then the db->mallocFailed flag needs to\n** be cleared before returning. Do this directly, instead of via\n** sqlite3ApiExit(), to avoid setting the database handle error message.\n*/\ndb->mallocFailed = 0;\n}\nsqlite3_mutex_leave(db->mutex);\nreturn z;\n}\n#endif // * SQLITE_OMIT_UTF16 */\n\n    /*\n** Return the most recent error code generated by an SQLite routine. If NULL is\n** passed to this function, we assume a malloc() failed during sqlite3_open().\n*/\n    public static int sqlite3_errcode( sqlite3 db )\n    {\n      if ( db != null && !sqlite3SafetyCheckSickOrOk( db ) )\n      {\n        return SQLITE_MISUSE;\n      }\n      if ( null == db /*|| db.mallocFailed != 0 */ )\n      {\n        return SQLITE_NOMEM;\n      }\n      return db.errCode & db.errMask;\n    }\n    static int sqlite3_extended_errcode( sqlite3 db )\n    {\n      if ( db != null && !sqlite3SafetyCheckSickOrOk( db ) )\n      {\n        return SQLITE_MISUSE;\n      }\n      if ( null == db /*|| db.mallocFailed != 0 */ )\n      {\n        return SQLITE_NOMEM;\n      }\n      return db.errCode;\n    }\n    /*\n    ** Create a new collating function for database "db".  The name is zName\n    ** and the encoding is enc.\n    */\n    static int createCollation(\n    sqlite3 db,\n    string zName,\n    int enc,\n    object pCtx,\n    dxCompare xCompare,//)(void*,int,const void*,int,const void*),\n    dxDelCollSeq xDel//)(void*)\n    )\n    {\n      CollSeq pColl;\n      int enc2;\n      int nName = sqlite3Strlen30( zName );\n\n      Debug.Assert( sqlite3_mutex_held( db.mutex ) );\n\n      /* If SQLITE_UTF16 is specified as the encoding type, transform this\n      ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the\n      ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.\n      */\n      enc2 = enc;\n      testcase( enc2 == SQLITE_UTF16 );\n      testcase( enc2 == SQLITE_UTF16_ALIGNED );\n      if ( enc2 == SQLITE_UTF16 || enc2 == SQLITE_UTF16_ALIGNED )\n      {\n        enc2 = SQLITE_UTF16NATIVE;\n      }\n      if ( enc2 < SQLITE_UTF8 || enc2 > SQLITE_UTF16BE )\n      {\n        return SQLITE_MISUSE;\n      }\n\n      /* Check if this call is removing or replacing an existing collation\n      ** sequence. If so, and there are active VMs, return busy. If there\n      ** are no active VMs, invalidate any pre-compiled statements.\n      */\n      pColl = sqlite3FindCollSeq( db, (u8)enc2, zName, 0 );\n      if ( pColl != null && pColl.xCmp != null )\n      {\n        if ( db.activeVdbeCnt != 0 )\n        {\n          sqlite3Error( db, SQLITE_BUSY,\n          "unable to delete/modify collation sequence due to active statements" );\n          return SQLITE_BUSY;\n        }\n        sqlite3ExpirePreparedStatements( db );\n\n        /* If collation sequence pColl was created directly by a call to\n        ** sqlite3_create_collation, and not generated by synthCollSeq(),\n        ** then any copies made by synthCollSeq() need to be invalidated.\n        ** Also, collation destructor - CollSeq.xDel() - function may need\n        ** to be called.\n        */\n        if ( ( pColl.enc & ~SQLITE_UTF16_ALIGNED ) == enc2 )\n        {\n          CollSeq[] aColl = (CollSeq[])sqlite3HashFind( db.aCollSeq, zName, nName );\n          int j;\n          for ( j = 0 ; j < 3 ; j++ )\n          {\n            CollSeq p = aColl[j];\n            if ( p.enc == pColl.enc )\n            {\n              if ( p.xDel != null )\n              {\n                p.xDel( ref p.pUser );\n              }\n              p.xCmp = null;\n            }\n          }\n        }\n      }\n\n      pColl = sqlite3FindCollSeq( db, (u8)enc2, zName, 1 );\n      if ( pColl != null )\n      {\n        pColl.xCmp = xCompare;\n        pColl.pUser = pCtx;\n        pColl.xDel = xDel;\n        pColl.enc = (u8)( enc2 | ( enc & SQLITE_UTF16_ALIGNED ) );\n      }\n      sqlite3Error( db, SQLITE_OK, 0 );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** This array defines hard upper bounds on limit values.  The\n    ** initializer must be kept in sync with the SQLITE_LIMIT_*\n    ** #defines in sqlite3.h.\n    */\n    static int[] aHardLimit = new int[]  {\nSQLITE_MAX_LENGTH,\nSQLITE_MAX_SQL_LENGTH,\nSQLITE_MAX_COLUMN,\nSQLITE_MAX_EXPR_DEPTH,\nSQLITE_MAX_COMPOUND_SELECT,\nSQLITE_MAX_VDBE_OP,\nSQLITE_MAX_FUNCTION_ARG,\nSQLITE_MAX_ATTACHED,\nSQLITE_MAX_LIKE_PATTERN_LENGTH,\nSQLITE_MAX_VARIABLE_NUMBER,\n};\n\n    /*\n    ** Make sure the hard limits are set to reasonable values\n    */\n    //#if SQLITE_MAX_LENGTH<100\n    //# error SQLITE_MAX_LENGTH must be at least 100\n    //#endif\n    //#if SQLITE_MAX_SQL_LENGTH<100\n    //# error SQLITE_MAX_SQL_LENGTH must be at least 100\n    //#endif\n    //#if SQLITE_MAX_SQL_LENGTH>SQLITE_MAX_LENGTH\n    //# error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH\n    //#endif\n    //#if SQLITE_MAX_COMPOUND_SELECT<2\n    //# error SQLITE_MAX_COMPOUND_SELECT must be at least 2\n    //#endif\n    //#if SQLITE_MAX_VDBE_OP<40\n    //# error SQLITE_MAX_VDBE_OP must be at least 40\n    //#endif\n    //#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>1000\n    //# error SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000\n    //#endif\n    //#if SQLITE_MAX_ATTACHED<0 || SQLITE_MAX_ATTACHED>30\n    //# error SQLITE_MAX_ATTACHED must be between 0 and 30\n    //#endif\n    //#if SQLITE_MAX_LIKE_PATTERN_LENGTH<1\n    //# error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1\n    //#endif\n    //#if SQLITE_MAX_VARIABLE_NUMBER<1\n    //# error SQLITE_MAX_VARIABLE_NUMBER must be at least 1\n    //#endif\n    //#if SQLITE_MAX_COLUMN>32767\n    //# error SQLITE_MAX_COLUMN must not exceed 32767\n    //#endif\n\n    /*\n    ** Change the value of a limit.  Report the old value.\n    ** If an invalid limit index is supplied, report -1.\n    ** Make no changes but still report the old value if the\n    ** new limit is negative.\n    **\n    ** A new lower limit does not shrink existing constructs.\n    ** It merely prevents new constructs that exceed the limit\n    ** from forming.\n    */\n    static int sqlite3_limit( sqlite3 db, int limitId, int newLimit )\n    {\n      int oldLimit;\n      if ( limitId < 0 || limitId >= SQLITE_N_LIMIT )\n      {\n        return -1;\n      }\n      oldLimit = db.aLimit[limitId];\n      if ( newLimit >= 0 )\n      {\n        if ( newLimit > aHardLimit[limitId] )\n        {\n          newLimit = aHardLimit[limitId];\n        }\n        db.aLimit[limitId] = newLimit;\n      }\n      return oldLimit;\n    }\n    /*\n    ** This routine does the work of opening a database on behalf of\n    ** sqlite3_open() and sqlite3_open16(). The database filename "zFilename"\n    ** is UTF-8 encoded.\n    */\n    static int openDatabase(\n    string zFilename, /* Database filename UTF-8 encoded */\n    ref sqlite3 ppDb,        /* OUT: Returned database handle */\n    unsigned flags,        /* Operational flags */\n    string zVfs       /* Name of the VFS to use */\n    )\n    {\n      sqlite3 db;\n      int rc;\n      CollSeq pColl;\n      int isThreadsafe;\n\n      ppDb = null;\n#if !SQLITE_OMIT_AUTOINIT\n      rc = sqlite3_initialize();\n      if ( rc != 0 ) return rc;\n#endif\n\n      if ( sqlite3GlobalConfig.bCoreMutex == false )\n      {\n        isThreadsafe = 0;\n      }\n      else if ( ( flags & SQLITE_OPEN_NOMUTEX ) != 0 )\n      {\n        isThreadsafe = 0;\n      }\n      else if ( ( flags & SQLITE_OPEN_FULLMUTEX ) != 0 )\n      {\n        isThreadsafe = 1;\n      }\n      else\n      {\n        isThreadsafe = sqlite3GlobalConfig.bFullMutex ? 1 : 0;\n      }\n\n      /* Remove harmful bits from the flags parameter\n      **\n      ** The SQLITE_OPEN_NOMUTEX and SQLITE_OPEN_FULLMUTEX flags were\n      ** dealt with in the previous code block.  Besides these, the only\n      ** valid input flags for sqlite3_open_v2() are SQLITE_OPEN_READONLY,\n      ** SQLITE_OPEN_READWRITE, and SQLITE_OPEN_CREATE.  Silently mask\n      ** off all other flags.\n      */\n      flags &= ~( SQLITE_OPEN_DELETEONCLOSE |\n      SQLITE_OPEN_EXCLUSIVE |\n      SQLITE_OPEN_MAIN_DB |\n      SQLITE_OPEN_TEMP_DB |\n      SQLITE_OPEN_TRANSIENT_DB |\n      SQLITE_OPEN_MAIN_JOURNAL |\n      SQLITE_OPEN_TEMP_JOURNAL |\n      SQLITE_OPEN_SUBJOURNAL |\n      SQLITE_OPEN_MASTER_JOURNAL |\n      SQLITE_OPEN_NOMUTEX |\n      SQLITE_OPEN_FULLMUTEX\n      );\n\n\n      /* Allocate the sqlite data structure */\n      db = new sqlite3();//sqlite3MallocZero( sqlite3.Length );\n      if ( db == null ) goto opendb_out;\n      if ( sqlite3GlobalConfig.bFullMutex && isThreadsafe != 0 )\n      {\n        db.mutex = sqlite3MutexAlloc( SQLITE_MUTEX_RECURSIVE );\n        if ( db.mutex == null )\n        {\n          //sqlite3_free( ref db );\n          goto opendb_out;\n        }\n      }\n      sqlite3_mutex_enter( db.mutex );\n      db.errMask = 0xff;\n      db.nDb = 2;\n      db.magic = SQLITE_MAGIC_BUSY;\n      Array.Copy( db.aDbStatic, db.aDb, db.aDbStatic.Length );// db.aDb = db.aDbStatic;\n      Debug.Assert( db.aLimit.Length == aHardLimit.Length );\n      Buffer.BlockCopy( aHardLimit, 0, db.aLimit, 0, aHardLimit.Length * sizeof( int ) );//memcpy(db.aLimit, aHardLimit, sizeof(db.aLimit));\n      db.autoCommit = 1;\n      db.nextAutovac = -1;\n      db.nextPagesize = 0;\n      db.flags |= SQLITE_ShortColNames;\n      if ( SQLITE_DEFAULT_FILE_FORMAT < 4 )\n        db.flags |= SQLITE_LegacyFileFmt\n#if  SQLITE_ENABLE_LOAD_EXTENSION\n| SQLITE_LoadExtension\n#endif\n;\n      sqlite3HashInit( db.aCollSeq );\n#if !SQLITE_OMIT_VIRTUALTABLE\nsqlite3HashInit( ref db.aModule );\n#endif\n      db.pVfs = sqlite3_vfs_find( zVfs );\n      if ( db.pVfs == null )\n      {\n        rc = SQLITE_ERROR;\n        sqlite3Error( db, rc, "no such vfs: %s", zVfs );\n        goto opendb_out;\n      }\n\n      /* Add the default collation sequence BINARY. BINARY works for both UTF-8\n      ** and UTF-16, so add a version for each to avoid any unnecessary\n      ** conversions. The only error that can occur here is a malloc() failure.\n      */\n      createCollation( db, "BINARY", SQLITE_UTF8, 0, (dxCompare)binCollFunc, null );\n      createCollation( db, "BINARY", SQLITE_UTF16BE, 0, (dxCompare)binCollFunc, null );\n      createCollation( db, "BINARY", SQLITE_UTF16LE, 0, (dxCompare)binCollFunc, null );\n      createCollation( db, "RTRIM", SQLITE_UTF8, 1, (dxCompare)binCollFunc, null );\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto opendb_out;\n      //}\n      db.pDfltColl = sqlite3FindCollSeq( db, SQLITE_UTF8, "BINARY", 0 );\n      Debug.Assert( db.pDfltColl != null );\n\n      /* Also add a UTF-8 case-insensitive collation sequence. */\n      createCollation( db, "NOCASE", SQLITE_UTF8, 0, nocaseCollatingFunc, null );\n\n      /* Set flags on the built-in collating sequences */\n      db.pDfltColl.type = SQLITE_COLL_BINARY;\n      pColl = sqlite3FindCollSeq( db, SQLITE_UTF8, "NOCASE", 0 );\n      if ( pColl != null )\n      {\n        pColl.type = SQLITE_COLL_NOCASE;\n      }\n\n      /* Open the backend database driver */\n      db.openFlags = flags;\n      rc = sqlite3BtreeFactory( db, zFilename, false, SQLITE_DEFAULT_CACHE_SIZE,\n      flags | SQLITE_OPEN_MAIN_DB,\n      ref db.aDb[0].pBt );\n      if ( rc != SQLITE_OK )\n      {\n        if ( rc == SQLITE_IOERR_NOMEM )\n        {\n          rc = SQLITE_NOMEM;\n        }\n        sqlite3Error( db, rc, 0 );\n        goto opendb_out;\n      }\n      db.aDb[0].pSchema = sqlite3SchemaGet( db, db.aDb[0].pBt );\n      db.aDb[1].pSchema = sqlite3SchemaGet( db, null );\n\n\n      /* The default safety_level for the main database is \'full\'; for the temp\n      ** database it is \'NONE\'. This matches the pager layer defaults.\n      */\n      db.aDb[0].zName = "main";\n      db.aDb[0].safety_level = 3;\n      db.aDb[1].zName = "temp";\n      db.aDb[1].safety_level = 1;\n\n      db.magic = SQLITE_MAGIC_OPEN;\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  goto opendb_out;\n      //}\n\n      /* Register all built-in functions, but do not attempt to read the\n      ** database schema yet. This is delayed until the first time the database\n      ** is accessed.\n      */\n      sqlite3Error( db, SQLITE_OK, 0 );\n      sqlite3RegisterBuiltinFunctions( db );\n\n      /* Load automatic extensions - extensions that have been registered\n      ** using the sqlite3_automatic_extension() API.\n      */\n      sqlite3AutoLoadExtensions( db );\n      rc = sqlite3_errcode( db );\n      if ( rc != SQLITE_OK )\n      {\n        goto opendb_out;\n      }\n\n\n#if  SQLITE_ENABLE_FTS1\nif( 0==db.mallocFailed ){\nextern int sqlite3Fts1Init(sqlite3*);\nrc = sqlite3Fts1Init(db);\n}\n#endif\n\n#if  SQLITE_ENABLE_FTS2\nif( 0==db.mallocFailed && rc==SQLITE_OK ){\nextern int sqlite3Fts2Init(sqlite3*);\nrc = sqlite3Fts2Init(db);\n}\n#endif\n\n#if  SQLITE_ENABLE_FTS3\nif( 0==db.mallocFailed && rc==SQLITE_OK ){\nrc = sqlite3Fts3Init(db);\n}\n#endif\n\n#if  SQLITE_ENABLE_ICU\nif( 0==db.mallocFailed && rc==SQLITE_OK ){\nextern int sqlite3IcuInit(sqlite3*);\nrc = sqlite3IcuInit(db);\n}\n#endif\n\n#if SQLITE_ENABLE_RTREE\nif( 0==db.mallocFailed && rc==SQLITE_OK){\nrc = sqlite3RtreeInit(db);\n}\n#endif\n\n      sqlite3Error( db, rc, 0 );\n\n      /* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking\n      ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking\n      ** mode.  Doing nothing at all also makes NORMAL the default.\n      */\n#if  SQLITE_DEFAULT_LOCKING_MODE\ndb.dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE;\nsqlite3PagerLockingMode(sqlite3BtreePager(db.aDb[0].pBt),\nSQLITE_DEFAULT_LOCKING_MODE);\n#endif\n\n      /* Enable the lookaside-malloc subsystem */\n      setupLookaside( db, null, sqlite3GlobalConfig.szLookaside,\n      sqlite3GlobalConfig.nLookaside );\n\nopendb_out:\n      if ( db != null )\n      {\n        Debug.Assert( db.mutex != null || isThreadsafe == 0 || !sqlite3GlobalConfig.bFullMutex );\n        sqlite3_mutex_leave( db.mutex );\n      }\n      rc = sqlite3_errcode( db );\n      if ( rc == SQLITE_NOMEM )\n      {\n        sqlite3_close( db );\n        db = null;\n      }\n      else if ( rc != SQLITE_OK )\n      {\n        db.magic = SQLITE_MAGIC_SICK;\n      }\n      ppDb = db;\n      return sqlite3ApiExit( 0, rc );\n    }\n\n    /*\n    ** Open a new database handle.\n    */\n    public static int sqlite3_open(\n    string zFilename,\n    ref sqlite3 ppDb\n    )\n    {\n      return openDatabase( zFilename, ref ppDb,\n      SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, null );\n    }\n\n    public static int sqlite3_open_v2(\n    string filename,   /* Database filename (UTF-8) */\n    ref sqlite3 ppDb,         /* OUT: SQLite db handle */\n    int flags,              /* Flags */\n    string zVfs        /* Name of VFS module to use */\n    )\n    {\n      return openDatabase( filename, ref ppDb, flags, zVfs );\n    }\n\n#if !SQLITE_OMIT_UTF16\n\n/*\n** Open a new database handle.\n*/\nint sqlite3_open16(\nconst void *zFilename,\nsqlite3 **ppDb\n){\nchar const *zFilename8;   /* zFilename encoded in UTF-8 instead of UTF-16 */\nsqlite3_value pVal;\nint rc;\n\nDebug.Assert(zFilename );\nDebug.Assert(ppDb );\n*ppDb = 0;\n#if !SQLITE_OMIT_AUTOINIT\nrc = sqlite3_initialize();\nif( rc !=0) return rc;\n#endif\npVal = sqlite3ValueNew(0);\nsqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC);\nzFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8);\nif( zFilename8 ){\nrc = openDatabase(zFilename8, ppDb,\nSQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);\nDebug.Assert(*ppDb || rc==SQLITE_NOMEM );\nif( rc==SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded) ){\nENC(*ppDb) = SQLITE_UTF16NATIVE;\n}\n}else{\nrc = SQLITE_NOMEM;\n}\nsqlite3ValueFree(pVal);\n\nreturn sqlite3ApiExit(0, rc);\n}\n#endif // * SQLITE_OMIT_UTF16 */\n\n    /*\n** Register a new collation sequence with the database handle db.\n*/\n    static int sqlite3_create_collation(\n    sqlite3 db,\n    string zName,\n    int enc,\n    object pCtx,\n    dxCompare xCompare\n    )\n    {\n      int rc;\n      sqlite3_mutex_enter( db.mutex );\n      //Debug.Assert( 0 == db.mallocFailed );\n      rc = createCollation( db, zName, enc, pCtx, xCompare, null );\n      rc = sqlite3ApiExit( db, rc );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n    /*\n    ** Register a new collation sequence with the database handle db.\n    */\n    static int sqlite3_create_collation_v2(\n    sqlite3 db,\n    string zName,\n    int enc,\n    object pCtx,\n    dxCompare xCompare, //int(*xCompare)(void*,int,const void*,int,const void*),\n    dxDelCollSeq xDel  //void(*xDel)(void*)\n    )\n    {\n      int rc;\n      sqlite3_mutex_enter( db.mutex );\n      //Debug.Assert( 0 == db.mallocFailed );\n      rc = createCollation( db, zName, enc, pCtx, xCompare, xDel );\n      rc = sqlite3ApiExit( db, rc );\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n#if !SQLITE_OMIT_UTF16\n/*\n** Register a new collation sequence with the database handle db.\n*/\n//int sqlite3_create_collation16(\n//  sqlite3* db,\n//  string zName,\n//  int enc,\n//  void* pCtx,\n//  int(*xCompare)(void*,int,const void*,int,const void*)\n//){\n//  int rc = SQLITE_OK;\n//  char *zName8;\n//  sqlite3_mutex_enter(db.mutex);\n//  Debug.Assert( 0==db.mallocFailed );\n//  zName8 = sqlite3Utf16to8(db, zName, -1);\n//  if( zName8 ){\n//    rc = createCollation(db, zName8, enc, pCtx, xCompare, 0);\n//    //sqlite3DbFree(db,ref zName8);\n//  }\n//  rc = sqlite3ApiExit(db, rc);\n//  sqlite3_mutex_leave(db.mutex);\n//  return rc;\n//}\n#endif // * SQLITE_OMIT_UTF16 */\n\n    /*\n** Register a collation sequence factory callback with the database handle\n** db. Replace any previously installed collation sequence factory.\n*/\n    static int sqlite3_collation_needed(\n    sqlite3 db,\n    object pCollNeededArg,\n    dxCollNeeded xCollNeeded\n    )\n    {\n      sqlite3_mutex_enter( db.mutex );\n      db.xCollNeeded = xCollNeeded;\n      db.xCollNeeded16 = null;\n      db.pCollNeededArg = pCollNeededArg;\n      sqlite3_mutex_leave( db.mutex );\n      return SQLITE_OK;\n    }\n\n#if !SQLITE_OMIT_UTF16\n/*\n** Register a collation sequence factory callback with the database handle\n** db. Replace any previously installed collation sequence factory.\n*/\n//int sqlite3_collation_needed16(\n//  sqlite3 db,\n//  void pCollNeededArg,\n//  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)\n//){\n//  sqlite3_mutex_enter(db.mutex);\n//  db.xCollNeeded = 0;\n//  db.xCollNeeded16 = xCollNeeded16;\n//  db.pCollNeededArg = pCollNeededArg;\n//  sqlite3_mutex_leave(db.mutex);\n//  return SQLITE_OK;\n//}\n#endif // * SQLITE_OMIT_UTF16 */\n\n#if !SQLITE_OMIT_GLOBALRECOVER\n#if !SQLITE_OMIT_DEPRECATED\n    /*\n** This function is now an anachronism. It used to be used to recover from a\n** malloc() failure, but SQLite now does this automatically.\n*/\n    static int sqlite3_global_recover()\n    {\n      return SQLITE_OK;\n    }\n#endif\n#endif\n\n    /*\n** Test to see whether or not the database connection is in autocommit\n** mode.  Return TRUE if it is and FALSE if not.  Autocommit mode is on\n** by default.  Autocommit is disabled by a BEGIN statement and reenabled\n** by the next COMMIT or ROLLBACK.\n**\n******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******\n*/\n    static u8 sqlite3_get_autocommit( sqlite3 db )\n    {\n      return db.autoCommit;\n    }\n\n#if  SQLITE_DEBUG\n    /*\n** The following routine is subtituted for constant SQLITE_CORRUPT in\n** debugging builds.  This provides a way to set a breakpoint for when\n** corruption is first detected.\n*/\n    static int sqlite3Corrupt()\n    {\n      return SQLITE_CORRUPT;\n    }\n#endif\n\n#if !SQLITE_OMIT_DEPRECATED\n    /*\n** This is a convenience routine that makes sure that all thread-specific\n** data for this thread has been deallocated.\n**\n** SQLite no longer uses thread-specific data so this routine is now a\n** no-op.  It is retained for historical compatibility.\n*/\n    void sqlite3_thread_cleanup()\n    {\n    }\n#endif\n    /*\n** Return meta information about a specific column of a database table.\n** See comment in sqlite3.h (sqlite.h.in) for details.\n*/\n#if SQLITE_ENABLE_COLUMN_METADATA\n\nint sqlite3_table_column_metadata(\nsqlite3 db,            /* Connection handle */\nstring zDbName,        /* Database name or NULL */\nstring zTableName,     /* Table name */\nstring zColumnName,    /* Column name */\nref byte[] pzDataType, /* OUTPUT: Declared data type */\nref byte[] pzCollSeq,  /* OUTPUT: Collation sequence name */\nref int pNotNull,      /* OUTPUT: True if NOT NULL constraint exists */\nref int pPrimaryKey,   /* OUTPUT: True if column part of PK */\nref int pAutoinc       /* OUTPUT: True if column is auto-increment */\n){\nint rc;\nstring zErrMsg = "";\nTable pTab = null;\nColumn pCol = null;\nint iCol;\n\nchar const *zDataType = 0;\nchar const *zCollSeq = 0;\nint notnull = 0;\nint primarykey = 0;\nint autoinc = 0;\n\n/* Ensure the database schema has been loaded */\nsqlite3_mutex_enter(db.mutex);\n(void)sqlite3SafetyOn(db);\nsqlite3BtreeEnterAll(db);\nrc = sqlite3Init(db, zErrMsg);\nif( SQLITE_OK!=rc ){\ngoto error_out;\n}\n\n/* Locate the table in question */\npTab = sqlite3FindTable(db, zTableName, zDbName);\nif( null==pTab || pTab.pSelect ){\npTab = 0;\ngoto error_out;\n}\n\n/* Find the column for which info is requested */\nif( sqlite3IsRowid(zColumnName) ){\niCol = pTab.iPKey;\nif( iCol>=0 ){\npCol = pTab.aCol[iCol];\n}\n}else{\nfor(iCol=0; iCol<pTab.nCol; iCol++){\npCol = pTab.aCol[iCol];\nif( 0==sqlite3StrICmp(pCol.zName, zColumnName) ){\nbreak;\n}\n}\nif( iCol==pTab.nCol ){\npTab = 0;\ngoto error_out;\n}\n}\n\n/* The following block stores the meta information that will be returned\n** to the caller in local variables zDataType, zCollSeq, notnull, primarykey\n** and autoinc. At this point there are two possibilities:\n**\n**     1. The specified column name was rowid", "oid" or "_rowid_"\n**        and there is no explicitly declared IPK column.\n**\n**     2. The table is not a view and the column name identified an\n**        explicitly declared column. Copy meta information from pCol.\n*/\nif( pCol ){\nzDataType = pCol.zType;\nzCollSeq = pCol.zColl;\nnotnull = pCol->notNull!=0;\nprimarykey  = pCol->isPrimKey!=0;\nautoinc = pTab.iPKey==iCol && (pTab.tabFlags & TF_Autoincrement)!=0;\n}else{\nzDataType = "INTEGER";\nprimarykey = 1;\n}\nif( !zCollSeq ){\nzCollSeq = "BINARY";\n}\n\nerror_out:\nsqlite3BtreeLeaveAll(db);\n(void)sqlite3SafetyOff(db);\n\n/* Whether the function call succeeded or failed, set the output parameters\n** to whatever their local counterparts contain. If an error did occur,\n** this has the effect of zeroing all output parameters.\n*/\nif( pzDataType ) pzDataType = zDataType;\nif( pzCollSeq ) pzCollSeq = zCollSeq;\nif( pNotNull ) pNotNull = notnull;\nif( pPrimaryKey ) pPrimaryKey = primarykey;\nif( pAutoinc ) pAutoinc = autoinc;\n\nif( SQLITE_OK==rc && !pTab ){\n//sqlite3DbFree(db, zErrMsg);\nzErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,\nzColumnName);\nrc = SQLITE_ERROR;\n}\nsqlite3Error(db, rc, (zErrMsg?"%s":0), zErrMsg);\n//sqlite3DbFree(db, zErrMsg);\nrc = sqlite3ApiExit(db, rc);\nsqlite3_mutex_leave(db.mutex);\nreturn rc;\n}\n#endif\n\n    /*\n** Sleep for a little while.  Return the amount of time slept.\n*/\n    public static int sqlite3_sleep( int ms )\n    {\n      sqlite3_vfs pVfs;\n      int rc;\n      pVfs = sqlite3_vfs_find( null );\n      if ( pVfs == null ) return 0;\n\n      /* This function works in milliseconds, but the underlying OsSleep()\n      ** API uses microseconds. Hence the 1000\'s.\n      */\n      rc = ( sqlite3OsSleep( pVfs, 1000 * ms ) / 1000 );\n      return rc;\n    }\n\n    /*\n    ** Enable or disable the extended result codes.\n    */\n    static int sqlite3_extended_result_codes( sqlite3 db, bool onoff )\n    {\n      sqlite3_mutex_enter( db.mutex );\n      db.errMask = (int)( onoff ? 0xffffffff : 0xff );\n      sqlite3_mutex_leave( db.mutex );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Invoke the xFileControl method on a particular database.\n    */\n    static int sqlite3_file_control( sqlite3 db, string zDbName, int op, ref int pArg )\n    {\n      int rc = SQLITE_ERROR;\n      int iDb;\n      sqlite3_mutex_enter( db.mutex );\n      if ( zDbName == null )\n      {\n        iDb = 0;\n      }\n      else\n      {\n        for ( iDb = 0 ; iDb < db.nDb ; iDb++ )\n        {\n          if ( db.aDb[iDb].zName == zDbName ) break;\n        }\n      }\n      if ( iDb < db.nDb )\n      {\n        Btree pBtree = db.aDb[iDb].pBt;\n        if ( pBtree != null )\n        {\n          Pager pPager;\n          sqlite3_file fd;\n          sqlite3BtreeEnter( pBtree );\n          pPager = sqlite3BtreePager( pBtree );\n          Debug.Assert( pPager != null );\n          fd = sqlite3PagerFile( pPager );\n          Debug.Assert( fd != null );\n          if ( fd.pMethods != null )\n          {\n            rc = sqlite3OsFileControl( fd, (u32)op, ref pArg );\n          }\n          sqlite3BtreeLeave( pBtree );\n        }\n      }\n      sqlite3_mutex_leave( db.mutex );\n      return rc;\n    }\n\n    /*\n    ** Interface to the testing logic.\n    */\n    static int sqlite3_test_control( int op, params object[] ap )\n    {\n      int rc = 0;\n#if !SQLITE_OMIT_BUILTIN_TEST\n      //  va_list ap;\n      va_start( ap, "op" );\n      switch ( op )\n      {\n\n        /*\n        ** Save the current state of the PRNG.\n        */\n        case SQLITE_TESTCTRL_PRNG_SAVE:\n          {\n            sqlite3PrngSaveState();\n            break;\n          }\n\n        /*\n        ** Restore the state of the PRNG to the last state saved using\n        ** PRNG_SAVE.  If PRNG_SAVE has never before been called, then\n        ** this verb acts like PRNG_RESET.\n        */\n        case SQLITE_TESTCTRL_PRNG_RESTORE:\n          {\n            sqlite3PrngRestoreState();\n            break;\n          }\n\n        /*\n        ** Reset the PRNG back to its uninitialized state.  The next call\n        ** to sqlite3_randomness() will reseed the PRNG using a single call\n        ** to the xRandomness method of the default VFS.\n        */\n        case SQLITE_TESTCTRL_PRNG_RESET:\n          {\n            sqlite3PrngResetState();\n            break;\n          }\n\n        /*\n        **  sqlite3_test_control(BITVEC_TEST, size, program)\n        **\n        ** Run a test against a Bitvec object of size.  The program argument\n        ** is an array of integers that defines the test.  Return -1 on a\n        ** memory allocation error, 0 on success, or non-zero for an error.\n        ** See the sqlite3BitvecBuiltinTest() for additional information.\n        */\n        case SQLITE_TESTCTRL_BITVEC_TEST:\n          {\n            int sz = (int)va_arg( ap, "int" );\n            int[] aProg = (int[])va_arg( ap, "int[]" );\n            rc = sqlite3BitvecBuiltinTest( (u32)sz, aProg );\n            break;\n          }\n\n        /*\n        **  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)\n        **\n        ** Register hooks to call to indicate which malloc() failures\n        ** are benign.\n        */\n        case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:\n          {\n            //typedef void (*void_function)(void);\n            void_function xBenignBegin;\n            void_function xBenignEnd;\n            xBenignBegin = (void_function)va_arg( ap, "void_function" );\n            xBenignEnd = (void_function)va_arg( ap, "void_function" );\n            sqlite3BenignMallocHooks( xBenignBegin, xBenignEnd );\n            break;\n          }\n        /*\n        **  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)\n        **\n        ** Set the PENDING byte to the value in the argument, if X>0.\n        ** Make no changes if X==0.  Return the value of the pending byte\n        ** as it existing before this routine was called.\n        **\n        ** IMPORTANT:  Changing the PENDING byte from 0x40000000 results in\n        ** an incompatible database file format.  Changing the PENDING byte\n        ** while any database connection is open results in undefined and\n        ** dileterious behavior.\n        */\n        case SQLITE_TESTCTRL_PENDING_BYTE:\n          {\n            u32 newVal = (u32)va_arg( ap, "u32" );\n            rc = sqlite3PendingByte;\n            if ( newVal != 0 )\n            {\n              if ( sqlite3PendingByte != newVal )\n                sqlite3PendingByte = (int)newVal;\n#if DEBUG && !NO_TCL\n              TCLsqlite3PendingByte.iValue = sqlite3PendingByte;\n#endif\n              PENDING_BYTE = sqlite3PendingByte;\n            }\n            break;\n          }\n\n        /*\n        **  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)\n        **\n        ** This action provides a run-time test to see whether or not\n        ** assert() was enabled at compile-time.  If X is true and assert()\n        ** is enabled, then the return value is true.  If X is true and\n        ** assert() is disabled, then the return value is zero.  If X is\n        ** false and assert() is enabled, then the assertion fires and the\n        ** process aborts.  If X is false and assert() is disabled, then the\n        ** return value is zero.\n        */\n        case SQLITE_TESTCTRL_ASSERT:\n          {\n            int x = 0;\n            Debug.Assert( ( x = (int)va_arg( ap, "int" ) ) != 0 );\n            rc = x;\n            break;\n          }\n\n\n        /*\n        **  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)\n        **\n        ** This action provides a run-time test to see how the ALWAYS and\n        ** NEVER macros were defined at compile-time.\n        **\n        ** The return value is ALWAYS(X).\n        **\n        ** The recommended test is X==2.  If the return value is 2, that means\n        ** ALWAYS() and NEVER() are both no-op pass-through macros, which is the\n        ** default setting.  If the return value is 1, then ALWAYS() is either\n        ** hard-coded to true or else it asserts if its argument is false.\n        ** The first behavior (hard-coded to true) is the case if\n        ** SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second\n        ** behavior (assert if the argument to ALWAYS() is false) is the case if\n        ** SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.\n        **\n        ** The run-time test procedure might look something like this:\n        **\n        **    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){\n        **      // ALWAYS() and NEVER() are no-op pass-through macros\n        **    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){\n        **      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.\n        **    }else{\n        **      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.\n        **    }\n        */\n        case SQLITE_TESTCTRL_ALWAYS:\n          {\n            int x = (int)va_arg( ap, "int" );\n            rc = ALWAYS( x );\n            break;\n          }\n\n        /*   sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, sqlite3 *db, int N)\n        **\n        ** Set the nReserve size to N for the main database on the database\n        ** connection db.\n        */\n        case SQLITE_TESTCTRL_RESERVE: {\n          sqlite3 db = (sqlite3)va_arg(ap, "sqlite3");\n          int x = (int)va_arg(ap,"int");\n          sqlite3_mutex_enter(db.mutex);\n          sqlite3BtreeSetPageSize(db.aDb[0].pBt, 0, x, 0);\n          sqlite3_mutex_leave(db.mutex);\n          break;\n        }\n      }\n      va_end( ap );\n#endif //* SQLITE_OMIT_BUILTIN_TEST */\n      return rc;\n    }\n  }\n}\n'