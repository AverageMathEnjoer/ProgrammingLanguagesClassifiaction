b"{-# LANGUAGE GADTs #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.Pen where\n\nimport Control.Lens (at, over, set, view)\nimport Control.Monad (when)\nimport Control.Monad.State (MonadIO (liftIO), get)\nimport Data.Foldable (toList)\nimport Data.Functor.Identity (Identity (..))\nimport Data.Hoodle.BBox\n  ( BBox,\n    getBBox,\n    makeBBoxed,\n  )\nimport Data.Hoodle.Generic (gitems, gpages)\nimport Data.Hoodle.Simple (Dimension (..))\nimport qualified Data.IntMap as IM\nimport Data.Ratio ((%))\nimport Data.Sequence\n  ( Seq (..),\n    ViewL (..),\n    empty,\n    viewl,\n    (|>),\n  )\nimport Data.Time.Clock\n  ( NominalDiffTime,\n    UTCTime,\n    diffUTCTime,\n    getCurrentTime,\n  )\nimport Graphics.Hoodle.Render (renderStrk, updateLayerBuf)\nimport Graphics.Hoodle.Render.Type (RHoodle, RItem (..))\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport Hoodle.Accessor\n  ( pureUpdateUhdl,\n    renderCache,\n  )\nimport Hoodle.Coroutine.Commit (commit)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer_,\n    invalidateAll,\n    invalidateAllInBBox,\n    nextevent,\n  )\nimport Hoodle.Device (PointerCoord (..))\nimport Hoodle.GUI.Reflect (changeCurrentCanvasId)\nimport Hoodle.ModelAction.Layer\n  ( adjustCurrentLayer,\n    getCurrentLayer,\n  )\nimport Hoodle.ModelAction.Page\n  ( getPageFromGHoodleMap,\n    updatePageAll,\n  )\nimport Hoodle.ModelAction.Pen\n  ( TempRender (..),\n    createNewStroke,\n    tempInfo,\n    tempSurfaceSrc,\n    tempSurfaceTgt,\n  )\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo,\n    CanvasInfoBox,\n    PenInfo,\n    currentPageNum,\n    drawArea,\n    forBoth,\n    forBoth',\n    mDrawSurface,\n    pageArrangement,\n    unboxBiAct,\n    unboxBiXform,\n    unboxLens,\n    viewInfo,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum\n  ( DrawFlag (Efficient),\n    PenColor (ColorRed),\n  )\nimport Hoodle.Type.Event (UserEvent (PenMove, PenUp))\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (ViewAppendState),\n    HoodleState,\n    currentCanvasInfo,\n    currentUnit,\n    getCanvasInfo,\n    getCurrentCanvasId,\n    getHoodle,\n    penInfo,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( CanvasDimension (..),\n    PageCoordinate (..),\n    PageNum (..),\n  )\nimport Hoodle.Type.Predefined (dtimeBound)\nimport Hoodle.Util (maybeFlip)\nimport Hoodle.View.Coordinate\n  ( CanvasGeometry\n      ( canvasDim,\n        desktop2Page\n      ),\n    device2Desktop,\n    makeCanvasGeometry,\n  )\nimport Hoodle.View.Draw\n  ( cairoXform4PageCoordinate,\n    canvasImageSurface,\n    doubleBufferFlush,\n    emphasisCanvasRender,\n    mkXform4Page,\n    virtualDoubleBufferDraw,\n  )\nimport Prelude hiding (mapM_)\n\n-- |\naddPDraw ::\n  CanvasId ->\n  PenInfo ->\n  RHoodle ->\n  PageNum ->\n  Seq (Double, Double, Double) ->\n  -- | new hoodle and bbox in page coordinate\n  MainCoroutine (RHoodle, BBox)\naddPDraw cid pinfo hdl (PageNum pgnum) pdraw = do\n  let currpage = getPageFromGHoodleMap pgnum hdl\n      currlayer = getCurrentLayer currpage\n      newstroke = createNewStroke pinfo pdraw\n      newstrokebbox = runIdentity (makeBBoxed newstroke)\n      bbox = getBBox newstrokebbox\n      newlayerbbox = over gitems (++ [RItemStroke newstrokebbox]) currlayer\n  callRenderer_ $ updateLayerBuf cid newlayerbbox\n  let newpagebbox = adjustCurrentLayer newlayerbbox currpage\n      newhdlbbox = set gpages (IM.adjust (const newpagebbox) pgnum (view gpages hdl)) hdl\n  return (newhdlbbox, bbox)\n\n-- |\ncreateTempRender :: CanvasGeometry -> a -> MainCoroutine (TempRender a)\ncreateTempRender geometry x = do\n  xst <- get\n  cache <- renderCache\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cinfobox = view currentCanvasInfo uhdl\n      mcvssfc = view (unboxLens mDrawSurface) cinfobox\n      cid = getCurrentCanvasId uhdl\n      hdl = getHoodle uhdl\n      Dim cw ch = unCanvasDimension . canvasDim $ geometry\n  srcsfc <-\n    liftIO $\n      maybe\n        (fst <$> canvasImageSurface cache cid Nothing geometry hdl)\n        ( \\cvssfc -> do\n            sfc <-\n              Cairo.createImageSurface\n                Cairo.FormatARGB32\n                (floor cw)\n                (floor ch)\n            Cairo.renderWith sfc $ do\n              Cairo.setSourceSurface cvssfc 0 0\n              Cairo.setOperator Cairo.OperatorSource\n              Cairo.paint\n            return sfc\n        )\n        mcvssfc\n  liftIO $\n    Cairo.renderWith srcsfc $ do\n      emphasisCanvasRender ColorRed geometry\n  tgtsfc <-\n    liftIO $\n      Cairo.createImageSurface\n        Cairo.FormatARGB32\n        (floor cw)\n        (floor ch)\n  let trdr = TempRender srcsfc tgtsfc (cw, ch) x\n  return trdr\n\n-- | page switch if pen click a page different than the current page\npenPageSwitch :: PageNum -> MainCoroutine CanvasInfoBox\npenPageSwitch pgn = do\n  xstate <- get\n  let uhdl = view (unitHoodles . currentUnit) xstate\n      cibox = view currentCanvasInfo uhdl\n      ncibox = (runIdentity . forBoth unboxBiXform (return . set currentPageNum (unPageNum pgn))) cibox\n      uhdl' = set currentCanvasInfo ncibox uhdl\n  pureUpdateUhdl (const uhdl')\n  invalidateAllInBBox Nothing Efficient\n  return ncibox\n\n-- | Common Pen Work starting point\ncommonPenStart ::\n  forall b.\n  ( forall a.\n    CanvasInfo a ->\n    PageNum ->\n    CanvasGeometry ->\n    (Double, Double) ->\n    UTCTime ->\n    MainCoroutine b\n  ) ->\n  CanvasId ->\n  PointerCoord ->\n  MainCoroutine (Maybe b)\ncommonPenStart action cid pcoord = do\n  oxstate <- get\n  let currcid = (getCurrentCanvasId . view (unitHoodles . currentUnit)) oxstate\n  ctime <- liftIO getCurrentTime\n  when (cid /= currcid) (changeCurrentCanvasId cid >> invalidateAll)\n  nxstate <- get\n  forBoth' unboxBiAct (f ctime) . getCanvasInfo cid . view (unitHoodles . currentUnit) $ nxstate\n  where\n    f :: forall c. UTCTime -> CanvasInfo c -> MainCoroutine (Maybe b)\n    f ctime cvsInfo = do\n      let cpn = PageNum . view currentPageNum $ cvsInfo\n          arr = view (viewInfo . pageArrangement) cvsInfo\n          canvas = view drawArea cvsInfo\n      geometry <- liftIO $ makeCanvasGeometry cpn arr canvas\n      let pagecoord = desktop2Page geometry . device2Desktop geometry $ pcoord\n      maybeFlip pagecoord (return Nothing) $\n        \\(pgn, PageCoord (x, y)) -> do\n          nCvsInfo <-\n            if cpn /= pgn\n              then do\n                _ <- penPageSwitch pgn\n                -- temporary dirty fix\n                return (set currentPageNum (unPageNum pgn) cvsInfo)\n              else return cvsInfo\n          Just <$> action nCvsInfo pgn geometry (x, y) ctime\n\n-- | enter pen drawing mode\npenStart ::\n  CanvasId ->\n  PointerCoord ->\n  MainCoroutine (Maybe (Maybe (Maybe ())))\npenStart cid pcoord = commonPenStart penAction cid pcoord\n  where\n    penAction ::\n      forall b.\n      CanvasInfo b ->\n      PageNum ->\n      CanvasGeometry ->\n      (Double, Double) ->\n      UTCTime ->\n      MainCoroutine (Maybe (Maybe ()))\n    penAction _cinfo pnum geometry (x, y) ctime = do\n      xstate <- get\n      let uhdl = view (unitHoodles . currentUnit) xstate\n      let PointerCoord _ _ _ z = pcoord\n      let currhdl = getHoodle uhdl\n          pinfo = view penInfo xstate\n          mpage = view (gpages . at (unPageNum pnum)) currhdl\n      maybeFlip mpage (return Nothing) $ \\_page -> do\n        trdr <- createTempRender geometry (empty |> (x, y, z))\n        mpdraw <- penProcess cid pnum geometry trdr ((x, y), z) ctime\n        Cairo.surfaceFinish (tempSurfaceSrc trdr)\n        Cairo.surfaceFinish (tempSurfaceTgt trdr)\n        maybeFlip mpdraw (return (Just Nothing)) $ \\pdraw ->\n          case viewl pdraw of\n            EmptyL -> return (Just (Just ()))\n            (x1, _y1, _z1) :< _rest -> do\n              if x1 <= 1e-3 -- this is ad hoc but..\n                then invalidateAll\n                else do\n                  (newhdl, _bbox) <- addPDraw cid pinfo currhdl pnum pdraw\n                  uhdl' <- liftIO (updatePageAll (ViewAppendState newhdl) uhdl)\n                  commit (set (unitHoodles . currentUnit) uhdl' xstate)\n                  return ()\n              return (Just (Just ()))\n\n-- | main pen coordinate adding process\n-- | now being changed\npenProcess ::\n  CanvasId ->\n  PageNum ->\n  CanvasGeometry ->\n  TempRender (Seq (Double, Double, Double)) ->\n  ((Double, Double), Double) ->\n  UTCTime ->\n  MainCoroutine (Maybe (Seq (Double, Double, Double)))\npenProcess cid pnum geometry trdr ((x0, y0), z0) ctime = do\n  r <- nextevent\n  ntime <- liftIO getCurrentTime\n  let ispressandhold =\n        abs (toRational (diffUTCTime ctime ntime)) > 1 % 2\n      lst = (toList . tempInfo) trdr\n      deltax =\n        let xlst = map (\\(x, _, _) -> x) lst\n         in abs (maximum xlst - minimum xlst)\n      deltay =\n        let ylst = map (\\(_, y, _) -> y) lst\n         in abs (maximum ylst - minimum ylst)\n  -- temporarily fix the range\n  if deltax < 20 && deltay < 20 && ispressandhold && Prelude.length lst < 20\n    then return Nothing\n    else do\n      xst <- get\n      forBoth' unboxBiAct (fsingle r xst) . (getCanvasInfo cid . view (unitHoodles . currentUnit)) $ xst\n  where\n    pdraw = tempInfo trdr\n    fsingle ::\n      forall b.\n      UserEvent ->\n      HoodleState ->\n      CanvasInfo b ->\n      MainCoroutine (Maybe (Seq (Double, Double, Double)))\n    fsingle r xstate cvsInfo =\n      penMoveAndUpOnly\n        r\n        pnum\n        geometry\n        (penProcess cid pnum geometry trdr ((x0, y0), z0) ctime)\n        ( \\(pcoord, (x, y)) -> do\n            let PointerCoord _ _ _ z = pcoord\n            let pinfo = view penInfo xstate\n            let xformfunc = cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n                tmpstrk = createNewStroke pinfo pdraw\n                renderfunc = do\n                  xformfunc\n                  renderStrk tmpstrk\n            let (srcsfc, tgtsfc) = (,) <$> tempSurfaceSrc <*> tempSurfaceTgt $ trdr\n            virtualDoubleBufferDraw srcsfc tgtsfc (return ()) renderfunc\n            liftIO $ doubleBufferFlush tgtsfc cvsInfo\n            ---\n            let ntrdr = trdr {tempInfo = pdraw |> (x, y, z)}\n            penProcess cid pnum geometry ntrdr ((x, y), z) ctime\n        )\n        (\\_ -> return (Just pdraw))\n\n-- |\nskipIfNotInSamePage ::\n  Monad m =>\n  PageNum ->\n  CanvasGeometry ->\n  PointerCoord ->\n  m a ->\n  ((PointerCoord, (Double, Double)) -> m a) ->\n  m a\nskipIfNotInSamePage pgn geometry pcoord skipaction ordaction =\n  switchActionEnteringDiffPage\n    pgn\n    geometry\n    pcoord\n    skipaction\n    (\\_ _ -> skipaction)\n    (\\_ (_, PageCoord xy) -> ordaction (pcoord, xy))\n\n-- |\nswitchActionEnteringDiffPage ::\n  Monad m =>\n  PageNum ->\n  CanvasGeometry ->\n  PointerCoord ->\n  m a ->\n  (PageNum -> (PageNum, PageCoordinate) -> m a) ->\n  (PageNum -> (PageNum, PageCoordinate) -> m a) ->\n  m a\nswitchActionEnteringDiffPage pgn geometry pcoord skipaction chgaction ordaction = do\n  let pagecoord = desktop2Page geometry . device2Desktop geometry $ pcoord\n  maybeFlip pagecoord skipaction $\n    \\(cpn, pxy) ->\n      if pgn == cpn\n        then ordaction pgn (cpn, pxy)\n        else chgaction pgn (cpn, pxy)\n\n-- | in page action\npenMoveAndUpOnly ::\n  Monad m =>\n  UserEvent ->\n  PageNum ->\n  CanvasGeometry ->\n  m a ->\n  ((PointerCoord, (Double, Double)) -> m a) ->\n  (PointerCoord -> m a) ->\n  m a\npenMoveAndUpOnly r pgn geometry defact moveaction upaction =\n  case r of\n    PenMove _ pcoord -> skipIfNotInSamePage pgn geometry pcoord defact moveaction\n    PenUp _ pcoord -> upaction pcoord\n    _ -> defact\n\n-- |\npenMoveAndUpInterPage ::\n  Monad m =>\n  UserEvent ->\n  PageNum ->\n  CanvasGeometry ->\n  m a ->\n  (PageNum -> (PageNum, PageCoordinate) -> m a) ->\n  (PointerCoord -> m a) ->\n  m a\npenMoveAndUpInterPage r pgn geometry defact moveaction upaction =\n  case r of\n    PenMove _ pcoord ->\n      switchActionEnteringDiffPage pgn geometry pcoord defact moveaction moveaction\n    PenUp _ pcoord -> upaction pcoord\n    _ -> defact\n\n-- | process action when last time was before time diff limit, otherwise\n--   just do default action.\nprocessWithTimeInterval ::\n  (Monad m, MonadIO m) =>\n  -- | time diff\n  NominalDiffTime ->\n  -- | not larger than time diff bound\n  (UTCTime -> m a) ->\n  -- | larger than time diff bound\n  (UTCTime -> m a) ->\n  -- | last updated time\n  UTCTime ->\n  m a\nprocessWithTimeInterval tdiffbound defact updateact otime = do\n  ctime <- liftIO getCurrentTime\n  let dtime = diffUTCTime ctime otime\n  if dtime > tdiffbound then updateact ctime else defact otime\n\n-- |\nprocessWithDefTimeInterval ::\n  (Monad m, MonadIO m) =>\n  -- | not larger than time diff bound\n  (UTCTime -> m a) ->\n  -- | larger than time diff bound\n  (UTCTime -> m a) ->\n  -- | last updated time\n  UTCTime ->\n  m a\nprocessWithDefTimeInterval = processWithTimeInterval dtimeBound\n"