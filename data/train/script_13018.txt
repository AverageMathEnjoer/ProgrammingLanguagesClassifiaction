b'package com.bennyhuo.kotlin.coroutines\n\nimport kotlinx.coroutines.asCoroutineDispatcher\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport java.util.concurrent.Executors\nimport kotlin.concurrent.thread\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.suspendCoroutine\nimport kotlin.reflect.KMutableProperty0\n\n/**\n * Created by benny.\n */\nsuspend fun main() {\n    eatGame()\n}\n\nsuspend fun noSuspend() {\n    println("noSuspend called.")\n}\n\nsuspend fun suspended() {\n    delay(100)\n    println("resumed after 100ms")\n}\n\nsuspend fun fakeSuspend() = suspendCoroutine<Int> {\n    it.resume(1)\n}\n\nsuspend fun fakeSuspend2() = suspendCoroutine<Int> {\n    Thread.sleep(100)\n    it.resume(1)\n}\n\nsuspend fun realSuspend() = suspendCoroutine<Int> {\n    thread {\n        Thread.sleep(100)\n        it.resume(1)\n    }\n}\n\nclass EatGame {\n    private var feedContinuation: Continuation<Int>? = null\n    private var eatContinuation: Continuation<String>? = null\n    private var eatAttempts = 0\n\n    var isActive: Boolean = true\n        private set\n\n    suspend fun eat(): String {\n        return if (isActive) suspendCoroutine<String> {\n            this.eatContinuation = it\n            resumeContinuation(this::feedContinuation, eatAttempts++)\n        } else ""\n    }\n\n    suspend fun feed(food: String): Int {\n        return if (isActive) suspendCoroutine {\n            this.feedContinuation = it\n            resumeContinuation(this::eatContinuation, food)\n        } else -1\n    }\n\n    fun timeout() {\n        isActive = false\n        resumeContinuation(this::feedContinuation, eatAttempts)\n        resumeContinuation(this::eatContinuation, "")\n    }\n\n    private fun <T> resumeContinuation(\n        continuationRef: KMutableProperty0<Continuation<T>?>,\n        value: T\n    ) {\n        val continuation = continuationRef.get()\n        continuationRef.set(null)\n        continuation?.resume(value)\n    }\n}\n\nsuspend fun eatGame() {\n    coroutineScope {\n        val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()\n        val game = EatGame()\n        launch(dispatcher) {\n            println("Ready Go!")\n            delay(1000)\n            game.timeout()\n            println("Timeout!")\n        }\n        launch(dispatcher) {\n            while (game.isActive) {\n                delay(60)\n                val food = Math.random()\n                println("[${Thread.currentThread().name} #1] Feed $food >>>")\n                println("[${Thread.currentThread().name} #1] Complete: ${game.feed("$food")}")\n            }\n        }\n\n        launch(dispatcher) {\n            while (game.isActive) {\n                delay(50)\n                println("[${Thread.currentThread().name} #2] Eat ${game.eat()} <<<")\n            }\n        }\n    }\n}'