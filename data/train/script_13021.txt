b'module Rest.Gen.Base.Link\n  ( Link\n  , LinkItem (..)\n  , flattenLast\n  , flattenLastResource\n  , flattenLink\n  , getLinkIds\n  , hasParam\n  , itemString\n  , setLinkIds\n  ) where\n\n-- | Data structure representing Api links\ndata LinkItem =\n    LResource String\n  | LAction String\n  | LParam String\n  | LAccess [Link] deriving Show\n\ninstance Eq LinkItem where\n  (==) (LAccess a) (LAccess b) = a == b\n  (==) (LAccess _) _ = False\n  (==) _ (LAccess _) = False\n  (==) a b = itemString a == itemString b\n\ntype Link = [LinkItem]\n\nhasParam :: LinkItem -> Bool\nhasParam (LAccess l) = any (any hasParam) l\nhasParam (LParam _) = True\nhasParam _ = False\n\nitemString :: LinkItem -> String\nitemString li =\n  case li of\n    LResource s   -> s\n    LAction   s   -> s\n    LParam    s   -> s\n    _             -> ""\n\nflattenLink :: Link -> [Link]\nflattenLink []               = [[]]\nflattenLink (LAccess ls: rs) = [l ++ r | l <- concatMap flattenLink ls, r <- flattenLink rs]\nflattenLink (v: rs)          = map (v :) $ flattenLink rs\n\nflattenFrom :: (LinkItem -> Bool) -> Link -> [Link]\nflattenFrom f = (\\(end, start) -> [ reverse start ++ epart | epart <- flattenLink (reverse end)]) . break f . reverse\n\nflattenLast :: Link -> [Link]\nflattenLast [] = [[]]\nflattenLast xs = (\\l -> map (reverse (tail l) ++) $ flattenLink [head l]) . reverse $ xs\n\nflattenLastResource :: Link -> [Link]\nflattenLastResource = flattenFrom $ \\x -> case x of LResource _ -> True; _ -> False\n{-\n-- | Make link by replacing identifiers with data\nmkLink :: Link -> [String] -> String\nmkLink []                     _        = ""\nmkLink ((LAction s) : ls)     ps       = "/" ++ s ++ mkLink ls ps\nmkLink ((LAccess _) : ls)     (p : ps) = "/" ++ p ++ mkLink ls ps\n\n-- | Make link by replacing the identifying parts\nmkLink\' :: Link -> [String] -> String\nmkLink\' []                     _            = ""\nmkLink\' ((LAction s) : ls)     ps           = "/" ++ s ++ mkLink\' ls ps\nmkLink\' ((LAccess _) : ls)     (p : ps)     = "/" ++ p ++ mkLink\' ls ps\n-}\n\ngetLinkIds :: Link -> [(String, [(String, String)])]\ngetLinkIds l =\n  case l of\n    []                   -> []\n    (q: LParam p   : rs) -> (itemString q, [(itemString q, p)]) : getLinkIds rs\n    (q: LAccess ls : rs) -> (itemString q, concatMap snd $ concatMap (getLinkIds . (q : )) ls) : getLinkIds rs\n    (_: rs)              -> getLinkIds rs\n\nsetLinkIds :: Link -> [String] -> String\nsetLinkIds _ [] = error "Error in setLinkIds, not enough parameters"\nsetLinkIds l (p : ps) =\n  case l of\n    []                    -> ""\n    (_: LParam _  : rs) -> "/" ++ p ++ setLinkIds rs ps\n    (_: LAccess _ : rs) -> "/" ++ p ++ setLinkIds rs ps\n    (s: rs)               -> "/" ++ itemString s ++ setLinkIds rs (p: ps)\n'