b'// UVa12105 Bigger is Better\n// Rujia Liu\n// This solution is simpler than the one described in the book\n\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nconst int maxn = 100 + 5;\nconst int maxm = 3000 + 5;\n\n// dp[i][j] is the maximal length of the integer whose remainder is j (with at most i matches)\n// p[i][j] is the maximal digit for state (i,j)\nint n, m, dp[maxn][maxm], p[maxn][maxm];\n\nint needs[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nint main(){\n  int kase = 0;\n  while(scanf("%d%d", &n, &m) == 2) {\n    printf("Case %d: ", ++kase);\n\n    for(int i = 0; i <= n; i++)\n      for(int j = 0; j < m; j++){\n        int& ans = dp[i][j];\n        ans = p[i][j] = -1;\n        if (j == 0) ans = 0;\n        for(int d = 9; d >= 0; d--)\n          if (i >= needs[d]){\n            int t = dp[i - needs[d]][(j * 10 + d) % m];\n            if (t >= 0 && t + 1 > ans){\n              ans = t + 1;\n              p[i][j] = d;\n            }\n          }\n      }\n\n    if (p[n][0] < 0) printf("-1");\n    else {\n      int i = n, j = 0;\n      for(int d = p[i][j]; d >= 0; d = p[i][j]){\n        printf("%d", d);\n        i -= needs[d];\n        j = (j * 10 + d) % m;\n      }\n    }\n    printf("\\n");\n  }\n  return 0;\n}\n'