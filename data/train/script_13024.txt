b'{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-incomplete-uni-patterns #-}\n\nmodule Hoodle.Coroutine.File where\n\nimport Control.Lens (at, over, set, view, (.~), (?~))\nimport Control.Monad (guard, unless, void, when, (<=<))\nimport Control.Monad.State (get, gets, lift, liftIO)\nimport Control.Monad.Trans.Crtn (CrtnErr (Other))\nimport Control.Monad.Trans.Except (ExceptT (..))\nimport Control.Monad.Trans.Maybe (MaybeT (..))\nimport Data.Attoparsec.ByteString.Char8 (parseOnly)\nimport Data.ByteString.Char8 as B (pack, readFile, unpack)\nimport qualified Data.ByteString.Lazy as L\nimport Data.Digest.Pure.MD5 (md5)\nimport Data.Foldable (forM_, mapM_)\nimport Data.Functor ((<&>))\nimport Data.Hoodle.Generic\n  ( gdimension,\n    ghoodleID,\n    gitems,\n    gpages,\n    grevisions,\n    gtitle,\n  )\nimport Data.Hoodle.Select\n  ( gselRevisions,\n    gselTitle,\n  )\nimport Data.Hoodle.Simple\n  ( Dimension (Dim),\n    Hoodle,\n    Image (..),\n    Item (..),\n    Revision (..),\n    SVG (..),\n    defaultHoodle,\n    hoodleID,\n    revmd5,\n    title,\n  )\nimport qualified Data.List as List\nimport Data.Maybe (fromJust, fromMaybe, maybeToList)\nimport Data.Time.Clock (getCurrentTime)\nimport Graphics.Hoodle.Render (Xform4Page (..), cnstrctRHoodle)\nimport Graphics.Hoodle.Render.Generic\n  ( cairoRender,\n    cairoRenderOption,\n  )\nimport Graphics.Hoodle.Render.Item (cnstrctRItem)\nimport Graphics.Hoodle.Render.Type\n  ( InBBox (..),\n    InBBoxOption (..),\n    RItem,\n    RenderCache,\n    rHoodle2Hoodle,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest (AlterList (..), Hitted (..))\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( applyActionToAllCVS,\n    getCurrentPageCurr,\n    getHoodleFilePath,\n    pureUpdateUhdl,\n    renderCache,\n    updateUhdl,\n  )\nimport Hoodle.Coroutine.Commit\n  ( clearUndoHistory,\n    commit_,\n  )\nimport Hoodle.Coroutine.Dialog\n  ( fileChooser,\n    okCancelMessageBox,\n    okMessageBox,\n    textInputDialog,\n  )\nimport Hoodle.Coroutine.Draw\n  ( callRenderer,\n    callRenderer_,\n    doIOaction_,\n    invalidateAll,\n    waitSomeEvent,\n  )\nimport Hoodle.Coroutine.Layer\n  ( makeNewLayer,\n  )\nimport Hoodle.Coroutine.Minibuffer\n  ( minibufDialog,\n  )\nimport Hoodle.Coroutine.Mode (modeChange)\nimport Hoodle.Coroutine.Page\n  ( canvasZoomUpdateAll,\n    changePage,\n    newPage,\n  )\nimport Hoodle.Coroutine.Scroll (adjustScrollbarWithGeometryCvsId)\nimport Hoodle.Coroutine.Select.Clipboard (updateTempHoodleSelectM)\nimport Hoodle.Coroutine.TextInput\n  ( autoPosText,\n    insertItemAt,\n  )\nimport Hoodle.GUI.Reflect (reflectUIToggle)\nimport Hoodle.ModelAction.File\n  ( checkVersionAndMigrate,\n    embedPDFInHoodle,\n    makeNewHoodleWithPDF,\n    makeNewItemImage,\n    saveHoodle,\n  )\nimport Hoodle.ModelAction.Layer (getCurrentLayer)\nimport Hoodle.ModelAction.Page\n  ( getPageFromGHoodleMap,\n    setPage,\n  )\nimport Hoodle.ModelAction.Select (makePageSelectMode)\nimport Hoodle.ModelAction.Window (setTitleFromFileName)\n-- import Hoodle.Publish.PDF (renderHoodleToPDF)\nimport qualified Hoodle.Script.Coroutine as S\nimport Hoodle.Script.Hook\n  ( fileNameSuggestionHook,\n    saveAsHook,\n    shrinkCmd4EmbedImage,\n    warningEmbedImageSize,\n  )\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    currentPageNum,\n    unboxLens,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine, doIOaction)\nimport Hoodle.Type.Enum (AddDirection (PageBefore))\nimport Hoodle.Type.Event\n  ( AllEvent (UsrEv),\n    RenderEvent\n      ( GotRHoodle,\n        GotRItem\n      ),\n    UserEvent\n      ( ActionOrdered,\n        GotOk,\n        GotRevision,\n        GotRevisionInk,\n        RenderEv,\n        ToSelectMode,\n        ToViewAppendMode\n      ),\n  )\nimport Hoodle.Type.HoodleState\n  ( FileStore (LocalDir),\n    HoodleModeState (SelectState, ViewAppendState),\n    IsOneTimeSelectMode (YesAfterSelect),\n    currentCanvasInfo,\n    currentUnit,\n    doesEmbedImage,\n    doesEmbedPDF,\n    getCurrentCanvasId,\n    getHoodle,\n    gtkUIManager,\n    hoodleFileControl,\n    hoodleFileName,\n    hoodleModeState,\n    hookSet,\n    isOneTimeSelectMode,\n    isSaved,\n    lastSavedTime,\n    resetHoodleModeStateBuffers,\n    settings,\n    syncMD5History,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement (PageCoordinate (..), PageNum (..))\nimport Hoodle.Util (mkTmpFile, msgShout)\nimport System.Directory\n  ( createDirectory,\n    doesDirectoryExist,\n    doesFileExist,\n    getDirectoryContents,\n    getHomeDirectory,\n    renameFile,\n  )\nimport System.FilePath\n  ( splitFileName,\n    takeExtension,\n    (<.>),\n    (</>),\n  )\nimport System.IO (IOMode (..), hClose, hFileSize, openFile)\nimport System.Process\n  ( createProcess,\n    proc,\n  )\nimport Text.Hoodle.Builder (builder)\nimport Text.Hoodle.Migrate.FromXournal (mkHoodleFromXournal)\nimport qualified Text.Hoodlet.Parse.Attoparsec as Hoodlet\nimport qualified Text.Xournal.Parse.Conduit as XP\n--\nimport Prelude hiding (concat, mapM, mapM_, readFile)\n\n-- |\naskIfSave :: MainCoroutine () -> MainCoroutine ()\naskIfSave action = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  if not (view isSaved uhdl)\n    then okCancelMessageBox "Current canvas is not saved yet. Will you proceed without save?" >>= flip when action\n    else action\n\n-- |\naskIfOverwrite :: FilePath -> MainCoroutine () -> MainCoroutine ()\naskIfOverwrite fp action = do\n  b <- liftIO $ doesFileExist fp\n  if b\n    then do\n      r <- okCancelMessageBox ("Overwrite " ++ fp ++ "???")\n      when r action\n    else action\n\n-- | get file content from xournal file and update hoodle state\ngetFileContent :: FileStore -> MainCoroutine ()\ngetFileContent store@(LocalDir (Just fname)) = do\n  xstate <- get\n  let ext = takeExtension fname\n  case ext of\n    ".hdl" -> do\n      bstr <- liftIO $ B.readFile fname\n      r <- liftIO $ checkVersionAndMigrate bstr\n      case r of\n        Left err -> liftIO $ putStrLn err\n        Right h -> do\n          constructNewHoodleStateFromHoodle h\n          ctime <- liftIO getCurrentTime\n          let mmd5 = Nothing\n          pureUpdateUhdl\n            ( (hoodleFileControl . hoodleFileName .~ store)\n                . (hoodleFileControl . lastSavedTime ?~ ctime)\n                . (hoodleFileControl . syncMD5History .~ maybeToList mmd5)\n            )\n          commit_\n    ".xoj" -> do\n      liftIO (XP.parseXojFile fname) >>= \\case\n        Left str -> msgShout $ "file reading error : " ++ str\n        Right xojcontent -> do\n          hdlcontent <- liftIO $ mkHoodleFromXournal xojcontent\n          constructNewHoodleStateFromHoodle hdlcontent\n          ctime <- liftIO getCurrentTime\n          pureUpdateUhdl\n            ( (hoodleFileControl . hoodleFileName .~ LocalDir Nothing)\n                . (hoodleFileControl . lastSavedTime ?~ ctime)\n            )\n          commit_\n    ".pdf" -> do\n      let doesembed = view (settings . doesEmbedPDF) xstate\n      mhdl <- liftIO $ makeNewHoodleWithPDF doesembed fname\n      case mhdl of\n        Nothing -> getFileContent (LocalDir Nothing)\n        Just hdl -> do\n          constructNewHoodleStateFromHoodle hdl\n          pureUpdateUhdl (hoodleFileControl . hoodleFileName .~ LocalDir Nothing)\n          commit_\n    _ -> getFileContent (LocalDir Nothing)\n  xstate\' <- get\n  doIOaction_ $ Gtk.postGUIAsync (setTitleFromFileName xstate\')\ngetFileContent (LocalDir Nothing) = do\n  constructNewHoodleStateFromHoodle =<< liftIO defaultHoodle\n  pureUpdateUhdl (hoodleFileControl . hoodleFileName .~ LocalDir Nothing)\n  commit_\ngetFileContent _ = return ()\n\n-- |\nconstructNewHoodleStateFromHoodle :: Hoodle -> MainCoroutine ()\nconstructNewHoodleStateFromHoodle hdl\' = do\n  callRenderer $\n    cnstrctRHoodle hdl\' <&> GotRHoodle\n  RenderEv (GotRHoodle rhdl) <- waitSomeEvent (\\case RenderEv (GotRHoodle _) -> True; _ -> False)\n  pureUpdateUhdl (hoodleModeState .~ ViewAppendState rhdl)\n\n-- | deprecated\nfileNew :: MainCoroutine ()\nfileNew = do\n  getFileContent (LocalDir Nothing)\n  updateUhdl $ \\uhdl -> do\n    ncvsinfo <- liftIO $ setPage uhdl 0 (getCurrentCanvasId uhdl)\n    return $ (currentCanvasInfo .~ ncvsinfo) uhdl\n  xst <- get\n  liftIO (setTitleFromFileName xst)\n  commit_\n  invalidateAll\n\n-- |\nfileSave :: MainCoroutine ()\nfileSave = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  case getHoodleFilePath uhdl of\n    Nothing -> fileSaveAs\n    Just filename -> do\n      -- this is rather temporary not to make mistake\n      if takeExtension filename == ".hdl"\n        then do\n          updateUhdl $ liftIO . saveHoodle . const uhdl\n          (S.afterSaveHook filename . rHoodle2Hoodle . getHoodle) uhdl\n        else fileExtensionInvalid (".hdl", "save") >> fileSaveAs\n\n-- | interleaving a monadic action between each pair of subsequent actions\nsequence1_ :: (Monad m) => m () -> [m ()] -> m ()\nsequence1_ _ [] = return ()\nsequence1_ _ [a] = a\nsequence1_ i (a : as) = a >> i >> sequence1_ i as\n\n-- |\nfileExport :: MainCoroutine ()\nfileExport = fileChooser Gtk.FileChooserActionSave Nothing >>= maybe (return ()) action\n  where\n    action filename = do\n      -- this is rather temporary not to make mistake\n      if takeExtension filename /= ".pdf"\n        then fileExtensionInvalid (".pdf", "export") >> fileExport\n        else do\n          hdl <- gets (rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit))\n          -- liftIO (renderHoodleToPDF hdl filename)\n          liftIO $ putStrLn "renderHoodleToPDF is disabled for now."\n\n-- | need to be merged with ContextMenuEventSVG\nexportCurrentPageAsSVG :: MainCoroutine ()\nexportCurrentPageAsSVG = fileChooser Gtk.FileChooserActionSave Nothing >>= maybe (return ()) action\n  where\n    action filename =\n      -- this is rather temporary not to make mistake\n      if takeExtension filename /= ".svg"\n        then fileExtensionInvalid (".svg", "export") >> exportCurrentPageAsSVG\n        else do\n          cvsid <- gets (getCurrentCanvasId . view (unitHoodles . currentUnit))\n          cache <- renderCache\n          cpg <- getCurrentPageCurr\n          let Dim w h = view gdimension cpg\n          liftIO $\n            Cairo.withSVGSurface filename w h $ \\s ->\n              Cairo.renderWith s $\n                void $\n                  cairoRenderOption\n                    (InBBoxOption Nothing)\n                    cache\n                    cvsid\n                    (InBBox cpg, Nothing :: Maybe Xform4Page)\n\n-- |\nfileLoad :: FileStore -> MainCoroutine ()\nfileLoad filestore = do\n  getFileContent filestore\n  updateUhdl $ \\uhdl -> do\n    ncvsinfo <- liftIO $ setPage uhdl 0 (getCurrentCanvasId uhdl)\n    return . (currentCanvasInfo .~ ncvsinfo) . (isSaved .~ True) $ uhdl\n  xst <- get\n  let ui = view gtkUIManager xst\n  liftIO $ reflectUIToggle ui "SAVEA" False\n  liftIO $ setTitleFromFileName xst\n  clearUndoHistory\n  modeChange ToViewAppendMode\n  canvasZoomUpdateAll\n  resetHoodleBuffers\n  invalidateAll\n  applyActionToAllCVS adjustScrollbarWithGeometryCvsId\n\n-- |\nresetHoodleBuffers :: MainCoroutine ()\nresetHoodleBuffers = do\n  updateUhdl $ \\uhdl -> do\n    let hdlst = view hoodleModeState uhdl\n        cvsid = getCurrentCanvasId uhdl\n    callRenderer_ $ resetHoodleModeStateBuffers cvsid hdlst\n    return . (hoodleModeState .~ hdlst) $ uhdl\n\n-- | main coroutine for open a file\nfileOpen :: MainCoroutine ()\nfileOpen = do\n  mfilename <- fileChooser Gtk.FileChooserActionOpen Nothing\n  forM_ mfilename (fileLoad . LocalDir . Just)\n\n-- | main coroutine for save as\nfileSaveAs :: MainCoroutine ()\nfileSaveAs = do\n  hdl <- gets (rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit))\n  maybe (defSaveAsAction hdl) (\\f -> liftIO (f hdl)) =<< hookSaveAsAction\n  where\n    hookSaveAsAction = gets (saveAsHook <=< view hookSet)\n    msuggestedact = gets (fileNameSuggestionHook <=< view hookSet)\n    defSaveAsAction hdl = do\n      (msuggested :: Maybe String) <- maybe (return Nothing) (fmap Just . liftIO) =<< msuggestedact\n      mr <- fileChooser Gtk.FileChooserActionSave msuggested\n      maybe (return ()) (action hdl) mr\n      where\n        action hd filename =\n          if takeExtension filename /= ".hdl"\n            then fileExtensionInvalid (".hdl", "save")\n            else do\n              askIfOverwrite filename $ do\n                updateUhdl $ \\uhdl -> do\n                  let ntitle = B.pack . snd . splitFileName $ filename\n                      (hdlmodst\', hdl\') = case view hoodleModeState uhdl of\n                        ViewAppendState hdlmap ->\n                          if view gtitle hdlmap == "untitled"\n                            then (ViewAppendState (set gtitle ntitle hdlmap), set title ntitle hd)\n                            else (ViewAppendState hdlmap, hd)\n                        SelectState thdl ->\n                          if view gselTitle thdl == "untitled"\n                            then\n                              ( SelectState $ set gselTitle ntitle thdl,\n                                set title ntitle hd\n                              )\n                            else (SelectState thdl, hd)\n                  liftIO . L.writeFile filename . builder $ hdl\'\n                  return . (hoodleFileControl . hoodleFileName .~ LocalDir (Just filename))\n                    . (hoodleModeState .~ hdlmodst\')\n                    . (isSaved .~ True)\n                    $ uhdl\n              xst <- get\n              let ui = view gtkUIManager xst\n                  hdl\'\' = (rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit)) xst\n              liftIO $ reflectUIToggle ui "SAVEA" False\n              liftIO $ setTitleFromFileName xst\n              S.afterSaveHook filename hdl\'\'\n\n-- | main coroutine for open a file\nfileReload :: MainCoroutine ()\nfileReload = do\n  uhdl <- gets (view (unitHoodles . currentUnit))\n  let filestore = view (hoodleFileControl . hoodleFileName) uhdl\n  if not (view isSaved uhdl)\n    then do\n      b <- okCancelMessageBox "Discard changes and reload the file?"\n      when b (fileLoad filestore)\n    else fileLoad filestore\n\n-- |\nfileExtensionInvalid :: (String, String) -> MainCoroutine ()\nfileExtensionInvalid (ext, a) =\n  okMessageBox $\n    "only "\n      ++ ext\n      ++ " extension is supported for "\n      ++ a\n\n-- |\nfileAnnotatePDF :: MainCoroutine ()\nfileAnnotatePDF =\n  fileChooser Gtk.FileChooserActionOpen Nothing >>= maybe (return ()) action\n  where\n    warning = do\n      okMessageBox "cannot load the pdf file. Check your hoodle compiled with poppler library"\n      invalidateAll\n    action filename = do\n      xstate <- get\n      let doesembed = view (settings . doesEmbedPDF) xstate\n      mhdl <- liftIO $ makeNewHoodleWithPDF doesembed filename\n      flip (maybe warning) mhdl $ \\hdl -> do\n        constructNewHoodleStateFromHoodle hdl\n        pureUpdateUhdl (hoodleFileControl . hoodleFileName .~ LocalDir Nothing)\n        commit_\n        setTitleFromFileName_\n        canvasZoomUpdateAll\n\n-- | set frame title according to file name\nsetTitleFromFileName_ :: MainCoroutine ()\nsetTitleFromFileName_ = get >>= liftIO . setTitleFromFileName\n\n-- |\ncheckEmbedImageSize :: FilePath -> MainCoroutine (Maybe FilePath)\ncheckEmbedImageSize filename = do\n  xst <- get\n  runMaybeT $ do\n    sizelimit <- (MaybeT . return) (warningEmbedImageSize =<< view hookSet xst)\n    siz <- liftIO $ do\n      h <- openFile filename ReadMode\n      s <- hFileSize h\n      hClose h\n      return s\n    guard (siz > sizelimit)\n    let suggestscale :: Double = sqrt (fromIntegral sizelimit / fromIntegral siz)\n    b <- lift . okCancelMessageBox $ "The size of " ++ filename ++ "=" ++ show siz ++ "\\nis bigger than limit=" ++ show sizelimit ++ ".\\nWill you reduce size?"\n    guard b\n    let ext =\n          let x\' = takeExtension filename\n           in if (not . null) x\' then tail x\' else ""\n    tmpfile <- liftIO $ mkTmpFile ext\n    cmd <- (MaybeT . return) (shrinkCmd4EmbedImage =<< view hookSet xst)\n    liftIO $ cmd suggestscale filename tmpfile\n    return tmpfile\n\n-- |\nfileLoadPNGorJPG :: MainCoroutine ()\nfileLoadPNGorJPG = do\n  fileChooser Gtk.FileChooserActionOpen Nothing >>= maybe (return ()) embedImage\n\n-- |\nfileLoadImageBackground :: MainCoroutine ()\nfileLoadImageBackground = do\n  fileChooser Gtk.FileChooserActionOpen Nothing >>= maybe (return ()) action\n  where\n    action filename = do\n      xst <- get\n      let fDoesEmbedImg = view (settings . doesEmbedImage) xst\n          uhdl = view (unitHoodles . currentUnit) xst\n          hdl = getHoodle uhdl\n          Dim pw _ph = (view gdimension . fromJust . view (gpages . at 0)) hdl\n      itm <-\n        if fDoesEmbedImg\n          then\n            checkEmbedImageSize filename\n              >>= maybe\n                (liftIO $ makeNewItemImage True filename)\n                (liftIO . makeNewItemImage True)\n          else liftIO (makeNewItemImage False filename)\n      let ItemImage img = itm\n          Dim w h = img_dim img\n          ratio = h / w\n          ndim = Dim pw (pw * ratio)\n          img\' = img {img_dim = ndim}\n      changePage (const 0)\n      newPage (Just ndim) PageBefore\n      callRenderer $\n        cnstrctRItem (ItemImage img\') <&> GotRItem\n      RenderEv (GotRItem nitm) <- waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n      insertItemAt (Just (PageNum 0, PageCoord (0, 0))) nitm\n      modeChange ToViewAppendMode\n      makeNewLayer\n\nembedImage :: FilePath -> MainCoroutine ()\nembedImage filename = do\n  xst <- get\n  let fDoesEmbedImg = view (settings . doesEmbedImage) xst\n      uhdl = view (unitHoodles . currentUnit) xst\n  nitm <-\n    if fDoesEmbedImg\n      then do\n        mf <- checkEmbedImageSize filename\n        --\n        callRenderer $ case mf of\n          Nothing ->\n            (liftIO (makeNewItemImage True filename) >>= cnstrctRItem) <&> GotRItem\n          Just f ->\n            (liftIO (makeNewItemImage True f) >>= cnstrctRItem) <&> GotRItem\n        RenderEv (GotRItem r) <- waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n        return r\n      else do\n        callRenderer $\n          (liftIO (makeNewItemImage False filename) >>= cnstrctRItem) <&> GotRItem\n        RenderEv (GotRItem r) <- waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n        return r\n  let cpn = view (currentCanvasInfo . unboxLens currentPageNum) uhdl\n  my <- autoPosText\n  let mpos = (\\y -> (PageNum cpn, PageCoord (50, y))) <$> my\n  insertItemAt mpos nitm\n\n-- |\nfileLoadSVG :: MainCoroutine ()\nfileLoadSVG = do\n  fileChooser Gtk.FileChooserActionOpen Nothing >>= maybe (return ()) action\n  where\n    action filename = do\n      xst <- get\n      bstr <- liftIO $ B.readFile filename\n      let uhdl = view (unitHoodles . currentUnit) xst\n          cvsid = getCurrentCanvasId uhdl\n          pgnum = view (currentCanvasInfo . unboxLens currentPageNum) uhdl\n          hdl = getHoodle uhdl\n          currpage = getPageFromGHoodleMap pgnum hdl\n          currlayer = getCurrentLayer currpage\n      --\n      callRenderer $\n        GotRItem\n          <$> (cnstrctRItem . ItemSVG)\n            (SVG Nothing Nothing bstr (100, 100) (Dim 300 300))\n      RenderEv (GotRItem newitem) <- waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n      --\n      let otheritems = view gitems currlayer\n      let ntpg = makePageSelectMode currpage (otheritems :- Hitted [newitem] :- Empty)\n      modeChange ToSelectMode\n      updateUhdl $ \\uhdl\' -> do\n        thdl <- case view hoodleModeState uhdl\' of\n          SelectState thdl\' -> return thdl\'\n          _ -> (lift . ExceptT . return . Left . Other) "fileLoadSVG"\n        nthdl <- updateTempHoodleSelectM cvsid thdl ntpg pgnum\n        return . (hoodleModeState .~ SelectState nthdl)\n          . (isOneTimeSelectMode .~ YesAfterSelect)\n          $ uhdl\'\n      commit_\n      invalidateAll\n\n-- |\naskQuitProgram :: MainCoroutine ()\naskQuitProgram = do\n  b <- okCancelMessageBox "Current canvas is not saved yet. Will you close hoodle?"\n  when b $\n    doIOaction_ $\n      Gtk.postGUIAsync Gtk.mainQuit >> return (UsrEv ActionOrdered)\n\n-- |\nembedPredefinedImage :: MainCoroutine ()\nembedPredefinedImage = do\n  mpredefined <- S.embedPredefinedImageHook\n  forM_ mpredefined embedImage\n\n-- | this is temporary. I will remove it\nembedPredefinedImage2 :: MainCoroutine ()\nembedPredefinedImage2 = do\n  mpredefined <- S.embedPredefinedImage2Hook\n  forM_ mpredefined embedImage\n\n-- | this is temporary. I will remove it\nembedPredefinedImage3 :: MainCoroutine ()\nembedPredefinedImage3 = do\n  mpredefined <- S.embedPredefinedImage3Hook\n  forM_ mpredefined embedImage\n\n-- |\nembedAllPDFBackground :: MainCoroutine ()\nembedAllPDFBackground = do\n  hdl <- gets (rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit))\n  nhdl <- liftIO . embedPDFInHoodle $ hdl\n  constructNewHoodleStateFromHoodle nhdl\n  commit_\n  invalidateAll\n\n-- | embed an item from hoodlet using hoodlet identifier\nembedHoodlet :: String -> MainCoroutine ()\nembedHoodlet str = loadHoodlet str >>= mapM_ (insertItemAt Nothing)\n\n-- |\nmkRevisionHdlFile :: Hoodle -> IO (String, String)\nmkRevisionHdlFile hdl = do\n  hdir <- getHomeDirectory\n  tempfile <- mkTmpFile "hdl"\n  let hdlbstr = builder hdl\n  L.writeFile tempfile hdlbstr\n  ctime <- getCurrentTime\n  let idstr = B.unpack (view hoodleID hdl)\n      md5str = show (md5 hdlbstr)\n      name = "UUID_" ++ idstr ++ "_MD5Digest_" ++ md5str ++ "_ModTime_" ++ show ctime\n      nfilename = name <.> "hdl"\n      vcsdir = hdir </> ".hoodle.d" </> "vcs"\n  b <- doesDirectoryExist vcsdir\n  unless b $ createDirectory vcsdir\n  renameFile tempfile (vcsdir </> nfilename)\n  return (md5str, name)\n\nmkRevisionPdfFile :: Hoodle -> String -> IO ()\nmkRevisionPdfFile hdl fname = do\n  putStrLn "mkRevisionPdfFile is disabled for now"\n\n{-  hdir <- getHomeDirectory\n  tempfile <- mkTmpFile "pdf"\n  renderHoodleToPDF hdl tempfile\n  let nfilename = fname <.> "pdf"\n      vcsdir = hdir </> ".hoodle.d" </> "vcs"\n  b <- doesDirectoryExist vcsdir\n  unless b $ createDirectory vcsdir\n  renameFile tempfile (vcsdir </> nfilename)\n-}\n\n-- |\nfileVersionSave :: MainCoroutine ()\nfileVersionSave = do\n  hdl <- gets (rHoodle2Hoodle . getHoodle . view (unitHoodles . currentUnit))\n  rmini <- minibufDialog "Commit Message:"\n  case rmini of\n    Right [] -> return ()\n    Right strks\' -> do\n      doIOaction $ \\_evhandler -> do\n        (md5str, fname) <- mkRevisionHdlFile hdl\n        mkRevisionPdfFile hdl fname\n        return (UsrEv (GotRevisionInk md5str strks\'))\n      r <- waitSomeEvent (\\case GotRevisionInk _ _ -> True; _ -> False)\n      let GotRevisionInk md5str strks = r\n          nrev = RevisionInk (B.pack md5str) strks\n      pureUpdateUhdl $ \\uhdl ->\n        let hdlmodst = view hoodleModeState uhdl\n         in case hdlmodst of\n              ViewAppendState rhdl\' ->\n                let nrhdl = over grevisions (<> [nrev]) rhdl\'\n                 in (hoodleModeState .~ ViewAppendState nrhdl) uhdl\n              SelectState thdl ->\n                let nthdl = over gselRevisions (<> [nrev]) thdl\n                 in (hoodleModeState .~ SelectState nthdl) uhdl\n      commit_\n    Left () -> do\n      txtstr <- fromMaybe "" <$> textInputDialog "revision description"\n      doIOaction $ \\_evhandler -> do\n        (md5str, fname) <- mkRevisionHdlFile hdl\n        mkRevisionPdfFile hdl fname\n        return (UsrEv (GotRevision md5str txtstr))\n      r <- waitSomeEvent (\\case GotRevision _ _ -> True; _ -> False)\n      let GotRevision md5str txtstr\' = r\n          nrev = Revision (B.pack md5str) (B.pack txtstr\')\n      pureUpdateUhdl $ \\uhdl ->\n        let hdlmodst = view hoodleModeState uhdl\n         in case hdlmodst of\n              ViewAppendState rhdl\' ->\n                let nrhdl = over grevisions (<> [nrev]) rhdl\'\n                 in (hoodleModeState .~ ViewAppendState nrhdl) uhdl\n              SelectState thdl ->\n                let nthdl = over gselRevisions (<> [nrev]) thdl\n                 in (hoodleModeState .~ SelectState nthdl) uhdl\n      commit_\n\nshowRevisionDialog :: Hoodle -> [Revision] -> MainCoroutine ()\nshowRevisionDialog hdl revs = do\n  cvsid <- gets (getCurrentCanvasId . view (unitHoodles . currentUnit))\n  cache <- renderCache\n  doIOaction (action (cache, cvsid))\n  void $ waitSomeEvent (\\case GotOk -> True; _ -> False)\n  where\n    action (cache, cvsid) _evhandler = do\n      dialog <- Gtk.dialogNew\n      upper <- fmap Gtk.castToContainer (Gtk.dialogGetContentArea dialog)\n      vbox <- Gtk.vBoxNew False 0\n      Gtk.containerAdd upper vbox\n      mapM_ (addOneRevisionBox cache cvsid vbox hdl) revs\n      _btnOk <- Gtk.dialogAddButton dialog ("Ok" :: String) Gtk.ResponseOk\n      Gtk.widgetShowAll dialog\n      _res <- Gtk.dialogRun dialog\n      Gtk.widgetDestroy dialog\n      return (UsrEv GotOk)\n\nmkPangoText :: String -> Cairo.Render ()\nmkPangoText str = do\n  let pangordr = do\n        ctxt <- Gtk.cairoCreateContext Nothing\n        layout <- Gtk.layoutEmpty ctxt\n        fdesc <- Gtk.fontDescriptionNew\n        Gtk.fontDescriptionSetFamily fdesc ("Sans Mono" :: String)\n        Gtk.fontDescriptionSetSize fdesc 8.0\n        Gtk.layoutSetFontDescription layout (Just fdesc)\n        Gtk.layoutSetWidth layout (Just 250)\n        Gtk.layoutSetWrap layout Gtk.WrapAnywhere\n        Gtk.layoutSetText layout str\n        return layout\n      rdr layout = do\n        Cairo.setSourceRGBA 0 0 0 1\n        Gtk.updateLayout layout\n        Gtk.showLayout layout\n  layout <- liftIO pangordr\n  rdr layout\n\naddOneRevisionBox :: RenderCache -> CanvasId -> Gtk.VBox -> Hoodle -> Revision -> IO ()\naddOneRevisionBox cache cvsid vbox hdl rev = do\n  cvs <- Gtk.drawingAreaNew\n  Gtk.widgetSetSizeRequest cvs 250 25\n  _ <- cvs `Gtk.on` Gtk.draw $ do\n    -- TODO: make a safe version\n    drawwdw <-\n      liftIO (Gtk.widgetGetWindow cvs) >>= \\case\n        Just drawwdw -> pure drawwdw\n        _ -> error "addOneRevisionBox: no canvas window"\n    liftIO . Gtk.renderWithDrawWindow drawwdw $ do\n      case rev of\n        RevisionInk _ strks -> Cairo.scale 0.5 0.5 >> mapM_ (cairoRender cache cvsid) strks\n        Revision _ txt -> mkPangoText (B.unpack txt)\n  hdir <- getHomeDirectory\n  let vcsdir = hdir </> ".hoodle.d" </> "vcs"\n  btn <- Gtk.buttonNewWithLabel ("view" :: String)\n  _ <- btn `Gtk.on` Gtk.buttonPressEvent $\n    Gtk.tryEvent $ do\n      files <- liftIO $ getDirectoryContents vcsdir\n      let fstrinit =\n            "UUID_" ++ B.unpack (view hoodleID hdl)\n              ++ "_MD5Digest_"\n              ++ B.unpack (view revmd5 rev)\n          matched =\n            filter ((== "fdp") . take 3 . reverse)\n              . filter (\\f -> fstrinit `List.isPrefixOf` f)\n              $ files\n      case matched of\n        x : _ -> void $ liftIO (createProcess (proc "evince" [vcsdir </> x]))\n        _ -> return ()\n  hbox <- Gtk.hBoxNew False 0\n  Gtk.boxPackStart hbox cvs Gtk.PackNatural 0\n  Gtk.boxPackStart hbox btn Gtk.PackGrow 0\n  Gtk.boxPackStart vbox hbox Gtk.PackNatural 0\n\nfileShowRevisions :: MainCoroutine ()\nfileShowRevisions = do\n  rhdl <- gets (getHoodle . view (unitHoodles . currentUnit))\n  let hdl = rHoodle2Hoodle rhdl\n  let revs = view grevisions rhdl\n  showRevisionDialog hdl revs\n\nfileShowUUID :: MainCoroutine ()\nfileShowUUID = do\n  hdl <- gets (getHoodle . view (unitHoodles . currentUnit))\n  let uuidstr = view ghoodleID hdl\n  okMessageBox (B.unpack uuidstr)\n\nloadHoodlet :: String -> MainCoroutine (Maybe RItem)\nloadHoodlet str = do\n  homedir <- liftIO getHomeDirectory\n  let hoodled = homedir </> ".hoodle.d"\n      hoodletdir = hoodled </> "hoodlet"\n  b\' <- liftIO $ doesDirectoryExist hoodletdir\n  if b\'\n    then do\n      let fp = hoodletdir </> str <.> "hdlt"\n      bstr <- liftIO $ B.readFile fp\n      case parseOnly Hoodlet.hoodlet bstr of\n        Left err -> msgShout err >> return Nothing\n        Right itm -> do\n          --\n          callRenderer (GotRItem <$> cnstrctRItem itm)\n          RenderEv (GotRItem ritm) <-\n            waitSomeEvent (\\case RenderEv (GotRItem _) -> True; _ -> False)\n          --\n          return (Just ritm)\n    else return Nothing\n'