b'#define SQLITE_MAX_EXPR_DEPTH\nusing System;\nusing System.Diagnostics;\nusing System.Text;\n\nusing i16 = System.Int16;\nusing u8 = System.Byte;\nusing u16 = System.UInt16;\nusing u32 = System.UInt32;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2001 September 15\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This file contains C code routines that are called by the parser\n    ** to handle SELECT statements in SQLite.\n    **\n    ** $Id: select.c,v 1.526 2009/08/01 15:09:58 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n\n    /*\n    ** Delete all the content of a Select structure but do not deallocate\n    ** the select structure itself.\n    */\n    static void clearSelect( sqlite3 db, Select p )\n    {\n      sqlite3ExprListDelete( db, ref p.pEList );\n      sqlite3SrcListDelete( db, ref p.pSrc );\n      sqlite3ExprDelete( db, ref p.pWhere );\n      sqlite3ExprListDelete( db, ref p.pGroupBy );\n      sqlite3ExprDelete( db, ref p.pHaving );\n      sqlite3ExprListDelete( db, ref p.pOrderBy );\n      sqlite3SelectDelete( db, ref p.pPrior );\n      sqlite3ExprDelete( db, ref p.pLimit );\n      sqlite3ExprDelete( db, ref p.pOffset );\n    }\n\n    /*\n    ** Initialize a SelectDest structure.\n    */\n    static void sqlite3SelectDestInit( SelectDest pDest, int eDest, int iParm )\n    {\n      pDest.eDest = (u8)eDest;\n      pDest.iParm = iParm;\n      pDest.affinity = \'\\0\';\n      pDest.iMem = 0;\n      pDest.nMem = 0;\n    }\n\n\n    /*\n    ** Allocate a new Select structure and return a pointer to that\n    ** structure.\n    */\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static Select sqlite3SelectNew( Parse pParse, int null_2, SrcList pSrc, int null_4, int null_5, int null_6, int null_7, int isDistinct, int null_9, int null_10 )\n    {\n      return sqlite3SelectNew( pParse, null, pSrc, null, null, null, null, isDistinct, null, null );\n    }\n    static Select sqlite3SelectNew(\n    Parse pParse,        /* Parsing context */\n    ExprList pEList,     /* which columns to include in the result */\n    SrcList pSrc,        /* the FROM clause -- which tables to scan */\n    Expr pWhere,         /* the WHERE clause */\n    ExprList pGroupBy,   /* the GROUP BY clause */\n    Expr pHaving,        /* the HAVING clause */\n    ExprList pOrderBy,   /* the ORDER BY clause */\n    int isDistinct,       /* true if the DISTINCT keyword is present */\n    Expr pLimit,         /* LIMIT value.  NULL means not used */\n    Expr pOffset         /* OFFSET value.  NULL means no offset */\n    )\n    {\n      Select pNew;\n      //           Select standin;\n      sqlite3 db = pParse.db;\n      pNew = new Select();//sqlite3DbMallocZero(db, sizeof(*pNew) );\n      Debug.Assert( //db.mallocFailed != 0 ||\n        null == pOffset || pLimit != null ); /* OFFSET implies LIMIT */\n      //if( pNew==null   ){\n      //  pNew = standin;\n      //  memset(pNew, 0, sizeof(*pNew));\n      //}\n      if ( pEList == null )\n      {\n        pEList = sqlite3ExprListAppend( pParse, null, sqlite3Expr( db, TK_ALL, null ) );\n      }\n      pNew.pEList = pEList;\n      pNew.pSrc = pSrc;\n      pNew.pWhere = pWhere;\n      pNew.pGroupBy = pGroupBy;\n      pNew.pHaving = pHaving;\n      pNew.pOrderBy = pOrderBy;\n      pNew.selFlags = (u16)( isDistinct != 0 ? SF_Distinct : 0 );\n      pNew.op = TK_SELECT;\n      pNew.pLimit = pLimit;\n      pNew.pOffset = pOffset;\n      Debug.Assert( pOffset == null || pLimit != null );\n      pNew.addrOpenEphm[0] = -1;\n      pNew.addrOpenEphm[1] = -1;\n      pNew.addrOpenEphm[2] = -1;\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  clearSelect( db, pNew );\n      //  //if ( pNew != standin ) //sqlite3DbFree( db, ref pNew );\n      //  pNew = null;\n      //}\n      return pNew;\n    }\n\n    /*\n    ** Delete the given Select structure and all of its substructures.\n    */\n    static void sqlite3SelectDelete( sqlite3 db, ref Select p )\n    {\n      if ( p != null )\n      {\n        clearSelect( db, p );\n        //sqlite3DbFree( db, ref p );\n      }\n    }\n\n    /*\n    ** Given 1 to 3 identifiers preceeding the JOIN keyword, determine the\n    ** type of join.  Return an integer constant that expresses that type\n    ** in terms of the following bit values:\n    **\n    **     JT_INNER\n    **     JT_CROSS\n    **     JT_OUTER\n    **     JT_NATURAL\n    **     JT_LEFT\n    **     JT_RIGHT\n    **\n    ** A full outer join is the combination of JT_LEFT and JT_RIGHT.\n    **\n    ** If an illegal or unsupported join type is seen, then still return\n    ** a join type, but put an error in the pParse structure.\n    */\n\n    class Keyword\n    {\n      public u8 i;        /* Beginning of keyword text in zKeyText[] */\n      public u8 nChar;    /* Length of the keyword in characters */\n      public u8 code;     /* Join type mask */\n      public Keyword( u8 i, u8 nChar, u8 code )\n      {\n        this.i = i;\n        this.nChar = nChar;\n        this.code = code;\n      }\n    }\n\n    // OVERLOADS, so I don\'t need to rewrite parse.c\n    static int sqlite3JoinType( Parse pParse, Token pA, int null_3, int null_4 )\n    {\n      return sqlite3JoinType( pParse, pA, null, null );\n    }\n    static int sqlite3JoinType( Parse pParse, Token pA, Token pB, int null_4 )\n    {\n      return sqlite3JoinType( pParse, pA, pB, null );\n    }\n    static int sqlite3JoinType( Parse pParse, Token pA, Token pB, Token pC )\n    {\n      int jointype = 0;\n      Token[] apAll = new Token[3];\n      Token p;\n\n      /*   0123456789 123456789 123456789 123 */\n      string zKeyText = "naturaleftouterightfullinnercross";\n\n      Keyword[] aKeyword = new Keyword[]{\n/* natural */ new Keyword( 0,  7, JT_NATURAL                ),\n/* left    */ new Keyword( 6,  4, JT_LEFT|JT_OUTER          ),\n/* outer   */ new Keyword( 10, 5, JT_OUTER                  ),\n/* right   */ new Keyword( 14, 5, JT_RIGHT|JT_OUTER         ),\n/* full    */ new Keyword( 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER ),\n/* inner   */ new Keyword( 23, 5, JT_INNER                  ),\n/* cross   */ new Keyword( 28, 5, JT_INNER|JT_CROSS         ),\n};\n      int i, j;\n      apAll[0] = pA;\n      apAll[1] = pB;\n      apAll[2] = pC;\n      for ( i = 0 ; i < 3 && apAll[i] != null ; i++ )\n      {\n        p = apAll[i];\n        for ( j = 0 ; j < ArraySize( aKeyword ) ; j++ )\n        {\n          if ( p.n == aKeyword[j].nChar\n          && sqlite3StrNICmp( p.z.ToString(), zKeyText.Substring( aKeyword[j].i ), p.n ) == 0 )\n          {\n            jointype |= aKeyword[j].code;\n            break;\n          }\n        }\n        testcase( j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5 || j == 6 );\n        if ( j >= ArraySize( aKeyword ) )\n        {\n          jointype |= JT_ERROR;\n          break;\n        }\n      }\n      if (\n      ( jointype & ( JT_INNER | JT_OUTER ) ) == ( JT_INNER | JT_OUTER ) ||\n      ( jointype & JT_ERROR ) != 0\n      )\n      {\n        string zSp = " ";\n        Debug.Assert( pB != null );\n        if ( pC == null ) { zSp = ""; }\n        sqlite3ErrorMsg( pParse, "unknown or unsupported join type: " +\n        "%T %T%s%T", pA, pB, zSp, pC );\n        jointype = JT_INNER;\n      }\n      else if ( ( jointype & JT_OUTER ) != 0\n      && ( jointype & ( JT_LEFT | JT_RIGHT ) ) != JT_LEFT )\n      {\n        sqlite3ErrorMsg( pParse,\n        "RIGHT and FULL OUTER JOINs are not currently supported" );\n        jointype = JT_INNER;\n      }\n      return jointype;\n    }\n\n    /*\n    ** Return the index of a column in a table.  Return -1 if the column\n    ** is not contained in the table.\n    */\n    static int columnIndex( Table pTab, string zCol )\n    {\n      int i;\n      for ( i = 0 ; i < pTab.nCol ; i++ )\n      {\n        if ( sqlite3StrICmp( pTab.aCol[i].zName, zCol ) == 0 ) return i;\n      }\n      return -1;\n    }\n\n\n    /*\n    ** Create an expression node for an identifier with the name of zName\n    */\n    static Expr sqlite3CreateIdExpr( Parse pParse, string zName )\n    {\n      return sqlite3Expr( pParse.db, TK_ID, zName );\n    }\n\n\n    /*\n    ** Add a term to the WHERE expression in ppExpr that requires the\n    ** zCol column to be equal in the two tables pTab1 and pTab2.\n    */\n    static void addWhereTerm(\n    Parse pParse,         /* Parsing context */\n    string zCol,          /* Name of the column */\n    Table pTab1,          /* First table */\n    string zAlias1,       /* Alias for first table.  May be NULL */\n    Table pTab2,          /* Second table */\n    string zAlias2,       /* Alias for second table.  May be NULL */\n    int iRightJoinTable,  /* VDBE cursor for the right table */\n    ref Expr ppExpr,      /* Add the equality term to this expression */\n    bool isOuterJoin      /* True if dealing with an OUTER join */\n    )\n    {\n      Expr pE1a, pE1b, pE1c;\n      Expr pE2a, pE2b, pE2c;\n      Expr pE;\n\n      pE1a = sqlite3CreateIdExpr( pParse, zCol );\n      pE2a = sqlite3CreateIdExpr( pParse, zCol );\n      if ( zAlias1 == null )\n      {\n        zAlias1 = pTab1.zName;\n      }\n      pE1b = sqlite3CreateIdExpr( pParse, zAlias1 );\n      if ( zAlias2 == null )\n      {\n        zAlias2 = pTab2.zName;\n      }\n      pE2b = sqlite3CreateIdExpr( pParse, zAlias2 );\n      pE1c = sqlite3PExpr( pParse, TK_DOT, pE1b, pE1a, null );\n      pE2c = sqlite3PExpr( pParse, TK_DOT, pE2b, pE2a, null );\n      pE = sqlite3PExpr( pParse, TK_EQ, pE1c, pE2c, null );\n      if ( pE != null && isOuterJoin )\n      {\n        ExprSetProperty( pE, EP_FromJoin );\n        Debug.Assert( !ExprHasAnyProperty( pE, EP_TokenOnly | EP_Reduced ) );\n        ExprSetIrreducible( pE );\n        pE.iRightJoinTable = (i16)iRightJoinTable;\n      }\n      ppExpr = sqlite3ExprAnd( pParse.db, ppExpr, pE );\n    }\n\n    /*\n    ** Set the EP_FromJoin property on all terms of the given expression.\n    ** And set the Expr.iRightJoinTable to iTable for every term in the\n    ** expression.\n    **\n    ** The EP_FromJoin property is used on terms of an expression to tell\n    ** the LEFT OUTER JOIN processing logic that this term is part of the\n    ** join restriction specified in the ON or USING clause and not a part\n    ** of the more general WHERE clause.  These terms are moved over to the\n    ** WHERE clause during join processing but we need to remember that they\n    ** originated in the ON or USING clause.\n    **\n    ** The Expr.iRightJoinTable tells the WHERE clause processing that the\n    ** expression depends on table iRightJoinTable even if that table is not\n    ** explicitly mentioned in the expression.  That information is needed\n    ** for cases like this:\n    **\n    **    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5\n    **\n    ** The where clause needs to defer the handling of the t1.x=5\n    ** term until after the t2 loop of the join.  In that way, a\n    ** NULL t2 row will be inserted whenever t1.x!=5.  If we do not\n    ** defer the handling of t1.x=5, it will be processed immediately\n    ** after the t1 loop and rows with t1.x!=5 will never appear in\n    ** the output, which is incorrect.\n    */\n    static void setJoinExpr( Expr p, int iTable )\n    {\n      while ( p != null )\n      {\n        ExprSetProperty( p, EP_FromJoin );\n        Debug.Assert( !ExprHasAnyProperty( p, EP_TokenOnly | EP_Reduced ) );\n        ExprSetIrreducible( p );\n        p.iRightJoinTable = (i16)iTable;\n        setJoinExpr( p.pLeft, iTable );\n        p = p.pRight;\n      }\n    }\n\n    /*\n    ** This routine processes the join information for a SELECT statement.\n    ** ON and USING clauses are converted into extra terms of the WHERE clause.\n    ** NATURAL joins also create extra WHERE clause terms.\n    **\n    ** The terms of a FROM clause are contained in the Select.pSrc structure.\n    ** The left most table is the first entry in Select.pSrc.  The right-most\n    ** table is the last entry.  The join operator is held in the entry to\n    ** the left.  Thus entry 0 contains the join operator for the join between\n    ** entries 0 and 1.  Any ON or USING clauses associated with the join are\n    ** also attached to the left entry.\n    **\n    ** This routine returns the number of errors encountered.\n    */\n    static int sqliteProcessJoin( Parse pParse, Select p )\n    {\n      SrcList pSrc;                  /* All tables in the FROM clause */\n      int i; int j;                       /* Loop counters */\n      SrcList_item pLeft;     /* Left table being joined */\n      SrcList_item pRight;    /* Right table being joined */\n\n      pSrc = p.pSrc;\n      //pLeft = pSrc.a[0];\n      //pRight = pLeft[1];\n      for ( i = 0 ; i < pSrc.nSrc - 1 ; i++ )\n      {\n        pLeft = pSrc.a[i]; // pLeft ++\n        pRight = pSrc.a[i + 1];//Right++,\n        Table pLeftTab = pLeft.pTab;\n        Table pRightTab = pRight.pTab;\n        bool isOuter;\n\n        if ( NEVER( pLeftTab == null || pRightTab == null ) ) continue;\n        isOuter = ( pRight.jointype & JT_OUTER ) != 0;\n\n        /* When the NATURAL keyword is present, add WHERE clause terms for\n        ** every column that the two tables have in common.\n        */\n        if ( ( pRight.jointype & JT_NATURAL ) != 0 )\n        {\n          if ( pRight.pOn != null || pRight.pUsing != null )\n          {\n            sqlite3ErrorMsg( pParse, "a NATURAL join may not have " +\n            "an ON or USING clause", "" );\n            return 1;\n          }\n          for ( j = 0 ; j < pLeftTab.nCol ; j++ )\n          {\n            string zName = pLeftTab.aCol[j].zName;\n            if ( columnIndex( pRightTab, zName ) >= 0 )\n            {\n              addWhereTerm( pParse, zName, pLeftTab, pLeft.zAlias,\n              pRightTab, pRight.zAlias,\n              pRight.iCursor, ref p.pWhere, isOuter );\n\n            }\n          }\n        }\n\n        /* Disallow both ON and USING clauses in the same join\n        */\n        if ( pRight.pOn != null && pRight.pUsing != null )\n        {\n          sqlite3ErrorMsg( pParse, "cannot have both ON and USING " +\n          "clauses in the same join" );\n          return 1;\n        }\n\n        /* Add the ON clause to the end of the WHERE clause, connected by\n        ** an AND operator.\n        */\n        if ( pRight.pOn != null )\n        {\n          if ( isOuter ) setJoinExpr( pRight.pOn, pRight.iCursor );\n          p.pWhere = sqlite3ExprAnd( pParse.db, p.pWhere, pRight.pOn );\n          pRight.pOn = null;\n        }\n\n        /* Create extra terms on the WHERE clause for each column named\n        ** in the USING clause.  Example: If the two tables to be joined are\n        ** A and B and the USING clause names X, Y, and Z, then add this\n        ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z\n        ** Report an error if any column mentioned in the USING clause is\n        ** not contained in both tables to be joined.\n        */\n        if ( pRight.pUsing != null )\n        {\n          IdList pList = pRight.pUsing;\n          for ( j = 0 ; j < pList.nId ; j++ )\n          {\n            string zName = pList.a[j].zName;\n            if ( columnIndex( pLeftTab, zName ) < 0 || columnIndex( pRightTab, zName ) < 0 )\n            {\n              sqlite3ErrorMsg( pParse, "cannot join using column %s - column " +\n              "not present in both tables", zName );\n              return 1;\n            }\n            addWhereTerm( pParse, zName, pLeftTab, pLeft.zAlias,\n            pRightTab, pRight.zAlias,\n            pRight.iCursor, ref p.pWhere, isOuter );\n          }\n        }\n      }\n      return 0;\n    }\n\n    /*\n    ** Insert code into "v" that will push the record on the top of the\n    ** stack into the sorter.\n    */\n    static void pushOntoSorter(\n    Parse pParse,         /* Parser context */\n    ExprList pOrderBy,    /* The ORDER BY clause */\n    Select pSelect,       /* The whole SELECT statement */\n    int regData           /* Register holding data to be sorted */\n    )\n    {\n      Vdbe v = pParse.pVdbe;\n      int nExpr = pOrderBy.nExpr;\n      int regBase = sqlite3GetTempRange( pParse, nExpr + 2 );\n      int regRecord = sqlite3GetTempReg( pParse );\n      sqlite3ExprCacheClear( pParse );\n      sqlite3ExprCodeExprList( pParse, pOrderBy, regBase, false );\n      sqlite3VdbeAddOp2( v, OP_Sequence, pOrderBy.iECursor, regBase + nExpr );\n      sqlite3ExprCodeMove( pParse, regData, regBase + nExpr + 1, 1 );\n      sqlite3VdbeAddOp3( v, OP_MakeRecord, regBase, nExpr + 2, regRecord );\n      sqlite3VdbeAddOp2( v, OP_IdxInsert, pOrderBy.iECursor, regRecord );\n      sqlite3ReleaseTempReg( pParse, regRecord );\n      sqlite3ReleaseTempRange( pParse, regBase, nExpr + 2 );\n      if ( pSelect.iLimit != 0 )\n      {\n        int addr1, addr2;\n        int iLimit;\n        if ( pSelect.iOffset != 0 )\n        {\n          iLimit = pSelect.iOffset + 1;\n        }\n        else\n        {\n          iLimit = pSelect.iLimit;\n        }\n        addr1 = sqlite3VdbeAddOp1( v, OP_IfZero, iLimit );\n        sqlite3VdbeAddOp2( v, OP_AddImm, iLimit, -1 );\n        addr2 = sqlite3VdbeAddOp0( v, OP_Goto );\n        sqlite3VdbeJumpHere( v, addr1 );\n        sqlite3VdbeAddOp1( v, OP_Last, pOrderBy.iECursor );\n        sqlite3VdbeAddOp1( v, OP_Delete, pOrderBy.iECursor );\n        sqlite3VdbeJumpHere( v, addr2 );\n        pSelect.iLimit = 0;\n      }\n    }\n\n    /*\n    ** Add code to implement the OFFSET\n    */\n    static void codeOffset(\n    Vdbe v,          /* Generate code into this VM */\n    Select p,        /* The SELECT statement being coded */\n    int iContinue    /* Jump here to skip the current record */\n    )\n    {\n      if ( p.iOffset != 0 && iContinue != 0 )\n      {\n        int addr;\n        sqlite3VdbeAddOp2( v, OP_AddImm, p.iOffset, -1 );\n        addr = sqlite3VdbeAddOp1( v, OP_IfNeg, p.iOffset );\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, iContinue );\n#if SQLITE_DEBUG\n        VdbeComment( v, "skip OFFSET records" );\n#endif\n        sqlite3VdbeJumpHere( v, addr );\n      }\n    }\n\n    /*\n    ** Add code that will check to make sure the N registers starting at iMem\n    ** form a distinct entry.  iTab is a sorting index that holds previously\n    ** seen combinations of the N values.  A new entry is made in iTab\n    ** if the current N values are new.\n    **\n    ** A jump to addrRepeat is made and the N+1 values are popped from the\n    ** stack if the top N elements are not distinct.\n    */\n    static void codeDistinct(\n    Parse pParse,     /* Parsing and code generating context */\n    int iTab,          /* A sorting index used to test for distinctness */\n    int addrRepeat,    /* Jump to here if not distinct */\n    int N,             /* Number of elements */\n    int iMem           /* First element */\n    )\n    {\n      Vdbe v;\n      int r1;\n\n      v = pParse.pVdbe;\n      r1 = sqlite3GetTempReg( pParse );\n      sqlite3VdbeAddOp3( v, OP_MakeRecord, iMem, N, r1 );\n      sqlite3VdbeAddOp3( v, OP_Found, iTab, addrRepeat, r1 );\n      sqlite3VdbeAddOp2( v, OP_IdxInsert, iTab, r1 );\n      sqlite3ReleaseTempReg( pParse, r1 );\n    }\n\n    /*\n    ** Generate an error message when a SELECT is used within a subexpression\n    ** (example:  "a IN (SELECT * FROM table)") but it has more than 1 result\n    ** column.  We do this in a subroutine because the error occurs in multiple\n    ** places.\n    */\n    static bool checkForMultiColumnSelectError(\n    Parse pParse,       /* Parse context. */\n    SelectDest pDest,   /* Destination of SELECT results */\n    int nExpr           /* Number of result columns returned by SELECT */\n    )\n    {\n      int eDest = pDest.eDest;\n      if ( nExpr > 1 && ( eDest == SRT_Mem || eDest == SRT_Set ) )\n      {\n        sqlite3ErrorMsg( pParse, "only a single result allowed for " +\n        "a SELECT that is part of an expression" );\n        return true;\n      }\n      else\n      {\n        return false;\n      }\n    }\n\n    /*\n    ** This routine generates the code for the inside of the inner loop\n    ** of a SELECT.\n    **\n    ** If srcTab and nColumn are both zero, then the pEList expressions\n    ** are evaluated in order to get the data for this row.  If nColumn>0\n    ** then data is pulled from srcTab and pEList is used only to get the\n    ** datatypes for each column.\n    */\n    static void selectInnerLoop(\n    Parse pParse,          /* The parser context */\n    Select p,              /* The complete select statement being coded */\n    ExprList pEList,       /* List of values being extracted */\n    int srcTab,            /* Pull data from this table */\n    int nColumn,           /* Number of columns in the source table */\n    ExprList pOrderBy,     /* If not NULL, sort results using this key */\n    int distinct,          /* If >=0, make sure results are distinct */\n    SelectDest pDest,      /* How to dispose of the results */\n    int iContinue,         /* Jump here to continue with next row */\n    int iBreak             /* Jump here to break out of the inner loop */\n    )\n    {\n      Vdbe v = pParse.pVdbe;\n      int i;\n      bool hasDistinct;         /* True if the DISTINCT keyword is present */\n      int regResult;            /* Start of memory holding result set */\n      int eDest = pDest.eDest;  /* How to dispose of results */\n      int iParm = pDest.iParm;  /* First argument to disposal method */\n      int nResultCol;           /* Number of result columns */\n\n      Debug.Assert( v != null );\n      if ( NEVER( v == null ) ) return;\n      Debug.Assert( pEList != null );\n      hasDistinct = distinct >= 0;\n      if ( pOrderBy == null && !hasDistinct )\n      {\n        codeOffset( v, p, iContinue );\n      }\n\n      /* Pull the requested columns.\n      */\n      if ( nColumn > 0 )\n      {\n        nResultCol = nColumn;\n      }\n      else\n      {\n        nResultCol = pEList.nExpr;\n      }\n      if ( pDest.iMem == 0 )\n      {\n        pDest.iMem = pParse.nMem + 1;\n        pDest.nMem = nResultCol;\n        pParse.nMem += nResultCol;\n      }\n      else\n      {\n        Debug.Assert( pDest.nMem == nResultCol );\n      }\n      regResult = pDest.iMem;\n      if ( nColumn > 0 )\n      {\n        for ( i = 0 ; i < nColumn ; i++ )\n        {\n          sqlite3VdbeAddOp3( v, OP_Column, srcTab, i, regResult + i );\n        }\n      }\n      else if ( eDest != SRT_Exists )\n      {\n        /* If the destination is an EXISTS(...) expression, the actual\n        ** values returned by the SELECT are not required.\n        */\n        sqlite3ExprCacheClear( pParse );\n        sqlite3ExprCodeExprList( pParse, pEList, regResult, eDest == SRT_Output );\n      }\n      nColumn = nResultCol;\n\n      /* If the DISTINCT keyword was present on the SELECT statement\n      ** and this row has been seen before, then do not make this row\n      ** part of the result.\n      */\n      if ( hasDistinct )\n      {\n        Debug.Assert( pEList != null );\n        Debug.Assert( pEList.nExpr == nColumn );\n        codeDistinct( pParse, distinct, iContinue, nColumn, regResult );\n        if ( pOrderBy == null )\n        {\n          codeOffset( v, p, iContinue );\n        }\n      }\n\n      if ( checkForMultiColumnSelectError( pParse, pDest, pEList.nExpr ) )\n      {\n        return;\n      }\n\n      switch ( eDest )\n      {\n        /* In this mode, write each query result to the key of the temporary\n        ** table iParm.\n        */\n#if !SQLITE_OMIT_COMPOUND_SELECT\n        case SRT_Union:\n          {\n            int r1;\n            r1 = sqlite3GetTempReg( pParse );\n            sqlite3VdbeAddOp3( v, OP_MakeRecord, regResult, nColumn, r1 );\n            sqlite3VdbeAddOp2( v, OP_IdxInsert, iParm, r1 );\n            sqlite3ReleaseTempReg( pParse, r1 );\n            break;\n          }\n\n        /* Construct a record from the query result, but instead of\n        ** saving that record, use it as a key to delete elements from\n        ** the temporary table iParm.\n        */\n        case SRT_Except:\n          {\n            sqlite3VdbeAddOp3( v, OP_IdxDelete, iParm, regResult, nColumn );\n            break;\n          }\n#endif\n\n        /* Store the result as data using a unique key.\n*/\n        case SRT_Table:\n        case SRT_EphemTab:\n          {\n            int r1 = sqlite3GetTempReg( pParse );\n            testcase( eDest == SRT_Table );\n            testcase( eDest == SRT_EphemTab );\n            sqlite3VdbeAddOp3( v, OP_MakeRecord, regResult, nColumn, r1 );\n            if ( pOrderBy != null )\n            {\n              pushOntoSorter( pParse, pOrderBy, p, r1 );\n            }\n            else\n            {\n              int r2 = sqlite3GetTempReg( pParse );\n              sqlite3VdbeAddOp2( v, OP_NewRowid, iParm, r2 );\n              sqlite3VdbeAddOp3( v, OP_Insert, iParm, r1, r2 );\n              sqlite3VdbeChangeP5( v, OPFLAG_APPEND );\n              sqlite3ReleaseTempReg( pParse, r2 );\n            }\n            sqlite3ReleaseTempReg( pParse, r1 );\n            break;\n          }\n\n#if !SQLITE_OMIT_SUBQUERY\n        /* If we are creating a set for an "expr IN (SELECT ...)" construct,\n** then there should be a single item on the stack.  Write this\n** item into the set table with bogus data.\n*/\n        case SRT_Set:\n          {\n            Debug.Assert( nColumn == 1 );\n            p.affinity = sqlite3CompareAffinity( pEList.a[0].pExpr, pDest.affinity );\n            if ( pOrderBy != null )\n            {\n              /* At first glance you would think we could optimize out the\n              ** ORDER BY in this case since the order of entries in the set\n              ** does not matter.  But there might be a LIMIT clause, in which\n              ** case the order does matter */\n              pushOntoSorter( pParse, pOrderBy, p, regResult );\n            }\n            else\n            {\n              int r1 = sqlite3GetTempReg( pParse );\n              sqlite3VdbeAddOp4( v, OP_MakeRecord, regResult, 1, r1, p.affinity, 1 );\n              sqlite3ExprCacheAffinityChange( pParse, regResult, 1 );\n              sqlite3VdbeAddOp2( v, OP_IdxInsert, iParm, r1 );\n              sqlite3ReleaseTempReg( pParse, r1 );\n            }\n            break;\n          }\n\n        /* If any row exist in the result set, record that fact and abort.\n        */\n        case SRT_Exists:\n          {\n            sqlite3VdbeAddOp2( v, OP_Integer, 1, iParm );\n            /* The LIMIT clause will terminate the loop for us */\n            break;\n          }\n\n        /* If this is a scalar select that is part of an expression, then\n        ** store the results in the appropriate memory cell and break out\n        ** of the scan loop.\n        */\n        case SRT_Mem:\n          {\n            Debug.Assert( nColumn == 1 );\n            if ( pOrderBy != null )\n            {\n              pushOntoSorter( pParse, pOrderBy, p, regResult );\n            }\n            else\n            {\n              sqlite3ExprCodeMove( pParse, regResult, iParm, 1 );\n              /* The LIMIT clause will jump out of the loop for us */\n            }\n            break;\n          }\n#endif // * #if !SQLITE_OMIT_SUBQUERY */\n\n        /* Send the data to the callback function or to a subroutine.  In the\n** case of a subroutine, the subroutine itself is responsible for\n** popping the data from the stack.\n*/\n        case SRT_Coroutine:\n        case SRT_Output:\n          {\n            testcase( eDest == SRT_Coroutine );\n            testcase( eDest == SRT_Output );\n            if ( pOrderBy != null )\n            {\n              int r1 = sqlite3GetTempReg( pParse );\n              sqlite3VdbeAddOp3( v, OP_MakeRecord, regResult, nColumn, r1 );\n              pushOntoSorter( pParse, pOrderBy, p, r1 );\n              sqlite3ReleaseTempReg( pParse, r1 );\n            }\n            else if ( eDest == SRT_Coroutine )\n            {\n              sqlite3VdbeAddOp1( v, OP_Yield, pDest.iParm );\n            }\n            else\n            {\n              sqlite3VdbeAddOp2( v, OP_ResultRow, regResult, nColumn );\n              sqlite3ExprCacheAffinityChange( pParse, regResult, nColumn );\n            }\n            break;\n          }\n\n#if !SQLITE_OMIT_TRIGGER\n        /* Discard the results.  This is used for SELECT statements inside\n** the body of a TRIGGER.  The purpose of such selects is to call\n** user-defined functions that have side effects.  We do not care\n** about the actual results of the select.\n*/\n        default:\n          {\n            Debug.Assert( eDest == SRT_Discard );\n            break;\n          }\n#endif\n      }\n\n      /* Jump to the end of the loop if the LIMIT is reached.\n      */\n      if ( p.iLimit != 0 )\n      {\n        Debug.Assert( pOrderBy == null );  /* If there is an ORDER BY, the call to\n** pushOntoSorter() would have cleared p.iLimit */\n        sqlite3VdbeAddOp2( v, OP_AddImm, p.iLimit, -1 );\n        sqlite3VdbeAddOp2( v, OP_IfZero, p.iLimit, iBreak );\n      }\n    }\n\n    /*\n    ** Given an expression list, generate a KeyInfo structure that records\n    ** the collating sequence for each expression in that expression list.\n    **\n    ** If the ExprList is an ORDER BY or GROUP BY clause then the resulting\n    ** KeyInfo structure is appropriate for initializing a virtual index to\n    ** implement that clause.  If the ExprList is the result set of a SELECT\n    ** then the KeyInfo structure is appropriate for initializing a virtual\n    ** index to implement a DISTINCT test.\n    **\n    ** Space to hold the KeyInfo structure is obtain from malloc.  The calling\n    ** function is responsible for seeing that this structure is eventually\n    ** freed.  Add the KeyInfo structure to the P4 field of an opcode using\n    ** P4_KEYINFO_HANDOFF is the usual way of dealing with this.\n    */\n    static KeyInfo keyInfoFromExprList( Parse pParse, ExprList pList )\n    {\n      sqlite3 db = pParse.db;\n      int nExpr;\n      KeyInfo pInfo;\n      ExprList_item pItem;\n      int i;\n\n      nExpr = pList.nExpr;\n      pInfo = new KeyInfo();//sqlite3DbMallocZero(db, sizeof(*pInfo) + nExpr*(CollSeq*.Length+1) );\n      if ( pInfo != null )\n      {\n        pInfo.aSortOrder = new byte[nExpr];// pInfo.aColl[nExpr];\n        pInfo.aColl = new CollSeq[nExpr];\n        pInfo.nField = (u16)nExpr;\n        pInfo.enc = db.aDbStatic[0].pSchema.enc;// ENC(db);\n        pInfo.db = db;\n        for ( i = 0 ; i < nExpr ; i++ )\n        {//, pItem++){\n          pItem = pList.a[i];\n          CollSeq pColl;\n          pColl = sqlite3ExprCollSeq( pParse, pItem.pExpr );\n          if ( pColl == null )\n          {\n            pColl = db.pDfltColl;\n          }\n          pInfo.aColl[i] = pColl;\n          pInfo.aSortOrder[i] = (byte)pItem.sortOrder;\n        }\n      }\n      return pInfo;\n    }\n\n\n    /*\n    ** If the inner loop was generated using a non-null pOrderBy argument,\n    ** then the results were placed in a sorter.  After the loop is terminated\n    ** we need to run the sorter and output the results.  The following\n    ** routine generates the code needed to do that.\n    */\n    static void generateSortTail(\n    Parse pParse,     /* Parsing context */\n    Select p,         /* The SELECT statement */\n    Vdbe v,           /* Generate code into this VDBE */\n    int nColumn,      /* Number of columns of data */\n    SelectDest pDest  /* Write the sorted results here */\n    )\n    {\n      int addrBreak = sqlite3VdbeMakeLabel( v );    /* Jump here to exit loop */\n      int addrContinue = sqlite3VdbeMakeLabel( v ); /* Jump here for next cycle */\n      int addr;\n      int iTab;\n      int pseudoTab = 0;\n      ExprList pOrderBy = p.pOrderBy;\n\n      int eDest = pDest.eDest;\n      int iParm = pDest.iParm;\n\n      int regRow;\n      int regRowid;\n\n      iTab = pOrderBy.iECursor;\n      if ( eDest == SRT_Output || eDest == SRT_Coroutine )\n      {\n        pseudoTab = pParse.nTab++;\n        sqlite3VdbeAddOp3( v, OP_OpenPseudo, pseudoTab, eDest == SRT_Output ? 1 : 0, nColumn );\n      }\n      addr = 1 + sqlite3VdbeAddOp2( v, OP_Sort, iTab, addrBreak );\n      codeOffset( v, p, addrContinue );\n      regRow = sqlite3GetTempReg( pParse );\n      regRowid = sqlite3GetTempReg( pParse );\n      sqlite3VdbeAddOp3( v, OP_Column, iTab, pOrderBy.nExpr + 1, regRow );\n      switch ( eDest )\n      {\n        case SRT_Table:\n        case SRT_EphemTab:\n          {\n            testcase( eDest == SRT_Table );\n            testcase( eDest == SRT_EphemTab );\n            sqlite3VdbeAddOp2( v, OP_NewRowid, iParm, regRowid );\n            sqlite3VdbeAddOp3( v, OP_Insert, iParm, regRow, regRowid );\n            sqlite3VdbeChangeP5( v, OPFLAG_APPEND );\n            break;\n          }\n#if !SQLITE_OMIT_SUBQUERY\n        case SRT_Set:\n          {\n            Debug.Assert( nColumn == 1 );\n            sqlite3VdbeAddOp4( v, OP_MakeRecord, regRow, 1, regRowid, p.affinity, 1 );\n            sqlite3ExprCacheAffinityChange( pParse, regRow, 1 );\n            sqlite3VdbeAddOp2( v, OP_IdxInsert, iParm, regRowid );\n            break;\n          }\n        case SRT_Mem:\n          {\n            Debug.Assert( nColumn == 1 );\n            sqlite3ExprCodeMove( pParse, regRow, iParm, 1 );\n            /* The LIMIT clause will terminate the loop for us */\n            break;\n          }\n#endif\n        default:\n          {\n            int i;\n            Debug.Assert( eDest == SRT_Output || eDest == SRT_Coroutine );\n            testcase( eDest == SRT_Output );\n            testcase( eDest == SRT_Coroutine );\n            sqlite3VdbeAddOp2( v, OP_Integer, 1, regRowid );\n            sqlite3VdbeAddOp3( v, OP_Insert, pseudoTab, regRow, regRowid );\n            for ( i = 0 ; i < nColumn ; i++ )\n            {\n              Debug.Assert( regRow != pDest.iMem + i );\n              sqlite3VdbeAddOp3( v, OP_Column, pseudoTab, i, pDest.iMem + i );\n            }\n            if ( eDest == SRT_Output )\n            {\n              sqlite3VdbeAddOp2( v, OP_ResultRow, pDest.iMem, nColumn );\n              sqlite3ExprCacheAffinityChange( pParse, pDest.iMem, nColumn );\n            }\n            else\n            {\n              sqlite3VdbeAddOp1( v, OP_Yield, pDest.iParm );\n            }\n            break;\n          }\n      }\n      sqlite3ReleaseTempReg( pParse, regRow );\n      sqlite3ReleaseTempReg( pParse, regRowid );\n\n      /* LIMIT has been implemented by the pushOntoSorter() routine.\n      */\n      Debug.Assert( p.iLimit == 0 );\n\n      /* The bottom of the loop\n      */\n      sqlite3VdbeResolveLabel( v, addrContinue );\n      sqlite3VdbeAddOp2( v, OP_Next, iTab, addr );\n      sqlite3VdbeResolveLabel( v, addrBreak );\n      if ( eDest == SRT_Output || eDest == SRT_Coroutine )\n      {\n        sqlite3VdbeAddOp2( v, OP_Close, pseudoTab, 0 );\n      }\n\n    }\n\n    /*\n    ** Return a pointer to a string containing the \'declaration type\' of the\n    ** expression pExpr. The string may be treated as static by the caller.\n    **\n    ** The declaration type is the exact datatype definition extracted from the\n    ** original CREATE TABLE statement if the expression is a column. The\n    ** declaration type for a ROWID field is INTEGER. Exactly when an expression\n    ** is considered a column can be complex in the presence of subqueries. The\n    ** result-set expression in all of the following SELECT statements is\n    ** considered a column by this function.\n    **\n    **   SELECT col FROM tbl;\n    **   SELECT (SELECT col FROM tbl;\n    **   SELECT (SELECT col FROM tbl);\n    **   SELECT abc FROM (SELECT col AS abc FROM tbl);\n    **\n    ** The declaration type for any expression other than a column is NULL.\n    */\n    static string columnType(\n    NameContext pNC,\n    Expr pExpr,\n    ref string pzOriginDb,\n    ref string pzOriginTab,\n    ref string pzOriginCol\n    )\n    {\n      string zType = null;\n      string zOriginDb = null;\n      string zOriginTab = null;\n      string zOriginCol = null;\n      int j;\n      if ( NEVER( pExpr == null ) || pNC.pSrcList == null ) return null;\n\n      switch ( pExpr.op )\n      {\n        case TK_AGG_COLUMN:\n        case TK_COLUMN:\n          {\n            /* The expression is a column. Locate the table the column is being\n            ** extracted from in NameContext.pSrcList. This table may be real\n            ** database table or a subquery.\n            */\n            Table pTab = null;            /* Table structure column is extracted from */\n            Select pS = null;            /* Select the column is extracted from */\n            int iCol = pExpr.iColumn;  /* Index of column in pTab */\n            testcase( pExpr.op == TK_AGG_COLUMN );\n            testcase( pExpr.op == TK_COLUMN );\n            while ( pNC != null && pTab == null )\n            {\n              SrcList pTabList = pNC.pSrcList;\n              for ( j = 0 ; j < pTabList.nSrc && pTabList.a[j].iCursor != pExpr.iTable ; j++ ) ;\n              if ( j < pTabList.nSrc )\n              {\n                pTab = pTabList.a[j].pTab;\n                pS = pTabList.a[j].pSelect;\n              }\n              else\n              {\n                pNC = pNC.pNext;\n              }\n            }\n\n            if ( pTab == null )\n            {\n              /* FIX ME:\n              ** This can occurs if you have something like "SELECT new.x;" inside\n              ** a trigger.  In other words, if you reference the special "new"\n              ** table in the result set of a select.  We do not have a good way\n              ** to find the actual table type, so call it "TEXT".  This is really\n              ** something of a bug, but I do not know how to fix it.\n              **\n              ** This code does not produce the correct answer - it just prevents\n              ** a segfault.  See ticket #1229.\n              */\n              zType = "TEXT";\n              break;\n            }\n\n            Debug.Assert( pTab != null );\n            if ( pS != null )\n            {\n              /* The "table" is actually a sub-select or a view in the FROM clause\n              ** of the SELECT statement. Return the declaration type and origin\n              ** data for the result-set column of the sub-select.\n              */\n              if ( ALWAYS( iCol >= 0 && iCol < pS.pEList.nExpr ) )\n              {\n                /* If iCol is less than zero, then the expression requests the\n                ** rowid of the sub-select or view. This expression is legal (see\n                ** test case misc2.2.2) - it always evaluates to NULL.\n                */\n                NameContext sNC = new NameContext();\n                Expr p = pS.pEList.a[iCol].pExpr;\n                sNC.pSrcList = pS.pSrc;\n                sNC.pNext = null;\n                sNC.pParse = pNC.pParse;\n                zType = columnType( sNC, p, ref zOriginDb, ref zOriginTab, ref zOriginCol );\n              }\n            }\n            else if ( ALWAYS( pTab.pSchema ) )\n            {\n              /* A real table */\n              Debug.Assert( pS == null );\n              if ( iCol < 0 ) iCol = pTab.iPKey;\n              Debug.Assert( iCol == -1 || ( iCol >= 0 && iCol < pTab.nCol ) );\n              if ( iCol < 0 )\n              {\n                zType = "INTEGER";\n                zOriginCol = "rowid";\n              }\n              else\n              {\n                zType = pTab.aCol[iCol].zType;\n                zOriginCol = pTab.aCol[iCol].zName;\n              }\n              zOriginTab = pTab.zName;\n              if ( pNC.pParse != null )\n              {\n                int iDb = sqlite3SchemaToIndex( pNC.pParse.db, pTab.pSchema );\n                zOriginDb = pNC.pParse.db.aDb[iDb].zName;\n              }\n            }\n            break;\n          }\n#if !SQLITE_OMIT_SUBQUERY\n        case TK_SELECT:\n          {\n            /* The expression is a sub-select. Return the declaration type and\n            ** origin info for the single column in the result set of the SELECT\n            ** statement.\n            */\n            NameContext sNC = new NameContext();\n            Select pS = pExpr.x.pSelect;\n            Expr p = pS.pEList.a[0].pExpr;\n            Debug.Assert( ExprHasProperty( pExpr, EP_xIsSelect ) );\n            sNC.pSrcList = pS.pSrc;\n            sNC.pNext = pNC;\n            sNC.pParse = pNC.pParse;\n            zType = columnType( sNC, p, ref zOriginDb, ref zOriginTab, ref zOriginCol );\n            break;\n          }\n#endif\n      }\n\n      if ( pzOriginDb != null )\n      {\n        Debug.Assert( pzOriginTab != null && pzOriginCol != null );\n        pzOriginDb = zOriginDb;\n        pzOriginTab = zOriginTab;\n        pzOriginCol = zOriginCol;\n      }\n      return zType;\n    }\n\n    /*\n    ** Generate code that will tell the VDBE the declaration types of columns\n    ** in the result set.\n    */\n    static void generateColumnTypes(\n    Parse pParse,      /* Parser context */\n    SrcList pTabList,  /* List of tables */\n    ExprList pEList    /* Expressions defining the result set */\n    )\n    {\n#if !SQLITE_OMIT_DECLTYPE\n      Vdbe v = pParse.pVdbe;\n      int i;\n      NameContext sNC = new NameContext();\n      sNC.pSrcList = pTabList;\n      sNC.pParse = pParse;\n      for ( i = 0 ; i < pEList.nExpr ; i++ )\n      {\n        Expr p = pEList.a[i].pExpr;\n        string zType;\n#if SQLITE_ENABLE_COLUMN_METADATA\nconst string zOrigDb = 0;\nconst string zOrigTab = 0;\nconst string zOrigCol = 0;\nzType = columnType(&sNC, p, zOrigDb, zOrigTab, zOrigCol);\n\n/* The vdbe must make its own copy of the column-type and other\n** column specific strings, in case the schema is reset before this\n** virtual machine is deleted.\n*/\nsqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);\nsqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);\nsqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);\n#else\n        string sDummy = null;\n        zType = columnType( sNC, p, ref sDummy, ref sDummy, ref sDummy );\n#endif\n        sqlite3VdbeSetColName( v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT );\n      }\n#endif //* SQLITE_OMIT_DECLTYPE */\n    }\n\n    /*\n    ** Generate code that will tell the VDBE the names of columns\n    ** in the result set.  This information is used to provide the\n    ** azCol[] values in the callback.\n    */\n    static void generateColumnNames(\n    Parse pParse,      /* Parser context */\n    SrcList pTabList,  /* List of tables */\n    ExprList pEList    /* Expressions defining the result set */\n    )\n    {\n      Vdbe v = pParse.pVdbe;\n      int i, j;\n      sqlite3 db = pParse.db;\n      bool fullNames; bool shortNames;\n\n#if !SQLITE_OMIT_EXPLAIN\n      /* If this is an EXPLAIN, skip this step */\n      if ( pParse.explain != 0 )\n      {\n        return;\n      }\n#endif\n\n      if ( pParse.colNamesSet != 0 || NEVER( v == null ) /*|| db.mallocFailed != 0 */ ) return;\n      pParse.colNamesSet = 1;\n      fullNames = ( db.flags & SQLITE_FullColNames ) != 0;\n      shortNames = ( db.flags & SQLITE_ShortColNames ) != 0;\n      sqlite3VdbeSetNumCols( v, pEList.nExpr );\n      for ( i = 0 ; i < pEList.nExpr ; i++ )\n      {\n        Expr p;\n        p = pEList.a[i].pExpr;\n        if ( NEVER( p == null ) ) continue;\n        if ( pEList.a[i].zName != null )\n        {\n          string zName = pEList.a[i].zName;\n          sqlite3VdbeSetColName( v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT );\n        }\n        else if ( ( p.op == TK_COLUMN || p.op == TK_AGG_COLUMN ) && pTabList != null )\n        {\n          Table pTab;\n          string zCol;\n          int iCol = p.iColumn;\n          for ( j = 0 ; ALWAYS( j < pTabList.nSrc ) ; j++ )\n          {\n            if ( pTabList.a[j].iCursor == p.iTable ) break;\n          }\n          Debug.Assert( j < pTabList.nSrc );\n          pTab = pTabList.a[j].pTab;\n          if ( iCol < 0 ) iCol = pTab.iPKey;\n          Debug.Assert( iCol == -1 || ( iCol >= 0 && iCol < pTab.nCol ) );\n          if ( iCol < 0 )\n          {\n            zCol = "rowid";\n          }\n          else\n          {\n            zCol = pTab.aCol[iCol].zName;\n          }\n          if ( !shortNames && !fullNames )\n          {\n            sqlite3VdbeSetColName( v, i, COLNAME_NAME,\n            pEList.a[i].zSpan, SQLITE_DYNAMIC );//sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC);\n          }\n          else if ( fullNames )\n          {\n            string zName;\n            zName = sqlite3MPrintf( db, "%s.%s", pTab.zName, zCol );\n            sqlite3VdbeSetColName( v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC );\n          }\n          else\n          {\n            sqlite3VdbeSetColName( v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT );\n          }\n        }\n        else\n        {\n          sqlite3VdbeSetColName( v, i, COLNAME_NAME,\n              pEList.a[i].zSpan, SQLITE_DYNAMIC );//sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC);\n        }\n      }\n      generateColumnTypes( pParse, pTabList, pEList );\n    }\n\n#if !SQLITE_OMIT_COMPOUND_SELECT\n    /*\n** Name of the connection operator, used for error messages.\n*/\n    static string selectOpName( int id )\n    {\n      string z;\n      switch ( id )\n      {\n        case TK_ALL: z = "UNION ALL"; break;\n        case TK_INTERSECT: z = "INTERSECT"; break;\n        case TK_EXCEPT: z = "EXCEPT"; break;\n        default: z = "UNION"; break;\n      }\n      return z;\n    }\n#endif // * SQLITE_OMIT_COMPOUND_SELECT */\n\n    /*\n** Given a an expression list (which is really the list of expressions\n** that form the result set of a SELECT statement) compute appropriate\n** column names for a table that would hold the expression list.\n**\n** All column names will be unique.\n**\n** Only the column names are computed.  Column.zType, Column.zColl,\n** and other fields of Column are zeroed.\n**\n** Return SQLITE_OK on success.  If a memory allocation error occurs,\n** store NULL in paCol and 0 in pnCol and return SQLITE_NOMEM.\n*/\n    static int selectColumnsFromExprList(\n    Parse pParse,          /* Parsing context */\n    ExprList pEList,       /* Expr list from which to derive column names */\n    ref int pnCol,             /* Write the number of columns here */\n    ref Column[] paCol          /* Write the new column list here */\n    )\n    {\n      sqlite3 db = pParse.db;     /* Database connection */\n      int i, j;                   /* Loop counters */\n      int cnt;                    /* Index added to make the name unique */\n      Column[] aCol; Column pCol; /* For looping over result columns */\n      int nCol;                   /* Number of columns in the result set */\n      Expr p;                     /* Expression for a single result column */\n      string zName;               /* Column name */\n      int nName;                  /* Size of name in zName[] */\n\n\n      pnCol = nCol = pEList.nExpr;\n      aCol = paCol = new Column[nCol];//sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);\n      if ( aCol == null ) return SQLITE_NOMEM;\n      for ( i = 0 ; i < nCol ; i++ )//, pCol++)\n      {\n        if ( aCol[i] == null ) aCol[i] = new Column();\n        pCol = aCol[i];\n        /* Get an appropriate name for the column\n        */\n        p = pEList.a[i].pExpr;\n        Debug.Assert( p.pRight == null || ExprHasProperty( p.pRight, EP_IntValue )\n        || p.pRight.u.zToken == null || p.pRight.u.zToken.Length > 0 );\n        if ( pEList.a[i].zName != null && ( zName = pEList.a[i].zName ) != "" )\n        {\n          /* If the column contains an "AS <name>" phrase, use <name> as the name */\n          //zName = sqlite3DbStrDup(db, zName);\n        }\n        else\n        {\n          Expr pColExpr = p;      /* The expression that is the result column name */\n          Table pTab;             /* Table associated with this expression */\n          while ( pColExpr.op == TK_DOT ) pColExpr = pColExpr.pRight;\n          if ( pColExpr.op == TK_COLUMN && ALWAYS( pColExpr.pTab != null ) )\n          {\n            /* For columns use the column name name */\n            int iCol = pColExpr.iColumn;\n            pTab = pColExpr.pTab;\n            if ( iCol < 0 ) iCol = pTab.iPKey;\n            zName = sqlite3MPrintf( db, "%s",\n            iCol >= 0 ? pTab.aCol[iCol].zName : "rowid" );\n          }\n          else if ( pColExpr.op == TK_ID )\n          {\n            Debug.Assert( !ExprHasProperty( pColExpr, EP_IntValue ) );\n            zName = sqlite3MPrintf( db, "%s", pColExpr.u.zToken );\n          }\n          else\n          {\n            /* Use the original text of the column expression as its name */\n            zName = sqlite3MPrintf( db, "%s", pEList.a[i].zSpan );\n          }\n        }\n        //if ( db.mallocFailed != 0 )\n        //{\n        //  //sqlite3DbFree( db, zName );\n        //  break;\n        //}\n\n        /* Make sure the column name is unique.  If the name is not unique,\n        ** append a integer to the name so that it becomes unique.\n        */\n        nName = sqlite3Strlen30( zName );\n        for ( j = cnt = 0 ; j < i ; j++ )\n        {\n          if ( sqlite3StrICmp( aCol[j].zName, zName ) == 0 )\n          {\n            string zNewName;\n            //zName[nName] = 0;\n            zNewName = sqlite3MPrintf( db, "%s:%d", zName.Substring( 0, nName ), ++cnt );\n            //sqlite3DbFree(db, zName);\n            zName = zNewName;\n            j = -1;\n            if ( zName == "" ) break;\n          }\n        }\n        pCol.zName = zName;\n      }\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  for ( j = 0 ; j < i ; j++ )\n      //  {\n      //    //sqlite3DbFree( db, aCol[j].zName );\n      //  }\n      //  //sqlite3DbFree( db, aCol );\n      //  paCol = null;\n      //  pnCol = 0;\n      //  return SQLITE_NOMEM;\n      //}\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Add type and collation information to a column list based on\n    ** a SELECT statement.\n    **\n    ** The column list presumably came from selectColumnNamesFromExprList().\n    ** The column list has only names, not types or collations.  This\n    ** routine goes through and adds the types and collations.\n    **\n    ** This routine requires that all identifiers in the SELECT\n    ** statement be resolved.\n    */\n    static void selectAddColumnTypeAndCollation(\n    Parse pParse,         /* Parsing contexts */\n    int nCol,             /* Number of columns */\n    Column[] aCol,        /* List of columns */\n    Select pSelect        /* SELECT used to determine types and collations */\n    )\n    {\n      sqlite3 db = pParse.db;\n      NameContext sNC;\n      Column pCol;\n      CollSeq pColl;\n      int i;\n      Expr p;\n      ExprList_item[] a;\n\n      Debug.Assert( pSelect != null );\n      Debug.Assert( ( pSelect.selFlags & SF_Resolved ) != 0 );\n      Debug.Assert( nCol == pSelect.pEList.nExpr /*|| db.mallocFailed != 0 */ );\n//      if ( db.mallocFailed != 0 ) return;\n      sNC = new NameContext();// memset( &sNC, 0, sizeof( sNC ) );\n      sNC.pSrcList = pSelect.pSrc;\n      a = pSelect.pEList.a;\n      for ( i = 0 ; i < nCol ; i++ )//, pCol++ )\n      {\n        pCol = aCol[i];\n        p = a[i].pExpr;\n        string bDummy = null; pCol.zType = columnType( sNC, p, ref bDummy, ref bDummy, ref bDummy );// sqlite3DbStrDup( db, columnType( sNC, p, 0, 0, 0 ) );\n        pCol.affinity = sqlite3ExprAffinity( p );\n        if ( pCol.affinity == 0 ) pCol.affinity = SQLITE_AFF_NONE;\n        pColl = sqlite3ExprCollSeq( pParse, p );\n        if ( pColl != null )\n        {\n          pCol.zColl = pColl.zName;// sqlite3DbStrDup( db, pColl.zName );\n        }\n      }\n    }\n\n    /*\n    ** Given a SELECT statement, generate a Table structure that describes\n    ** the result set of that SELECT.\n    */\n    static Table sqlite3ResultSetOfSelect( Parse pParse, Select pSelect )\n    {\n      Table pTab;\n      sqlite3 db = pParse.db;\n      int savedFlags;\n\n      savedFlags = db.flags;\n      db.flags &= ~SQLITE_FullColNames;\n      db.flags |= SQLITE_ShortColNames;\n      sqlite3SelectPrep( pParse, pSelect, null );\n      if ( pParse.nErr != 0 ) return null;\n      while ( pSelect.pPrior != null ) pSelect = pSelect.pPrior;\n      db.flags = savedFlags;\n      pTab = new Table();// sqlite3DbMallocZero( db, sizeof( Table ) );\n      if ( pTab == null )\n      {\n        return null;\n      }\n      /* The sqlite3ResultSetOfSelect() is only used n contexts where lookaside\n      ** is disabled, so we might as well hard-code pTab->dbMem to NULL. */\n      Debug.Assert( db.lookaside.bEnabled == 0 );\n      pTab.dbMem = null;\n      pTab.nRef = 1;\n      pTab.zName = null;\n      selectColumnsFromExprList( pParse, pSelect.pEList, ref pTab.nCol, ref pTab.aCol );\n      selectAddColumnTypeAndCollation( pParse, pTab.nCol, pTab.aCol, pSelect );\n      pTab.iPKey = -1;\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  sqlite3DeleteTable( ref pTab );\n      //  return null;\n      //}\n      return pTab;\n    }\n\n    /*\n    ** Get a VDBE for the given parser context.  Create a new one if necessary.\n    ** If an error occurs, return NULL and leave a message in pParse.\n    */\n    static Vdbe sqlite3GetVdbe( Parse pParse )\n    {\n      Vdbe v = pParse.pVdbe;\n      if ( v == null )\n      {\n        v = pParse.pVdbe = sqlite3VdbeCreate( pParse.db );\n#if !SQLITE_OMIT_TRACE\n        if ( v != null )\n        {\n          sqlite3VdbeAddOp0( v, OP_Trace );\n        }\n#endif\n      }\n      return v;\n    }\n\n\n    /*\n    ** Compute the iLimit and iOffset fields of the SELECT based on the\n    ** pLimit and pOffset expressions.  pLimit and pOffset hold the expressions\n    ** that appear in the original SQL statement after the LIMIT and OFFSET\n    ** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset\n    ** are the integer memory register numbers for counters used to compute\n    ** the limit and offset.  If there is no limit and/or offset, then\n    ** iLimit and iOffset are negative.\n    **\n    ** This routine changes the values of iLimit and iOffset only if\n    ** a limit or offset is defined by pLimit and pOffset.  iLimit and\n    ** iOffset should have been preset to appropriate default values\n    ** (usually but not always -1) prior to calling this routine.\n    ** Only if pLimit!=0 or pOffset!=0 do the limit registers get\n    ** redefined.  The UNION ALL operator uses this property to force\n    ** the reuse of the same limit and offset registers across multiple\n    ** SELECT statements.\n    */\n    static void computeLimitRegisters( Parse pParse, Select p, int iBreak )\n    {\n      Vdbe v = null;\n      int iLimit = 0;\n      int iOffset;\n      int addr1;\n      if ( p.iLimit != 0 ) return;\n\n      /*\n      ** "LIMIT -1" always shows all rows.  There is some\n      ** contraversy about what the correct behavior should be.\n      ** The current implementation interprets "LIMIT 0" to mean\n      ** no rows.\n      */\n      sqlite3ExprCacheClear( pParse );\n      Debug.Assert( p.pOffset == null || p.pLimit != null );\n      if ( p.pLimit != null )\n      {\n        p.iLimit = iLimit = ++pParse.nMem;\n        v = sqlite3GetVdbe( pParse );\n        if ( NEVER( v == null ) ) return;  /* VDBE should have already been allocated */\n        sqlite3ExprCode( pParse, p.pLimit, iLimit );\n        sqlite3VdbeAddOp1( v, OP_MustBeInt, iLimit );\n#if SQLITE_DEBUG\n        VdbeComment( v, "LIMIT counter" );\n#endif\n        sqlite3VdbeAddOp2( v, OP_IfZero, iLimit, iBreak );\n        if ( p.pOffset != null )\n        {\n          p.iOffset = iOffset = ++pParse.nMem;\n          pParse.nMem++;   /* Allocate an extra register for limit+offset */\n          sqlite3ExprCode( pParse, p.pOffset, iOffset );\n          sqlite3VdbeAddOp1( v, OP_MustBeInt, iOffset );\n#if SQLITE_DEBUG\n          VdbeComment( v, "OFFSET counter" );\n#endif\n          addr1 = sqlite3VdbeAddOp1( v, OP_IfPos, iOffset );\n          sqlite3VdbeAddOp2( v, OP_Integer, 0, iOffset );\n          sqlite3VdbeJumpHere( v, addr1 );\n          sqlite3VdbeAddOp3( v, OP_Add, iLimit, iOffset, iOffset + 1 );\n#if SQLITE_DEBUG\n          VdbeComment( v, "LIMIT+OFFSET" );\n#endif\n          addr1 = sqlite3VdbeAddOp1( v, OP_IfPos, iLimit );\n          sqlite3VdbeAddOp2( v, OP_Integer, -1, iOffset + 1 );\n          sqlite3VdbeJumpHere( v, addr1 );\n        }\n      }\n    }\n\n#if !SQLITE_OMIT_COMPOUND_SELECT\n    /*\n** Return the appropriate collating sequence for the iCol-th column of\n** the result set for the compound-select statement "p".  Return NULL if\n** the column has no default collating sequence.\n**\n** The collating sequence for the compound select is taken from the\n** left-most term of the select that has a collating sequence.\n*/\n    static CollSeq multiSelectCollSeq( Parse pParse, Select p, int iCol )\n    {\n      CollSeq pRet;\n      if ( p.pPrior != null )\n      {\n        pRet = multiSelectCollSeq( pParse, p.pPrior, iCol );\n      }\n      else\n      {\n        pRet = null;\n      }\n      Debug.Assert( iCol >= 0 );\n      if ( pRet == null && iCol < p.pEList.nExpr )\n      {\n        pRet = sqlite3ExprCollSeq( pParse, p.pEList.a[iCol].pExpr );\n      }\n      return pRet;\n    }\n#endif // * SQLITE_OMIT_COMPOUND_SELECT */\n\n    /* Forward reference */\n    //static int multiSelectOrderBy(\n    //  Parse* pParse,        /* Parsing context */\n    //  Select* p,            /* The right-most of SELECTs to be coded */\n    //  SelectDest* pDest     /* What to do with query results */\n    //);\n\n#if !SQLITE_OMIT_COMPOUND_SELECT\n    /*\n** This routine is called to process a compound query form from\n** two or more separate queries using UNION, UNION ALL, EXCEPT, or\n** INTERSECT\n**\n** "p" points to the right-most of the two queries.  the query on the\n** left is p.pPrior.  The left query could also be a compound query\n** in which case this routine will be called recursively.\n**\n** The results of the total query are to be written into a destination\n** of type eDest with parameter iParm.\n**\n** Example 1:  Consider a three-way compound SQL statement.\n**\n**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3\n**\n** This statement is parsed up as follows:\n**\n**     SELECT c FROM t3\n**      |\n**      `----.  SELECT b FROM t2\n**                |\n**                `-----.  SELECT a FROM t1\n**\n** The arrows in the diagram above represent the Select.pPrior pointer.\n** So if this routine is called with p equal to the t3 query, then\n** pPrior will be the t2 query.  p.op will be TK_UNION in this case.\n**\n** Notice that because of the way SQLite parses compound SELECTs, the\n** individual selects always group from left to right.\n*/\n    static int multiSelect(\n    Parse pParse,             /* Parsing context */\n    Select p,                 /* The right-most of SELECTs to be coded */\n    SelectDest pDest          /* What to do with query results */\n    )\n    {\n      int rc = SQLITE_OK;       /* Success code from a subroutine */\n      Select pPrior;            /* Another SELECT immediately to our left */\n      Vdbe v;                   /* Generate code to this VDBE */\n      SelectDest dest = new SelectDest(); /* Alternative data destination */\n      Select pDelete = null;    /* Chain of simple selects to delete */\n      sqlite3 db;               /* Database connection */\n\n      /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n      ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n      */\n      Debug.Assert( p != null && p.pPrior != null );  /* Calling function guarantees this much */\n      db = pParse.db;\n      pPrior = p.pPrior;\n      Debug.Assert( pPrior.pRightmost != pPrior );\n      Debug.Assert( pPrior.pRightmost == p.pRightmost );\n      dest = pDest;\n      if ( pPrior.pOrderBy != null )\n      {\n        sqlite3ErrorMsg( pParse, "ORDER BY clause should come after %s not before",\n        selectOpName( p.op ) );\n        rc = 1;\n        goto multi_select_end;\n      }\n      if ( pPrior.pLimit != null )\n      {\n        sqlite3ErrorMsg( pParse, "LIMIT clause should come after %s not before",\n        selectOpName( p.op ) );\n        rc = 1;\n        goto multi_select_end;\n      }\n\n      v = sqlite3GetVdbe( pParse );\n      Debug.Assert( v != null );  /* The VDBE already created by calling function */\n\n      /* Create the destination temporary table if necessary\n      */\n      if ( dest.eDest == SRT_EphemTab )\n      {\n        Debug.Assert( p.pEList != null );\n        sqlite3VdbeAddOp2( v, OP_OpenEphemeral, dest.iParm, p.pEList.nExpr );\n        dest.eDest = SRT_Table;\n      }\n\n      /* Make sure all SELECTs in the statement have the same number of elements\n      ** in their result sets.\n      */\n      Debug.Assert( p.pEList != null && pPrior.pEList != null );\n      if ( p.pEList.nExpr != pPrior.pEList.nExpr )\n      {\n        sqlite3ErrorMsg( pParse, "SELECTs to the left and right of %s" +\n        " do not have the same number of result columns", selectOpName( p.op ) );\n        rc = 1;\n        goto multi_select_end;\n      }\n\n      /* Compound SELECTs that have an ORDER BY clause are handled separately.\n      */\n      if ( p.pOrderBy != null )\n      {\n        return multiSelectOrderBy( pParse, p, pDest );\n      }\n\n      /* Generate code for the left and right SELECT statements.\n      */\n      switch ( p.op )\n      {\n        case TK_ALL:\n          {\n            int addr = 0;\n            Debug.Assert( pPrior.pLimit == null );\n            pPrior.pLimit = p.pLimit;\n            pPrior.pOffset = p.pOffset;\n            rc = sqlite3Select( pParse, pPrior, ref dest );\n            p.pLimit = null;\n            p.pOffset = null;\n            if ( rc != 0 )\n            {\n              goto multi_select_end;\n            }\n            p.pPrior = null;\n            p.iLimit = pPrior.iLimit;\n            p.iOffset = pPrior.iOffset;\n            if ( p.iLimit != 0 )\n            {\n              addr = sqlite3VdbeAddOp1( v, OP_IfZero, p.iLimit );\n#if SQLITE_DEBUG\n              VdbeComment( v, "Jump ahead if LIMIT reached" );\n#endif\n            }\n            rc = sqlite3Select( pParse, p, ref dest );\n            testcase( rc != SQLITE_OK );\n            pDelete = p.pPrior;\n            p.pPrior = pPrior;\n            if ( addr != 0 )\n            {\n              sqlite3VdbeJumpHere( v, addr );\n            }\n            break;\n          }\n        case TK_EXCEPT:\n        case TK_UNION:\n          {\n            int unionTab;    /* VdbeCursor number of the temporary table holding result */\n            u8 op = 0;      /* One of the SRT_ operations to apply to self */\n            int priorOp;     /* The SRT_ operation to apply to prior selects */\n            Expr pLimit, pOffset; /* Saved values of p.nLimit and p.nOffset */\n            int addr;\n            SelectDest uniondest = new SelectDest();\n\n            testcase( p.op == TK_EXCEPT );\n            testcase( p.op == TK_UNION );\n            priorOp = SRT_Union;\n            if ( dest.eDest == priorOp && ALWAYS( null == p.pLimit && null == p.pOffset ) )\n            {\n              /* We can reuse a temporary table generated by a SELECT to our\n              ** right.\n              */\n              Debug.Assert( p.pRightmost != p );  /* Can only happen for leftward elements\n                 ** of a 3-way or more compound */\n              Debug.Assert( p.pLimit == null );      /* Not allowed on leftward elements */\n              Debug.Assert( p.pOffset == null );     /* Not allowed on leftward elements */\n              unionTab = dest.iParm;\n            }\n            else\n            {\n              /* We will need to create our own temporary table to hold the\n              ** intermediate results.\n              */\n              unionTab = pParse.nTab++;\n              Debug.Assert( p.pOrderBy == null );\n              addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, unionTab, 0 );\n              Debug.Assert( p.addrOpenEphm[0] == -1 );\n              p.addrOpenEphm[0] = addr;\n              p.pRightmost.selFlags |= SF_UsesEphemeral;\n              Debug.Assert( p.pEList != null );\n            }\n\n            /* Code the SELECT statements to our left\n            */\n            Debug.Assert( pPrior.pOrderBy == null );\n            sqlite3SelectDestInit( uniondest, priorOp, unionTab );\n            rc = sqlite3Select( pParse, pPrior, ref uniondest );\n            if ( rc != 0 )\n            {\n              goto multi_select_end;\n            }\n\n            /* Code the current SELECT statement\n            */\n            if ( p.op == TK_EXCEPT )\n            {\n              op = SRT_Except;\n            }\n            else\n            {\n              Debug.Assert( p.op == TK_UNION );\n              op = SRT_Union;\n            }\n            p.pPrior = null;\n            pLimit = p.pLimit;\n            p.pLimit = null;\n            pOffset = p.pOffset;\n            p.pOffset = null;\n            uniondest.eDest = op;\n            rc = sqlite3Select( pParse, p, ref  uniondest );\n            testcase( rc != SQLITE_OK );\n            /* Query flattening in sqlite3Select() might refill p.pOrderBy.\n            ** Be sure to delete p.pOrderBy, therefore, to avoid a memory leak. */\n            sqlite3ExprListDelete( db, ref p.pOrderBy );\n            pDelete = p.pPrior;\n            p.pPrior = pPrior;\n            p.pOrderBy = null;\n            sqlite3ExprDelete( db, ref p.pLimit );\n            p.pLimit = pLimit;\n            p.pOffset = pOffset;\n            p.iLimit = 0;\n            p.iOffset = 0;\n\n            /* Convert the data in the temporary table into whatever form\n            ** it is that we currently need.\n            */\n            Debug.Assert( unionTab == dest.iParm || dest.eDest != priorOp );\n            if ( dest.eDest != priorOp )\n            {\n              int iCont, iBreak, iStart;\n              Debug.Assert( p.pEList != null );\n              if ( dest.eDest == SRT_Output )\n              {\n                Select pFirst = p;\n                while ( pFirst.pPrior != null ) pFirst = pFirst.pPrior;\n                generateColumnNames( pParse, null, pFirst.pEList );\n              }\n              iBreak = sqlite3VdbeMakeLabel( v );\n              iCont = sqlite3VdbeMakeLabel( v );\n              computeLimitRegisters( pParse, p, iBreak );\n              sqlite3VdbeAddOp2( v, OP_Rewind, unionTab, iBreak );\n              iStart = sqlite3VdbeCurrentAddr( v );\n              selectInnerLoop( pParse, p, p.pEList, unionTab, p.pEList.nExpr,\n              null, -1, dest, iCont, iBreak );\n              sqlite3VdbeResolveLabel( v, iCont );\n              sqlite3VdbeAddOp2( v, OP_Next, unionTab, iStart );\n              sqlite3VdbeResolveLabel( v, iBreak );\n              sqlite3VdbeAddOp2( v, OP_Close, unionTab, 0 );\n            }\n            break;\n          }\n        default: Debug.Assert( p.op == TK_INTERSECT );\n          {\n            int tab1, tab2;\n            int iCont, iBreak, iStart;\n            Expr pLimit, pOffset;\n            int addr;\n            SelectDest intersectdest = new SelectDest();\n            int r1;\n\n            /* INTERSECT is different from the others since it requires\n            ** two temporary tables.  Hence it has its own case.  Begin\n            ** by allocating the tables we will need.\n            */\n            tab1 = pParse.nTab++;\n            tab2 = pParse.nTab++;\n            Debug.Assert( p.pOrderBy == null );\n\n            addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, tab1, 0 );\n            Debug.Assert( p.addrOpenEphm[0] == -1 );\n            p.addrOpenEphm[0] = addr;\n            p.pRightmost.selFlags |= SF_UsesEphemeral;\n            Debug.Assert( p.pEList != null );\n\n            /* Code the SELECTs to our left into temporary table "tab1".\n            */\n            sqlite3SelectDestInit( intersectdest, SRT_Union, tab1 );\n            rc = sqlite3Select( pParse, pPrior, ref intersectdest );\n            if ( rc != 0 )\n            {\n              goto multi_select_end;\n            }\n\n            /* Code the current SELECT into temporary table "tab2"\n            */\n            addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, tab2, 0 );\n            Debug.Assert( p.addrOpenEphm[1] == -1 );\n            p.addrOpenEphm[1] = addr;\n            p.pPrior = null;\n            pLimit = p.pLimit;\n            p.pLimit = null;\n            pOffset = p.pOffset;\n            p.pOffset = null;\n            intersectdest.iParm = tab2;\n            rc = sqlite3Select( pParse, p, ref intersectdest );\n            testcase( rc != SQLITE_OK );\n            p.pPrior = pPrior;\n            sqlite3ExprDelete( db, ref p.pLimit );\n            p.pLimit = pLimit;\n            p.pOffset = pOffset;\n\n            /* Generate code to take the intersection of the two temporary\n            ** tables.\n            */\n            Debug.Assert( p.pEList != null );\n            if ( dest.eDest == SRT_Output )\n            {\n              Select pFirst = p;\n              while ( pFirst.pPrior != null ) pFirst = pFirst.pPrior;\n              generateColumnNames( pParse, null, pFirst.pEList );\n            }\n            iBreak = sqlite3VdbeMakeLabel( v );\n            iCont = sqlite3VdbeMakeLabel( v );\n            computeLimitRegisters( pParse, p, iBreak );\n            sqlite3VdbeAddOp2( v, OP_Rewind, tab1, iBreak );\n            r1 = sqlite3GetTempReg( pParse );\n            iStart = sqlite3VdbeAddOp2( v, OP_RowKey, tab1, r1 );\n            sqlite3VdbeAddOp3( v, OP_NotFound, tab2, iCont, r1 );\n            sqlite3ReleaseTempReg( pParse, r1 );\n            selectInnerLoop( pParse, p, p.pEList, tab1, p.pEList.nExpr,\n            null, -1, dest, iCont, iBreak );\n            sqlite3VdbeResolveLabel( v, iCont );\n            sqlite3VdbeAddOp2( v, OP_Next, tab1, iStart );\n            sqlite3VdbeResolveLabel( v, iBreak );\n            sqlite3VdbeAddOp2( v, OP_Close, tab2, 0 );\n            sqlite3VdbeAddOp2( v, OP_Close, tab1, 0 );\n            break;\n          }\n      }\n\n\n      /* Compute collating sequences used by\n      ** temporary tables needed to implement the compound select.\n      ** Attach the KeyInfo structure to all temporary tables.\n      **\n      ** This section is run by the right-most SELECT statement only.\n      ** SELECT statements to the left always skip this part.  The right-most\n      ** SELECT might also skip this part if it has no ORDER BY clause and\n      ** no temp tables are required.\n      */\n      if ( ( p.selFlags & SF_UsesEphemeral ) != 0 )\n      {\n        int i;                        /* Loop counter */\n        KeyInfo pKeyInfo;             /* Collating sequence for the result set */\n        Select pLoop;                 /* For looping through SELECT statements */\n        CollSeq apColl;               /* For looping through pKeyInfo.aColl[] */\n        int nCol;                     /* Number of columns in result set */\n\n        Debug.Assert( p.pRightmost == p );\n        nCol = p.pEList.nExpr;\n        pKeyInfo = new KeyInfo();           //sqlite3DbMallocZero(db,\n        pKeyInfo.aColl = new CollSeq[nCol]; //sizeof(*pKeyInfo)+nCol*(CollSeq*.Length + 1));\n        if ( pKeyInfo == null )\n        {\n          rc = SQLITE_NOMEM;\n          goto multi_select_end;\n        }\n\n        pKeyInfo.enc = db.aDbStatic[0].pSchema.enc;// ENC( pParse.db );\n        pKeyInfo.nField = (u16)nCol;\n\n        for ( i = 0 ; i < nCol ; i++ )\n        {//, apColl++){\n          apColl = multiSelectCollSeq( pParse, p, i );\n          if ( null == apColl )\n          {\n            apColl = db.pDfltColl;\n          }\n          pKeyInfo.aColl[i] = apColl;\n        }\n\n        for ( pLoop = p ; pLoop != null ; pLoop = pLoop.pPrior )\n        {\n          for ( i = 0 ; i < 2 ; i++ )\n          {\n            int addr = pLoop.addrOpenEphm[i];\n            if ( addr < 0 )\n            {\n              /* If [0] is unused then [1] is also unused.  So we can\n              ** always safely abort as soon as the first unused slot is found */\n              Debug.Assert( pLoop.addrOpenEphm[1] < 0 );\n              break;\n            }\n            sqlite3VdbeChangeP2( v, addr, nCol );\n            sqlite3VdbeChangeP4( v, addr, pKeyInfo, P4_KEYINFO );\n            pLoop.addrOpenEphm[i] = -1;\n          }\n        }\n        //sqlite3DbFree( db, ref pKeyInfo );\n      }\n\nmulti_select_end:\n      pDest.iMem = dest.iMem;\n      pDest.nMem = dest.nMem;\n      sqlite3SelectDelete( db, ref pDelete );\n      return rc;\n    }\n#endif // * SQLITE_OMIT_COMPOUND_SELECT */\n\n    /*\n** Code an output subroutine for a coroutine implementation of a\n** SELECT statment.\n**\n** The data to be output is contained in pIn.iMem.  There are\n** pIn.nMem columns to be output.  pDest is where the output should\n** be sent.\n**\n** regReturn is the number of the register holding the subroutine\n** return address.\n**\n** If regPrev>0 then it is a the first register in a vector that\n** records the previous output.  mem[regPrev] is a flag that is false\n** if there has been no previous output.  If regPrev>0 then code is\n** generated to suppress duplicates.  pKeyInfo is used for comparing\n** keys.\n**\n** If the LIMIT found in p.iLimit is reached, jump immediately to\n** iBreak.\n*/\n    static int generateOutputSubroutine(\n    Parse pParse,          /* Parsing context */\n    Select p,              /* The SELECT statement */\n    SelectDest pIn,        /* Coroutine supplying data */\n    SelectDest pDest,      /* Where to send the data */\n    int regReturn,         /* The return address register */\n    int regPrev,           /* Previous result register.  No uniqueness if 0 */\n    KeyInfo pKeyInfo,      /* For comparing with previous entry */\n    int p4type,            /* The p4 type for pKeyInfo */\n    int iBreak             /* Jump here if we hit the LIMIT */\n    )\n    {\n      Vdbe v = pParse.pVdbe;\n      int iContinue;\n      int addr;\n\n      addr = sqlite3VdbeCurrentAddr( v );\n      iContinue = sqlite3VdbeMakeLabel( v );\n\n      /* Suppress duplicates for UNION, EXCEPT, and INTERSECT\n      */\n      if ( regPrev != 0 )\n      {\n        int j1, j2;\n        j1 = sqlite3VdbeAddOp1( v, OP_IfNot, regPrev );\n        j2 = sqlite3VdbeAddOp4( v, OP_Compare, pIn.iMem, regPrev + 1, pIn.nMem,\n        pKeyInfo, p4type );\n        sqlite3VdbeAddOp3( v, OP_Jump, j2 + 2, iContinue, j2 + 2 );\n        sqlite3VdbeJumpHere( v, j1 );\n        sqlite3ExprCodeCopy( pParse, pIn.iMem, regPrev + 1, pIn.nMem );\n        sqlite3VdbeAddOp2( v, OP_Integer, 1, regPrev );\n      }\n      //if ( pParse.db.mallocFailed != 0 ) return 0;\n\n      /* Suppress the the first OFFSET entries if there is an OFFSET clause\n      */\n      codeOffset( v, p, iContinue );\n\n      switch ( pDest.eDest )\n      {\n        /* Store the result as data using a unique key.\n        */\n        case SRT_Table:\n        case SRT_EphemTab:\n          {\n            int r1 = sqlite3GetTempReg( pParse );\n            int r2 = sqlite3GetTempReg( pParse );\n            testcase( pDest.eDest == SRT_Table );\n            testcase( pDest.eDest == SRT_EphemTab );\n            sqlite3VdbeAddOp3( v, OP_MakeRecord, pIn.iMem, pIn.nMem, r1 );\n            sqlite3VdbeAddOp2( v, OP_NewRowid, pDest.iParm, r2 );\n            sqlite3VdbeAddOp3( v, OP_Insert, pDest.iParm, r1, r2 );\n            sqlite3VdbeChangeP5( v, OPFLAG_APPEND );\n            sqlite3ReleaseTempReg( pParse, r2 );\n            sqlite3ReleaseTempReg( pParse, r1 );\n            break;\n          }\n\n#if !SQLITE_OMIT_SUBQUERY\n        /* If we are creating a set for an "expr IN (SELECT ...)" construct,\n** then there should be a single item on the stack.  Write this\n** item into the set table with bogus data.\n*/\n        case SRT_Set:\n          {\n            int r1;\n            Debug.Assert( pIn.nMem == 1 );\n            p.affinity =\n            sqlite3CompareAffinity( p.pEList.a[0].pExpr, pDest.affinity );\n            r1 = sqlite3GetTempReg( pParse );\n            sqlite3VdbeAddOp4( v, OP_MakeRecord, pIn.iMem, 1, r1, p.affinity, 1 );\n            sqlite3ExprCacheAffinityChange( pParse, pIn.iMem, 1 );\n            sqlite3VdbeAddOp2( v, OP_IdxInsert, pDest.iParm, r1 );\n            sqlite3ReleaseTempReg( pParse, r1 );\n            break;\n          }\n\n#if FALSE  //* Never occurs on an ORDER BY query */\n/* If any row exist in the result set, record that fact and abort.\n*/\ncase SRT_Exists: {\nsqlite3VdbeAddOp2(v, OP_Integer, 1, pDest.iParm);\n/* The LIMIT clause will terminate the loop for us */\nbreak;\n}\n#endif\n\n        /* If this is a scalar select that is part of an expression, then\n** store the results in the appropriate memory cell and break out\n** of the scan loop.\n*/\n        case SRT_Mem:\n          {\n            Debug.Assert( pIn.nMem == 1 );\n            sqlite3ExprCodeMove( pParse, pIn.iMem, pDest.iParm, 1 );\n            /* The LIMIT clause will jump out of the loop for us */\n            break;\n          }\n#endif //* #if !SQLITE_OMIT_SUBQUERY */\n\n        /* The results are stored in a sequence of registers\n** starting at pDest.iMem.  Then the co-routine yields.\n*/\n        case SRT_Coroutine:\n          {\n            if ( pDest.iMem == 0 )\n            {\n              pDest.iMem = sqlite3GetTempRange( pParse, pIn.nMem );\n              pDest.nMem = pIn.nMem;\n            }\n            sqlite3ExprCodeMove( pParse, pIn.iMem, pDest.iMem, pDest.nMem );\n            sqlite3VdbeAddOp1( v, OP_Yield, pDest.iParm );\n            break;\n          }\n\n        /* If none of the above, then the result destination must be\n        ** SRT_Output.  This routine is never called with any other\n        ** destination other than the ones handled above or SRT_Output.\n        **\n        ** For SRT_Output, results are stored in a sequence of registers.\n        ** Then the OP_ResultRow opcode is used to cause sqlite3_step() to\n        ** return the next row of result.\n        */\n        default:\n          {\n            Debug.Assert( pDest.eDest == SRT_Output );\n            sqlite3VdbeAddOp2( v, OP_ResultRow, pIn.iMem, pIn.nMem );\n            sqlite3ExprCacheAffinityChange( pParse, pIn.iMem, pIn.nMem );\n            break;\n          }\n      }\n\n      /* Jump to the end of the loop if the LIMIT is reached.\n      */\n      if ( p.iLimit != 0 )\n      {\n        sqlite3VdbeAddOp2( v, OP_AddImm, p.iLimit, -1 );\n        sqlite3VdbeAddOp2( v, OP_IfZero, p.iLimit, iBreak );\n      }\n\n      /* Generate the subroutine return\n      */\n      sqlite3VdbeResolveLabel( v, iContinue );\n      sqlite3VdbeAddOp1( v, OP_Return, regReturn );\n\n      return addr;\n    }\n\n    /*\n    ** Alternative compound select code generator for cases when there\n    ** is an ORDER BY clause.\n    **\n    ** We assume a query of the following form:\n    **\n    **      <selectA>  <operator>  <selectB>  ORDER BY <orderbylist>\n    **\n    ** <operator> is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea\n    ** is to code both <selectA> and <selectB> with the ORDER BY clause as\n    ** co-routines.  Then run the co-routines in parallel and merge the results\n    ** into the output.  In addition to the two coroutines (called selectA and\n    ** selectB) there are 7 subroutines:\n    **\n    **    outA:    Move the output of the selectA coroutine into the output\n    **             of the compound query.\n    **\n    **    outB:    Move the output of the selectB coroutine into the output\n    **             of the compound query.  (Only generated for UNION and\n    **             UNION ALL.  EXCEPT and INSERTSECT never output a row that\n    **             appears only in B.)\n    **\n    **    AltB:    Called when there is data from both coroutines and A<B.\n    **\n    **    AeqB:    Called when there is data from both coroutines and A==B.\n    **\n    **    AgtB:    Called when there is data from both coroutines and A>B.\n    **\n    **    EofA:    Called when data is exhausted from selectA.\n    **\n    **    EofB:    Called when data is exhausted from selectB.\n    **\n    ** The implementation of the latter five subroutines depend on which\n    ** <operator> is used:\n    **\n    **\n    **             UNION ALL         UNION            EXCEPT          INTERSECT\n    **          -------------  -----------------  --------------  -----------------\n    **   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA\n    **\n    **   AeqB:   outA, nextA         nextA             nextA         outA, nextA\n    **\n    **   AgtB:   outB, nextB      outB, nextB          nextB            nextB\n    **\n    **   EofA:   outB, nextB      outB, nextB          halt             halt\n    **\n    **   EofB:   outA, nextA      outA, nextA       outA, nextA         halt\n    **\n    ** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA\n    ** causes an immediate jump to EofA and an EOF on B following nextB causes\n    ** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or\n    ** following nextX causes a jump to the end of the select processing.\n    **\n    ** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled\n    ** within the output subroutine.  The regPrev register set holds the previously\n    ** output value.  A comparison is made against this value and the output\n    ** is skipped if the next results would be the same as the previous.\n    **\n    ** The implementation plan is to implement the two coroutines and seven\n    ** subroutines first, then put the control logic at the bottom.  Like this:\n    **\n    **          goto Init\n    **     coA: coroutine for left query (A)\n    **     coB: coroutine for right query (B)\n    **    outA: output one row of A\n    **    outB: output one row of B (UNION and UNION ALL only)\n    **    EofA: ...\n    **    EofB: ...\n    **    AltB: ...\n    **    AeqB: ...\n    **    AgtB: ...\n    **    Init: initialize coroutine registers\n    **          yield coA\n    **          if eof(A) goto EofA\n    **          yield coB\n    **          if eof(B) goto EofB\n    **    Cmpr: Compare A, B\n    **          Jump AltB, AeqB, AgtB\n    **     End: ...\n    **\n    ** We call AltB, AeqB, AgtB, EofA, and EofB "subroutines" but they are not\n    ** actually called using Gosub and they do not Return.  EofA and EofB loop\n    ** until all data is exhausted then jump to the "end" labe.  AltB, AeqB,\n    ** and AgtB jump to either L2 or to one of EofA or EofB.\n    */\n#if !SQLITE_OMIT_COMPOUND_SELECT\n    static int multiSelectOrderBy(\n    Parse pParse,         /* Parsing context */\n    Select p,             /* The right-most of SELECTs to be coded */\n    SelectDest pDest      /* What to do with query results */\n    )\n    {\n      int i, j;             /* Loop counters */\n      Select pPrior;        /* Another SELECT immediately to our left */\n      Vdbe v;               /* Generate code to this VDBE */\n      SelectDest destA = new SelectDest();     /* Destination for coroutine A */\n      SelectDest destB = new SelectDest();     /* Destination for coroutine B */\n      int regAddrA;         /* Address register for select-A coroutine */\n      int regEofA;          /* Flag to indicate when select-A is complete */\n      int regAddrB;         /* Address register for select-B coroutine */\n      int regEofB;          /* Flag to indicate when select-B is complete */\n      int addrSelectA;      /* Address of the select-A coroutine */\n      int addrSelectB;      /* Address of the select-B coroutine */\n      int regOutA;          /* Address register for the output-A subroutine */\n      int regOutB;          /* Address register for the output-B subroutine */\n      int addrOutA;         /* Address of the output-A subroutine */\n      int addrOutB = 0;     /* Address of the output-B subroutine */\n      int addrEofA;         /* Address of the select-A-exhausted subroutine */\n      int addrEofB;         /* Address of the select-B-exhausted subroutine */\n      int addrAltB;         /* Address of the A<B subroutine */\n      int addrAeqB;         /* Address of the A==B subroutine */\n      int addrAgtB;         /* Address of the A>B subroutine */\n      int regLimitA;        /* Limit register for select-A */\n      int regLimitB;        /* Limit register for select-A */\n      int regPrev;          /* A range of registers to hold previous output */\n      int savedLimit;       /* Saved value of p.iLimit */\n      int savedOffset;      /* Saved value of p.iOffset */\n      int labelCmpr;        /* Label for the start of the merge algorithm */\n      int labelEnd;         /* Label for the end of the overall SELECT stmt */\n      int j1;               /* Jump instructions that get retargetted */\n      int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */\n      KeyInfo pKeyDup = null;      /* Comparison information for duplicate removal */\n      KeyInfo pKeyMerge;    /* Comparison information for merging rows */\n      sqlite3 db;           /* Database connection */\n      ExprList pOrderBy;    /* The ORDER BY clause */\n      int nOrderBy;         /* Number of terms in the ORDER BY clause */\n      int[] aPermute;       /* Mapping from ORDER BY terms to result set columns */\n\n      Debug.Assert( p.pOrderBy != null );\n      Debug.Assert( pKeyDup == null ); /* "Managed" code needs this.  Ticket #3382. */\n      db = pParse.db;\n      v = pParse.pVdbe;\n      Debug.Assert( v != null );       /* Already thrown the error if VDBE alloc failed */\n      labelEnd = sqlite3VdbeMakeLabel( v );\n      labelCmpr = sqlite3VdbeMakeLabel( v );\n\n\n      /* Patch up the ORDER BY clause\n      */\n      op = p.op;\n      pPrior = p.pPrior;\n      Debug.Assert( pPrior.pOrderBy == null );\n      pOrderBy = p.pOrderBy;\n      Debug.Assert( pOrderBy != null );\n      nOrderBy = pOrderBy.nExpr;\n\n      /* For operators other than UNION ALL we have to make sure that\n      ** the ORDER BY clause covers every term of the result set.  Add\n      ** terms to the ORDER BY clause as necessary.\n      */\n      if ( op != TK_ALL )\n      {\n        for ( i = 1 ; /* db.mallocFailed == 0 && */ i <= p.pEList.nExpr ; i++ )\n        {\n          ExprList_item pItem;\n          for ( j = 0 ; j < nOrderBy ; j++ )//, pItem++)\n          {\n            pItem = pOrderBy.a[j];\n            Debug.Assert( pItem.iCol > 0 );\n            if ( pItem.iCol == i ) break;\n          }\n          if ( j == nOrderBy )\n          {\n            Expr pNew = sqlite3Expr( db, TK_INTEGER, null );\n            if ( pNew == null ) return SQLITE_NOMEM;\n            pNew.flags |= EP_IntValue;\n            pNew.u.iValue = i;\n            pOrderBy = sqlite3ExprListAppend( pParse, pOrderBy, pNew );\n            pOrderBy.a[nOrderBy++].iCol = (u16)i;\n          }\n        }\n      }\n\n      /* Compute the comparison permutation and keyinfo that is used with\n      ** the permutation used to determine if the next\n      ** row of results comes from selectA or selectB.  Also add explicit\n      ** collations to the ORDER BY clause terms so that when the subqueries\n      ** to the right and the left are evaluated, they use the correct\n      ** collation.\n      */\n      aPermute = new int[nOrderBy];// sqlite3DbMallocRaw( db, sizeof( int ) * nOrderBy );\n      if ( aPermute != null )\n      {\n        ExprList_item pItem;\n        for ( i = 0 ; i < nOrderBy ; i++ )//, pItem++)\n        {\n          pItem = pOrderBy.a[i];\n          Debug.Assert( pItem.iCol > 0 && pItem.iCol <= p.pEList.nExpr );\n          aPermute[i] = pItem.iCol - 1;\n        }\n        pKeyMerge = new KeyInfo();//      sqlite3DbMallocRaw(db, sizeof(*pKeyMerge)+nOrderBy*(sizeof(CollSeq*)+1));\n        if ( pKeyMerge != null )\n        {\n          pKeyMerge.aColl = new CollSeq[nOrderBy];\n          pKeyMerge.aSortOrder = new byte[nOrderBy];//(u8*)&pKeyMerge.aColl[nOrderBy];\n          pKeyMerge.nField = (u16)nOrderBy;\n          pKeyMerge.enc = ENC( db );\n          for ( i = 0 ; i < nOrderBy ; i++ )\n          {\n            CollSeq pColl;\n            Expr pTerm = pOrderBy.a[i].pExpr;\n            if ( ( pTerm.flags & EP_ExpCollate ) != 0 )\n            {\n              pColl = pTerm.pColl;\n            }\n            else\n            {\n              pColl = multiSelectCollSeq( pParse, p, aPermute[i] );\n              pTerm.flags |= EP_ExpCollate;\n              pTerm.pColl = pColl;\n            }\n            pKeyMerge.aColl[i] = pColl;\n            pKeyMerge.aSortOrder[i] = (byte)pOrderBy.a[i].sortOrder;\n          }\n        }\n      }\n      else\n      {\n        pKeyMerge = null;\n      }\n\n      /* Reattach the ORDER BY clause to the query.\n      */\n      p.pOrderBy = pOrderBy;\n      pPrior.pOrderBy = sqlite3ExprListDup( pParse.db, pOrderBy, 0 );\n\n      /* Allocate a range of temporary registers and the KeyInfo needed\n      ** for the logic that removes duplicate result rows when the\n      ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).\n      */\n      if ( op == TK_ALL )\n      {\n        regPrev = 0;\n      }\n      else\n      {\n        int nExpr = p.pEList.nExpr;\n        Debug.Assert( nOrderBy >= nExpr /*|| db.mallocFailed != 0 */ );\n        regPrev = sqlite3GetTempRange( pParse, nExpr + 1 );\n        sqlite3VdbeAddOp2( v, OP_Integer, 0, regPrev );\n        pKeyDup = new KeyInfo();//sqlite3DbMallocZero(db,\n        //sizeof(*pKeyDup) + nExpr*(sizeof(CollSeq*)+1) );\n        if ( pKeyDup != null )\n        {\n          pKeyDup.aColl = new CollSeq[nExpr];\n          pKeyDup.aSortOrder = new byte[nExpr];//(u8*)&pKeyDup.aColl[nExpr];\n          pKeyDup.nField = (u16)nExpr;\n          pKeyDup.enc = ENC( db );\n          for ( i = 0 ; i < nExpr ; i++ )\n          {\n            pKeyDup.aColl[i] = multiSelectCollSeq( pParse, p, i );\n            pKeyDup.aSortOrder[i] = 0;\n          }\n        }\n      }\n\n      /* Separate the left and the right query from one another\n      */\n      p.pPrior = null;\n      pPrior.pRightmost = null;\n      sqlite3ResolveOrderGroupBy( pParse, p, p.pOrderBy, "ORDER" );\n      if ( pPrior.pPrior == null )\n      {\n        sqlite3ResolveOrderGroupBy( pParse, pPrior, pPrior.pOrderBy, "ORDER" );\n      }\n\n      /* Compute the limit registers */\n      computeLimitRegisters( pParse, p, labelEnd );\n      if ( p.iLimit != 0 && op == TK_ALL )\n      {\n        regLimitA = ++pParse.nMem;\n        regLimitB = ++pParse.nMem;\n        sqlite3VdbeAddOp2( v, OP_Copy, ( p.iOffset != 0 ) ? p.iOffset + 1 : p.iLimit,\n        regLimitA );\n        sqlite3VdbeAddOp2( v, OP_Copy, regLimitA, regLimitB );\n      }\n      else\n      {\n        regLimitA = regLimitB = 0;\n      }\n      sqlite3ExprDelete( db, ref p.pLimit );\n      p.pLimit = null;\n      sqlite3ExprDelete( db, ref p.pOffset );\n      p.pOffset = null;\n\n      regAddrA = ++pParse.nMem;\n      regEofA = ++pParse.nMem;\n      regAddrB = ++pParse.nMem;\n      regEofB = ++pParse.nMem;\n      regOutA = ++pParse.nMem;\n      regOutB = ++pParse.nMem;\n      sqlite3SelectDestInit( destA, SRT_Coroutine, regAddrA );\n      sqlite3SelectDestInit( destB, SRT_Coroutine, regAddrB );\n\n      /* Jump past the various subroutines and coroutines to the main\n      ** merge loop\n      */\n      j1 = sqlite3VdbeAddOp0( v, OP_Goto );\n      addrSelectA = sqlite3VdbeCurrentAddr( v );\n\n\n      /* Generate a coroutine to evaluate the SELECT statement to the\n      ** left of the compound operator - the "A" select.\n      */\n      VdbeNoopComment( v, "Begin coroutine for left SELECT" );\n      pPrior.iLimit = regLimitA;\n      sqlite3Select( pParse, pPrior, ref destA );\n      sqlite3VdbeAddOp2( v, OP_Integer, 1, regEofA );\n      sqlite3VdbeAddOp1( v, OP_Yield, regAddrA );\n      VdbeNoopComment( v, "End coroutine for left SELECT" );\n\n      /* Generate a coroutine to evaluate the SELECT statement on\n      ** the right - the "B" select\n      */\n      addrSelectB = sqlite3VdbeCurrentAddr( v );\n      VdbeNoopComment( v, "Begin coroutine for right SELECT" );\n      savedLimit = p.iLimit;\n      savedOffset = p.iOffset;\n      p.iLimit = regLimitB;\n      p.iOffset = 0;\n      sqlite3Select( pParse, p, ref destB );\n      p.iLimit = savedLimit;\n      p.iOffset = savedOffset;\n      sqlite3VdbeAddOp2( v, OP_Integer, 1, regEofB );\n      sqlite3VdbeAddOp1( v, OP_Yield, regAddrB );\n      VdbeNoopComment( v, "End coroutine for right SELECT" );\n\n      /* Generate a subroutine that outputs the current row of the A\n      ** select as the next output row of the compound select.\n      */\n      VdbeNoopComment( v, "Output routine for A" );\n      addrOutA = generateOutputSubroutine( pParse,\n      p, destA, pDest, regOutA,\n      regPrev, pKeyDup, P4_KEYINFO_HANDOFF, labelEnd );\n\n      /* Generate a subroutine that outputs the current row of the B\n      ** select as the next output row of the compound select.\n      */\n      if ( op == TK_ALL || op == TK_UNION )\n      {\n        VdbeNoopComment( v, "Output routine for B" );\n        addrOutB = generateOutputSubroutine( pParse,\n        p, destB, pDest, regOutB,\n        regPrev, pKeyDup, P4_KEYINFO_STATIC, labelEnd );\n      }\n\n      /* Generate a subroutine to run when the results from select A\n      ** are exhausted and only data in select B remains.\n      */\n      VdbeNoopComment( v, "eof-A subroutine" );\n      if ( op == TK_EXCEPT || op == TK_INTERSECT )\n      {\n        addrEofA = sqlite3VdbeAddOp2( v, OP_Goto, 0, labelEnd );\n      }\n      else\n      {\n        addrEofA = sqlite3VdbeAddOp2( v, OP_If, regEofB, labelEnd );\n        sqlite3VdbeAddOp2( v, OP_Gosub, regOutB, addrOutB );\n        sqlite3VdbeAddOp1( v, OP_Yield, regAddrB );\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, addrEofA );\n      }\n\n      /* Generate a subroutine to run when the results from select B\n      ** are exhausted and only data in select A remains.\n      */\n      if ( op == TK_INTERSECT )\n      {\n        addrEofB = addrEofA;\n      }\n      else\n      {\n        VdbeNoopComment( v, "eof-B subroutine" );\n        addrEofB = sqlite3VdbeAddOp2( v, OP_If, regEofA, labelEnd );\n        sqlite3VdbeAddOp2( v, OP_Gosub, regOutA, addrOutA );\n        sqlite3VdbeAddOp1( v, OP_Yield, regAddrA );\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, addrEofB );\n      }\n\n      /* Generate code to handle the case of A<B\n      */\n      VdbeNoopComment( v, "A-lt-B subroutine" );\n      addrAltB = sqlite3VdbeAddOp2( v, OP_Gosub, regOutA, addrOutA );\n      sqlite3VdbeAddOp1( v, OP_Yield, regAddrA );\n      sqlite3VdbeAddOp2( v, OP_If, regEofA, addrEofA );\n      sqlite3VdbeAddOp2( v, OP_Goto, 0, labelCmpr );\n\n      /* Generate code to handle the case of A==B\n      */\n      if ( op == TK_ALL )\n      {\n        addrAeqB = addrAltB;\n      }\n      else if ( op == TK_INTERSECT )\n      {\n        addrAeqB = addrAltB;\n        addrAltB++;\n      }\n      else\n      {\n        VdbeNoopComment( v, "A-eq-B subroutine" );\n        addrAeqB =\n        sqlite3VdbeAddOp1( v, OP_Yield, regAddrA );\n        sqlite3VdbeAddOp2( v, OP_If, regEofA, addrEofA );\n        sqlite3VdbeAddOp2( v, OP_Goto, 0, labelCmpr );\n      }\n\n      /* Generate code to handle the case of A>B\n      */\n      VdbeNoopComment( v, "A-gt-B subroutine" );\n      addrAgtB = sqlite3VdbeCurrentAddr( v );\n      if ( op == TK_ALL || op == TK_UNION )\n      {\n        sqlite3VdbeAddOp2( v, OP_Gosub, regOutB, addrOutB );\n      }\n      sqlite3VdbeAddOp1( v, OP_Yield, regAddrB );\n      sqlite3VdbeAddOp2( v, OP_If, regEofB, addrEofB );\n      sqlite3VdbeAddOp2( v, OP_Goto, 0, labelCmpr );\n\n      /* This code runs once to initialize everything.\n      */\n      sqlite3VdbeJumpHere( v, j1 );\n      sqlite3VdbeAddOp2( v, OP_Integer, 0, regEofA );\n      sqlite3VdbeAddOp2( v, OP_Integer, 0, regEofB );\n      sqlite3VdbeAddOp2( v, OP_Gosub, regAddrA, addrSelectA );\n      sqlite3VdbeAddOp2( v, OP_Gosub, regAddrB, addrSelectB );\n      sqlite3VdbeAddOp2( v, OP_If, regEofA, addrEofA );\n      sqlite3VdbeAddOp2( v, OP_If, regEofB, addrEofB );\n\n      /* Implement the main merge loop\n      */\n      sqlite3VdbeResolveLabel( v, labelCmpr );\n      sqlite3VdbeAddOp4( v, OP_Permutation, 0, 0, 0, aPermute, P4_INTARRAY );\n      sqlite3VdbeAddOp4( v, OP_Compare, destA.iMem, destB.iMem, nOrderBy,\n      pKeyMerge, P4_KEYINFO_HANDOFF );\n      sqlite3VdbeAddOp3( v, OP_Jump, addrAltB, addrAeqB, addrAgtB );\n\n      /* Release temporary registers\n      */\n      if ( regPrev != 0 )\n      {\n        sqlite3ReleaseTempRange( pParse, regPrev, nOrderBy + 1 );\n      }\n\n      /* Jump to the this point in order to terminate the query.\n      */\n      sqlite3VdbeResolveLabel( v, labelEnd );\n\n      /* Set the number of output columns\n      */\n      if ( pDest.eDest == SRT_Output )\n      {\n        Select pFirst = pPrior;\n        while ( pFirst.pPrior != null ) pFirst = pFirst.pPrior;\n        generateColumnNames( pParse, null, pFirst.pEList );\n      }\n\n      /* Reassembly the compound query so that it will be freed correctly\n      ** by the calling function */\n      if ( p.pPrior != null )\n      {\n        sqlite3SelectDelete( db, ref p.pPrior );\n      }\n      p.pPrior = pPrior;\n\n      /*** TBD:  Insert subroutine calls to close cursors on incomplete\n      **** subqueries ****/\n      return SQLITE_OK;\n    }\n#endif\n#if !(SQLITE_OMIT_SUBQUERY) || !(SQLITE_OMIT_VIEW)\n    /* Forward Declarations */\n    //static void substExprList(sqlite3*, ExprList*, int, ExprList*);\n    //static void substSelect(sqlite3*, Select *, int, ExprList *);\n\n    /*\n    ** Scan through the expression pExpr.  Replace every reference to\n    ** a column in table number iTable with a copy of the iColumn-th\n    ** entry in pEList.  (But leave references to the ROWID column\n    ** unchanged.)\n    **\n    ** This routine is part of the flattening procedure.  A subquery\n    ** whose result set is defined by pEList appears as entry in the\n    ** FROM clause of a SELECT such that the VDBE cursor assigned to that\n    ** FORM clause entry is iTable.  This routine make the necessary\n    ** changes to pExpr so that it refers directly to the source table\n    ** of the subquery rather the result set of the subquery.\n    */\n    static Expr substExpr(\n    sqlite3 db,        /* Report malloc errors to this connection */\n    Expr pExpr,        /* Expr in which substitution occurs */\n    int iTable,        /* Table to be substituted */\n    ExprList pEList    /* Substitute expressions */\n    )\n    {\n      if ( pExpr == null ) return null;\n      if ( pExpr.op == TK_COLUMN && pExpr.iTable == iTable )\n      {\n        if ( pExpr.iColumn < 0 )\n        {\n          pExpr.op = TK_NULL;\n        }\n        else\n        {\n          Expr pNew;\n          Debug.Assert( pEList != null && pExpr.iColumn < pEList.nExpr );\n          Debug.Assert( pExpr.pLeft == null && pExpr.pRight == null );\n          pNew = sqlite3ExprDup( db, pEList.a[pExpr.iColumn].pExpr, 0 );\n          if ( pExpr.pColl != null )\n          {\n            pNew.pColl = pExpr.pColl;\n          }\n          sqlite3ExprDelete( db, ref pExpr );\n          pExpr = pNew;\n        }\n      }\n      else\n      {\n        pExpr.pLeft = substExpr( db, pExpr.pLeft, iTable, pEList );\n        pExpr.pRight = substExpr( db, pExpr.pRight, iTable, pEList );\n        if ( ExprHasProperty( pExpr, EP_xIsSelect ) )\n        {\n          substSelect( db, pExpr.x.pSelect, iTable, pEList );\n        }\n        else\n        {\n          substExprList( db, pExpr.x.pList, iTable, pEList );\n        }\n      }\n      return pExpr;\n    }\n\n    static void substExprList(\n    sqlite3 db,         /* Report malloc errors here */\n    ExprList pList,     /* List to scan and in which to make substitutes */\n    int iTable,          /* Table to be substituted */\n    ExprList pEList     /* Substitute values */\n    )\n    {\n      int i;\n      if ( pList == null ) return;\n      for ( i = 0 ; i < pList.nExpr ; i++ )\n      {\n        pList.a[i].pExpr = substExpr( db, pList.a[i].pExpr, iTable, pEList );\n      }\n    }\n\n    static void substSelect(\n    sqlite3 db,         /* Report malloc errors here */\n    Select p,           /* SELECT statement in which to make substitutions */\n    int iTable,          /* Table to be replaced */\n    ExprList pEList     /* Substitute values */\n    )\n    {\n      SrcList pSrc;\n      SrcList_item pItem;\n      int i;\n      if ( p == null ) return;\n      substExprList( db, p.pEList, iTable, pEList );\n      substExprList( db, p.pGroupBy, iTable, pEList );\n      substExprList( db, p.pOrderBy, iTable, pEList );\n      p.pHaving = substExpr( db, p.pHaving, iTable, pEList );\n      p.pWhere = substExpr( db, p.pWhere, iTable, pEList );\n      substSelect( db, p.pPrior, iTable, pEList );\n      pSrc = p.pSrc;\n      Debug.Assert( pSrc != null );  /* Even for (SELECT 1) we have: pSrc!=0 but pSrc->nSrc==0 */\n      if ( ALWAYS( pSrc ) )\n      {\n        for ( i = pSrc.nSrc ; i > 0 ; i-- )//, pItem++ )\n        {\n          pItem = pSrc.a[pSrc.nSrc - i];\n          substSelect( db, pItem.pSelect, iTable, pEList );\n        }\n      }\n    }\n#endif //* !SQLITE_OMIT_SUBQUERY) || !SQLITE_OMIT_VIEW) */\n\n#if !(SQLITE_OMIT_SUBQUERY) || !(SQLITE_OMIT_VIEW)\n    /*\n** This routine attempts to flatten subqueries in order to speed\n** execution.  It returns 1 if it makes changes and 0 if no flattening\n** occurs.\n**\n** To understand the concept of flattening, consider the following\n** query:\n**\n**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z<100) WHERE a>5\n**\n** The default way of implementing this query is to execute the\n** subquery first and store the results in a temporary table, then\n** run the outer query on that temporary table.  This requires two\n** passes over the data.  Furthermore, because the temporary table\n** has no indices, the WHERE clause on the outer query cannot be\n** optimized.\n**\n** This routine attempts to rewrite queries such as the above into\n** a single flat select, like this:\n**\n**     SELECT x+y AS a FROM t1 WHERE z<100 AND a>5\n**\n** The code generated for this simpification gives the same result\n** but only has to scan the data once.  And because indices might\n** exist on the table t1, a complete scan of the data might be\n** avoided.\n**\n** Flattening is only attempted if all of the following are true:\n**\n**   (1)  The subquery and the outer query do not both use aggregates.\n**\n**   (2)  The subquery is not an aggregate or the outer query is not a join.\n**\n**   (3)  The subquery is not the right operand of a left outer join\n**        (Originally ticket #306.  Strenghtened by ticket #3300)\n**\n**   (4)  The subquery is not DISTINCT or the outer query is not a join.\n**\n**   (5)  The subquery is not DISTINCT or the outer query does not use\n**        aggregates.\n**\n**   (6)  The subquery does not use aggregates or the outer query is not\n**        DISTINCT.\n**\n**   (7)  The subquery has a FROM clause.\n**\n**   (8)  The subquery does not use LIMIT or the outer query is not a join.\n**\n**   (9)  The subquery does not use LIMIT or the outer query does not use\n**        aggregates.\n**\n**  (10)  The subquery does not use aggregates or the outer query does not\n**        use LIMIT.\n**\n**  (11)  The subquery and the outer query do not both have ORDER BY clauses.\n**\n**  (12)  Not implemented.  Subsumed into restriction (3).  Was previously\n**        a separate restriction deriving from ticket #350.\n**\n**  (13)  The subquery and outer query do not both use LIMIT\n**\n**  (14)  The subquery does not use OFFSET\n**\n**  (15)  The outer query is not part of a compound select or the\n**        subquery does not have both an ORDER BY and a LIMIT clause.\n**        (See ticket #2339)\n**\n**  (16)  The outer query is not an aggregate or the subquery does\n**        not contain ORDER BY.  (Ticket #2942)  This used to not matter\n**        until we introduced the group_concat() function.\n**\n**  (17)  The sub-query is not a compound select, or it is a UNION ALL\n**        compound clause made up entirely of non-aggregate queries, and\n**        the parent query:\n**\n**          * is not itself part of a compound select,\n**          * is not an aggregate or DISTINCT query, and\n**          * has no other tables or sub-selects in the FROM clause.\n**\n**        The parent and sub-query may contain WHERE clauses. Subject to\n**        rules (11), (13) and (14), they may also contain ORDER BY,\n**        LIMIT and OFFSET clauses.\n**\n**  (18)  If the sub-query is a compound select, then all terms of the\n**        ORDER by clause of the parent must be simple references to\n**        columns of the sub-query.\n**\n**  (19)  The subquery does not use LIMIT or the outer query does not\n**        have a WHERE clause.\n**\n**  (20)  If the sub-query is a compound select, then it must not use\n**        an ORDER BY clause.  Ticket #3773.  We could relax this constraint\n**        somewhat by saying that the terms of the ORDER BY clause must\n**        appear as unmodified result columns in the outer query.  But\n**        have other optimizations in mind to deal with that case.\n**\n** In this routine, the "p" parameter is a pointer to the outer query.\n** The subquery is p.pSrc.a[iFrom].  isAgg is true if the outer query\n** uses aggregates and subqueryIsAgg is true if the subquery uses aggregates.\n**\n** If flattening is not attempted, this routine is a no-op and returns 0.\n** If flattening is attempted this routine returns 1.\n**\n** All of the expression analysis must occur on both the outer query and\n** the subquery before this routine runs.\n*/\n    static int flattenSubquery(\n    Parse pParse,        /* Parsing context */\n    Select p,            /* The parent or outer SELECT statement */\n    int iFrom,           /* Index in p.pSrc.a[] of the inner subquery */\n    bool isAgg,          /* True if outer SELECT uses aggregate functions */\n    bool subqueryIsAgg   /* True if the subquery uses aggregate functions */\n    )\n    {\n      string zSavedAuthContext = pParse.zAuthContext;\n      Select pParent;\n      Select pSub;         /* The inner query or "subquery" */\n      Select pSub1;      /* Pointer to the rightmost select in sub-query */\n      SrcList pSrc;        /* The FROM clause of the outer query */\n      SrcList pSubSrc;     /* The FROM clause of the subquery */\n      ExprList pList;      /* The result set of the outer query */\n      int iParent;         /* VDBE cursor number of the pSub result set temp table */\n      int i;               /* Loop counter */\n      Expr pWhere;         /* The WHERE clause */\n      SrcList_item pSubitem;/* The subquery */\n      sqlite3 db = pParse.db;\n\n      /* Check to see if flattening is permitted.  Return 0 if not.\n      */\n      Debug.Assert( p != null );\n      Debug.Assert( p.pPrior == null );  /* Unable to flatten compound queries */\n      pSrc = p.pSrc;\n      Debug.Assert( pSrc != null && iFrom >= 0 && iFrom < pSrc.nSrc );\n      pSubitem = pSrc.a[iFrom];\n      iParent = pSubitem.iCursor;\n      pSub = pSubitem.pSelect;\n      Debug.Assert( pSub != null );\n      if ( isAgg && subqueryIsAgg ) return 0;                 /* Restriction (1)  */\n      if ( subqueryIsAgg && pSrc.nSrc > 1 ) return 0;          /* Restriction (2)  */\n      pSubSrc = pSub.pSrc;\n      Debug.Assert( pSubSrc != null );\n      /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n      ** not arbitrary expresssions, we allowed some combining of LIMIT and OFFSET\n      ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n      ** became arbitrary expressions, we were forced to add restrictions (13)\n      ** and (14). */\n      if ( pSub.pLimit != null && p.pLimit != null ) return 0;              /* Restriction (13) */\n      if ( pSub.pOffset != null ) return 0;                          /* Restriction (14) */\n      if ( p.pRightmost != null && pSub.pLimit != null && pSub.pOrderBy != null )\n      {\n        return 0;                                            /* Restriction (15) */\n      }\n      if ( pSubSrc.nSrc == 0 ) return 0;                       /* Restriction (7)  */\n      if ( ( pSub.selFlags & SF_Distinct ) != 0 || pSub.pLimit != null\n      && ( pSrc.nSrc > 1 || isAgg ) )\n      {          /* Restrictions (4)(5)(8)(9) */\n        return 0;\n      }\n      if ( ( p.selFlags & SF_Distinct ) != 0 && subqueryIsAgg )\n      {\n        return 0;         /* Restriction (6)  */\n      }\n      if ( p.pOrderBy != null && pSub.pOrderBy != null )\n      {\n        return 0;                                           /* Restriction (11) */\n      }\n      if ( isAgg && pSub.pOrderBy != null ) return 0;                /* Restriction (16) */\n      if ( pSub.pLimit != null && p.pWhere != null ) return 0;              /* Restriction (19) */\n\n      /* OBSOLETE COMMENT 1:\n      ** Restriction 3:  If the subquery is a join, make sure the subquery is\n      ** not used as the right operand of an outer join.  Examples of why this\n      ** is not allowed:\n      **\n      **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n      **\n      ** If we flatten the above, we would get\n      **\n      **         (t1 LEFT OUTER JOIN t2) JOIN t3\n      **\n      ** which is not at all the same thing.\n      **\n      ** OBSOLETE COMMENT 2:\n      ** Restriction 12:  If the subquery is the right operand of a left outer\n\n      /* Restriction 12:  If the subquery is the right operand of a left outer\n      ** join, make sure the subquery has no WHERE clause.\n      ** An examples of why this is not allowed:\n      **\n      **         t1 LEFT OUTER JOIN (SELECT * FROM t2 WHERE t2.x>0)\n      **\n      ** If we flatten the above, we would get\n      **\n      **         (t1 LEFT OUTER JOIN t2) WHERE t2.x>0\n      **\n      ** But the t2.x>0 test will always fail on a NULL row of t2, which\n      ** effectively converts the OUTER JOIN into an INNER JOIN.\n      **\n      ** THIS OVERRIDES OBSOLETE COMMENTS 1 AND 2 ABOVE:\n      ** Ticket #3300 shows that flattening the right term of a LEFT JOIN\n      ** is fraught with danger.  Best to avoid the whole thing.  If the\n      ** subquery is the right term of a LEFT JOIN, then do not flatten.\n      */\n      if ( ( pSubitem.jointype & JT_OUTER ) != 0 )\n      {\n        return 0;\n      }\n\n      /* Restriction 17: If the sub-query is a compound SELECT, then it must\n      ** use only the UNION ALL operator. And none of the simple select queries\n      ** that make up the compound SELECT are allowed to be aggregate or distinct\n      ** queries.\n      */\n      if ( pSub.pPrior != null )\n      {\n        if ( pSub.pOrderBy != null )\n        {\n          return 0;  /* Restriction 20 */\n        }\n        if ( isAgg || ( p.selFlags & SF_Distinct ) != 0 || pSrc.nSrc != 1 )\n        {\n          return 0;\n        }\n        for ( pSub1 = pSub ; pSub1 != null ; pSub1 = pSub1.pPrior )\n        {\n          testcase( ( pSub1.selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct );\n          testcase( ( pSub1.selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Aggregate );\n          if ( ( pSub1.selFlags & ( SF_Distinct | SF_Aggregate ) ) != 0\n          || ( pSub1.pPrior != null && pSub1.op != TK_ALL )\n          || NEVER( pSub1.pSrc == null ) || pSub1.pSrc.nSrc != 1\n          )\n          {\n            return 0;\n          }\n        }\n\n        /* Restriction 18. */\n        if ( p.pOrderBy != null )\n        {\n          int ii;\n          for ( ii = 0 ; ii < p.pOrderBy.nExpr ; ii++ )\n          {\n            if ( p.pOrderBy.a[ii].iCol == 0 ) return 0;\n          }\n        }\n      }\n\n      /***** If we reach this point, flattening is permitted. *****/\n\n      /* Authorize the subquery */\n      pParse.zAuthContext = pSubitem.zName;\n      sqlite3AuthCheck( pParse, SQLITE_SELECT, null, null, null );\n      pParse.zAuthContext = zSavedAuthContext;\n\n      /* If the sub-query is a compound SELECT statement, then (by restrictions\n      ** 17 and 18 above) it must be a UNION ALL and the parent query must\n      ** be of the form:\n      **\n      **     SELECT <expr-list> FROM (<sub-query>) <where-clause>\n      **\n      ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n      ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or\n      ** OFFSET clauses and joins them to the left-hand-side of the original\n      ** using UNION ALL operators. In this case N is the number of simple\n      ** select statements in the compound sub-query.\n      **\n      ** Example:\n      **\n      **     SELECT a+1 FROM (\n      **        SELECT x FROM tab\n      **        UNION ALL\n      **        SELECT y FROM tab\n      **        UNION ALL\n      **        SELECT abs(z*2) FROM tab2\n      **     ) WHERE a!=5 ORDER BY 1\n      **\n      ** Transformed into:\n      **\n      **     SELECT x+1 FROM tab WHERE x+1!=5\n      **     UNION ALL\n      **     SELECT y+1 FROM tab WHERE y+1!=5\n      **     UNION ALL\n      **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n      **     ORDER BY 1\n      **\n      ** We call this the "compound-subquery flattening".\n      */\n      for ( pSub = pSub.pPrior ; pSub != null ; pSub = pSub.pPrior )\n      {\n        Select pNew;\n        ExprList pOrderBy = p.pOrderBy;\n        Expr pLimit = p.pLimit;\n        Select pPrior = p.pPrior;\n        p.pOrderBy = null;\n        p.pSrc = null;\n        p.pPrior = null;\n        p.pLimit = null;\n        pNew = sqlite3SelectDup( db, p, 0 );\n        p.pLimit = pLimit;\n        p.pOrderBy = pOrderBy;\n        p.pSrc = pSrc;\n        p.op = TK_ALL;\n        p.pRightmost = null;\n        if ( pNew == null )\n        {\n          pNew = pPrior;\n        }\n        else\n        {\n          pNew.pPrior = pPrior;\n          pNew.pRightmost = null;\n        }\n        p.pPrior = pNew;\n//        if ( db.mallocFailed != 0 ) return 1;\n      }\n\n      /* Begin flattening the iFrom-th entry of the FROM clause\n      ** in the outer query.\n      */\n      pSub = pSub1 = pSubitem.pSelect;\n      /* Delete the transient table structure associated with the\n      ** subquery\n      */\n\n      //sqlite3DbFree( db, ref pSubitem.zDatabase );\n      //sqlite3DbFree( db, ref pSubitem.zName );\n      //sqlite3DbFree( db, ref pSubitem.zAlias );\n      pSubitem.zDatabase = null;\n      pSubitem.zName = null;\n      pSubitem.zAlias = null;\n      pSubitem.pSelect = null;\n      /* Defer deleting the Table object associated with the\n      ** subquery until code generation is\n      ** complete, since there may still exist Expr.pTab entries that\n      ** refer to the subquery even after flattening.  Ticket #3346.\n      **\n      ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n      */\n      if ( ALWAYS( pSubitem.pTab != null ) )\n      {\n        Table pTabToDel = pSubitem.pTab;\n        if ( pTabToDel.nRef == 1 )\n        {\n          pTabToDel.pNextZombie = pParse.pZombieTab;\n          pParse.pZombieTab = pTabToDel;\n        }\n        else\n        {\n          pTabToDel.nRef--;\n        }\n        pSubitem.pTab = null;\n      }\n\n      /* The following loop runs once for each term in a compound-subquery\n      ** flattening (as described above).  If we are doing a different kind\n      ** of flattening - a flattening other than a compound-subquery flattening -\n      ** then this loop only runs once.\n      **\n      ** This loop moves all of the FROM elements of the subquery into the\n      ** the FROM clause of the outer query.  Before doing this, remember\n      ** the cursor number for the original outer query FROM element in\n      ** iParent.  The iParent cursor will never be used.  Subsequent code\n      ** will scan expressions looking for iParent references and replace\n      ** those references with expressions that resolve to the subquery FROM\n      ** elements we are now copying in.\n      */\n      for ( pParent = p ; pParent != null ; pParent = pParent.pPrior, pSub = pSub.pPrior )\n      {\n        int nSubSrc;\n        u8 jointype = 0;\n        pSubSrc = pSub.pSrc;     /* FROM clause of subquery */\n        nSubSrc = pSubSrc.nSrc;  /* Number of terms in subquery FROM clause */\n        pSrc = pParent.pSrc;     /* FROM clause of the outer query */\n\n        if ( pSrc != null )\n        {\n          Debug.Assert( pParent == p );  /* First time through the loop */\n          jointype = pSubitem.jointype;\n        }\n        else\n        {\n          Debug.Assert( pParent != p );  /* 2nd and subsequent times through the loop */\n          pSrc = pParent.pSrc = sqlite3SrcListAppend( db, null, null, null );\n          //if ( pSrc == null )\n          //{\n          //  //Debug.Assert( db.mallocFailed != 0 );\n          //  break;\n          //}\n        }\n\n        /* The subquery uses a single slot of the FROM clause of the outer\n        ** query.  If the subquery has more than one element in its FROM clause,\n        ** then expand the outer query to make space for it to hold all elements\n        ** of the subquery.\n        **\n        ** Example:\n        **\n        **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n        **\n        ** The outer query has 3 slots in its FROM clause.  One slot of the\n        ** outer query (the middle slot) is used by the subquery.  The next\n        ** block of code will expand the out query to 4 slots.  The middle\n        ** slot is expanded to two slots in order to make space for the\n        ** two elements in the FROM clause of the subquery.\n        */\n        if ( nSubSrc > 1 )\n        {\n          pParent.pSrc = pSrc = sqlite3SrcListEnlarge( db, pSrc, nSubSrc - 1, iFrom + 1 );\n          //if ( db.mallocFailed != 0 )\n          //{\n          //  break;\n          //}\n        }\n\n        /* Transfer the FROM clause terms from the subquery into the\n        ** outer query.\n        */\n        for ( i = 0 ; i < nSubSrc ; i++ )\n        {\n          sqlite3IdListDelete( db, ref pSrc.a[i + iFrom].pUsing );\n          pSrc.a[i + iFrom] = pSubSrc.a[i];\n          pSubSrc.a[i] = new SrcList_item();//memset(pSubSrc.a[i], 0, sizeof(pSubSrc.a[i]));\n        }\n        pSrc.a[iFrom].jointype = jointype;\n\n        /* Now begin substituting subquery result set expressions for\n        ** references to the iParent in the outer query.\n        **\n        ** Example:\n        **\n        **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n        **   \\                     \\_____________ subquery __________/          /\n        **    \\_____________________ outer query ______________________________/\n        **\n        ** We look at every expression in the outer query and every place we see\n        ** "a" we substitute "x*3" and every place we see "b" we substitute "y+10".\n        */\n        pList = pParent.pEList;\n        for ( i = 0 ; i < pList.nExpr ; i++ )\n        {\n          if ( pList.a[i].zName == null )\n          {\n            string zSpan = pList.a[i].zSpan;\n            if ( ALWAYS( zSpan ) )\n            {\n              pList.a[i].zName = zSpan;// sqlite3DbStrDup( db, zSpan );\n            }\n          }\n        }\n        substExprList( db, pParent.pEList, iParent, pSub.pEList );\n        if ( isAgg )\n        {\n          substExprList( db, pParent.pGroupBy, iParent, pSub.pEList );\n          pParent.pHaving = substExpr( db, pParent.pHaving, iParent, pSub.pEList );\n        }\n        if ( pSub.pOrderBy != null )\n        {\n          Debug.Assert( pParent.pOrderBy == null );\n          pParent.pOrderBy = pSub.pOrderBy;\n          pSub.pOrderBy = null;\n        }\n        else if ( pParent.pOrderBy != null )\n        {\n          substExprList( db, pParent.pOrderBy, iParent, pSub.pEList );\n        }\n        if ( pSub.pWhere != null )\n        {\n          pWhere = sqlite3ExprDup( db, pSub.pWhere, 0 );\n        }\n        else\n        {\n          pWhere = null;\n        }\n        if ( subqueryIsAgg )\n        {\n          Debug.Assert( pParent.pHaving == null );\n          pParent.pHaving = pParent.pWhere;\n          pParent.pWhere = pWhere;\n          pParent.pHaving = substExpr( db, pParent.pHaving, iParent, pSub.pEList );\n          pParent.pHaving = sqlite3ExprAnd( db, pParent.pHaving,\n          sqlite3ExprDup( db, pSub.pHaving, 0 ) );\n          Debug.Assert( pParent.pGroupBy == null );\n          pParent.pGroupBy = sqlite3ExprListDup( db, pSub.pGroupBy, 0 );\n        }\n        else\n        {\n          pParent.pWhere = substExpr( db, pParent.pWhere, iParent, pSub.pEList );\n          pParent.pWhere = sqlite3ExprAnd( db, pParent.pWhere, pWhere );\n        }\n\n        /* The flattened query is distinct if either the inner or the\n        ** outer query is distinct.\n        */\n        pParent.selFlags = (u16)( pParent.selFlags | pSub.selFlags & SF_Distinct );\n\n        /*\n        ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n        **\n        ** One is tempted to try to add a and b to combine the limits.  But this\n        ** does not work if either limit is negative.\n        */\n        if ( pSub.pLimit != null )\n        {\n          pParent.pLimit = pSub.pLimit;\n          pSub.pLimit = null;\n        }\n      }\n\n      /* Finially, delete what is left of the subquery and return\n      ** success.\n      */\n      sqlite3SelectDelete( db, ref pSub );\n      sqlite3SelectDelete( db, ref pSub1 );\n      return 1;\n    }\n#endif //* !SQLITE_OMIT_SUBQUERY) || !SQLITE_OMIT_VIEW) */\n\n    /*\n** Analyze the SELECT statement passed as an argument to see if it\n** is a min() or max() query. Return WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX if\n** it is, or 0 otherwise. At present, a query is considered to be\n** a min()/max() query if:\n**\n**   1. There is a single object in the FROM clause.\n**\n**   2. There is a single expression in the result set, and it is\n**      either min(x) or max(x), where x is a column reference.\n*/\n    static u8 minMaxQuery( Select p )\n    {\n      Expr pExpr;\n      ExprList pEList = p.pEList;\n\n      if ( pEList.nExpr != 1 ) return WHERE_ORDERBY_NORMAL;\n      pExpr = pEList.a[0].pExpr;\n      if ( pExpr.op != TK_AGG_FUNCTION ) return 0;\n      if ( NEVER( ExprHasProperty( pExpr, EP_xIsSelect ) ) ) return 0;\n      pEList = pExpr.x.pList;\n      if ( pEList == null || pEList.nExpr != 1 ) return 0;\n      if ( pEList.a[0].pExpr.op != TK_AGG_COLUMN ) return WHERE_ORDERBY_NORMAL;\n      Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) );\n      if ( String.Compare( pExpr.u.zToken, "min", true ) == 0 )//sqlite3StrICmp(pExpr->u.zToken,"min")==0 )\n      {\n        return WHERE_ORDERBY_MIN;\n      }\n      else if ( String.Compare( pExpr.u.zToken, "max", true ) == 0 )//sqlite3StrICmp(pExpr->u.zToken,"max")==0 )\n      {\n        return WHERE_ORDERBY_MAX;\n      }\n      return WHERE_ORDERBY_NORMAL;\n    }\n\n    /*\n    ** The select statement passed as the first argument is an aggregate query.\n    ** The second argment is the associated aggregate-info object. This\n    ** function tests if the SELECT is of the form:\n    **\n    **   SELECT count(*) FROM <tbl>\n    **\n    ** where table is a database table, not a sub-select or view. If the query\n    ** does match this pattern, then a pointer to the Table object representing\n    ** <tbl> is returned. Otherwise, 0 is returned.\n    */\n    static Table isSimpleCount( Select p, AggInfo pAggInfo )\n    {\n      Table pTab;\n      Expr pExpr;\n\n      Debug.Assert( null == p.pGroupBy );\n\n      if ( p.pWhere != null || p.pEList.nExpr != 1\n      || p.pSrc.nSrc != 1 || p.pSrc.a[0].pSelect != null\n      )\n      {\n        return null;\n      }\n      pTab = p.pSrc.a[0].pTab;\n      pExpr = p.pEList.a[0].pExpr;\n      Debug.Assert( pTab != null && null == pTab.pSelect && pExpr != null );\n\n      if ( IsVirtual( pTab ) ) return null;\n      if ( pExpr.op != TK_AGG_FUNCTION ) return null;\n      if ( ( pAggInfo.aFunc[0].pFunc.flags & SQLITE_FUNC_COUNT ) == 0 ) return null;\n      if ( ( pExpr.flags & EP_Distinct ) != 0 ) return null;\n\n      return pTab;\n    }\n\n    /*\n    ** If the source-list item passed as an argument was augmented with an\n    ** INDEXED BY clause, then try to locate the specified index. If there\n    ** was such a clause and the named index cannot be found, return\n    ** SQLITE_ERROR and leave an error in pParse. Otherwise, populate\n    ** pFrom.pIndex and return SQLITE_OK.\n    */\n    static int sqlite3IndexedByLookup( Parse pParse, SrcList_item pFrom )\n    {\n      if ( pFrom.pTab != null && pFrom.zIndex != null && pFrom.zIndex.Length != 0 )\n      {\n        Table pTab = pFrom.pTab;\n        string zIndex = pFrom.zIndex;\n        Index pIdx;\n        for ( pIdx = pTab.pIndex ;\n        pIdx != null && sqlite3StrICmp( pIdx.zName, zIndex ) != 0 ;\n        pIdx = pIdx.pNext\n        ) ;\n        if ( null == pIdx )\n        {\n          sqlite3ErrorMsg( pParse, "no such index: %s", zIndex );\n          return SQLITE_ERROR;\n        }\n        pFrom.pIndex = pIdx;\n      }\n      return SQLITE_OK;\n    }\n\n    /*\n    ** This routine is a Walker callback for "expanding" a SELECT statement.\n    ** "Expanding" means to do the following:\n    **\n    **    (1)  Make sure VDBE cursor numbers have been assigned to every\n    **         element of the FROM clause.\n    **\n    **    (2)  Fill in the pTabList.a[].pTab fields in the SrcList that\n    **         defines FROM clause.  When views appear in the FROM clause,\n    **         fill pTabList.a[].x.pSelect with a copy of the SELECT statement\n    **         that implements the view.  A copy is made of the view\'s SELECT\n    **         statement so that we can freely modify or delete that statement\n    **         without worrying about messing up the presistent representation\n    **         of the view.\n    **\n    **    (3)  Add terms to the WHERE clause to accomodate the NATURAL keyword\n    **         on joins and the ON and USING clause of joins.\n    **\n    **    (4)  Scan the list of columns in the result set (pEList) looking\n    **         for instances of the "*" operator or the TABLE.* operator.\n    **         If found, expand each "*" to be every column in every table\n    **         and TABLE.* to be every column in TABLE.\n    **\n    */\n    static int selectExpander( Walker pWalker, Select p )\n    {\n      Parse pParse = pWalker.pParse;\n      int i, j, k;\n      SrcList pTabList;\n      ExprList pEList;\n      SrcList_item pFrom;\n      sqlite3 db = pParse.db;\n\n      //if ( db.mallocFailed != 0 )\n      //{\n      //  return WRC_Abort;\n      //}\n      if ( NEVER( p.pSrc == null ) || ( p.selFlags & SF_Expanded ) != 0 )\n      {\n        return WRC_Prune;\n      }\n      p.selFlags |= SF_Expanded;\n      pTabList = p.pSrc;\n      pEList = p.pEList;\n\n      /* Make sure cursor numbers have been assigned to all entries in\n      ** the FROM clause of the SELECT statement.\n      */\n      sqlite3SrcListAssignCursors( pParse, pTabList );\n\n      /* Look up every table named in the FROM clause of the select.  If\n      ** an entry of the FROM clause is a subquery instead of a table or view,\n      ** then create a transient table ure to describe the subquery.\n      */\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )// pFrom++ )\n      {\n        pFrom = pTabList.a[i];\n        Table pTab;\n        if ( pFrom.pTab != null )\n        {\n          /* This statement has already been prepared.  There is no need\n          ** to go further. */\n          Debug.Assert( i == 0 );\n          return WRC_Prune;\n        }\n        if ( pFrom.zName == null )\n        {\n#if !SQLITE_OMIT_SUBQUERY\n          Select pSel = pFrom.pSelect;\n          /* A sub-query in the FROM clause of a SELECT */\n          Debug.Assert( pSel != null );\n          Debug.Assert( pFrom.pTab == null );\n          sqlite3WalkSelect( pWalker, pSel );\n          pFrom.pTab = pTab = new Table();// sqlite3DbMallocZero( db, sizeof( Table ) );\n          if ( pTab == null ) return WRC_Abort;\n          pTab.dbMem = db.lookaside.bEnabled != 0 ? db : null;\n          pTab.nRef = 1;\n          pTab.zName = sqlite3MPrintf( db, "sqlite_subquery_%p_", pTab );\n          while ( pSel.pPrior != null ) { pSel = pSel.pPrior; }\n          selectColumnsFromExprList( pParse, pSel.pEList, ref pTab.nCol, ref pTab.aCol );\n          pTab.iPKey = -1;\n          pTab.tabFlags |= TF_Ephemeral;\n#endif\n        }\n        else\n        {\n          /* An ordinary table or view name in the FROM clause */\n          Debug.Assert( pFrom.pTab == null );\n          pFrom.pTab = pTab =\n          sqlite3LocateTable( pParse, 0, pFrom.zName, pFrom.zDatabase );\n          if ( pTab == null ) return WRC_Abort;\n          pTab.nRef++;\n#if !(SQLITE_OMIT_VIEW) || !(SQLITE_OMIT_VIRTUALTABLE)\n          if ( pTab.pSelect != null || IsVirtual( pTab ) )\n          {\n            /* We reach here if the named table is a really a view */\n            if ( sqlite3ViewGetColumnNames( pParse, pTab ) != 0 ) return WRC_Abort;\n\n            pFrom.pSelect = sqlite3SelectDup( db, pTab.pSelect, 0 );\n            sqlite3WalkSelect( pWalker, pFrom.pSelect );\n          }\n#endif\n        }\n        /* Locate the index named by the INDEXED BY clause, if any. */\n        if ( sqlite3IndexedByLookup( pParse, pFrom ) != 0 )\n        {\n          return WRC_Abort;\n        }\n      }\n\n      /* Process NATURAL keywords, and ON and USING clauses of joins.\n      */\n      if ( /* db.mallocFailed != 0 || */ sqliteProcessJoin( pParse, p ) != 0 )\n      {\n        return WRC_Abort;\n      }\n\n      /* For every "*" that occurs in the column list, insert the names of\n      ** all columns in all tables.  And for every TABLE.* insert the names\n      ** of all columns in TABLE.  The parser inserted a special expression\n      ** with the TK_ALL operator for each "*" that it found in the column list.\n      ** The following code just has to locate the TK_ALL expressions and expand\n      ** each one to the list of all columns in all tables.\n      **\n      ** The first loop just checks to see if there are any "*" operators\n      ** that need expanding.\n      */\n      for ( k = 0 ; k < pEList.nExpr ; k++ )\n      {\n        Expr pE = pEList.a[k].pExpr;\n        if ( pE.op == TK_ALL ) break;\n        Debug.Assert( pE.op != TK_DOT || pE.pRight != null );\n        Debug.Assert( pE.op != TK_DOT || ( pE.pLeft != null && pE.pLeft.op == TK_ID ) );\n        if ( pE.op == TK_DOT && pE.pRight.op == TK_ALL ) break;\n      }\n      if ( k < pEList.nExpr )\n      {\n        /*\n        ** If we get here it means the result set contains one or more "*"\n        ** operators that need to be expanded.  Loop through each expression\n        ** in the result set and expand them one by one.\n        */\n        ExprList_item[] a = pEList.a;\n        ExprList pNew = null;\n        int flags = pParse.db.flags;\n        bool longNames = ( flags & SQLITE_FullColNames ) != 0\n        && ( flags & SQLITE_ShortColNames ) == 0;\n\n        for ( k = 0 ; k < pEList.nExpr ; k++ )\n        {\n          Expr pE = a[k].pExpr;\n          Debug.Assert( pE.op != TK_DOT || pE.pRight != null );\n          if ( pE.op != TK_ALL && ( pE.op != TK_DOT || pE.pRight.op != TK_ALL ) )\n          {\n            /* This particular expression does not need to be expanded.\n            */\n            pNew = sqlite3ExprListAppend( pParse, pNew, a[k].pExpr );\n            if ( pNew != null )\n            {\n              pNew.a[pNew.nExpr - 1].zName = a[k].zName;\n              pNew.a[pNew.nExpr - 1].zSpan = a[k].zSpan;\n              a[k].zName = null;\n              a[k].zSpan = null;\n            }\n            a[k].pExpr = null;\n          }\n          else\n          {\n            /* This expression is a "*" or a "TABLE.*" and needs to be\n            ** expanded. */\n            int tableSeen = 0;      /* Set to 1 when TABLE matches */\n            string zTName;            /* text of name of TABLE */\n            if ( pE.op == TK_DOT )\n            {\n              Debug.Assert( pE.pLeft != null );\n              Debug.Assert( !ExprHasProperty( pE.pLeft, EP_IntValue ) );\n              zTName = pE.pLeft.u.zToken;\n            }\n            else\n            {\n              zTName = null;\n            }\n            for ( i = 0 ; i < pTabList.nSrc ; i++ )//, pFrom++ )\n            {\n              pFrom = pTabList.a[i];\n              Table pTab = pFrom.pTab;\n              string zTabName = pFrom.zAlias;\n              if ( zTabName == null )\n              {\n                zTabName = pTab.zName;\n              }\n              ///if ( db.mallocFailed != 0 ) break;\n              if ( zTName != null && sqlite3StrICmp( zTName, zTabName ) != 0 )\n              {\n                continue;\n              }\n              tableSeen = 1;\n              for ( j = 0 ; j < pTab.nCol ; j++ )\n              {\n                Expr pExpr, pRight;\n                string zName = pTab.aCol[j].zName;\n                string zColname;  /* The computed column name */\n                string zToFree;   /* Malloced string that needs to be freed */\n                Token sColname = new Token();   /* Computed column name as a token */\n\n                /* If a column is marked as \'hidden\' (currently only possible\n                ** for virtual tables), do not include it in the expanded\n                ** result-set list.\n                */\n                if ( IsHiddenColumn( pTab.aCol[j] ) )\n                {\n                  Debug.Assert( IsVirtual( pTab ) );\n                  continue;\n                }\n\n                if ( i > 0 && ( zTName == null || zTName.Length == 0 ) )\n                {\n                  SrcList_item pLeft = pTabList.a[i - 1];\n                  if ( ( pTabList.a[i].jointype & JT_NATURAL ) != 0 &&//pLeft[1]\n                  columnIndex( pLeft.pTab, zName ) >= 0 )\n                  {\n                    /* In a NATURAL join, omit the join columns from the\n                    ** table on the right */\n                    continue;\n                  }\n                  if ( sqlite3IdListIndex( pTabList.a[i].pUsing, zName ) >= 0 )//pLeft[1]\n                  {\n                    /* In a join with a USING clause, omit columns in the\n                    ** using clause from the table on the right. */\n                    continue;\n                  }\n                }\n                pRight = sqlite3Expr( db, TK_ID, zName );\n                zColname = zName;\n                zToFree = "";\n                if ( longNames || pTabList.nSrc > 1 )\n                {\n                  Expr pLeft;\n                  pLeft = sqlite3Expr( db, TK_ID, zTabName );\n                  pExpr = sqlite3PExpr( pParse, TK_DOT, pLeft, pRight, 0 );\n                  if ( longNames )\n                  {\n                    zColname = sqlite3MPrintf( db, "%s.%s", zTabName, zName );\n                    zToFree = zColname;\n                  }\n                }\n                else\n                {\n                  pExpr = pRight;\n                }\n                pNew = sqlite3ExprListAppend( pParse, pNew, pExpr );\n                sColname.z = zColname;\n                sColname.n = sqlite3Strlen30( zColname );\n                sqlite3ExprListSetName( pParse, pNew, sColname, 0 );\n                //sqlite3DbFree( db, zToFree );\n              }\n            }\n            if ( tableSeen == 0 )\n            {\n              if ( zTName != null )\n              {\n                sqlite3ErrorMsg( pParse, "no such table: %s", zTName );\n              }\n              else\n              {\n                sqlite3ErrorMsg( pParse, "no tables specified" );\n              }\n            }\n          }\n        }\n        sqlite3ExprListDelete( db, ref pEList );\n        p.pEList = pNew;\n      }\n#if SQLITE_MAX_COLUMN\nif( p.pEList && p.pEList.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] ){\nsqlite3ErrorMsg(pParse, "too many columns in result set");\n}\n#endif\n      return WRC_Continue;\n    }\n\n    /*\n    ** No-op routine for the parse-tree walker.\n    **\n    ** When this routine is the Walker.xExprCallback then expression trees\n    ** are walked without any actions being taken at each node.  Presumably,\n    ** when this routine is used for Walker.xExprCallback then\n    ** Walker.xSelectCallback is set to do something useful for every\n    ** subquery in the parser tree.\n    */\n    static int exprWalkNoop( Walker NotUsed, ref Expr NotUsed2 )\n    {\n      UNUSED_PARAMETER2( NotUsed, NotUsed2 );\n      return WRC_Continue;\n    }\n\n    /*\n    ** This routine "expands" a SELECT statement and all of its subqueries.\n    ** For additional information on what it means to "expand" a SELECT\n    ** statement, see the comment on the selectExpand worker callback above.\n    **\n    ** Expanding a SELECT statement is the first step in processing a\n    ** SELECT statement.  The SELECT statement must be expanded before\n    ** name resolution is performed.\n    **\n    ** If anything goes wrong, an error message is written into pParse.\n    ** The calling function can detect the problem by looking at pParse.nErr\n    ** and/or pParse.db.mallocFailed.\n    */\n    static void sqlite3SelectExpand( Parse pParse, Select pSelect )\n    {\n      Walker w = new Walker();\n      w.xSelectCallback = selectExpander;\n      w.xExprCallback = exprWalkNoop;\n      w.pParse = pParse;\n      sqlite3WalkSelect( w, pSelect );\n    }\n\n\n#if !SQLITE_OMIT_SUBQUERY\n    /*\n** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()\n** interface.\n**\n** For each FROM-clause subquery, add Column.zType and Column.zColl\n** information to the Table ure that represents the result set\n** of that subquery.\n**\n** The Table ure that represents the result set was coned\n** by selectExpander() but the type and collation information was omitted\n** at that point because identifiers had not yet been resolved.  This\n** routine is called after identifier resolution.\n*/\n    static int selectAddSubqueryTypeInfo( Walker pWalker, Select p )\n    {\n      Parse pParse;\n      int i;\n      SrcList pTabList;\n      SrcList_item pFrom;\n\n      Debug.Assert( ( p.selFlags & SF_Resolved ) != 0 );\n      Debug.Assert( ( p.selFlags & SF_HasTypeInfo ) == 0 );\n      p.selFlags |= SF_HasTypeInfo;\n      pParse = pWalker.pParse;\n      pTabList = p.pSrc;\n      for ( i = 0 ; i < pTabList.nSrc ; i++ )//, pFrom++ )\n      {\n        pFrom = pTabList.a[i];\n        Table pTab = pFrom.pTab;\n        if ( ALWAYS( pTab != null ) && ( pTab.tabFlags & TF_Ephemeral ) != 0 )\n        {\n          /* A sub-query in the FROM clause of a SELECT */\n          Select pSel = pFrom.pSelect;\n          Debug.Assert( pSel != null );\n          while ( pSel.pPrior != null ) pSel = pSel.pPrior;\n          selectAddColumnTypeAndCollation( pParse, pTab.nCol, pTab.aCol, pSel );\n        }\n      }\n      return WRC_Continue;\n    }\n#endif\n\n\n    /*\n** This routine adds datatype and collating sequence information to\n** the Table ures of all FROM-clause subqueries in a\n** SELECT statement.\n**\n** Use this routine after name resolution.\n*/\n    static void sqlite3SelectAddTypeInfo( Parse pParse, Select pSelect )\n    {\n#if !SQLITE_OMIT_SUBQUERY\n      Walker w = new Walker();\n      w.xSelectCallback = selectAddSubqueryTypeInfo;\n      w.xExprCallback = exprWalkNoop;\n      w.pParse = pParse;\n      sqlite3WalkSelect( w, pSelect );\n#endif\n    }\n\n\n    /*\n    ** This routine sets of a SELECT statement for processing.  The\n    ** following is accomplished:\n    **\n    **     *  VDBE VdbeCursor numbers are assigned to all FROM-clause terms.\n    **     *  Ephemeral Table objects are created for all FROM-clause subqueries.\n    **     *  ON and USING clauses are shifted into WHERE statements\n    **     *  Wildcards "*" and "TABLE.*" in result sets are expanded.\n    **     *  Identifiers in expression are matched to tables.\n    **\n    ** This routine acts recursively on all subqueries within the SELECT.\n    */\n    static void sqlite3SelectPrep(\n    Parse pParse,         /* The parser context */\n    Select p,             /* The SELECT statement being coded. */\n    NameContext pOuterNC  /* Name context for container */\n    )\n    {\n      sqlite3 db;\n      if ( NEVER( p == null ) ) return;\n      db = pParse.db;\n      if ( ( p.selFlags & SF_HasTypeInfo ) != 0 ) return;\n      sqlite3SelectExpand( pParse, p );\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ ) return;\n      sqlite3ResolveSelectNames( pParse, p, pOuterNC );\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ ) return;\n      sqlite3SelectAddTypeInfo( pParse, p );\n    }\n\n    /*\n    ** Reset the aggregate accumulator.\n    **\n    ** The aggregate accumulator is a set of memory cells that hold\n    ** intermediate results while calculating an aggregate.  This\n    ** routine simply stores NULLs in all of those memory cells.\n    */\n    static void resetAccumulator( Parse pParse, AggInfo pAggInfo )\n    {\n      Vdbe v = pParse.pVdbe;\n      int i;\n      AggInfo_func pFunc;\n      if ( pAggInfo.nFunc + pAggInfo.nColumn == 0 )\n      {\n        return;\n      }\n      for ( i = 0 ; i < pAggInfo.nColumn ; i++ )\n      {\n        sqlite3VdbeAddOp2( v, OP_Null, 0, pAggInfo.aCol[i].iMem );\n      }\n      for ( i = 0 ; i < pAggInfo.nFunc ; i++ )\n      {//, pFunc++){\n        pFunc = pAggInfo.aFunc[i];\n        sqlite3VdbeAddOp2( v, OP_Null, 0, pFunc.iMem );\n        if ( pFunc.iDistinct >= 0 )\n        {\n          Expr pE = pFunc.pExpr;\n          Debug.Assert( !ExprHasProperty( pE, EP_xIsSelect ) );\n          if ( pE.x.pList == null || pE.x.pList.nExpr != 1 )\n          {\n            sqlite3ErrorMsg( pParse, "DISTINCT aggregates must have exactly one " +\n            "argument" );\n            pFunc.iDistinct = -1;\n          }\n          else\n          {\n            KeyInfo pKeyInfo = keyInfoFromExprList( pParse, pE.x.pList );\n            sqlite3VdbeAddOp4( v, OP_OpenEphemeral, pFunc.iDistinct, 0, 0,\n            pKeyInfo, P4_KEYINFO_HANDOFF );\n          }\n        }\n      }\n    }\n\n    /*\n    ** Invoke the OP_AggFinalize opcode for every aggregate function\n    ** in the AggInfo structure.\n    */\n    static void finalizeAggFunctions( Parse pParse, AggInfo pAggInfo )\n    {\n      Vdbe v = pParse.pVdbe;\n      int i;\n      AggInfo_func pF;\n      for ( i = 0 ; i < pAggInfo.nFunc ; i++ )\n      {//, pF++){\n        pF = pAggInfo.aFunc[i];\n        ExprList pList = pF.pExpr.x.pList;\n        Debug.Assert( !ExprHasProperty( pF.pExpr, EP_xIsSelect ) );\n        sqlite3VdbeAddOp4( v, OP_AggFinal, pF.iMem, pList != null ? pList.nExpr : 0, 0,\n        pF.pFunc, P4_FUNCDEF );\n      }\n    }\n\n    /*\n    ** Update the accumulator memory cells for an aggregate based on\n    ** the current cursor position.\n    */\n    static void updateAccumulator( Parse pParse, AggInfo pAggInfo )\n    {\n      Vdbe v = pParse.pVdbe;\n      int i;\n      AggInfo_func pF;\n      AggInfo_col pC;\n\n      pAggInfo.directMode = 1;\n      sqlite3ExprCacheClear( pParse );\n      for ( i = 0 ; i < pAggInfo.nFunc ; i++ )\n      {//, pF++){\n        pF = pAggInfo.aFunc[i];\n        int nArg;\n        int addrNext = 0;\n        int regAgg;\n        Debug.Assert( !ExprHasProperty( pF.pExpr, EP_xIsSelect ) );\n        ExprList pList = pF.pExpr.x.pList;\n        if ( pList != null )\n        {\n          nArg = pList.nExpr;\n          regAgg = sqlite3GetTempRange( pParse, nArg );\n          sqlite3ExprCodeExprList( pParse, pList, regAgg, false );\n        }\n        else\n        {\n          nArg = 0;\n          regAgg = 0;\n        }\n        if ( pF.iDistinct >= 0 )\n        {\n          addrNext = sqlite3VdbeMakeLabel( v );\n          Debug.Assert( nArg == 1 );\n          codeDistinct( pParse, pF.iDistinct, addrNext, 1, regAgg );\n        }\n        if ( ( pF.pFunc.flags & SQLITE_FUNC_NEEDCOLL ) != 0 )\n        {\n          CollSeq pColl = null;\n          ExprList_item pItem;\n          int j;\n          Debug.Assert( pList != null );  /* pList!=0 if pF->pFunc has NEEDCOLL */\n          for ( j = 0 ; pColl == null && j < nArg ; j++ )\n          {//, pItem++){\n            pItem = pList.a[j];\n            pColl = sqlite3ExprCollSeq( pParse, pItem.pExpr );\n          }\n          if ( pColl == null )\n          {\n            pColl = pParse.db.pDfltColl;\n          }\n          sqlite3VdbeAddOp4( v, OP_CollSeq, 0, 0, 0, pColl, P4_COLLSEQ );\n        }\n        sqlite3VdbeAddOp4( v, OP_AggStep, 0, regAgg, pF.iMem,\n        pF.pFunc, P4_FUNCDEF );\n        sqlite3VdbeChangeP5( v, (u8)nArg );\n        sqlite3ReleaseTempRange( pParse, regAgg, nArg );\n        sqlite3ExprCacheAffinityChange( pParse, regAgg, nArg );\n        if ( addrNext != 0 )\n        {\n          sqlite3VdbeResolveLabel( v, addrNext );\n          sqlite3ExprCacheClear( pParse );\n        }\n      }\n      for ( i = 0 ; i < pAggInfo.nAccumulator ; i++ )//, pC++)\n      {\n        pC = pAggInfo.aCol[i];\n        sqlite3ExprCode( pParse, pC.pExpr, pC.iMem );\n      }\n      pAggInfo.directMode = 0;\n      sqlite3ExprCacheClear( pParse );\n    }\n\n    /*\n    ** Generate code for the SELECT statement given in the p argument.\n    **\n    ** The results are distributed in various ways depending on the\n    ** contents of the SelectDest structure pointed to by argument pDest\n    ** as follows:\n    **\n    **     pDest.eDest    Result\n    **     ------------    -------------------------------------------\n    **     SRT_Output      Generate a row of output (using the OP_ResultRow\n    **                     opcode) for each row in the result set.\n    **\n    **     SRT_Mem         Only valid if the result is a single column.\n    **                     Store the first column of the first result row\n    **                     in register pDest.iParm then abandon the rest\n    **                     of the query.  This destination implies "LIMIT 1".\n    **\n    **     SRT_Set         The result must be a single column.  Store each\n    **                     row of result as the key in table pDest.iParm.\n    **                     Apply the affinity pDest.affinity before storing\n    **                     results.  Used to implement "IN (SELECT ...)".\n    **\n    **     SRT_Union       Store results as a key in a temporary table pDest.iParm.\n    **\n    **     SRT_Except      Remove results from the temporary table pDest.iParm.\n    **\n    **     SRT_Table       Store results in temporary table pDest.iParm.\n    **                     This is like SRT_EphemTab except that the table\n    **                     is assumed to already be open.\n    **\n    **     SRT_EphemTab    Create an temporary table pDest.iParm and store\n    **                     the result there. The cursor is left open after\n    **                     returning.  This is like SRT_Table except that\n    **                     this destination uses OP_OpenEphemeral to create\n    **                     the table first.\n    **\n    **     SRT_Coroutine   Generate a co-routine that returns a new row of\n    **                     results each time it is invoked.  The entry point\n    **                     of the co-routine is stored in register pDest.iParm.\n    **\n    **     SRT_Exists      Store a 1 in memory cell pDest.iParm if the result\n    **                     set is not empty.\n    **\n    **     SRT_Discard     Throw the results away.  This is used by SELECT\n    **                     statements within triggers whose only purpose is\n    **                     the side-effects of functions.\n    **\n    ** This routine returns the number of errors.  If any errors are\n    ** encountered, then an appropriate error message is left in\n    ** pParse.zErrMsg.\n    **\n    ** This routine does NOT free the Select structure passed in.  The\n    ** calling function needs to do that.\n    */\n    static SelectDest sdDummy = null;\n    static bool bDummy = false;\n\n    static int sqlite3Select(\n    Parse pParse,         /* The parser context */\n    Select p,             /* The SELECT statement being coded. */\n    ref SelectDest pDest /* What to do with the query results */\n    )\n    {\n      int i, j;               /* Loop counters */\n      WhereInfo pWInfo;       /* Return from sqlite3WhereBegin() */\n      Vdbe v;                 /* The virtual machine under construction */\n      bool isAgg;             /* True for select lists like "count(*)" */\n      ExprList pEList = new ExprList();      /* List of columns to extract. */\n      SrcList pTabList = new SrcList();     /* List of tables to select from */\n      Expr pWhere;            /* The WHERE clause.  May be NULL */\n      ExprList pOrderBy;      /* The ORDER BY clause.  May be NULL */\n      ExprList pGroupBy;      /* The GROUP BY clause.  May be NULL */\n      Expr pHaving;           /* The HAVING clause.  May be NULL */\n      bool isDistinct;        /* True if the DISTINCT keyword is present */\n      int distinct;           /* Table to use for the distinct set */\n      int rc = 1;             /* Value to return from this function */\n      int addrSortIndex;      /* Address of an OP_OpenEphemeral instruction */\n      AggInfo sAggInfo;       /* Information used by aggregate queries */\n      int iEnd;               /* Address of the end of the query */\n      sqlite3 db;             /* The database connection */\n\n      db = pParse.db;\n      if ( p == null /*|| db.mallocFailed != 0 */ || pParse.nErr != 0 )\n      {\n        return 1;\n      }\n#if !SQLITE_OMIT_AUTHORIZATION\nif (sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0)) return 1;\n#endif\n      sAggInfo = new AggInfo();// memset(sAggInfo, 0, sAggInfo).Length;\n\n      if ( pDest.eDest <= SRT_Discard ) //IgnorableOrderby(pDest))\n      {\n        Debug.Assert( pDest.eDest == SRT_Exists || pDest.eDest == SRT_Union ||\n        pDest.eDest == SRT_Except || pDest.eDest == SRT_Discard );\n        /* If ORDER BY makes no difference in the output then neither does\n        ** DISTINCT so it can be removed too. */\n        sqlite3ExprListDelete( db, ref p.pOrderBy );\n        p.pOrderBy = null;\n        p.selFlags = (u16)( p.selFlags & ~SF_Distinct );\n      }\n      sqlite3SelectPrep( pParse, p, null );\n      pOrderBy = p.pOrderBy;\n      pTabList = p.pSrc;\n      pEList = p.pEList;\n      if ( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ )\n      {\n        goto select_end;\n      }\n      isAgg = ( p.selFlags & SF_Aggregate ) != 0;\n      Debug.Assert( pEList != null );\n\n      /* Begin generating code.\n      */\n      v = sqlite3GetVdbe( pParse );\n      if ( v == null ) goto select_end;\n\n      /* Generate code for all sub-queries in the FROM clause\n      */\n#if !SQLITE_OMIT_SUBQUERY || !SQLITE_OMIT_VIEW\n      for ( i = 0 ; p.pPrior == null && i < pTabList.nSrc ; i++ )\n      {\n        SrcList_item pItem = pTabList.a[i];\n        SelectDest dest = new SelectDest();\n        Select pSub = pItem.pSelect;\n        bool isAggSub;\n\n        if ( pSub == null || pItem.isPopulated != 0 ) continue;\n\n        /* Increment Parse.nHeight by the height of the largest expression\n        ** tree refered to by this, the parent select. The child select\n        ** may contain expression trees of at most\n        ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n        ** more conservative than necessary, but much easier than enforcing\n        ** an exact limit.\n        */\n        pParse.nHeight += sqlite3SelectExprHeight( p );\n\n        /* Check to see if the subquery can be absorbed into the parent. */\n        isAggSub = ( pSub.selFlags & SF_Aggregate ) != 0;\n        if ( flattenSubquery( pParse, p, i, isAgg, isAggSub ) != 0 )\n        {\n          if ( isAggSub )\n          {\n            isAgg = true;\n            p.selFlags |= SF_Aggregate;\n          }\n          i = -1;\n        }\n        else\n        {\n          sqlite3SelectDestInit( dest, SRT_EphemTab, pItem.iCursor );\n          Debug.Assert( 0 == pItem.isPopulated );\n          sqlite3Select( pParse, pSub, ref dest );\n          pItem.isPopulated = 1;\n        }\n        //if ( /* pParse.nErr != 0 || */ db.mallocFailed != 0 )\n        //{\n        //  goto select_end;\n        //}\n        pParse.nHeight -= sqlite3SelectExprHeight( p );\n        pTabList = p.pSrc;\n        if ( !( pDest.eDest <= SRT_Discard ) )//        if( !IgnorableOrderby(pDest) )\n        {\n          pOrderBy = p.pOrderBy;\n        }\n      }\n      pEList = p.pEList;\n#endif\n      pWhere = p.pWhere;\n      pGroupBy = p.pGroupBy;\n      pHaving = p.pHaving;\n      isDistinct = ( p.selFlags & SF_Distinct ) != 0;\n\n#if  !SQLITE_OMIT_COMPOUND_SELECT\n      /* If there is are a sequence of queries, do the earlier ones first.\n*/\n      if ( p.pPrior != null )\n      {\n        if ( p.pRightmost == null )\n        {\n          Select pLoop, pRight = null;\n          int cnt = 0;\n          int mxSelect;\n          for ( pLoop = p ; pLoop != null ; pLoop = pLoop.pPrior, cnt++ )\n          {\n            pLoop.pRightmost = p;\n            pLoop.pNext = pRight;\n            pRight = pLoop;\n          }\n          mxSelect = db.aLimit[SQLITE_LIMIT_COMPOUND_SELECT];\n          if ( mxSelect != 0 && cnt > mxSelect )\n          {\n            sqlite3ErrorMsg( pParse, "too many terms in compound SELECT" );\n            return 1;\n          }\n        }\n        return multiSelect( pParse, p, pDest );\n      }\n#endif\n\n      /* If writing to memory or generating a set\n** only a single column may be output.\n*/\n#if  !SQLITE_OMIT_SUBQUERY\n      if ( checkForMultiColumnSelectError( pParse, pDest, pEList.nExpr ) )\n      {\n        goto select_end;\n      }\n#endif\n      /* If possible, rewrite the query to use GROUP BY instead of DISTINCT.\n** GROUP BY might use an index, DISTINCT never does.\n*/\n      Debug.Assert( p.pGroupBy == null || ( p.selFlags & SF_Aggregate ) != 0 );\n      if ( ( p.selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct )\n      {\n        p.pGroupBy = sqlite3ExprListDup( db, p.pEList, 0 );\n        pGroupBy = p.pGroupBy;\n        p.selFlags = (u16)( p.selFlags & ~SF_Distinct );\n        isDistinct = false;\n      }\n\n      /* If there is an ORDER BY clause, then this sorting\n      ** index might end up being unused if the data can be\n      ** extracted in pre-sorted order.  If that is the case, then the\n      ** OP_OpenEphemeral instruction will be changed to an OP_Noop once\n      ** we figure out that the sorting index is not needed.  The addrSortIndex\n      ** variable is used to facilitate that change.\n      */\n      if ( pOrderBy != null )\n      {\n        KeyInfo pKeyInfo;\n        pKeyInfo = keyInfoFromExprList( pParse, pOrderBy );\n        pOrderBy.iECursor = pParse.nTab++;\n        p.addrOpenEphm[2] = addrSortIndex =\n        sqlite3VdbeAddOp4( v, OP_OpenEphemeral,\n        pOrderBy.iECursor, pOrderBy.nExpr + 2, 0,\n        pKeyInfo, P4_KEYINFO_HANDOFF );\n      }\n      else\n      {\n        addrSortIndex = -1;\n      }\n\n      /* If the output is destined for a temporary table, open that table.\n      */\n      if ( pDest.eDest == SRT_EphemTab )\n      {\n        sqlite3VdbeAddOp2( v, OP_OpenEphemeral, pDest.iParm, pEList.nExpr );\n      }\n\n      /* Set the limiter.\n      */\n      iEnd = sqlite3VdbeMakeLabel( v );\n      computeLimitRegisters( pParse, p, iEnd );\n\n      /* Open a virtual index to use for the distinct set.\n      */\n      if ( isDistinct )\n      {\n        KeyInfo pKeyInfo;\n        Debug.Assert( isAgg || pGroupBy != null );\n        distinct = pParse.nTab++;\n        pKeyInfo = keyInfoFromExprList( pParse, p.pEList );\n        sqlite3VdbeAddOp4( v, OP_OpenEphemeral, distinct, 0, 0,\n        pKeyInfo, P4_KEYINFO_HANDOFF );\n      }\n      else\n      {\n        distinct = -1;\n      }\n\n      /* Aggregate and non-aggregate queries are handled differently */\n      if ( !isAgg && pGroupBy == null )\n      {\n        /* This case is for non-aggregate queries\n        ** Begin the database scan\n        */\n        pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref pOrderBy, 0 );\n        if ( pWInfo == null ) goto select_end;\n\n        /* If sorting index that was created by a prior OP_OpenEphemeral\n        ** instruction ended up not being needed, then change the OP_OpenEphemeral\n        ** into an OP_Noop.\n        */\n        if ( addrSortIndex >= 0 && pOrderBy == null )\n        {\n          sqlite3VdbeChangeToNoop( v, addrSortIndex, 1 );\n          p.addrOpenEphm[2] = -1;\n        }\n\n        /* Use the standard inner loop\n        */\n        Debug.Assert( !isDistinct );\n        selectInnerLoop( pParse, p, pEList, 0, 0, pOrderBy, -1, pDest,\n        pWInfo.iContinue, pWInfo.iBreak );\n\n        /* End the database scan loop.\n        */\n        sqlite3WhereEnd( pWInfo );\n      }\n      else\n      {\n        /* This is the processing for aggregate queries */\n        NameContext sNC;    /* Name context for processing aggregate information */\n        int iAMem;          /* First Mem address for storing current GROUP BY */\n        int iBMem;          /* First Mem address for previous GROUP BY */\n        int iUseFlag;       /* Mem address holding flag indicating that at least\n** one row of the input to the aggregator has been\n** processed */\n        int iAbortFlag;     /* Mem address which causes query abort if positive */\n        int groupBySort;    /* Rows come from source in GR BY\' clause thanROUP BY order */\n\n        int addrEnd;        /* End of processing for this SELECT */\n\n        /* Remove any and all aliases between the result set and the\n        ** GROUP BY clause.\n        */\n        if ( pGroupBy != null )\n        {\n          int k;                        /* Loop counter */\n          ExprList_item pItem;          /* For looping over expression in a list */\n\n          for ( k = p.pEList.nExpr ; k > 0 ; k-- )//, pItem++)\n          {\n            pItem = p.pEList.a[p.pEList.nExpr - k];\n            pItem.iAlias = 0;\n          }\n          for ( k = pGroupBy.nExpr ; k > 0 ; k-- )//, pItem++ )\n          {\n            pItem = pGroupBy.a[pGroupBy.nExpr - k];\n            pItem.iAlias = 0;\n          }\n        }\n\n        /* Create a label to jump to when we want to abort the query */\n        addrEnd = sqlite3VdbeMakeLabel( v );\n\n        /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n        ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n        ** SELECT statement.\n        */\n        sNC = new NameContext(); // memset(sNC, 0, sNC).Length;\n        sNC.pParse = pParse;\n        sNC.pSrcList = pTabList;\n        sNC.pAggInfo = sAggInfo;\n        sAggInfo.nSortingColumn = pGroupBy != null ? pGroupBy.nExpr + 1 : 0;\n        sAggInfo.pGroupBy = pGroupBy;\n        sqlite3ExprAnalyzeAggList( sNC, pEList );\n        sqlite3ExprAnalyzeAggList( sNC, pOrderBy );\n        if ( pHaving != null )\n        {\n          sqlite3ExprAnalyzeAggregates( sNC, ref pHaving );\n        }\n        sAggInfo.nAccumulator = sAggInfo.nColumn;\n        for ( i = 0 ; i < sAggInfo.nFunc ; i++ )\n        {\n          Debug.Assert( !ExprHasProperty( sAggInfo.aFunc[i].pExpr, EP_xIsSelect ) );\n          sqlite3ExprAnalyzeAggList( sNC, sAggInfo.aFunc[i].pExpr.x.pList );\n        }\n  //      if ( db.mallocFailed != 0 ) goto select_end;\n\n        /* Processing for aggregates with GROUP BY is very different and\n        ** much more complex than aggregates without a GROUP BY.\n        */\n        if ( pGroupBy != null )\n        {\n          KeyInfo pKeyInfo;  /* Keying information for the group by clause */\n          int j1;             /* A-vs-B comparision jump */\n          int addrOutputRow;  /* Start of subroutine that outputs a result row */\n          int regOutputRow;   /* Return address register for output subroutine */\n          int addrSetAbort;   /* Set the abort flag and return */\n          int addrTopOfLoop;  /* Top of the input loop */\n          int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n          int addrReset;      /* Subroutine for resetting the accumulator */\n          int regReset;       /* Return address register for reset subroutine */\n\n          /* If there is a GROUP BY clause we might need a sorting index to\n          ** implement it.  Allocate that sorting index now.  If it turns out\n          ** that we do not need it after all, the OpenEphemeral instruction\n          ** will be converted into a Noop.\n          */\n          sAggInfo.sortingIdx = pParse.nTab++;\n          pKeyInfo = keyInfoFromExprList( pParse, pGroupBy );\n          addrSortingIdx = sqlite3VdbeAddOp4( v, OP_OpenEphemeral,\n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn,\n          0, pKeyInfo, P4_KEYINFO_HANDOFF );\n\n          /* Initialize memory locations used by GROUP BY aggregate processing\n          */\n          iUseFlag = ++pParse.nMem;\n          iAbortFlag = ++pParse.nMem;\n          regOutputRow = ++pParse.nMem;\n          addrOutputRow = sqlite3VdbeMakeLabel( v );\n          regReset = ++pParse.nMem;\n          addrReset = sqlite3VdbeMakeLabel( v );\n          iAMem = pParse.nMem + 1;\n          pParse.nMem += pGroupBy.nExpr;\n          iBMem = pParse.nMem + 1;\n          pParse.nMem += pGroupBy.nExpr;\n          sqlite3VdbeAddOp2( v, OP_Integer, 0, iAbortFlag );\n#if SQLITE_DEBUG\n          VdbeComment( v, "clear abort flag" );\n#endif\n          sqlite3VdbeAddOp2( v, OP_Integer, 0, iUseFlag );\n#if SQLITE_DEBUG\n          VdbeComment( v, "indicate accumulator empty" );\n#endif\n\n          /* Begin a loop that will extract all source rows in GROUP BY order.\n** This might involve two separate loops with an OP_Sort in between, or\n** it might be a single loop that uses an index to extract information\n** in the right order to begin with.\n*/\n          sqlite3VdbeAddOp2( v, OP_Gosub, regReset, addrReset );\n          pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref pGroupBy, 0 );\n          if ( pWInfo == null ) goto select_end;\n          if ( pGroupBy == null )\n          {\n            /* The optimizer is able to deliver rows in group by order so\n            ** we do not have to sort.  The OP_OpenEphemeral table will be\n            ** cancelled later because we still need to use the pKeyInfo\n            */\n            pGroupBy = p.pGroupBy;\n            groupBySort = 0;\n          }\n          else\n          {\n            /* Rows are coming out in undetermined order.  We have to push\n            ** each row into a sorting index, terminate the first loop,\n            ** then loop over the sorting index in order to get the output\n            ** in sorted order\n            */\n            int regBase;\n            int regRecord;\n            int nCol;\n            int nGroupBy;\n\n            groupBySort = 1;\n            nGroupBy = pGroupBy.nExpr;\n            nCol = nGroupBy + 1;\n            j = nGroupBy + 1;\n            for ( i = 0 ; i < sAggInfo.nColumn ; i++ )\n            {\n              if ( sAggInfo.aCol[i].iSorterColumn >= j )\n              {\n                nCol++;\n                j++;\n              }\n            }\n            regBase = sqlite3GetTempRange( pParse, nCol );\n            sqlite3ExprCacheClear( pParse );\n            sqlite3ExprCodeExprList( pParse, pGroupBy, regBase, false );\n            sqlite3VdbeAddOp2( v, OP_Sequence, sAggInfo.sortingIdx, regBase + nGroupBy );\n            j = nGroupBy + 1;\n            for ( i = 0 ; i < sAggInfo.nColumn ; i++ )\n            {\n              AggInfo_col pCol = sAggInfo.aCol[i];\n              if ( pCol.iSorterColumn >= j )\n              {\n                int r1 = j + regBase;\n                int r2;\n                r2 = sqlite3ExprCodeGetColumn( pParse,\n                pCol.pTab, pCol.iColumn, pCol.iTable, r1, false );\n                if ( r1 != r2 )\n                {\n                  sqlite3VdbeAddOp2( v, OP_SCopy, r2, r1 );\n                }\n                j++;\n              }\n            }\n            regRecord = sqlite3GetTempReg( pParse );\n            sqlite3VdbeAddOp3( v, OP_MakeRecord, regBase, nCol, regRecord );\n            sqlite3VdbeAddOp2( v, OP_IdxInsert, sAggInfo.sortingIdx, regRecord );\n            sqlite3ReleaseTempReg( pParse, regRecord );\n            sqlite3ReleaseTempRange( pParse, regBase, nCol );\n            sqlite3WhereEnd( pWInfo );\n            sqlite3VdbeAddOp2( v, OP_Sort, sAggInfo.sortingIdx, addrEnd );\n#if SQLITE_DEBUG\n            VdbeComment( v, "GROUP BY sort" );\n#endif\n            sAggInfo.useSortingIdx = 1;\n            sqlite3ExprCacheClear( pParse );\n          }\n\n          /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n          ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n          ** Then compare the current GROUP BY terms against the GROUP BY terms\n          ** from the previous row currently stored in a0, a1, a2...\n          */\n          addrTopOfLoop = sqlite3VdbeCurrentAddr( v );\n          sqlite3ExprCacheClear( pParse );\n          for ( j = 0 ; j < pGroupBy.nExpr ; j++ )\n          {\n            if ( groupBySort != 0 )\n            {\n              sqlite3VdbeAddOp3( v, OP_Column, sAggInfo.sortingIdx, j, iBMem + j );\n            }\n            else\n            {\n              sAggInfo.directMode = 1;\n              sqlite3ExprCode( pParse, pGroupBy.a[j].pExpr, iBMem + j );\n            }\n          }\n          sqlite3VdbeAddOp4( v, OP_Compare, iAMem, iBMem, pGroupBy.nExpr,\n          pKeyInfo, P4_KEYINFO );\n          j1 = sqlite3VdbeCurrentAddr( v );\n          sqlite3VdbeAddOp3( v, OP_Jump, j1 + 1, 0, j1 + 1 );\n\n          /* Generate code that runs whenever the GROUP BY changes.\n          ** Changes in the GROUP BY are detected by the previous code\n          ** block.  If there were no changes, this block is skipped.\n          **\n          ** This code copies current group by terms in b0,b1,b2,...\n          ** over to a0,a1,a2.  It then calls the output subroutine\n          ** and resets the aggregate accumulator registers in preparation\n          ** for the next GROUP BY batch.\n          */\n          sqlite3ExprCodeMove( pParse, iBMem, iAMem, pGroupBy.nExpr );\n          sqlite3VdbeAddOp2( v, OP_Gosub, regOutputRow, addrOutputRow );\n#if SQLITE_DEBUG\n          VdbeComment( v, "output one row" );\n#endif\n          sqlite3VdbeAddOp2( v, OP_IfPos, iAbortFlag, addrEnd );\n#if SQLITE_DEBUG\n          VdbeComment( v, "check abort flag" );\n#endif\n          sqlite3VdbeAddOp2( v, OP_Gosub, regReset, addrReset );\n#if SQLITE_DEBUG\n          VdbeComment( v, "reset accumulator" );\n#endif\n\n          /* Update the aggregate accumulators based on the content of\n** the current row\n*/\n          sqlite3VdbeJumpHere( v, j1 );\n          updateAccumulator( pParse, sAggInfo );\n          sqlite3VdbeAddOp2( v, OP_Integer, 1, iUseFlag );\n#if SQLITE_DEBUG\n          VdbeComment( v, "indicate data in accumulator" );\n#endif\n          /* End of the loop\n*/\n          if ( groupBySort != 0 )\n          {\n            sqlite3VdbeAddOp2( v, OP_Next, sAggInfo.sortingIdx, addrTopOfLoop );\n          }\n          else\n          {\n            sqlite3WhereEnd( pWInfo );\n            sqlite3VdbeChangeToNoop( v, addrSortingIdx, 1 );\n          }\n\n          /* Output the final row of result\n          */\n          sqlite3VdbeAddOp2( v, OP_Gosub, regOutputRow, addrOutputRow );\n#if SQLITE_DEBUG\n          VdbeComment( v, "output final row" );\n#endif\n          /* Jump over the subroutines\n*/\n          sqlite3VdbeAddOp2( v, OP_Goto, 0, addrEnd );\n\n          /* Generate a subroutine that outputs a single row of the result\n          ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n          ** is less than or equal to zero, the subroutine is a no-op.  If\n          ** the processing calls for the query to abort, this subroutine\n          ** increments the iAbortFlag memory location before returning in\n          ** order to signal the caller to abort.\n          */\n          addrSetAbort = sqlite3VdbeCurrentAddr( v );\n          sqlite3VdbeAddOp2( v, OP_Integer, 1, iAbortFlag );\n          VdbeComment( v, "set abort flag" );\n          sqlite3VdbeAddOp1( v, OP_Return, regOutputRow );\n          sqlite3VdbeResolveLabel( v, addrOutputRow );\n          addrOutputRow = sqlite3VdbeCurrentAddr( v );\n          sqlite3VdbeAddOp2( v, OP_IfPos, iUseFlag, addrOutputRow + 2 );\n          VdbeComment( v, "Groupby result generator entry point" );\n          sqlite3VdbeAddOp1( v, OP_Return, regOutputRow );\n          finalizeAggFunctions( pParse, sAggInfo );\n          sqlite3ExprIfFalse( pParse, pHaving, addrOutputRow + 1, SQLITE_JUMPIFNULL );\n          selectInnerLoop( pParse, p, p.pEList, 0, 0, pOrderBy,\n          distinct, pDest,\n          addrOutputRow + 1, addrSetAbort );\n          sqlite3VdbeAddOp1( v, OP_Return, regOutputRow );\n          VdbeComment( v, "end groupby result generator" );\n\n          /* Generate a subroutine that will reset the group-by accumulator\n          */\n          sqlite3VdbeResolveLabel( v, addrReset );\n          resetAccumulator( pParse, sAggInfo );\n          sqlite3VdbeAddOp1( v, OP_Return, regReset );\n\n        } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n        else\n        {\n          ExprList pDel = null;\n#if !SQLITE_OMIT_BTREECOUNT\n          Table pTab;\n          if ( ( pTab = isSimpleCount( p, sAggInfo ) ) != null )\n          {\n            /* If isSimpleCount() returns a pointer to a Table structure, then\n            ** the SQL statement is of the form:\n            **\n            **   SELECT count(*) FROM <tbl>\n            **\n            ** where the Table structure returned represents table <tbl>.\n            **\n            ** This statement is so common that it is optimized specially. The\n            ** OP_Count instruction is executed either on the intkey table that\n            ** contains the data for table <tbl> or on one of its indexes. It\n            ** is better to execute the op on an index, as indexes are almost\n            ** always spread across less pages than their corresponding tables.\n            */\n            int iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema );\n            int iCsr = pParse.nTab++;     /* Cursor to scan b-tree */\n            Index pIdx;                   /* Iterator variable */\n            KeyInfo pKeyInfo = null;      /* Keyinfo for scanned index */\n            Index pBest = null;           /* Best index found so far */\n            int iRoot = pTab.tnum;        /* Root page of scanned b-tree */\n\n            sqlite3CodeVerifySchema( pParse, iDb );\n            sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName );\n\n            /* Search for the index that has the least amount of columns. If\n            ** there is such an index, and it has less columns than the table\n            ** does, then we can assume that it consumes less space on disk and\n            ** will therefore be cheaper to scan to determine the query result.\n            ** In this case set iRoot to the root page number of the index b-tree\n            ** and pKeyInfo to the KeyInfo structure required to navigate the\n            ** index.\n            **\n            ** In practice the KeyInfo structure will not be used. It is only\n            ** passed to keep OP_OpenRead happy.\n            */\n            for ( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext )\n            {\n              if ( null == pBest || pIdx.nColumn < pBest.nColumn )\n              {\n                pBest = pIdx;\n              }\n            }\n            if ( pBest != null && pBest.nColumn < pTab.nCol )\n            {\n              iRoot = pBest.tnum;\n              pKeyInfo = sqlite3IndexKeyinfo( pParse, pBest );\n            }\n\n            /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n            sqlite3VdbeAddOp3( v, OP_OpenRead, iCsr, iRoot, iDb );\n            if ( pKeyInfo != null )\n            {\n              sqlite3VdbeChangeP4( v, -1, pKeyInfo, P4_KEYINFO_HANDOFF );\n            }\n            sqlite3VdbeAddOp2( v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem );\n            sqlite3VdbeAddOp1( v, OP_Close, iCsr );\n          }\n          else\n#endif //* SQLITE_OMIT_BTREECOUNT */\n          {\n\n            /* Check if the query is of one of the following forms:\n            **\n            **   SELECT min(x) FROM ...\n            **   SELECT max(x) FROM ...\n            **\n            ** If it is, then ask the code in where.c to attempt to sort results\n            ** as if there was an "ORDER ON x" or "ORDER ON x DESC" clause.\n            ** If where.c is able to produce results sorted in this order, then\n            ** add vdbe code to break out of the processing loop after the\n            ** first iteration (since the first iteration of the loop is\n            ** guaranteed to operate on the row with the minimum or maximum\n            ** value of x, the only row required).\n            **\n            ** A special flag must be passed to sqlite3WhereBegin() to slightly\n            ** modify behavior as follows:\n            **\n            **   + If the query is a "SELECT min(x)", then the loop coded by\n            **     where.c should not iterate over any values with a NULL value\n            **     for x.\n            **\n            **   + The optimizer code in where.c (the thing that decides which\n            **     index or indices to use) should place a different priority on\n            **     satisfying the \'ORDER BY\' clause than it does in other cases.\n            **     Refer to code and comments in where.c for details.\n            */\n            ExprList pMinMax = null;\n            int flag = minMaxQuery( p );\n            if ( flag != 0 )\n            {\n              Debug.Assert( !ExprHasProperty( p.pEList.a[0].pExpr, EP_xIsSelect ) );\n              pMinMax = sqlite3ExprListDup( db, p.pEList.a[0].pExpr.x.pList, 0 );\n              pDel = pMinMax;\n              if ( pMinMax != null )///* && 0 == db.mallocFailed */ )\n              {\n                pMinMax.a[0].sortOrder = (u8)( flag != WHERE_ORDERBY_MIN ? 1 : 0 );\n                pMinMax.a[0].pExpr.op = TK_COLUMN;\n              }\n            }\n\n            /* This case runs if the aggregate has no GROUP BY clause.  The\n            ** processing is much simpler since there is only a single row\n            ** of output.\n            */\n            resetAccumulator( pParse, sAggInfo );\n            pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref pMinMax, (byte)flag );\n            if ( pWInfo == null )\n            {\n              sqlite3ExprListDelete( db, ref pDel );\n              goto select_end;\n            }\n            updateAccumulator( pParse, sAggInfo );\n            if ( pMinMax == null && flag != 0 )\n            {\n              sqlite3VdbeAddOp2( v, OP_Goto, 0, pWInfo.iBreak );\n#if SQLITE_DEBUG\n              VdbeComment( v, "%s() by index",\n              ( flag == WHERE_ORDERBY_MIN ? "min" : "max" ) );\n#endif\n            }\n            sqlite3WhereEnd( pWInfo );\n            finalizeAggFunctions( pParse, sAggInfo );\n          }\n\n          pOrderBy = null;\n          sqlite3ExprIfFalse( pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL );\n          selectInnerLoop( pParse, p, p.pEList, 0, 0, null, -1,\n          pDest, addrEnd, addrEnd );\n\n          sqlite3ExprListDelete( db, ref pDel );\n        }\n        sqlite3VdbeResolveLabel( v, addrEnd );\n\n      } /* endif aggregate query */\n\n      /* If there is an ORDER BY clause, then we need to sort the results\n      ** and send them to the callback one by one.\n      */\n      if ( pOrderBy != null )\n      {\n        generateSortTail( pParse, p, v, pEList.nExpr, pDest );\n      }\n\n      /* Jump here to skip this query\n      */\n      sqlite3VdbeResolveLabel( v, iEnd );\n\n      /* The SELECT was successfully coded.   Set the return code to 0\n      ** to indicate no errors.\n      */\n      rc = 0;\n\n      /* Control jumps to here if an error is encountered above, or upon\n      ** successful coding of the SELECT.\n      */\nselect_end:\n\n      /* Identify column names if results of the SELECT are to be output.\n      */\n      if ( rc == SQLITE_OK && pDest.eDest == SRT_Output )\n      {\n        generateColumnNames( pParse, pTabList, pEList );\n      }\n\n      //sqlite3DbFree( db, ref sAggInfo.aCol );\n      //sqlite3DbFree( db, ref sAggInfo.aFunc );\n      return rc;\n    }\n\n#if SQLITE_DEBUG\n    /*\n*******************************************************************************\n** The following code is used for testing and debugging only.  The code\n** that follows does not appear in normal builds.\n**\n** These routines are used to print out the content of all or part of a\n** parse structures such as Select or Expr.  Such printouts are useful\n** for helping to understand what is happening inside the code generator\n** during the execution of complex SELECT statements.\n**\n** These routine are not called anywhere from within the normal\n** code base.  Then are intended to be called from within the debugger\n** or from temporary "printf" statements inserted for debugging.\n*/\n    void sqlite3PrintExpr( Expr p )\n    {\n      if ( !ExprHasProperty( p, EP_IntValue ) && p.u.zToken != null )\n      {\n        sqlite3DebugPrintf( "(%s", p.u.zToken );\n      }\n      else\n      {\n        sqlite3DebugPrintf( "(%d", p.op );\n      }\n      if ( p.pLeft != null )\n      {\n        sqlite3DebugPrintf( " " );\n        sqlite3PrintExpr( p.pLeft );\n      }\n      if ( p.pRight != null )\n      {\n        sqlite3DebugPrintf( " " );\n        sqlite3PrintExpr( p.pRight );\n      }\n      sqlite3DebugPrintf( ")" );\n    }\n    void sqlite3PrintExprList( ExprList pList )\n    {\n      int i;\n      for ( i = 0 ; i < pList.nExpr ; i++ )\n      {\n        sqlite3PrintExpr( pList.a[i].pExpr );\n        if ( i < pList.nExpr - 1 )\n        {\n          sqlite3DebugPrintf( ", " );\n        }\n      }\n    }\n    void sqlite3PrintSelect( Select p, int indent )\n    {\n      sqlite3DebugPrintf( "%*sSELECT(%p) ", indent, "", p );\n      sqlite3PrintExprList( p.pEList );\n      sqlite3DebugPrintf( "\\n" );\n      if ( p.pSrc != null )\n      {\n        string zPrefix;\n        int i;\n        zPrefix = "FROM";\n        for ( i = 0 ; i < p.pSrc.nSrc ; i++ )\n        {\n          SrcList_item pItem = p.pSrc.a[i];\n          sqlite3DebugPrintf( "%*s ", indent + 6, zPrefix );\n          zPrefix = "";\n          if ( pItem.pSelect != null )\n          {\n            sqlite3DebugPrintf( "(\\n" );\n            sqlite3PrintSelect( pItem.pSelect, indent + 10 );\n            sqlite3DebugPrintf( "%*s)", indent + 8, "" );\n          }\n          else if ( pItem.zName != null )\n          {\n            sqlite3DebugPrintf( "%s", pItem.zName );\n          }\n          if ( pItem.pTab != null )\n          {\n            sqlite3DebugPrintf( "(table: %s)", pItem.pTab.zName );\n          }\n          if ( pItem.zAlias != null )\n          {\n            sqlite3DebugPrintf( " AS %s", pItem.zAlias );\n          }\n          if ( i < p.pSrc.nSrc - 1 )\n          {\n            sqlite3DebugPrintf( "," );\n          }\n          sqlite3DebugPrintf( "\\n" );\n        }\n      }\n      if ( p.pWhere != null )\n      {\n        sqlite3DebugPrintf( "%*s WHERE ", indent, "" );\n        sqlite3PrintExpr( p.pWhere );\n        sqlite3DebugPrintf( "\\n" );\n      }\n      if ( p.pGroupBy != null )\n      {\n        sqlite3DebugPrintf( "%*s GROUP BY ", indent, "" );\n        sqlite3PrintExprList( p.pGroupBy );\n        sqlite3DebugPrintf( "\\n" );\n      }\n      if ( p.pHaving != null )\n      {\n        sqlite3DebugPrintf( "%*s HAVING ", indent, "" );\n        sqlite3PrintExpr( p.pHaving );\n        sqlite3DebugPrintf( "\\n" );\n      }\n      if ( p.pOrderBy != null )\n      {\n        sqlite3DebugPrintf( "%*s ORDER BY ", indent, "" );\n        sqlite3PrintExprList( p.pOrderBy );\n        sqlite3DebugPrintf( "\\n" );\n      }\n    }\n    /* End of the structure debug printing code\n    *****************************************************************************/\n#endif // * defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */\n  }\n}\n'