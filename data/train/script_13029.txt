b'using System.Diagnostics;\nusing System.Text;\n\nusing u8 = System.Byte;\nusing u32 = System.UInt32;\n\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  using sqlite3_value = CSSQLite.Mem;\n  using sqlite3_pcache = CSSQLite.PCache1;\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 November 05\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file implements the default page cache implementation (the\n    ** sqlite3_pcache interface). It also contains part of the implementation\n    ** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.\n    ** If the default page cache implementation is overriden, then neither of\n    ** these two features are available.\n    **\n    ** @(#) $Id: pcache1.c,v 1.19 2009/07/17 11:44:07 drh Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n    //#include "sqliteInt.h"\n\n    //typedef struct PCache1 PCache1;\n    //typedef struct PgHdr1 PgHdr1;\n    //typedef struct PgFreeslot PgFreeslot;\n\n    /* Pointers to structures of this type are cast and returned as\n    ** opaque sqlite3_pcache* handles\n    */\n\n    public class PCache1\n    {\n      /* Cache configuration parameters. Page size (szPage) and the purgeable\n      ** flag (bPurgeable) are set when the cache is created. nMax may be\n      ** modified at any time by a call to the pcache1CacheSize() method.\n      ** The global mutex must be held when accessing nMax.\n      */\n      public int szPage;                /* Size of every page in this cache */\n      public bool bPurgeable;           /* True if pages are on backing store */\n      public u32 nMin;                  /* Minimum number of pages reserved */\n      public u32 nMax;                  /* Configured "cache_size" value */\n\n      /* Hash table of all pages. The following variables may only be accessed\n      ** when the accessor is holding the global mutex (see pcache1EnterMutex()\n      ** and pcache1LeaveMutex()).\n      */\n      public u32 nRecyclable;           /* Number of pages in the LRU list */\n      public u32 nPage;                 /* Total number of pages in apHash */\n      public u32 nHash;                 /* Number of slots in apHash[] */\n      public PgHdr1[] apHash;           /* Hash table for fast lookup by pgno */\n      public u32 iMaxKey;               /* Largest key seen since xTruncate() */\n\n\n      public void Clear()\n      {\n        nRecyclable = 0;\n        nPage = 0;\n        nHash = 0;\n        apHash = null;\n        iMaxKey = 0;\n      }\n    };\n\n    /*\n    ** Each cache entry is represented by an instance of the following\n    ** structure. A buffer of PgHdr1.pCache.szPage bytes is allocated\n    ** directly before this structure in memory (see the PGHDR1_TO_PAGE()\n    ** macro below).\n    */\n    public class PgHdr1\n    {\n      public u32 iKey;                     /* Key value (page number) */\n      public PgHdr1 pNext;                 /* Next in hash table chain */\n      public PCache1 pCache;               /* Cache that currently owns this page */\n      public PgHdr1 pLruNext;              /* Next in LRU list of unpinned pages */\n      public PgHdr1 pLruPrev;              /* Previous in LRU list of unpinned pages */\n      public PgHdr pPgHdr = new PgHdr();   /* Pointer to Actual Page Header */\n\n      public void Clear()\n      {\n        this.iKey = 0;\n        this.pNext = null;\n        this.pCache = null;\n        this.pPgHdr.Clear();\n      }\n    };\n\n    /*\n    ** Free slots in the allocator used to divide up the buffer provided using\n    ** the SQLITE_CONFIG_PAGECACHE mechanism.\n    */\n    //typedef struct PgFreeslot PgFreeslot;\n    public class PgFreeslot\n    {\n      public PgFreeslot pNext;  /* Next free slot */\n      public PgHdr _PgHdr;      /* Next Free Header */\n    };\n\n    /*\n    ** Global data for the page cache.\n    */\n    public class PCacheGlobal\n    {\n      public sqlite3_mutex mutex;               /* static mutex MUTEX_STATIC_LRU */\n\n      public int nMaxPage;                     /* Sum of nMaxPage for purgeable caches */\n      public int nMinPage;                     /* Sum of nMinPage for purgeable caches */\n      public int nCurrentPage;                  /* Number of purgeable pages allocated */\n      public PgHdr1 pLruHead, pLruTail;          /* LRU list of unused clean pgs */\n\n      /* Variables related to SQLITE_CONFIG_PAGECACHE settings. */\n      public int szSlot;                         /* Size of each free slot */\n      public object pStart, pEnd;                /* Bounds of pagecache malloc range */\n      public PgFreeslot pFree;                   /* Free page blocks */\n      public int isInit;                         /* True if initialized */\n    }\n    static PCacheGlobal pcache = new PCacheGlobal();\n\n    /*\n    ** All code in this file should access the global structure above via the\n    ** alias "pcache1". This ensures that the WSD emulation is used when\n    ** compiling for systems that do not support real WSD.\n    */\n\n    //#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))\n    static PCacheGlobal pcache1 = pcache;\n\n    /*\n    ** When a PgHdr1 structure is allocated, the associated PCache1.szPage\n    ** bytes of data are located directly before it in memory (i.e. the total\n    ** size of the allocation is sizeof(PgHdr1)+PCache1.szPage byte). The\n    ** PGHDR1_TO_PAGE() macro takes a pointer to a PgHdr1 structure as\n    ** an argument and returns a pointer to the associated block of szPage\n    ** bytes. The PAGE_TO_PGHDR1() macro does the opposite: its argument is\n    ** a pointer to a block of szPage bytes of data and the return value is\n    ** a pointer to the associated PgHdr1 structure.\n    **\n    **   assert( PGHDR1_TO_PAGE(PAGE_TO_PGHDR1(pCache, X))==X );\n    */\n    //#define PGHDR1_TO_PAGE(p)    (void*)(((char*)p) - p->pCache->szPage)\n    static PgHdr PGHDR1_TO_PAGE( PgHdr1 p ) { return p.pPgHdr; }\n\n    //#define PAGE_TO_PGHDR1(c, p) (PgHdr1*)(((char*)p) + c->szPage)\n    static PgHdr1 PAGE_TO_PGHDR1( PCache1 c, PgHdr p ) { return p.pPgHdr1; }\n    /*\n    ** Macros to enter and leave the global LRU mutex.\n    */\n    //#define pcache1EnterMutex() sqlite3_mutex_enter(pcache1.mutex)\n    //#define pcache1LeaveMutex() sqlite3_mutex_leave(pcache1.mutex)\n    static void pcache1EnterMutex() { sqlite3_mutex_enter( pcache1.mutex ); }\n    static void pcache1LeaveMutex() { sqlite3_mutex_leave( pcache1.mutex ); }\n\n    /******************************************************************************/\n    /******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/\n\n    /*\n    ** This function is called during initialization if a static buffer is\n    ** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE\n    ** verb to sqlite3_config(). Parameter pBuf points to an allocation large\n    ** enough to contain \'n\' buffers of \'sz\' bytes each.\n    */\n    static void sqlite3PCacheBufferSetup( object pBuf, int sz, int n )\n    {\n      if ( pcache1.isInit != 0 )\n      {\n        PgFreeslot p;\n        sz = ROUNDDOWN8( sz );\n        pcache1.szSlot = sz;\n        pcache1.pStart = pBuf;\n        pcache1.pFree = null;\n        while ( n-- != 0 )\n        {\n          p = new PgFreeslot();// (PgFreeslot)pBuf;\n          p._PgHdr = new PgHdr();\n          p.pNext = pcache1.pFree;\n          pcache1.pFree = p;\n          //pBuf = (void*)&((char*)pBuf)[sz];\n        }\n        pcache1.pEnd = pBuf;\n      }\n    }\n\n    /*\n    ** Malloc function used within this file to allocate space from the buffer\n    ** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no\n    ** such buffer exists or there is no space left in it, this function falls\n    ** back to sqlite3Malloc().\n    */\n    static PgHdr pcache1Alloc( int nByte )\n    {\n      PgHdr p;\n      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) );\n      if ( nByte <= pcache1.szSlot && pcache1.pFree != null )\n      {\n        Debug.Assert( pcache1.isInit != 0 );\n        p = pcache1.pFree._PgHdr;\n        p.CacheAllocated = true;\n        pcache1.pFree = pcache1.pFree.pNext;\n        sqlite3StatusSet( SQLITE_STATUS_PAGECACHE_SIZE, nByte );\n        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_USED, 1 );\n      }\n      else\n      {\n\n        /* Allocate a new buffer using sqlite3Malloc. Before doing so, exit the\n        ** global pcache mutex and unlock the pager-cache object pCache. This is\n        ** so that if the attempt to allocate a new buffer causes the the\n        ** configured soft-heap-limit to be breached, it will be possible to\n        ** reclaim memory from this pager-cache.\n        */\n        pcache1LeaveMutex();\n        p = new PgHdr();//  p = sqlite3Malloc(nByte);\n        p.CacheAllocated = false;\n        pcache1EnterMutex();\n        //  if( p !=null){\n        int sz = nByte;//int sz = sqlite3MallocSize(p);\n        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_OVERFLOW, sz );\n      }\n      return p;\n    }\n\n    /*\n    ** Free an allocated buffer obtained from pcache1Alloc().\n    */\n    static void pcache1Free( ref PgHdr p )\n    {\n      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) );\n      if ( p == null ) return;\n      if (p.CacheAllocated) //if ( p >= pcache1.pStart && p < pcache1.pEnd )\n      {\n        PgFreeslot pSlot = new PgFreeslot();\n        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_USED, -1 );\n        pSlot._PgHdr = p;// (PgFreeslot)p;\n        pSlot.pNext = pcache1.pFree;\n        pcache1.pFree = pSlot;\n      }\n      else\n      {\n        int iSize = p.pData.Length;//sqlite3MallocSize( p );\n        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize );\n        p = null;//sqlite3_free( ref p );\n      }\n    }\n\n    /*\n    ** Allocate a new page object initially associated with cache pCache.\n    */\n    static PgHdr1 pcache1AllocPage( PCache1 pCache )\n    {\n      //int nByte = sizeof(PgHdr1) + pCache.szPage;\n      PgHdr pPg = pcache1Alloc( pCache.szPage );\n      PgHdr1 p;\n      //if ( pPg != null )\n      {\n        // PAGE_TO_PGHDR1( pCache, pPg );\n        p = new PgHdr1();\n        p.pCache = pCache;\n        p.pPgHdr = pPg;\n        if ( pCache.bPurgeable )\n        {\n          pcache1.nCurrentPage++;\n        }\n      }\n      //else\n      //{\n      //  p = null;\n      //}\n      return p;\n    }\n\n    /*\n    ** Free a page object allocated by pcache1AllocPage().\n    **\n    ** The pointer is allowed to be NULL, which is prudent.  But it turns out\n    ** that the current implementation happens to never call this routine\n    ** with a NULL pointer, so we mark the NULL test with ALWAYS().\n    */\n    static void pcache1FreePage( ref PgHdr1 p )\n    {\n      if ( ALWAYS( p != null ) )\n      {\n        if ( p.pCache.bPurgeable )\n        {\n          pcache1.nCurrentPage--;\n        }\n        pcache1Free( ref p.pPgHdr );//PGHDR1_TO_PAGE( p );\n      }\n    }\n\n    /*\n    ** Malloc function used by SQLite to obtain space from the buffer configured\n    ** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such buffer\n    ** exists, this function falls back to sqlite3Malloc().\n    */\n    static PgHdr sqlite3PageMalloc( int sz )\n    {\n      PgHdr p;\n      pcache1EnterMutex();\n      p = pcache1Alloc( sz );\n      pcache1LeaveMutex();\n      return p;\n    }\n\n    /*\n    ** Free an allocated buffer obtained from sqlite3PageMalloc().\n    */\n    static void sqlite3PageFree( ref PgHdr p)\n    {\n      pcache1EnterMutex();\n      pcache1Free( ref p );\n      pcache1LeaveMutex();\n    }\n\n    /******************************************************************************/\n    /******** General Implementation Functions ************************************/\n\n    /*\n    ** This function is used to resize the hash table used by the cache passed\n    ** as the first argument.\n    **\n    ** The global mutex must be held when this function is called.\n    */\n    static int pcache1ResizeHash( PCache1 p )\n    {\n      PgHdr1[] apNew;\n      u32 nNew;\n      u32 i;\n\n      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) );\n\n      nNew = p.nHash * 2;\n      if ( nNew < 256 )\n      {\n        nNew = 256;\n      }\n\n      pcache1LeaveMutex();\n      if ( p.nHash != 0 ) { sqlite3BeginBenignMalloc(); }\n      apNew = new PgHdr1[nNew];// (PgHdr1**)sqlite3_malloc( sizeof( PgHdr1* ) * nNew );\n      if ( p.nHash != 0 ) { sqlite3EndBenignMalloc(); }\n      pcache1EnterMutex();\n      if ( apNew != null )\n      {\n        //memset(apNew, 0, sizeof(PgHdr1 *)*nNew);\n        for ( i = 0 ; i < p.nHash ; i++ )\n        {\n          PgHdr1 pPage;\n          PgHdr1 pNext = p.apHash[i];\n          while ( ( pPage = pNext ) != null )\n          {\n            u32 h = (u32)( pPage.iKey % nNew );\n            pNext = pPage.pNext;\n            pPage.pNext = apNew[h];\n            apNew[h] = pPage;\n          }\n        }\n        //sqlite3_free( ref p.apHash );\n        p.apHash = apNew;\n        p.nHash = nNew;\n      }\n\n      return ( p.apHash != null ? SQLITE_OK : SQLITE_NOMEM );\n    }\n\n    /*\n    ** This function is used internally to remove the page pPage from the\n    ** global LRU list, if is part of it. If pPage is not part of the global\n    ** LRU list, then this function is a no-op.\n    **\n    ** The global mutex must be held when this function is called.\n    */\n    static void pcache1PinPage( PgHdr1 pPage )\n    {\n      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) );\n      if ( pPage != null && ( pPage.pLruNext != null || pPage == pcache1.pLruTail ) )\n      {\n        if ( pPage.pLruPrev != null )\n        {\n          pPage.pLruPrev.pLruNext = pPage.pLruNext;\n        }\n        if ( pPage.pLruNext != null )\n        {\n          pPage.pLruNext.pLruPrev = pPage.pLruPrev;\n        }\n        if ( pcache1.pLruHead == pPage )\n        {\n          pcache1.pLruHead = pPage.pLruNext;\n        }\n        if ( pcache1.pLruTail == pPage )\n        {\n          pcache1.pLruTail = pPage.pLruPrev;\n        }\n        pPage.pLruNext = null;\n        pPage.pLruPrev = null;\n        pPage.pCache.nRecyclable--;\n      }\n    }\n\n\n    /*\n    ** Remove the page supplied as an argument from the hash table\n    ** (PCache1.apHash structure) that it is currently stored in.\n    **\n    ** The global mutex must be held when this function is called.\n    */\n    static void pcache1RemoveFromHash( PgHdr1 pPage )\n    {\n      u32 h;\n      PCache1 pCache = pPage.pCache;\n      PgHdr1 pp, pPrev;\n\n      h = pPage.iKey % pCache.nHash;\n      pPrev = null;\n      for ( pp = pCache.apHash[h] ; pp != pPage ; pPrev = pp, pp = pp.pNext ) ;\n      if ( pPrev == null ) pCache.apHash[h] = pp.pNext; else pPrev.pNext = pp.pNext; // pCache.apHash[h] = pp.pNext;\n\n      pCache.nPage--;\n    }\n\n    /*\n    ** If there are currently more than pcache.nMaxPage pages allocated, try\n    ** to recycle pages to reduce the number allocated to pcache.nMaxPage.\n    */\n    static void pcache1EnforceMaxPage()\n    {\n      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) );\n      while ( pcache1.nCurrentPage > pcache1.nMaxPage && pcache1.pLruTail != null )\n      {\n        PgHdr1 p = pcache1.pLruTail;\n        pcache1PinPage( p );\n        pcache1RemoveFromHash( p );\n        pcache1FreePage( ref p );\n      }\n    }\n\n    /*\n    ** Discard all pages from cache pCache with a page number (key value)\n    ** greater than or equal to iLimit. Any pinned pages that meet this\n    ** criteria are unpinned before they are discarded.\n    **\n    ** The global mutex must be held when this function is called.\n    */\n    static void pcache1TruncateUnsafe(\n    PCache1 pCache,\n    u32 iLimit\n    )\n    {\n      //TESTONLY( unsigned int nPage = 0; )      /* Used to assert pCache->nPage is correct */\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n      u32 nPage = 0;\n#endif\n      u32 h;\n      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) );\n      for ( h = 0 ; h < pCache.nHash ; h++ )\n      {\n        PgHdr1 pp = pCache.apHash[h];\n        PgHdr1 pPage;\n        while ( ( pPage = pp ) != null )\n        {\n          if ( pPage.iKey >= iLimit )\n          {\n            pCache.nPage--;\n            pp = pPage.pNext;\n            pcache1PinPage( pPage );\n            if ( pCache.apHash[h] == pPage )\n              pCache.apHash[h] = pPage.pNext;\n            else Debugger.Break();\n            pcache1FreePage( ref  pPage );\n          }\n          else\n          {\n            pp = pPage.pNext;\n            //TESTONLY( nPage++; )\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n            nPage++;\n#endif\n          }\n        }\n      }\n#if !NDEBUG || SQLITE_COVERAGE_TEST\n      Debug.Assert( pCache.nPage == nPage );\n#endif\n    }\n\n    /******************************************************************************/\n    /******** sqlite3_pcache Methods **********************************************/\n\n    /*\n    ** Implementation of the sqlite3_pcache.xInit method.\n    */\n    static int pcache1Init( object NotUsed )\n    {\n      UNUSED_PARAMETER( NotUsed );\n      Debug.Assert( pcache1.isInit == 0 );\n      pcache1 = new PCacheGlobal();// memset( &pcache1, 0, sizeof( pcache1 ) );\n      if ( sqlite3GlobalConfig.bCoreMutex )\n      {\n        pcache1.mutex = sqlite3_mutex_alloc( SQLITE_MUTEX_STATIC_LRU );\n      }\n      pcache1.isInit = 1;\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xShutdown method.\n    */\n    static void pcache1Shutdown( object NotUsed )\n    {\n      UNUSED_PARAMETER( NotUsed );\n      Debug.Assert( pcache1.isInit != 0 );\n      pcache1 = new PCacheGlobal(); //memset( &pcache1, 0, sizeof( pcache1 ) );\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xCreate method.\n    **\n    ** Allocate a new cache.\n    */\n    static sqlite3_pcache pcache1Create( int szPage, int bPurgeable )\n    {\n      PCache1 pCache;\n\n      pCache = new PCache1();// (PCache1*)sqlite3_malloc( sizeof( PCache1 ) );\n      if ( pCache != null )\n      {\n        //memset(pCache, 0, sizeof(PCache1));\n        pCache.szPage = szPage;\n        pCache.bPurgeable = ( bPurgeable != 0 );\n        if ( bPurgeable != 0 )\n        {\n          pCache.nMin = 10;\n          pcache1EnterMutex();\n          pcache1.nMinPage += (int)pCache.nMin;\n          pcache1LeaveMutex();\n        }\n      }\n      return pCache;\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xCachesize method.\n    **\n    ** Configure the cache_size limit for a cache.\n    */\n    static void pcache1Cachesize( sqlite3_pcache p, int nMax )\n    {\n      PCache1 pCache = (PCache1)p;\n      if ( pCache.bPurgeable )\n      {\n        pcache1EnterMutex();\n        pcache1.nMaxPage += (int)( nMax - pCache.nMax );\n        pCache.nMax = (u32)nMax;\n        pcache1EnforceMaxPage();\n        pcache1LeaveMutex();\n      }\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xPagecount method.\n    */\n    static int pcache1Pagecount( sqlite3_pcache p )\n    {\n      int n;\n      pcache1EnterMutex();\n      n = (int)( (PCache1)p ).nPage;\n      pcache1LeaveMutex();\n      return n;\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xFetch method. \n    **\n    ** Fetch a page by key value.\n    **\n    ** Whether or not a new page may be allocated by this function depends on\n    ** the value of the createFlag argument.  0 means do not allocate a new\n    ** page.  1 means allocate a new page if space is easily available.  2 \n    ** means to try really hard to allocate a new page.\n    **\n    ** For a non-purgeable cache (a cache used as the storage for an in-memory\n    ** database) there is really no difference between createFlag 1 and 2.  So\n    ** the calling function (pcache.c) will never have a createFlag of 1 on\n    ** a non-purgable cache.\n    **\n    ** There are three different approaches to obtaining space for a page,\n    ** depending on the value of parameter createFlag (which may be 0, 1 or 2).\n    **\n    **   1. Regardless of the value of createFlag, the cache is searched for a \n    **      copy of the requested page. If one is found, it is returned.\n    **\n    **   2. If createFlag==0 and the page is not already in the cache, NULL is\n    **      returned.\n    **\n    **   3. If createFlag is 1, and the page is not already in the cache,\n    **      and if either of the following are true, return NULL:\n    **\n    **       (a) the number of pages pinned by the cache is greater than\n    **           PCache1.nMax, or\n    **       (b) the number of pages pinned by the cache is greater than\n    **           the sum of nMax for all purgeable caches, less the sum of \n    **           nMin for all other purgeable caches. \n    **\n    **   4. If none of the first three conditions apply and the cache is marked\n    **      as purgeable, and if one of the following is true:\n    **\n    **       (a) The number of pages allocated for the cache is already \n    **           PCache1.nMax, or\n    **\n    **       (b) The number of pages allocated for all purgeable caches is\n    **           already equal to or greater than the sum of nMax for all\n    **           purgeable caches,\n    **\n    **      then attempt to recycle a page from the LRU list. If it is the right\n    **      size, return the recycled buffer. Otherwise, free the buffer and\n    **      proceed to step 5. \n    **\n    **   5. Otherwise, allocate and return a new page buffer.\n    */\n    static PgHdr pcache1Fetch( sqlite3_pcache p, u32 iKey, int createFlag )\n    {\n      u32 nPinned;\n      PCache1 pCache = p;\n      PgHdr1 pPage = null;\n\n      Debug.Assert( pCache.bPurgeable || createFlag != 1 );\n      pcache1EnterMutex();\n      if ( createFlag == 1 ) sqlite3BeginBenignMalloc();\n\n      /* Search the hash table for an existing entry. */\n      if ( pCache.nHash > 0 )\n      {\n        u32 h = iKey % pCache.nHash;\n        for ( pPage = pCache.apHash[h] ; pPage != null && pPage.iKey != iKey ; pPage = pPage.pNext ) ;\n      }\n\n      if ( pPage != null || createFlag == 0 )\n      {\n        pcache1PinPage( pPage );\n        goto fetch_out;\n      }\n\n      /* Step 3 of header comment. */\n      nPinned = pCache.nPage - pCache.nRecyclable;\n      if ( createFlag == 1 && (\n      nPinned >= ( pcache1.nMaxPage + pCache.nMin - pcache1.nMinPage )\n      || nPinned >= ( pCache.nMax * 9 / 10 )\n      ) )\n      {\n        goto fetch_out;\n      }\n\n      if ( pCache.nPage >= pCache.nHash && pcache1ResizeHash( pCache ) != 0 )\n      {\n        goto fetch_out;\n      }\n\n      /* Step 4. Try to recycle a page buffer if appropriate. */\n      if ( pCache.bPurgeable && pcache1.pLruTail != null && (\n      pCache.nPage + 1 >= pCache.nMax || pcache1.nCurrentPage >= pcache1.nMaxPage\n      ) )\n      {\n        pPage = pcache1.pLruTail;\n        pcache1RemoveFromHash( pPage );\n        pcache1PinPage( pPage );\n        if ( pPage.pCache.szPage != pCache.szPage )\n        {\n          pcache1FreePage( ref pPage );\n          pPage = null;\n        }\n        else\n        {\n          pcache1.nCurrentPage -= ( ( pPage.pCache.bPurgeable ? 1 : 0 ) - ( pCache.bPurgeable ? 1 : 0 ) );\n        }\n      }\n\n      /* Step 5. If a usable page buffer has still not been found,\n      ** attempt to allocate a new one.\n      */\n      if ( null == pPage )\n      {\n        pPage = pcache1AllocPage( pCache );\n      }\n\n      if ( pPage != null )\n      {\n        u32 h = iKey % pCache.nHash;\n        pCache.nPage++;\n        pPage.iKey = iKey;\n        pPage.pNext = pCache.apHash[h];\n        pPage.pCache = pCache;\n        pPage.pLruPrev = null;\n        pPage.pLruNext = null;\n        PGHDR1_TO_PAGE( pPage ).Clear();// *(void **)(PGHDR1_TO_PAGE(pPage)) = 0;\n        pPage.pPgHdr.pPgHdr1 = pPage;\n        pCache.apHash[h] = pPage;\n      }\n\nfetch_out:\n      if ( pPage != null && iKey > pCache.iMaxKey )\n      {\n        pCache.iMaxKey = iKey;\n      }\n      if ( createFlag == 1 ) sqlite3EndBenignMalloc();\n      pcache1LeaveMutex();\n      return ( pPage != null ? PGHDR1_TO_PAGE( pPage ) : null );\n    }\n\n\n    /*\n    ** Implementation of the sqlite3_pcache.xUnpin method.\n    **\n    ** Mark a page as unpinned (eligible for asynchronous recycling).\n    */\n    static void pcache1Unpin( sqlite3_pcache p, PgHdr pPg, int reuseUnlikely )\n    {\n      PCache1 pCache = (PCache1)p;\n      PgHdr1 pPage = PAGE_TO_PGHDR1( pCache, pPg );\n\n      Debug.Assert( pPage.pCache == pCache );\n      pcache1EnterMutex();\n\n      /* It is an error to call this function if the page is already\n      ** part of the global LRU list.\n      */\n      Debug.Assert( pPage.pLruPrev == null && pPage.pLruNext == null );\n      Debug.Assert( pcache1.pLruHead != pPage && pcache1.pLruTail != pPage );\n\n      if ( reuseUnlikely != 0 || pcache1.nCurrentPage > pcache1.nMaxPage )\n      {\n        pcache1RemoveFromHash( pPage );\n        pcache1FreePage( ref pPage );\n      }\n      else\n      {\n        /* Add the page to the global LRU list. Normally, the page is added to\n        ** the head of the list (last page to be recycled). However, if the\n        ** reuseUnlikely flag passed to this function is true, the page is added\n        ** to the tail of the list (first page to be recycled).\n        */\n        if ( pcache1.pLruHead != null )\n        {\n          pcache1.pLruHead.pLruPrev = pPage;\n          pPage.pLruNext = pcache1.pLruHead;\n          pcache1.pLruHead = pPage;\n        }\n        else\n        {\n          pcache1.pLruTail = pPage;\n          pcache1.pLruHead = pPage;\n        }\n        pCache.nRecyclable++;\n      }\n\n      pcache1LeaveMutex();\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xRekey method.\n    */\n    static void pcache1Rekey(\n    sqlite3_pcache p,\n    PgHdr pPg,\n    u32 iOld,\n    u32 iNew\n    )\n    {\n      PCache1 pCache = p;\n      PgHdr1 pPage = PAGE_TO_PGHDR1( pCache, pPg );\n      PgHdr1 pp;\n      u32 h;\n      Debug.Assert( pPage.iKey == iOld );\n      Debug.Assert( pPage.pCache == pCache );\n\n      pcache1EnterMutex();\n\n      h = iOld % pCache.nHash;\n      pp = pCache.apHash[h];\n      while ( pp != pPage )\n      {\n        pp = pp.pNext;\n      }\n      if ( pp == pCache.apHash[h] ) pCache.apHash[h] = pp.pNext;\n      else pp.pNext = pPage.pNext;\n\n      h = iNew % pCache.nHash;\n      pPage.iKey = iNew;\n      pPage.pNext = pCache.apHash[h];\n      pCache.apHash[h] = pPage;\n\n      /* The xRekey() interface is only used to move pages earlier in the\n      ** database file (in order to move all free pages to the end of the\n      ** file where they can be truncated off.)  Hence, it is not possible\n      ** for the new page number to be greater than the largest previously\n      ** fetched page.  But we retain the following test in case xRekey()\n      ** begins to be used in different ways in the future.\n      */\n      if ( NEVER( iNew > pCache.iMaxKey ) )\n      {\n        pCache.iMaxKey = iNew;\n      }\n\n      pcache1LeaveMutex();\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xTruncate method.\n    **\n    ** Discard all unpinned pages in the cache with a page number equal to\n    ** or greater than parameter iLimit. Any pinned pages with a page number\n    ** equal to or greater than iLimit are implicitly unpinned.\n    */\n    static void pcache1Truncate( sqlite3_pcache p, u32 iLimit )\n    {\n      PCache1 pCache = (PCache1)p;\n      pcache1EnterMutex();\n      if ( iLimit <= pCache.iMaxKey )\n      {\n        pcache1TruncateUnsafe( pCache, iLimit );\n        pCache.iMaxKey = iLimit - 1;\n      }\n      pcache1LeaveMutex();\n    }\n\n    /*\n    ** Implementation of the sqlite3_pcache.xDestroy method.\n    **\n    ** Destroy a cache allocated using pcache1Create().\n    */\n    static void pcache1Destroy( ref sqlite3_pcache p )\n    {\n      PCache1 pCache = p;\n      pcache1EnterMutex();\n      pcache1TruncateUnsafe( pCache, 0 );\n      pcache1.nMaxPage -= (int)pCache.nMax;\n      pcache1.nMinPage -= (int)pCache.nMin;\n      pcache1EnforceMaxPage();\n      pcache1LeaveMutex();\n      //sqlite3_free( ref pCache.apHash );\n      //sqlite3_free( ref pCache );\n    }\n\n    /*\n    ** This function is called during initialization (sqlite3_initialize()) to\n    ** install the default pluggable cache module, assuming the user has not\n    ** already provided an alternative.\n    */\n    static void sqlite3PCacheSetDefault()\n    {\n      sqlite3_pcache_methods defaultMethods = new sqlite3_pcache_methods(\n      0,                                /* pArg */\n      (dxPC_Init)pcache1Init,             /* xInit */\n      (dxPC_Shutdown)pcache1Shutdown,  /* xShutdown */\n      (dxPC_Create)pcache1Create,      /* xCreate */\n      (dxPC_Cachesize)pcache1Cachesize,/* xCachesize */\n      (dxPC_Pagecount)pcache1Pagecount,/* xPagecount */\n      (dxPC_Fetch)pcache1Fetch,         /* xFetch */\n      (dxPC_Unpin)pcache1Unpin,         /* xUnpin */\n      (dxPC_Rekey)pcache1Rekey,         /* xRekey */\n      (dxPC_Truncate)pcache1Truncate,   /* xTruncate */\n      (dxPC_Destroy)pcache1Destroy      /* xDestroy */\n      );\n      sqlite3_config( SQLITE_CONFIG_PCACHE, defaultMethods );\n    }\n\n#if  SQLITE_ENABLE_MEMORY_MANAGEMENT\n/*\n** This function is called to free superfluous dynamically allocated memory\n** held by the pager system. Memory in use by any SQLite pager allocated\n** by the current thread may be //sqlite3_free()ed.\n**\n** nReq is the number of bytes of memory required. Once this much has\n** been released, the function returns. The return value is the total number\n** of bytes of memory released.\n*/\nint sqlite3PcacheReleaseMemory(int nReq){\nint nFree = 0;\nif( pcache1.pStart==0 ){\nPgHdr1 p;\npcache1EnterMutex();\nwhile( (nReq<0 || nFree<nReq) && (p=pcache1.pLruTail) ){\nnFree += sqlite3MallocSize(PGHDR1_TO_PAGE(p));\npcache1PinPage(p);\npcache1RemoveFromHash(p);\npcache1FreePage(p);\n}\npcache1LeaveMutex();\n}\nreturn nFree;\n}\n#endif //* SQLITE_ENABLE_MEMORY_MANAGEMENT */\n\n#if  SQLITE_TEST\n    /*\n** This function is used by test procedures to inspect the internal state\n** of the global cache.\n*/\n    static void sqlite3PcacheStats(\n    ref int pnCurrent,      /* OUT: Total number of pages cached */\n    ref int pnMax,          /* OUT: Global maximum cache size */\n    ref int pnMin,          /* OUT: Sum of PCache1.nMin for purgeable caches */\n    ref int pnRecyclable    /* OUT: Total number of pages available for recycling */\n    )\n    {\n      PgHdr1 p;\n      int nRecyclable = 0;\n      for ( p = pcache1.pLruHead ; p != null ; p = p.pLruNext )\n      {\n        nRecyclable++;\n      }\n      pnCurrent = pcache1.nCurrentPage;\n      pnMax = pcache1.nMaxPage;\n      pnMin = pcache1.nMinPage;\n      pnRecyclable = nRecyclable;\n    }\n#endif\n\n  }\n}\n'