b'-----------------------------------------------------------------------------\n-- |\n-- Module      :  Main (HaddockCoverage)\n-- Copyright   :  (C) 2015 Ivan Perez\n-- License     :  BSD-style (see the file LICENSE)\n-- Maintainer  :  Ivan Perez <ivan.perez@keera.co.uk>\n-- Stability   :  provisional\n-- Portability :  portable\n--\n-- Copyright notice: This file borrows code\n-- https://hackage.haskell.org/package/lens-4.7/src/tests/doctests.hsc\n-- which is itself licensed BSD-style as well.\n--\n-- Run haddock on a source tree and report if anything in any\n-- module is not documented.\n-----------------------------------------------------------------------------\nmodule Main where\n\nimport Control.Applicative\nimport Control.Monad\nimport Data.List\nimport System.Directory\nimport System.Exit\nimport System.FilePath\nimport System.IO\nimport System.Process\nimport Text.Regex.Posix\n\nmain :: IO ()\nmain = do\n  -- Find haskell modules\n  -- TODO: Ideally cabal should do this (provide us with the\n  -- list of modules). An alternative would be to use cabal haddock\n  -- but that would need a --no-html argument or something like that.\n  -- Alternatively, we could use cabal haddock with additional arguments.\n  --\n  -- See:\n  -- https://github.com/keera-studios/haddock/commit/d5d752943c4e5c6c9ffcdde4dc136fcee967c495\n  -- https://github.com/haskell/haddock/issues/309#issuecomment-150811929\n  files <- getSources\n\n  let haddockArgs = [ "--no-warnings", "--ignore-all-exports" ] ++ files\n  let cabalArgs   = [ "exec", "--", "haddock" ] ++ haddockArgs\n  (code, out, _err) <- readProcessWithExitCode "cabal" cabalArgs ""\n\n  -- Filter out coverage lines, and find those that denote undocumented\n  -- modules.\n  --\n  -- TODO: is there a way to annotate a function as self-documenting,\n  -- in the same way we do with ANN for hlint?\n  let isIncompleteModule :: String -> Bool\n      isIncompleteModule line = isCoverageLine line && not (line =~ "^ *100%")\n        where isCoverageLine :: String -> Bool\n              isCoverageLine line = line =~ "^ *[0-9]+%"\n\n  let incompleteModules :: [String]\n      incompleteModules = filter isIncompleteModule $ lines out\n\n  -- Based on the result of haddock, report errors and exit.\n  -- Note that, unline haddock, this script does not\n  -- output anything to stdout. It uses stderr instead\n  -- (as it should).\n  case (code, incompleteModules) of\n    (ExitSuccess  , []) -> return ()\n    -- (ExitFailure _, _)  -> exitFailure\n    (_            , _)  -> do\n      hPutStrLn stderr "The following modules are not fully documented:"\n      mapM_ (hPutStrLn stderr) incompleteModules\n      exitFailure\n\ngetSources :: IO [FilePath]\ngetSources = filter isHaskellFile <$> go "src"\n  where\n    go dir = do\n      (dirs, files) <- getFilesAndDirectories dir\n      (files ++) . concat <$> mapM go dirs\n\n    isHaskellFile fp = (isSuffixOf ".hs" fp || isSuffixOf ".lhs" fp)\n                     && not (any (`isSuffixOf` fp) excludedFiles)\n\n    excludedFiles = [ ]\n\ngetFilesAndDirectories :: FilePath -> IO ([FilePath], [FilePath])\ngetFilesAndDirectories dir = do\n  c <- map (dir </>) . filter (`notElem` ["..", "."]) <$> getDirectoryContents dir\n  (,) <$> filterM doesDirectoryExist c <*> filterM doesFileExist c\n\n-- find-based implementation (not portable)\n--\n-- getSources :: IO [FilePath]\n-- getSources = fmap lines $ readProcess "find" ["src/", "-iname", "*hs"] ""\n'