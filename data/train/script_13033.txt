b'{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nmodule Control.Monad.Trans.Crtn.World where\n\nimport Control.Monad (void)\nimport Control.Monad.Trans.Crtn (request)\nimport Control.Monad.Trans.Crtn.Event (ActionOrder)\nimport Control.Monad.Trans.Crtn.Logger (LogServer)\nimport Control.Monad.Trans.Crtn.Object\n  ( Arg (..),\n    CObjT,\n    Res (..),\n    SObjT,\n  )\nimport Prelude hiding (id, (.))\n\n-- |\ndata WorldOp e m i o where\n  GiveEvent :: WorldOp e m e ()\n  FlushLog :: WorldOp e m (LogServer m ()) (LogServer m ())\n  FlushQueue :: WorldOp e m () [Either (ActionOrder e) e]\n\n-- |\ntype World e m r = SObjT (WorldOp e m) m r\n\n-- |\ngiveEvent :: (Monad m) => e -> CObjT (WorldOp e m) m ()\ngiveEvent ev = void $ request (Arg GiveEvent ev)\n\n-- |\nflushLog :: (Monad m) => LogServer m () -> CObjT (WorldOp e m) m (LogServer m ())\nflushLog logobj = do\n  req <- request (Arg FlushLog logobj)\n  case req of\n    Res FlushLog logobj\' -> return logobj\'\n    Ign -> return logobj\n    _ -> error "error in flushLog" -- allow partiality\n\n-- |\nflushQueue :: (Monad m) => CObjT (WorldOp e m) m [Either (ActionOrder e) e]\nflushQueue = do\n  req <- request (Arg FlushQueue ())\n  case req of\n    Res FlushQueue lst -> return lst\n    Ign -> return []\n    _ -> error "error in flushQueue" -- allow partiality\n'