b'{-# LANGUAGE DeriveDataTypeable #-}\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.Runners\nimport Test.Tasty.Options\nimport Test.Tasty.Patterns.Types\nimport Data.Maybe\nimport Data.Typeable\nimport Options.Applicative\nimport Resources\nimport Timeouts\nimport Dependencies\nimport AWK\n\nmain :: IO ()\nmain = do\n  defaultMain =<< mainGroup\n\nmainGroup :: IO TestTree\nmainGroup = do\n  awkTests_ <- awkTests\n  return $ testGroup "Tests"\n    [ testResources\n    , testTimeouts\n    , testDependencies\n    , patternTests\n    , awkTests_\n    , optionMessagesTests\n    ]\n\n-- | \'patternTests\' are not supposed to test every awk feature; that\'s the\n-- job of \'awkTests\'.\n--\n-- We test two things:\n--\n-- 1. awk patterns are properly integrated\n-- 2. simple strings are promoted to awk patterns\npatternTests :: TestTree\npatternTests = testGroup "Patterns"\n  [ testCase "Absent pattern"\n      (getTestNames mempty tt @?= ["Tests.Europe.London","Tests.Europe.Paris","Tests.Europe.Berlin","Tests.North America.Ottawa","Tests.North America.Washington DC"])\n  , testCase "Simple string"\n      (o "America" @?= ["Tests.North America.Ottawa","Tests.North America.Washington DC"])\n  , testCase "AWK expression"\n      (o "$3 ~ /r/ || $2 != \\"Europe\\"" @?= ["Tests.Europe.Paris","Tests.Europe.Berlin","Tests.North America.Ottawa","Tests.North America.Washington DC"])\n  , testCase "Simple ERE is parsed as such" $ -- #220\n      parseTestPattern "/foo/" @?= Just (TestPattern (Just (ERE "foo")))\n  , testCase "Dashes are acceptable in raw patterns" $ -- #220\n      parseTestPattern "type-checking" @?= Just (TestPattern (Just (ERE "type-checking")))\n  , testCase ". is a field separator (works as a raw pattern)" $\n      (o "ca.Ot" @?= ["Tests.North America.Ottawa"])\n  , testCase ". is a field separator (works inside an AWK expression)" $\n      (o "/ca.Ot/" @?= ["Tests.North America.Ottawa"])\n  , testCase "Trees can adjust pattern" $\n      let tt\' =\n            adjustOption (\\(TestPattern _) -> fromJust $ parseTestPattern "Paris")\n              tt\n      in\n        (getTestNames mempty tt\' @?= ["Tests.Europe.Paris"])\n  ]\n  where\n  -- apply a pattern to tt and get the names of tests that match\n  o s = getTestNames (setOption (fromJust $ parseTestPattern s) mempty) tt\n\ngetTestNames :: OptionSet -> TestTree -> [String]\ngetTestNames =\n  foldTestTree\n    trivialFold\n      { foldSingle = \\_ name _ -> [name]\n      , foldGroup = \\_opts n l -> map ((n ++ ".") ++) (concat l)\n      }\n\n-- the tree being tested\ntt :: TestTree\ntt =\n  testGroup "Tests"\n    [ testGroup "Europe" [t "London", t "Paris", t "Berlin"]\n    , testGroup "North America" [t "Ottawa", t "Washington DC"]\n    ]\n  where\n    -- trivial HUnit test\n    t s = testCase s (return ())\n\n-- | Test the behavior of the warning messages that are generated from\n-- command-line argument parsers. See #270.\noptionMessagesTests :: TestTree\noptionMessagesTests = testGroup "OptionMessages"\n  [ testCaseInfo "JankyOption generates warning messages" $ do\n      length warnings @?= 2\n      return (unlines warnings)\n  ]\n  where\n    (warnings, _) = optionParser [Option (Proxy :: Proxy JankyOption)]\n\ndata JankyOption = MkJankyOption Int Int\n  deriving Typeable\ninstance IsOption JankyOption where\n  defaultValue   = MkJankyOption 27 42\n  parseValue     = \\_ -> return defaultValue\n  optionName     = return "janky-option"\n  optionHelp     = return "This is an incredibly janky option. For testing purposes only!"\n  -- This implementation of optionCLParser does two shameful things that\n  -- beget warning messages:\n  --\n  -- 1. It uses Options.Applicative.value.\n  -- 2. It defines two options instead of just one.\n  optionCLParser = MkJankyOption\n    <$> option auto (value 27)\n    <*> option auto (value 42)\n'