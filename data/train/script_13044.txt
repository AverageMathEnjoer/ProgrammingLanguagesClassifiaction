b'{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Data.Hoodle.Simple.V0_1_1 where\n\nimport qualified Data.ByteString as S\nimport Data.ByteString.Char8 (ByteString)\nimport Data.Hoodle.Util (fst3, snd3)\nimport qualified Data.Serialize as SE\nimport Data.Strict.Tuple (Pair (..))\nimport Lens.Micro (Lens\', lens)\nimport Prelude hiding (curry, fst, id, putStrLn, snd, uncurry, (.))\n\n-- |\ntype Title = S.ByteString\n\n-- | wrapper of object embeddable in Layer\ndata Item\n  = ItemStroke Stroke\n  | ItemImage Image\n  | ItemSVG SVG\n  --  | ItemLink Link\n  deriving (Show, Eq, Ord)\n\n-- | Pen stroke item\ndata Stroke\n  = Stroke\n      { stroke_tool :: !S.ByteString,\n        stroke_color :: !S.ByteString,\n        stroke_width :: !Double,\n        stroke_data :: ![Pair Double Double]\n      }\n  | VWStroke\n      { stroke_tool :: S.ByteString,\n        stroke_color :: S.ByteString,\n        stroke_vwdata :: [(Double, Double, Double)]\n      }\n  deriving (Show, Eq, Ord)\n\n-- | Image item\ndata Image = Image\n  { img_src :: S.ByteString,\n    img_pos :: (Double, Double),\n    img_dim :: !Dimension\n  }\n  deriving (Show, Eq, Ord)\n\ndata SVG = SVG\n  { svg_text :: Maybe S.ByteString,\n    svg_command :: Maybe S.ByteString,\n    svg_render :: S.ByteString,\n    svg_pos :: (Double, Double),\n    svg_dim :: !Dimension\n  }\n  deriving (Show, Eq, Ord)\n\n-- |\ninstance SE.Serialize Stroke where\n  put Stroke {..} =\n    SE.putWord8 0\n      >> SE.put stroke_tool\n      >> SE.put stroke_color\n      >> SE.put stroke_width\n      >> SE.put stroke_data\n  put VWStroke {..} =\n    SE.putWord8 1\n      >> SE.put stroke_tool\n      >> SE.put stroke_color\n      >> SE.put stroke_vwdata\n  get = do\n    tag <- SE.getWord8\n    case tag of\n      0 -> Stroke <$> SE.get <*> SE.get <*> SE.get <*> SE.get\n      1 -> VWStroke <$> SE.get <*> SE.get <*> SE.get\n      _ -> fail "err in Stroke parsing"\n\n-- |\ninstance SE.Serialize Image where\n  put Image {..} =\n    SE.put img_src\n      >> SE.put img_pos\n      >> SE.put img_dim\n  get = Image <$> SE.get <*> SE.get <*> SE.get\n\n-- |\ninstance SE.Serialize SVG where\n  put SVG {..} =\n    SE.put svg_text\n      >> SE.put svg_command\n      >> SE.put svg_render\n      >> SE.put svg_pos\n      >> SE.put svg_dim\n  get = SVG <$> SE.get <*> SE.get <*> SE.get <*> SE.get <*> SE.get\n\n-- |\ninstance SE.Serialize Item where\n  put (ItemStroke str) =\n    SE.putWord8 0\n      >> SE.put str\n  put (ItemImage img) =\n    SE.putWord8 1\n      >> SE.put img\n  put (ItemSVG svg) =\n    SE.putWord8 2\n      >> SE.put svg\n  get = do\n    tag <- SE.getWord8\n    case tag of\n      0 -> ItemStroke <$> SE.get\n      1 -> ItemImage <$> SE.get\n      2 -> ItemSVG <$> SE.get\n      _ -> fail "err in Item parsing"\n\n-- | Orphan instancef for Pair\ninstance (SE.Serialize a, SE.Serialize b) => SE.Serialize (Pair a b) where\n  put (x :!: y) =\n    SE.put x\n      >> SE.put y\n  get = (:!:) <$> SE.get <*> SE.get\n\n-- |\ndata Dimension = Dim {dim_width :: !Double, dim_height :: !Double}\n  deriving (Show, Eq, Ord)\n\n-- |\ninstance SE.Serialize Dimension where\n  put (Dim w h) = SE.put w >> SE.put h\n  get = Dim <$> SE.get <*> SE.get\n\n-- |\ndata Background\n  = Background\n      { bkg_type :: !S.ByteString,\n        bkg_color :: !S.ByteString,\n        bkg_style :: !S.ByteString\n      }\n  | BackgroundPdf\n      { bkg_type :: S.ByteString,\n        bkg_domain :: Maybe S.ByteString,\n        bkg_filename :: Maybe S.ByteString,\n        bkg_pageno :: Int\n      }\n  deriving (Show)\n\n-- |\ndata Hoodle = Hoodle\n  { hoodle_title :: !Title,\n    hoodle_pages :: ![Page]\n  }\n  deriving (Show)\n\n-- |\ndata Page = Page\n  { page_dim :: !Dimension,\n    page_bkg :: !Background,\n    page_layers :: ![Layer]\n  }\n  deriving (Show)\n\n-- |\nnewtype Layer = Layer {layer_items :: [Item]}\n  deriving (Show)\n\n-- |\ngetXYtuples :: Stroke -> [(Double, Double)]\ngetXYtuples (Stroke _t _c _w d) = map (\\(x :!: y) -> (x, y)) d\ngetXYtuples (VWStroke _t _c d) = map ((,) <$> fst3 <*> snd3) d\n\n----------------------------\n-- Lenses\n----------------------------\n\n-- |\ntool :: Lens\' Stroke ByteString\ntool = lens stroke_tool (\\f a -> f {stroke_tool = a})\n\n-- |\ncolor :: Lens\' Stroke ByteString\ncolor = lens stroke_color (\\f a -> f {stroke_color = a})\n\n-- |\ntitle :: Lens\' Hoodle Title\ntitle = lens hoodle_title (\\f a -> f {hoodle_title = a})\n\n-- |\npages :: Lens\' Hoodle [Page]\npages = lens hoodle_pages (\\f a -> f {hoodle_pages = a})\n\n-- |\ndimension :: Lens\' Page Dimension\ndimension = lens page_dim (\\f a -> f {page_dim = a})\n\n-- |\nbackground :: Lens\' Page Background\nbackground = lens page_bkg (\\f a -> f {page_bkg = a})\n\n-- |\nlayers :: Lens\' Page [Layer]\nlayers = lens page_layers (\\f a -> f {page_layers = a})\n\n-- |\nitems :: Lens\' Layer [Item]\nitems = lens layer_items (\\f a -> f {layer_items = a})\n\n--------------------------\n-- empty objects\n--------------------------\n\n-- |\nemptyHoodle :: Hoodle\nemptyHoodle = Hoodle "" []\n\n-- |\nemptyLayer :: Layer\nemptyLayer = Layer {layer_items = []}\n\n-- |\nemptyStroke :: Stroke\nemptyStroke = Stroke "pen" "black" 1.4 []\n\n-- |\ndefaultBackground :: Background\ndefaultBackground =\n  Background\n    { bkg_type = "solid",\n      bkg_color = "white",\n      bkg_style = "lined"\n    }\n\n-- |\ndefaultPage :: Page\ndefaultPage =\n  Page\n    { page_dim = Dim 612.0 792.0,\n      page_bkg = defaultBackground,\n      page_layers = [emptyLayer]\n    }\n\n-- |\ndefaultHoodle :: Hoodle\ndefaultHoodle = Hoodle "untitled" [defaultPage]\n\n-- |\nnewPageFromOld :: Page -> Page\nnewPageFromOld page =\n  Page\n    { page_dim = page_dim page,\n      page_bkg = page_bkg page,\n      page_layers = [emptyLayer]\n    }\n'