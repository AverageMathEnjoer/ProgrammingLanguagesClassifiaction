b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE CPP #-}\n\n-- | Instances that allow us to use Haskell as a backend syntax. This allows us\n-- to use migrations defined a la \'Database.Beam.Migrate.SQL\' to generate a beam\n-- schema.\n--\n-- Mainly of interest to backends.\n--\n-- Unfortunately, we define some orphan \'Hashable\' instances that aren\'t defined\n-- for us in @haskell-src-exts@.\nmodule Database.Beam.Haskell.Syntax where\n\nimport           Database.Beam\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Backend.SQL.AST\nimport           Database.Beam.Backend.SQL.Builder\nimport           Database.Beam.Migrate.Checks (HasDataTypeCreatedCheck(..))\nimport           Database.Beam.Migrate.SQL.SQL92\nimport           Database.Beam.Migrate.SQL.Types\nimport           Database.Beam.Migrate.Serialization\n\nimport           Data.Char (toLower, toUpper)\nimport           Data.Hashable\nimport           Data.Int\nimport           Data.List (find, nub)\nimport qualified Data.Map as M\nimport           Data.Maybe\nimport qualified Data.Set as S\nimport           Data.String\nimport qualified Data.Text as T\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\n\nimport qualified Language.Haskell.Exts as Hs\n\nimport           Text.PrettyPrint (render)\n\nnewtype HsDbField = HsDbField { buildHsDbField :: Hs.Type () -> Hs.Type () }\n\ndata HsConstraintDefinition\n  = HsConstraintDefinition\n  { hsConstraintDefinitionConstraint :: HsExpr }\n  deriving (Show, Eq, Generic)\ninstance Hashable HsConstraintDefinition\ninstance Sql92DisplaySyntax HsConstraintDefinition where\n  displaySyntax = show\n\nnewtype HsEntityName = HsEntityName { getHsEntityName :: String } deriving (Show, Eq, Ord, IsString)\n\ndata HsImport = HsImportAll | HsImportSome (S.Set (Hs.ImportSpec ()))\n  deriving (Show, Eq, Generic)\ninstance Hashable HsImport\ninstance Semigroup HsImport where\n  (<>) = mappend\ninstance Monoid HsImport where\n  mempty = HsImportSome mempty\n  mappend HsImportAll _ = HsImportAll\n  mappend _ HsImportAll = HsImportAll\n  mappend (HsImportSome a) (HsImportSome b) =\n    HsImportSome (a <> b)\n\nimportSome :: T.Text -> [ Hs.ImportSpec () ] -> HsImports\nimportSome modNm names = HsImports (M.singleton (Hs.ModuleName () (T.unpack modNm))\n                                                (HsImportSome (S.fromList names)))\n\nimportTyNamed :: T.Text -> Hs.ImportSpec ()\nimportTyNamed = importVarNamed -- nm = Hs.IAbs () (Hs.TypeNamespace ()) (Hs.Ident () (T.unpack nm))\n\nimportVarNamed :: T.Text -> Hs.ImportSpec ()\nimportVarNamed nm = Hs.IVar () (Hs.Ident () (T.unpack nm))\n\nnewtype HsImports = HsImports (M.Map (Hs.ModuleName ()) HsImport)\n  deriving (Show, Eq)\ninstance Hashable HsImports where\n  hashWithSalt s (HsImports a) = hashWithSalt s (M.assocs a)\ninstance Semigroup HsImports where\n  (<>) = mappend\ninstance Monoid HsImports where\n  mempty = HsImports mempty\n  mappend (HsImports a) (HsImports b) =\n    HsImports (M.unionWith mappend a b)\n\ndata HsDataType\n  = HsDataType\n  { hsDataTypeMigration :: HsExpr\n  , hsDataTypeType :: HsType\n  , hsDataTypeSerialized :: BeamSerializedDataType\n  } deriving (Eq, Show, Generic)\ninstance Hashable HsDataType where\n  hashWithSalt salt (HsDataType mig ty _) = hashWithSalt salt (mig, ty)\ninstance Sql92DisplaySyntax HsDataType where\n  displaySyntax = show\ninstance HasDataTypeCreatedCheck HsDataType where\n  dataTypeHasBeenCreated _ _ = True -- TODO make this more robust\n\ndata HsType\n  = HsType\n  { hsTypeSyntax  :: Hs.Type ()\n  , hsTypeImports :: HsImports\n  } deriving (Show, Eq, Generic)\ninstance Hashable HsType\n\ndata HsExpr\n  = HsExpr\n  { hsExprSyntax  :: Hs.Exp ()\n  , hsExprImports :: HsImports\n  , hsExprConstraints :: [ Hs.Asst () ]\n  , hsExprTypeVariables :: S.Set (Hs.Name ())\n  } deriving (Show, Eq, Generic)\ninstance Hashable HsExpr\n\ndata HsColumnSchema\n  = HsColumnSchema\n  { mkHsColumnSchema :: T.Text -> HsExpr\n  , hsColumnSchemaType :: HsType\n  }\ninstance Show HsColumnSchema where\n  show (HsColumnSchema mk _) = show (mk "fieldNm")\ninstance Eq HsColumnSchema where\n  HsColumnSchema a aTy == HsColumnSchema b bTy = a "fieldNm" == b "fieldNm" && aTy == bTy\ninstance Hashable HsColumnSchema where\n  hashWithSalt s (HsColumnSchema mk ty) = hashWithSalt s (mk "fieldNm", ty)\ninstance Sql92DisplaySyntax HsColumnSchema where\n  displaySyntax = show\n\ndata HsDecl\n  = HsDecl\n  { hsDeclSyntax  :: Hs.Decl ()\n  , hsDeclImports :: HsImports\n  , hsDeclExports :: [ Hs.ExportSpec () ]\n  }\n\ndata HsAction\n  = HsAction\n  { hsSyntaxMigration :: [ (Maybe (Hs.Pat ()), HsExpr) ]\n  , hsSyntaxEntities  :: [ HsEntity ]\n  }\n\ninstance Semigroup HsAction where\n  (<>) = mappend\ninstance Monoid HsAction where\n  mempty = HsAction [] []\n  mappend (HsAction ma ea) (HsAction mb eb) =\n    HsAction (ma <> mb) (ea <> eb)\n\nnewtype HsBackendConstraint = HsBackendConstraint { buildHsBackendConstraint :: Hs.Type () -> Hs.Asst () }\n\ndata HsBeamBackend f\n  = HsBeamBackendSingle HsType f\n  | HsBeamBackendConstrained [ HsBackendConstraint ]\n  | HsBeamBackendNone\n\ninstance Semigroup (HsBeamBackend f) where\n  (<>) = mappend\ninstance Monoid (HsBeamBackend f) where\n  mempty = HsBeamBackendConstrained []\n  mappend (HsBeamBackendSingle aTy aExp) (HsBeamBackendSingle bTy _)\n    | aTy == bTy = HsBeamBackendSingle aTy aExp\n    | otherwise = HsBeamBackendNone\n  mappend a@HsBeamBackendSingle {} _ = a\n  mappend _ b@HsBeamBackendSingle {} = b\n  mappend HsBeamBackendNone _ = HsBeamBackendNone\n  mappend _ HsBeamBackendNone = HsBeamBackendNone\n  mappend (HsBeamBackendConstrained a) (HsBeamBackendConstrained b) =\n    HsBeamBackendConstrained (a <> b)\n\ndata HsEntity\n    = HsEntity\n    { hsEntityBackend :: HsBeamBackend HsExpr\n\n    , hsEntityName    :: HsEntityName\n\n    , hsEntityDecls   :: [ HsDecl ]\n    , hsEntityDbDecl  :: HsDbField\n\n    , hsEntityExp     :: HsExpr\n    }\n\nnewtype HsFieldLookup = HsFieldLookup { hsFieldLookup :: T.Text -> Maybe (T.Text, Hs.Type ()) }\nnewtype HsTableConstraint = HsTableConstraint (T.Text -> HsFieldLookup -> HsTableConstraintDecls)\n\ndata HsTableConstraintDecls\n    = HsTableConstraintDecls\n    { hsTableConstraintInstance :: [ Hs.InstDecl () ]\n    , hsTableConstraintDecls    :: [ HsDecl ]\n    }\n\ninstance Semigroup HsTableConstraintDecls where\n  (<>) = mappend\n\ninstance Monoid HsTableConstraintDecls where\n  mempty = HsTableConstraintDecls [] []\n  mappend (HsTableConstraintDecls ai ad) (HsTableConstraintDecls bi bd) =\n    HsTableConstraintDecls (ai <> bi) (ad <> bd)\n\ndata HsModule\n  = HsModule\n  { hsModuleName :: String\n  , hsModuleEntities :: [ HsEntity ]\n  , hsModuleMigration :: [ (Maybe (Hs.Pat ()), HsExpr) ]\n  }\n\nhsActionsToModule :: String -> [ HsAction ] -> HsModule\nhsActionsToModule modNm actions =\n  let HsAction ms es = mconcat actions\n  in HsModule modNm es ms\n\nunqual :: String -> Hs.QName ()\nunqual = Hs.UnQual () . Hs.Ident ()\n\nentityDbFieldName :: HsEntity -> String\nentityDbFieldName entity = "_" ++ getHsEntityName (hsEntityName entity)\n\nderivingDecl :: [Hs.InstRule ()] -> Hs.Deriving ()\nderivingDecl =\n#if MIN_VERSION_haskell_src_exts(1,20,0)\n  Hs.Deriving () Nothing\n#else\n  Hs.Deriving ()\n#endif\n\ndataDecl :: Hs.DeclHead ()\n         -> [Hs.QualConDecl ()]\n         -> Maybe (Hs.Deriving ())\n         -> Hs.Decl ()\ndataDecl declHead cons deriving_ =\n#if MIN_VERSION_haskell_src_exts(1,20,0)\n  Hs.DataDecl () (Hs.DataType ()) Nothing declHead cons (maybeToList deriving_)\n#else\n  Hs.DataDecl () (Hs.DataType ()) Nothing declHead cons deriving_\n#endif\n\ninsDataDecl :: Hs.Type ()\n            -> [Hs.QualConDecl ()]\n            -> Maybe (Hs.Deriving ())\n            -> Hs.InstDecl ()\ninsDataDecl declHead cons deriving_ =\n#if MIN_VERSION_haskell_src_exts(1,20,0)\n   Hs.InsData () (Hs.DataType ()) declHead cons (maybeToList deriving_)\n#else\n   Hs.InsData () (Hs.DataType ()) declHead cons deriving_\n#endif\n\ndatabaseTypeDecl :: [ HsEntity ] -> Hs.Decl ()\ndatabaseTypeDecl entities =\n  dataDecl declHead [ conDecl ] (Just deriving_)\n  where\n    declHead = Hs.DHApp () (Hs.DHead () (Hs.Ident () "Db"))\n                           (Hs.UnkindedVar () (Hs.Ident () "entity"))\n    conDecl = Hs.QualConDecl () Nothing Nothing\n                (Hs.RecDecl () (Hs.Ident () "Db") (mkField <$> entities))\n    deriving_ = derivingDecl [ Hs.IRule () Nothing Nothing $\n                               Hs.IHCon () $ Hs.UnQual () $\n                               Hs.Ident () "Generic" ]\n\n    mkField entity = Hs.FieldDecl () [ Hs.Ident () (entityDbFieldName entity) ]\n                                     (buildHsDbField (hsEntityDbDecl entity) $\n                                      Hs.TyVar () (Hs.Ident () "entity"))\n\nmigrationTypeDecl :: HsBeamBackend HsExpr -> [Hs.Type ()] -> Hs.Decl ()\nmigrationTypeDecl be inputs =\n  Hs.TypeSig () [Hs.Ident () "migration"] migrationType\n  where\n    (beAssts, beVar) =\n      case be of\n        HsBeamBackendNone -> error "No backend matches"\n        HsBeamBackendSingle ty _ -> ([], hsTypeSyntax ty)\n        HsBeamBackendConstrained cs ->\n          ( map (flip buildHsBackendConstraint beVar) cs\n          , tyVarNamed "be" )\n\n    resultType = tyApp (tyConNamed "Migration")\n                       [ beVar\n                       , tyApp (tyConNamed "CheckedDatabaseSettings")\n                               [ beVar\n                               , tyConNamed "Db" ] ]\n\n    migrationUnconstrainedType\n      | [] <- inputs = resultType\n      | otherwise    = functionTy (tyTuple inputs) resultType\n\n    constraints = nub beAssts\n    migrationType\n      | [] <- constraints  = migrationUnconstrainedType\n      | [c] <- constraints = Hs.TyForall () Nothing (Just (Hs.CxSingle () c)) migrationUnconstrainedType\n      | otherwise          = Hs.TyForall () Nothing (Just (Hs.CxTuple () constraints)) migrationUnconstrainedType\n\nmigrationDecl :: HsBeamBackend HsExpr -> [Hs.Exp ()] -> [ (Maybe (Hs.Pat ()), HsExpr) ] -> [HsEntity] -> Hs.Decl ()\nmigrationDecl _ _ migrations entities =\n  Hs.FunBind () [ Hs.Match () (Hs.Ident () "migration") [] (Hs.UnGuardedRhs () body) Nothing ]\n  where\n    body = Hs.Do () (map (\\(pat, expr) ->\n                            let expr\' = hsExprSyntax expr\n                            in case pat of\n                              Nothing -> Hs.Qualifier () expr\'\n                              Just pat\' -> Hs.Generator () pat\' expr\') migrations ++\n                     [Hs.Qualifier () (hsExprSyntax finalReturn)])\n\n    finalReturn = hsApp (hsVar "pure")\n                        [ hsRecCon "Db" (map (\\e -> (fromString (entityDbFieldName e), hsEntityExp e)) entities) ]\n\ndbTypeDecl :: HsBeamBackend HsExpr -> Hs.Decl ()\ndbTypeDecl be =\n  Hs.TypeSig () [ Hs.Ident () "db" ] dbType\n  where\n    unconstrainedDbType = tyApp (tyConNamed "DatabaseSettings")\n                                [ beVar, tyConNamed "Db" ]\n    dbType\n      | []  <- constraints, [] <- bindings = unconstrainedDbType\n      | []  <- constraints  = Hs.TyForall () (Just bindings) Nothing unconstrainedDbType\n      | [c] <- constraints = Hs.TyForall () (Just bindings) (Just (Hs.CxSingle () c)) unconstrainedDbType\n      | otherwise          = Hs.TyForall () (Just bindings) (Just (Hs.CxTuple () constraints)) unconstrainedDbType\n\n    constraints = nub beAssts\n    (bindings, beAssts, beVar) =\n      case be of\n        HsBeamBackendNone -> error "No backend matches"\n        HsBeamBackendSingle ty _ -> (standardBindings, [], hsTypeSyntax ty)\n        HsBeamBackendConstrained cs ->\n          ( tyVarBind "be":standardBindings\n          , map (flip buildHsBackendConstraint beVar) cs\n          , tyVarNamed "be" )\n\n    standardBindings = []\n\n    tyVarBind nm = Hs.UnkindedVar () (Hs.Ident () nm)\n\ndbDecl :: HsBeamBackend HsExpr -> [HsExpr] -> Hs.Decl ()\ndbDecl backend params =\n  Hs.FunBind () [ Hs.Match () (Hs.Ident () "db") [] (Hs.UnGuardedRhs () body) Nothing ]\n  where\n    backendVar = case backend of\n                   HsBeamBackendNone -> error "No syntax matches"\n                   HsBeamBackendSingle ty _ -> hsTypeSyntax ty\n                   HsBeamBackendConstrained _ -> tyVarNamed "be"\n\n    body = hsExprSyntax $\n           hsApp (hsVar "unCheckDatabase")\n                 [ hsApp (hsVarFrom "runMigrationSilenced" "Database.Beam.Migrate")\n                   [ hsApp (hsVisibleTyApp (hsVar "migration") backendVar) $\n                     case params of\n                       [] -> []\n                       _  -> [ hsTuple params ]\n                   ] ]\n\nrenderHsSchema :: HsModule -> Either String String\nrenderHsSchema (HsModule modNm entities migrations) =\n  let hsMod = Hs.Module () (Just modHead) modPragmas imports decls\n\n      modHead = Hs.ModuleHead () (Hs.ModuleName () modNm) Nothing (Just modExports)\n      modExports = Hs.ExportSpecList () (commonExports ++ foldMap (foldMap hsDeclExports . hsEntityDecls) entities)\n      commonExports = [ Hs.EVar () (unqual "db")\n                      , Hs.EVar () (unqual "migration")\n                      , Hs.EThingWith () (Hs.EWildcard () 0)\n                                      (unqual "Db") [] ]\n\n      modPragmas = [ Hs.LanguagePragma () [ Hs.Ident () "StandaloneDeriving"\n                                          , Hs.Ident () "GADTs"\n                                          , Hs.Ident () "ScopedTypeVariables"\n                                          , Hs.Ident () "FlexibleContexts"\n                                          , Hs.Ident () "FlexibleInstances"\n                                          , Hs.Ident () "DeriveGeneric"\n                                          , Hs.Ident () "TypeSynonymInstances"\n                                          , Hs.Ident () "ExplicitNamespaces"\n                                          , Hs.Ident () "TypeApplications"\n                                          , Hs.Ident () "TypeFamilies"\n                                          , Hs.Ident () "OverloadedStrings" ] ]\n\n      HsImports importedModules = foldMap (\\e -> foldMap hsDeclImports (hsEntityDecls e) <>\n                                                 hsExprImports (hsEntityExp e)) entities <>\n                                  foldMap (hsExprImports . snd) migrations <>\n                                  importSome "Database.Beam.Migrate" [ importTyNamed "CheckedDatabaseSettings", importTyNamed "Migration"\n                                                                     , importTyNamed "BeamMigrateSqlBackend"\n                                                                     , importVarNamed "runMigrationSilenced"\n                                                                     , importVarNamed "unCheckDatabase" ]\n      imports = commonImports <>\n                map (\\(modName, spec) ->\n                       case spec of\n                         HsImportAll -> Hs.ImportDecl () modName False False False Nothing Nothing Nothing\n                         HsImportSome nms ->\n                           let importList = Hs.ImportSpecList () False (S.toList nms)\n                           in Hs.ImportDecl () modName False False False Nothing Nothing (Just importList)\n                    )\n                    (M.assocs importedModules)\n\n      commonImports = [ Hs.ImportDecl () (Hs.ModuleName () "Database.Beam") False False False Nothing Nothing Nothing\n                      , Hs.ImportDecl () (Hs.ModuleName () "Control.Applicative") False False False Nothing Nothing Nothing ]\n\n      backend = foldMap hsEntityBackend entities\n\n      backendHs = case backend of\n                    HsBeamBackendNone -> error "Can\'t instantiate Database instance: No backend matches"\n                    HsBeamBackendSingle ty _ -> hsTypeSyntax ty\n                    HsBeamBackendConstrained {} -> tyVarNamed "be" -- TODO constraints\n\n      decls = foldMap (map hsDeclSyntax . hsEntityDecls) entities ++\n              [ databaseTypeDecl entities\n\n              , migrationTypeDecl backend []\n              , migrationDecl backend [] migrations entities\n\n              , hsInstance "Database" [ backendHs, tyConNamed "Db" ] []\n\n              , dbTypeDecl backend\n              , dbDecl backend [] ]\n\n  in Right (render (Hs.prettyPrim hsMod))\n\n-- * DDL Syntax definitions\n\ndata HsNone = HsNone deriving (Show, Eq, Ord, Generic)\ninstance Hashable HsNone\n\ninstance Semigroup HsNone where\n  (<>) = mappend\ninstance Monoid HsNone where\n  mempty = HsNone\n  mappend _ _ = HsNone\n\ndata HsMigrateBackend = HsMigrateBackend\n\ninstance BeamMigrateOnlySqlBackend HsMigrateBackend\ntype instance BeamSqlBackendSyntax HsMigrateBackend = HsAction\n\nhsMkTableName :: (Char -> Char) -> TableName -> String\nhsMkTableName toNameCase (TableName sch nm) =\n  case sch of\n    Nothing ->\n      case T.unpack nm of\n        [] -> error "No name for table"\n        x:xs -> toNameCase x:xs\n    Just schNm ->\n      case T.unpack schNm of\n        [] -> error "Empty schema name"\n        x:xs -> toNameCase x:xs ++ "_" ++ T.unpack nm\n\nhsTableVarName, hsTableTypeName :: TableName -> String\nhsTableVarName = hsMkTableName toLower\nhsTableTypeName = hsMkTableName toUpper\n\ninstance IsSql92DdlCommandSyntax HsAction where\n  type Sql92DdlCommandCreateTableSyntax HsAction = HsAction\n  type Sql92DdlCommandAlterTableSyntax HsAction = HsAction\n  type Sql92DdlCommandDropTableSyntax HsAction = HsAction\n\n  createTableCmd = id\n  dropTableCmd = id\n  alterTableCmd = id\n\ninstance IsSql92AlterTableSyntax HsAction where\n  type Sql92AlterTableTableNameSyntax HsAction = TableName\n  type Sql92AlterTableAlterTableActionSyntax HsAction = HsNone\n\n  alterTableSyntax _ _ = error "alterTableSyntax"\n\ninstance IsSql92AlterTableActionSyntax HsNone where\n  type Sql92AlterTableColumnSchemaSyntax HsNone = HsColumnSchema\n  type Sql92AlterTableAlterColumnActionSyntax HsNone = HsNone\n\n  alterColumnSyntax _ _ = HsNone\n  addColumnSyntax _ _ = HsNone\n  dropColumnSyntax _ = HsNone\n  renameTableToSyntax _ = HsNone\n  renameColumnToSyntax _ _ = HsNone\n\ninstance IsSql92AlterColumnActionSyntax HsNone where\n  setNullSyntax = HsNone\n  setNotNullSyntax = HsNone\n\ninstance IsSql92DropTableSyntax HsAction where\n  type Sql92DropTableTableNameSyntax HsAction = TableName\n\n  dropTableSyntax nm = HsAction [ (Nothing, dropTable) ] []\n    where\n      dropTable = hsApp (hsVar "dropTable") [ hsVar (fromString (hsTableVarName nm)) ]\n\ninstance IsSql92CreateTableSyntax HsAction where\n  type Sql92CreateTableTableNameSyntax HsAction = TableName\n  type Sql92CreateTableOptionsSyntax HsAction = HsNone\n  type Sql92CreateTableTableConstraintSyntax HsAction = HsTableConstraint\n  type Sql92CreateTableColumnSchemaSyntax HsAction = HsColumnSchema\n\n  createTableSyntax _ nm fields cs =\n    HsAction [ ( Just (Hs.PVar () (Hs.Ident () varName))\n               , migration ) ]\n             [ entity ]\n    where\n      (varName, tyName, tyConName) =\n        ( hsTableVarName nm, hsTableTypeName nm ++ "T", hsTableTypeName nm )\n\n      mkHsFieldName fieldNm = "_" ++ varName ++\n                              case T.unpack fieldNm of\n                                [] -> error "empty field name"\n                                (x:xs) -> toUpper x:xs\n\n      HsTableConstraintDecls tableInstanceDecls constraintDecls = foldMap (\\(HsTableConstraint mkConstraint) -> mkConstraint (fromString tyConName) fieldLookup) cs\n      fieldLookup = HsFieldLookup $ \\fieldNm ->\n                    fmap (\\(fieldNm\', ty\') -> (fromString (mkHsFieldName fieldNm\'), ty\')) $\n                    find ( (== fieldNm) . fst ) tyConFields\n\n      migration =\n        hsApp (hsVarFrom "createTable" "Database.Beam.Migrate")\n              [ hsStr (fromString (hsTableVarName nm))\n              , hsApp (hsTyCon (fromString tyConName))\n                      (map (\\(fieldNm, ty) -> mkHsColumnSchema ty fieldNm) fields) ]\n      entity = HsEntity\n             { hsEntityBackend = HsBeamBackendConstrained [ beamMigrateSqlBackend ]\n\n             , hsEntityName    = HsEntityName varName\n             , hsEntityDecls   = [ HsDecl tblDecl imports\n                                          [ Hs.EThingWith () (Hs.EWildcard () 0) (unqual tyName) [] ]\n                                 , HsDecl tblBeamable imports []\n\n                                 , HsDecl tblPun imports [ Hs.EVar () (unqual tyConName) ]\n\n                                 , HsDecl tblShowInstance imports []\n                                 , HsDecl tblEqInstance imports []\n\n                                 , HsDecl tblInstanceDecl imports []\n                                 ] ++\n                                 constraintDecls\n             , hsEntityDbDecl  = HsDbField (\\f -> tyApp f [ tyApp (tyConNamed "TableEntity") [tyConNamed tyName] ])\n             , hsEntityExp     = hsVar (fromString varName)\n             }\n\n      imports = foldMap (\\(_, ty) -> hsTypeImports (hsColumnSchemaType ty)) fields\n\n      tblDecl = dataDecl tblDeclHead [ tblConDecl ] (Just deriving_)\n      tblDeclHead = Hs.DHApp () (Hs.DHead () (Hs.Ident () tyName))\n                                (Hs.UnkindedVar () (Hs.Ident () "f"))\n      tblConDecl = Hs.QualConDecl () Nothing Nothing (Hs.RecDecl () (Hs.Ident () tyConName) tyConFieldDecls)\n\n      tyConFieldDecls = map (\\(fieldNm, ty) ->\n                                Hs.FieldDecl () [ Hs.Ident () (mkHsFieldName fieldNm) ] ty) tyConFields\n      tyConFields = map (\\(fieldNm, ty) -> ( fieldNm\n                                           , tyApp (tyConNamed "Columnar")\n                                                   [ tyVarNamed "f"\n                                                   , hsTypeSyntax (hsColumnSchemaType ty) ])) fields\n\n      deriving_ = derivingDecl [ inst "Generic" ]\n\n      tblBeamable = hsInstance "Beamable" [ tyConNamed tyName ] []\n      tblPun = Hs.TypeDecl () (Hs.DHead () (Hs.Ident () tyConName))\n                              (tyApp (tyConNamed tyName) [ tyConNamed "Identity" ])\n\n      tblEqInstance = hsDerivingInstance "Eq" [ tyConNamed tyConName ]\n      tblShowInstance = hsDerivingInstance "Show" [ tyConNamed tyConName]\n\n      tblInstanceDecl = hsInstance "Table" [ tyConNamed tyName ] tableInstanceDecls\n\ninstance IsSql92ColumnSchemaSyntax HsColumnSchema where\n  type Sql92ColumnSchemaColumnConstraintDefinitionSyntax HsColumnSchema = HsConstraintDefinition\n  type Sql92ColumnSchemaColumnTypeSyntax HsColumnSchema = HsDataType\n  type Sql92ColumnSchemaExpressionSyntax HsColumnSchema = HsExpr\n\n  columnSchemaSyntax dataType _ cs _ = HsColumnSchema (\\nm -> fieldExpr nm)\n                                                      (modTy $ hsDataTypeType dataType)\n    where\n      notNullable = any ((==notNullConstraintSyntax) . hsConstraintDefinitionConstraint) cs\n      modTy t = if notNullable then t else t { hsTypeSyntax = tyApp (tyConNamed "Maybe") [ hsTypeSyntax t ] }\n      modDataTy e = if notNullable then e else hsApp (hsVarFrom "maybeType" "Database.Beam.Migrate") [e]\n\n      fieldExpr nm = hsApp (hsVarFrom "field" "Database.Beam.Migrate")\n                           ([ hsStr nm\n                            , modDataTy (hsDataTypeMigration dataType) ] ++\n                            map hsConstraintDefinitionConstraint cs)\n\ninstance IsSql92TableConstraintSyntax HsTableConstraint where\n  primaryKeyConstraintSyntax fields =\n    HsTableConstraint $ \\tblNm tblFields ->\n    let primaryKeyDataDecl = insDataDecl primaryKeyType [ primaryKeyConDecl ] (Just primaryKeyDeriving)\n\n        tableTypeNm = tblNm <> "T"\n        tableTypeKeyNm = tblNm <> "Key"\n\n        (fieldRecordNames, fieldTys) = unzip (fromMaybe (error "fieldTys") (mapM (hsFieldLookup tblFields) fields))\n\n        primaryKeyType = tyApp (tyConNamed "PrimaryKey") [ tyConNamed (T.unpack tableTypeNm), tyVarNamed "f" ]\n        primaryKeyConDecl  = Hs.QualConDecl () Nothing Nothing (Hs.ConDecl () (Hs.Ident () (T.unpack tableTypeKeyNm)) fieldTys)\n        primaryKeyDeriving = derivingDecl [ inst "Generic" ]\n\n        primaryKeyTypeDecl = Hs.TypeDecl () (Hs.DHead () (Hs.Ident () (T.unpack tableTypeKeyNm)))\n                                            (tyApp (tyConNamed "PrimaryKey")\n                                                   [ tyConNamed (T.unpack tableTypeNm)\n                                                   , tyConNamed "Identity" ])\n\n        primaryKeyFunDecl = Hs.InsDecl () (Hs.FunBind () [Hs.Match () (Hs.Ident () "primaryKey") [] (Hs.UnGuardedRhs () primaryKeyFunBody) Nothing])\n        primaryKeyFunBody = hsExprSyntax $\n                            hsApApp (hsVar tableTypeKeyNm)\n                                    (map hsVar fieldRecordNames)\n\n        decl d = HsDecl d mempty mempty\n\n    in HsTableConstraintDecls [ primaryKeyDataDecl\n                              , primaryKeyFunDecl ]\n                              (HsDecl primaryKeyTypeDecl mempty [ Hs.EVar () (unqual (T.unpack tableTypeKeyNm)) ]:\n                               map decl [ hsInstance "Beamable" [ tyParens (tyApp (tyConNamed "PrimaryKey") [ tyConNamed (T.unpack tableTypeNm)  ]) ] []\n                                        , hsDerivingInstance "Eq" [ tyConNamed (T.unpack tableTypeKeyNm) ]\n                                        , hsDerivingInstance "Show" [ tyConNamed (T.unpack tableTypeKeyNm) ]\n                                        ])\n\ninstance IsSql92ColumnConstraintDefinitionSyntax HsConstraintDefinition where\n  type Sql92ColumnConstraintDefinitionAttributesSyntax HsConstraintDefinition = HsNone\n  type Sql92ColumnConstraintDefinitionConstraintSyntax HsConstraintDefinition = HsExpr\n\n  constraintDefinitionSyntax Nothing expr Nothing = HsConstraintDefinition expr\n  constraintDefinitionSyntax _ _ _ = error "constraintDefinitionSyntax{HsExpr}"\n\ninstance Sql92SerializableConstraintDefinitionSyntax HsConstraintDefinition where\n  serializeConstraint _ = "unknown-constrainst"\n\ninstance IsSql92MatchTypeSyntax HsNone where\n  fullMatchSyntax = HsNone\n  partialMatchSyntax = HsNone\ninstance IsSql92ReferentialActionSyntax HsNone where\n  referentialActionCascadeSyntax = HsNone\n  referentialActionNoActionSyntax = HsNone\n  referentialActionSetDefaultSyntax = HsNone\n  referentialActionSetNullSyntax = HsNone\n\ninstance IsSql92ExtractFieldSyntax HsExpr where\n  secondsField = hsVar "secondsField"\n  minutesField = hsVar "minutesField"\n  hourField    = hsVar "hourField"\n  yearField    = hsVar "yearField"\n  monthField   = hsVar "monthField"\n  dayField     = hsVar "dayField"\n\ninstance IsSql92ExpressionSyntax HsExpr where\n  type Sql92ExpressionFieldNameSyntax HsExpr = HsExpr\n  type Sql92ExpressionSelectSyntax HsExpr = SqlSyntaxBuilder\n  type Sql92ExpressionValueSyntax HsExpr = HsExpr\n  type Sql92ExpressionQuantifierSyntax HsExpr = HsExpr\n  type Sql92ExpressionExtractFieldSyntax HsExpr = HsExpr\n  type Sql92ExpressionCastTargetSyntax HsExpr = HsDataType\n\n  valueE = hsApp (hsVar "valueE") . pure\n  rowE = error "rowE"\n\n  currentTimestampE = hsVar "currentTimestampE"\n  defaultE = hsVar "defaultE"\n\n  coalesceE = hsApp (hsVar "coalesceE")\n  fieldE = hsApp (hsVar "fieldE") . pure\n\n  betweenE a b c = hsApp (hsVar "betweenE") [a, b, c]\n\n  andE a b = hsApp (hsVar "andE") [a, b]\n  orE a b = hsApp (hsVar "orE") [a, b]\n  addE a b = hsApp (hsVar "addE") [a, b]\n  subE a b = hsApp (hsVar "subE") [a, b]\n  mulE a b = hsApp (hsVar "mulE") [a, b]\n  divE a b = hsApp (hsVar "divE") [a, b]\n  modE a b = hsApp (hsVar "modE") [a, b]\n  likeE a b = hsApp (hsVar "likeE") [a, b]\n  overlapsE a b = hsApp (hsVar "overlapsE") [a, b]\n  positionE a b = hsApp (hsVar "positionE") [a, b]\n\n  notE = hsApp (hsVar "notE") . pure\n  negateE = hsApp (hsVar "negateE") . pure\n  absE = hsApp (hsVar "absE") . pure\n  charLengthE = hsApp (hsVar "charLengthE") . pure\n  octetLengthE = hsApp (hsVar "octetLengthE") . pure\n  bitLengthE = hsApp (hsVar "bitLengthE") . pure\n  lowerE = hsApp (hsVar "lowerE") . pure\n  upperE = hsApp (hsVar "upperE") . pure\n  trimE = hsApp (hsVar "trimE") . pure\n\n  existsE = error "existsE"\n  uniqueE = error "uniqueE"\n  subqueryE = error "subqueryE"\n\n  caseE = error "caseE"\n  nullIfE a b = hsApp (hsVar "nullIfE") [a, b]\n\n  castE = error "castE"\n  extractE = error "extractE"\n\n  isNullE = hsApp (hsVar "isNullE") . pure\n  isNotNullE = hsApp (hsVar "isNotNullE") . pure\n  isTrueE = hsApp (hsVar "isTrueE") . pure\n  isFalseE = hsApp (hsVar "isFalseE") . pure\n  isNotTrueE = hsApp (hsVar "isNotTrueE") . pure\n  isNotFalseE = hsApp (hsVar "isNotFalseE") . pure\n  isUnknownE = hsApp (hsVar "isUnknownE") . pure\n  isNotUnknownE = hsApp (hsVar "isNotUnknownE") . pure\n\n  eqE q a b = hsApp (hsVar "eqE")   [hsMaybe q, a, b]\n  neqE q a b = hsApp (hsVar "neqE") [hsMaybe q, a, b]\n  gtE q a b = hsApp (hsVar "gtE")   [hsMaybe q, a, b]\n  ltE q a b = hsApp (hsVar "ltE")   [hsMaybe q, a, b]\n  geE q a b = hsApp (hsVar "geE")   [hsMaybe q, a, b]\n  leE q a b = hsApp (hsVar "leE")   [hsMaybe q, a, b]\n\n  inE a b = hsApp (hsVar "inE") [a, hsList b]\n  inSelectE _ _ = error "inSelectE"\n\ninstance IsSql92QuantifierSyntax HsExpr where\n  quantifyOverAll = hsVar "quantifyOverAll"\n  quantifyOverAny = hsVar "quantifyOverAny"\n\ninstance IsSql92ColumnConstraintSyntax HsExpr where\n  type Sql92ColumnConstraintExpressionSyntax HsExpr = HsExpr\n  type Sql92ColumnConstraintMatchTypeSyntax HsExpr = HsNone\n  type Sql92ColumnConstraintReferentialActionSyntax HsExpr = HsNone\n\n  notNullConstraintSyntax = hsVarFrom "notNull" "Database.Beam.Migrate"\n  uniqueColumnConstraintSyntax = hsVar "unique"\n  checkColumnConstraintSyntax = error "checkColumnConstraintSyntax"\n  primaryKeyColumnConstraintSyntax = error "primaryKeyColumnConstraintSyntax"\n  referencesConstraintSyntax = error "referencesConstraintSyntax"\n\ninstance IsSql92ConstraintAttributesSyntax HsNone where\n  initiallyDeferredAttributeSyntax = HsNone\n  initiallyImmediateAttributeSyntax = HsNone\n  notDeferrableAttributeSyntax = HsNone\n  deferrableAttributeSyntax = HsNone\n\ninstance HasSqlValueSyntax HsExpr Int32 where\n  sqlValueSyntax = hsInt\ninstance HasSqlValueSyntax HsExpr Bool where\n  sqlValueSyntax True = hsVar "True"\n  sqlValueSyntax False = hsVar "False"\n\ninstance IsSql92FieldNameSyntax HsExpr where\n  qualifiedField tbl nm = hsApp (hsVar "qualifiedField") [ hsStr tbl, hsStr nm ]\n  unqualifiedField nm = hsApp (hsVar "unqualifiedField") [ hsStr nm ]\n\nhsErrorType :: String -> HsDataType\nhsErrorType msg =\n  HsDataType (hsApp (hsVar "error") [ hsStr ("Unknown type: " <> fromString msg) ]) (HsType (tyConNamed "Void") (importSome "Data.Void" [ importTyNamed "Void" ]))\n             (BeamSerializedDataType "hsErrorType")\n\ninstance IsSql92DataTypeSyntax HsDataType where\n  intType = HsDataType (hsVarFrom "int" "Database.Beam.Migrate") (HsType (tyConNamed "Int") mempty) intType\n  smallIntType = HsDataType (hsVarFrom "smallint" "Database.Beam.Migrate") (HsType (tyConNamed "Int16") (importSome "Data.Int" [ importTyNamed "Int16" ])) intType\n  doubleType = HsDataType (hsVarFrom "double" "Database.Beam.Migrate") (HsType (tyConNamed "Double") mempty) doubleType\n\n  floatType width = HsDataType (hsApp (hsVarFrom "float" "Database.Beam.Migrate")\n                                      [ hsMaybe (hsInt <$> width) ])\n                               (HsType (tyConNamed "Scientific") (importSome "Data.Scientific" [ importTyNamed "Scientific" ]))\n                               (floatType width)\n\n  realType = HsDataType (hsVarFrom "real" "Database.Beam.Migrate") (HsType (tyConNamed "Double") mempty) realType\n\n  charType _ Just {} = error "char collation"\n  charType width Nothing = HsDataType (hsApp (hsVarFrom "char" "Database.Beam.Migrate")\n                                             [ hsMaybe (hsInt <$> width) ])\n                                      (HsType (tyConNamed "Text") (importSome "Data.Text" [ importTyNamed "Text" ]))\n                                      (charType width Nothing)\n\n  varCharType _ Just {} = error "varchar collation"\n  varCharType width Nothing = HsDataType (hsApp (hsVarFrom "varchar" "Database.Beam.Migrate")\n                                                [ hsMaybe (hsInt <$> width) ])\n                                         (HsType (tyConNamed "Text") (importSome "Data.Text" [ importTyNamed "Text" ]))\n                                         (varCharType width Nothing)\n\n  nationalCharType width = HsDataType (hsApp (hsVarFrom "nationalChar" "Database.Beam.Migrate")\n                                             [ hsMaybe (hsInt <$> width) ])\n                                      (HsType (tyConNamed "Text") (importSome "Data.Text" [ importTyNamed "Text" ]))\n                                      (nationalCharType width)\n\n  nationalVarCharType width = HsDataType (hsApp (hsVarFrom "nationalVarchar" "Database.Beam.Migrate")\n                                                [ hsMaybe (hsInt <$> width) ])\n                                         (HsType (tyConNamed "Text") (importSome "Data.Text" [ importTyNamed "Text" ]))\n                                         (nationalVarCharType width)\n\n  bitType width = HsDataType (hsApp (hsVarFrom "bit" "Database.Beam.Migrate")\n                                    [ hsMaybe (hsInt <$> width) ])\n                             (HsType (tyConNamed "SqlBits") mempty)\n                             (bitType width)\n\n  varBitType width = HsDataType (hsApp (hsVarFrom "varbit" "Database.Beam.Migrate")\n                                       [ hsMaybe (hsInt <$> width) ])\n                                (HsType (tyConNamed "SqlBits") mempty)\n                                (varBitType width)\n\n  dateType = HsDataType (hsVarFrom "date" "Database.Beam.Migrate")\n                        (HsType (tyConNamed "Day") (importSome "Data.Time" [ importTyNamed "Day" ])) dateType\n\n  timeType p False = HsDataType (hsApp (hsVarFrom "time" "Database.Beam.Migrate") [ hsMaybe Nothing ] )\n                                (HsType (tyConNamed "TimeOfDay") (importSome "Data.Time" [ importTyNamed "TimeOfDay" ]))\n                                (timeType p False)\n  timeType _ _ = error "timeType"\n  domainType _ = error "domainType"\n  timestampType Nothing True =\n    HsDataType (hsVarFrom "timestamptz" "Database.Beam.Migrate")\n               (HsType (tyConNamed "LocalTime") (importSome "Data.Time" [ importTyNamed "LocalTime" ]))\n               (timestampType Nothing True)\n  timestampType Nothing False =\n    HsDataType (hsVarFrom "timestamp" "Database.Beam.Migrate")\n               (HsType (tyConNamed "LocalTime") (importSome "Data.Time" [ importTyNamed "LocalTime" ]))\n               (timestampType Nothing False)\n  timestampType _ _ = error "timestampType with prec"\n\n  numericType precDec =\n    HsDataType (hsApp (hsVarFrom "numeric" "Database.Beam.Migrate")\n                      [ hsMaybe (fmap (\\(prec, dec) -> hsTuple [ hsInt prec, hsMaybe (fmap hsInt dec) ]) precDec) ])\n               (HsType (tyConNamed "Scientific") (importSome "Data.Scientific" [ importTyNamed "Scientific" ]))\n               (numericType precDec)\n\n  decimalType = numericType\n\ninstance IsSql99DataTypeSyntax HsDataType where\n  characterLargeObjectType =\n    HsDataType (hsVarFrom "characterLargeObject" "Database.Beam.Migrate")\n               (HsType (tyConNamed "Text") (importSome "Data.Text" [ importTyNamed "Text" ]))\n               characterLargeObjectType\n  binaryLargeObjectType =\n    HsDataType (hsVarFrom "binaryLargeObject" "Database.Beam.Migrate")\n               (HsType (tyConNamed "ByteString") (importSome "Data.ByteString" [ importTyNamed "ByteString" ]))\n               binaryLargeObjectType\n  booleanType =\n    HsDataType (hsVarFrom "boolean" "Database.Beam.Migrate")\n               (HsType (tyConNamed "Bool") mempty)\n               booleanType\n  arrayType (HsDataType migType (HsType typeExpr typeImports) serialized) len =\n    HsDataType (hsApp (hsVarFrom "array" "Database.Beam.Migrate") [ migType, hsInt len ])\n               (HsType (tyApp (tyConNamed "Vector") [typeExpr])\n                       (typeImports <> importSome "Data.Vector" [ importTyNamed "Vector" ]))\n               (arrayType serialized len)\n  rowType _ = error "row types"\n\ninstance IsSql2003BinaryAndVarBinaryDataTypeSyntax HsDataType where\n  binaryType prec =\n    HsDataType (hsApp (hsVarFrom "binary" "Database.Beam.Migrate") [ hsMaybe (hsInt <$> prec) ])\n               (HsType (tyConNamed "Integer") mempty)\n               (binaryType prec)\n  varBinaryType prec =\n    HsDataType (hsApp (hsVarFrom "varbinary" "Database.Beam.Migrate") [ hsMaybe (hsInt <$> prec) ])\n               (HsType (tyConNamed "Integer") mempty)\n               (varBinaryType prec)\n\ninstance IsSql2008BigIntDataTypeSyntax HsDataType where\n  bigIntType =\n    HsDataType (hsVarFrom "bigint" "Database.Beam.Migrate")\n               (HsType (tyConNamed "Int64") (importSome "Data.Int" [ importTyNamed "Int64" ]))\n               bigIntType\n\ninstance Sql92SerializableDataTypeSyntax HsDataType where\n  serializeDataType = fromBeamSerializedDataType . hsDataTypeSerialized\n\n-- * HsSyntax utilities\n\ntyParens :: Hs.Type () -> Hs.Type ()\ntyParens = Hs.TyParen ()\n\nfunctionTy :: Hs.Type () -> Hs.Type () -> Hs.Type ()\nfunctionTy = Hs.TyFun ()\n\ntyTuple :: [ Hs.Type () ] -> Hs.Type ()\ntyTuple = Hs.TyTuple () Hs.Boxed\n\ntyApp :: Hs.Type () -> [ Hs.Type () ]\n      -> Hs.Type ()\ntyApp fn args = foldl (Hs.TyApp ()) fn args\n\ntyConNamed :: String -> Hs.Type ()\ntyConNamed nm = Hs.TyCon () (Hs.UnQual () (Hs.Ident () nm))\n\ntyVarNamed :: String -> Hs.Type ()\ntyVarNamed nm = Hs.TyVar () (Hs.Ident () nm)\n\ncombineHsExpr :: (Hs.Exp () -> Hs.Exp () -> Hs.Exp ())\n              -> HsExpr -> HsExpr -> HsExpr\ncombineHsExpr f a b =\n  HsExpr (f (hsExprSyntax a) (hsExprSyntax b))\n         (hsExprImports a <> hsExprImports b)\n         (hsExprConstraints a <> hsExprConstraints b)\n         (hsExprTypeVariables a <> hsExprTypeVariables b)\n\nhsApp :: HsExpr -> [HsExpr] -> HsExpr\nhsApp fn args = foldl hsDoApp fn args\n  where\n    hsDoApp = combineHsExpr (Hs.App ())\n\nhsVisibleTyApp :: HsExpr -> Hs.Type () -> HsExpr\nhsVisibleTyApp e t = e { hsExprSyntax = Hs.App () (hsExprSyntax e) (Hs.TypeApp () t) }\n\nhsApApp :: HsExpr -> [HsExpr] -> HsExpr\nhsApApp fn [] = hsApp (hsVar "pure") [ fn ]\nhsApApp fn (x:xs) = foldl mkAp (mkFmap fn x) xs\n  where\n    mkFmap = combineHsExpr (\\a b -> Hs.InfixApp () a fmapOp b)\n    mkAp = combineHsExpr (\\a b -> Hs.InfixApp () a apOp b)\n\n    fmapOp = hsOp "<$>"\n    apOp = hsOp "<*>"\n\nhsStr :: T.Text -> HsExpr\nhsStr t = HsExpr (Hs.Lit () (Hs.String () s s)) mempty mempty mempty\n  where s = T.unpack t\n\nhsRecCon :: T.Text -> [ (T.Text, HsExpr) ] -> HsExpr\nhsRecCon nm fs = foldl (combineHsExpr const) (HsExpr e mempty mempty mempty) (map snd fs)\n  where\n    e = Hs.RecConstr () (Hs.UnQual () (Hs.Ident () (T.unpack nm)))\n                        (map (\\(fieldNm, e\') -> Hs.FieldUpdate () (Hs.UnQual () (Hs.Ident () (T.unpack fieldNm)))\n                                                                  (hsExprSyntax e\')) fs)\n\nhsMaybe :: Maybe HsExpr -> HsExpr\nhsMaybe Nothing = hsTyCon "Nothing"\nhsMaybe (Just e) = hsApp (hsTyCon "Just") [e]\n\nhsVar :: T.Text -> HsExpr\nhsVar nm = HsExpr (Hs.Var () (Hs.UnQual () (Hs.Ident () (T.unpack nm)))) mempty mempty mempty\n\nhsVarFrom :: T.Text -> T.Text -> HsExpr\nhsVarFrom nm modNm = HsExpr (Hs.Var () (Hs.UnQual () (Hs.Ident () (T.unpack nm)))) (importSome modNm [ importVarNamed nm])\n                            mempty mempty\n\nhsTyCon :: T.Text -> HsExpr\nhsTyCon nm = HsExpr (Hs.Con () (Hs.UnQual () (Hs.Ident () (T.unpack nm)))) mempty mempty mempty\n\nhsInt :: (Integral a, Show a) => a -> HsExpr\nhsInt i = HsExpr (Hs.Lit () (Hs.Int () (fromIntegral i) (show i))) mempty mempty mempty\n\nhsOp :: T.Text -> Hs.QOp ()\nhsOp nm = Hs.QVarOp () (Hs.UnQual () (Hs.Symbol () (T.unpack nm)))\n\nhsInstance :: T.Text -> [ Hs.Type () ] -> [ Hs.InstDecl () ] -> Hs.Decl ()\nhsInstance classNm params decls =\n  Hs.InstDecl () Nothing (Hs.IRule () Nothing Nothing instHead) $\n  case decls of\n    [] -> Nothing\n    _  -> Just decls\n  where\n    instHead = foldl (Hs.IHApp ()) (Hs.IHCon () (Hs.UnQual () (Hs.Ident () (T.unpack classNm)))) params\n\nhsDerivingInstance :: T.Text -> [ Hs.Type () ] -> Hs.Decl ()\nhsDerivingInstance classNm params =\n#if MIN_VERSION_haskell_src_exts(1,20,0)\n  Hs.DerivDecl () Nothing Nothing (Hs.IRule () Nothing Nothing instHead)\n#else\n  Hs.DerivDecl () Nothing (Hs.IRule () Nothing Nothing instHead)\n#endif\n  where\n    instHead = foldl (Hs.IHApp ()) (Hs.IHCon () (Hs.UnQual () (Hs.Ident () (T.unpack classNm)))) params\n\nhsList, hsTuple :: [ HsExpr ] -> HsExpr\nhsList = foldl (combineHsExpr addList) (HsExpr (Hs.List () []) mempty mempty mempty)\n  where\n    addList (Hs.List () ts) t = Hs.List () (ts ++ [t])\n    addList _ _ = error "addList"\nhsTuple = foldl (combineHsExpr addTuple) (HsExpr (Hs.Tuple () Hs.Boxed []) mempty mempty mempty)\n  where\n    addTuple (Hs.Tuple () boxed ts) t = Hs.Tuple () boxed (ts ++ [t])\n    addTuple _ _ = error "addTuple"\n\ninst :: String -> Hs.InstRule ()\ninst = Hs.IRule () Nothing Nothing . Hs.IHCon () . Hs.UnQual () . Hs.Ident ()\n\nbeamMigrateSqlBackend :: HsBackendConstraint\nbeamMigrateSqlBackend =\n  HsBackendConstraint $ \\beTy ->\n#if MIN_VERSION_haskell_src_exts(1, 22, 0)\n  Hs.TypeA () (Hs.TyApp () (Hs.TyCon () (Hs.UnQual () (Hs.Ident () "BeamMigrateSqlBackend"))) beTy)\n#else\n  Hs.ClassA () (Hs.UnQual () (Hs.Ident () "BeamMigrateSqlBackend")) [ beTy ]\n#endif\n\n\n\n-- * Orphans\n\ninstance Hashable (Hs.Exp ())\ninstance Hashable (Hs.QName ())\ninstance Hashable (Hs.ModuleName ())\ninstance Hashable (Hs.IPName ())\ninstance Hashable (Hs.Asst ())\ninstance Hashable (Hs.Literal ())\ninstance Hashable (Hs.Name ())\ninstance Hashable (Hs.Type ())\ninstance Hashable (Hs.QOp ())\ninstance Hashable (Hs.TyVarBind ())\n#if !MIN_VERSION_haskell_src_exts(1, 21, 0)\ninstance Hashable (Hs.Kind ())\n#endif\ninstance Hashable (Hs.Context ())\ninstance Hashable (Hs.SpecialCon ())\ninstance Hashable (Hs.Pat ())\ninstance Hashable (Hs.Sign ())\ninstance Hashable Hs.Boxed\ninstance Hashable (Hs.Promoted ())\ninstance Hashable (Hs.Binds ())\ninstance Hashable (Hs.Splice ())\ninstance Hashable (Hs.PatField ())\ninstance Hashable (Hs.Decl ())\ninstance Hashable (Hs.DeclHead ())\ninstance Hashable (Hs.IPBind ())\ninstance Hashable (Hs.RPat ())\ninstance Hashable (Hs.Stmt ())\ninstance Hashable (Hs.RPatOp ())\ninstance Hashable (Hs.XName ())\ninstance Hashable (Hs.ResultSig ())\ninstance Hashable (Hs.Alt ())\ninstance Hashable (Hs.Unpackedness ())\ninstance Hashable (Hs.InjectivityInfo ())\ninstance Hashable (Hs.PXAttr ())\ninstance Hashable (Hs.Rhs ())\ninstance Hashable (Hs.FieldUpdate ())\ninstance Hashable (Hs.TypeEqn ())\ninstance Hashable (Hs.QualStmt ())\ninstance Hashable (Hs.DataOrNew ())\ninstance Hashable (Hs.Bracket ())\ninstance Hashable (Hs.QualConDecl ())\ninstance Hashable (Hs.XAttr ())\ninstance Hashable (Hs.ConDecl ())\ninstance Hashable (Hs.Deriving ())\ninstance Hashable (Hs.InstRule ())\ninstance Hashable (Hs.FieldDecl ())\ninstance Hashable (Hs.GadtDecl ())\ninstance Hashable (Hs.InstHead ())\ninstance Hashable (Hs.FunDep ())\ninstance Hashable (Hs.ClassDecl ())\ninstance Hashable (Hs.Overlap ())\ninstance Hashable (Hs.InstDecl ())\ninstance Hashable (Hs.Assoc ())\ninstance Hashable (Hs.Op ())\ninstance Hashable (Hs.Match ())\ninstance Hashable (Hs.PatternSynDirection ())\ninstance Hashable (Hs.CallConv ())\ninstance Hashable (Hs.Safety ())\ninstance Hashable (Hs.Rule ())\ninstance Hashable (Hs.Activation ())\ninstance Hashable (Hs.RuleVar ())\ninstance Hashable (Hs.Annotation ())\ninstance Hashable (Hs.BooleanFormula ())\ninstance Hashable (Hs.Role ())\ninstance Hashable (Hs.GuardedRhs ())\ninstance Hashable (Hs.BangType ())\ninstance Hashable (Hs.ImportSpec ())\ninstance Hashable (Hs.Namespace ())\ninstance Hashable (Hs.CName ())\n#if MIN_VERSION_haskell_src_exts(1,20,0)\ninstance Hashable (Hs.DerivStrategy ())\ninstance Hashable (Hs.MaybePromotedName ())\n#endif\n#if !MIN_VERSION_hashable(1, 3, 4)\ninstance Hashable a => Hashable (S.Set a) where\n  hashWithSalt s a = hashWithSalt s (S.toList a)\n#endif\n'