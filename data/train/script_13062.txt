b'/*\n    SPDX-FileCopyrightText: 2014-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n/**\n * @file heaptrack_interpret.cpp\n *\n * @brief Interpret raw heaptrack data and add Dwarf based debug information.\n */\n\n#include <algorithm>\n#include <cinttypes>\n#include <iostream>\n#include <sstream>\n#ifdef __linux__\n#include <stdio_ext.h>\n#endif\n#include <tuple>\n#include <vector>\n\n#include <cxxabi.h>\n\n#include "libbacktrace/backtrace.h"\n#include "libbacktrace/internal.h"\n#include "util/linereader.h"\n#include "util/linewriter.h"\n#include "util/pointermap.h"\n\n#include <signal.h>\n#include <unistd.h>\n\nusing namespace std;\n\nnamespace {\n\n#define error_out cerr << __FILE__ << \':\' << __LINE__ << " ERROR:"\n\nstring demangle(const char* function)\n{\n    if (!function) {\n        return {};\n    } else if (function[0] != \'_\' || function[1] != \'Z\') {\n        return {function};\n    }\n\n    string ret;\n    int status = 0;\n    char* demangled = abi::__cxa_demangle(function, 0, 0, &status);\n    if (demangled) {\n        ret = demangled;\n        free(demangled);\n    }\n    return ret;\n}\n\nbool startsWith(const std::string& haystack, const char* needle)\n{\n    return haystack.compare(0, strlen(needle), needle) == 0;\n}\n\nstruct Frame\n{\n    Frame(string function = {}, string file = {}, int line = 0)\n        : function(function)\n        , file(file)\n        , line(line)\n    {\n    }\n\n    bool isValid() const\n    {\n        return !function.empty();\n    }\n\n    string function;\n    string file;\n    int line;\n};\n\nstruct AddressInformation\n{\n    Frame frame;\n    vector<Frame> inlined;\n};\n\nstruct ResolvedFrame\n{\n    ResolvedFrame(size_t functionIndex = 0, size_t fileIndex = 0, int line = 0)\n        : functionIndex(functionIndex)\n        , fileIndex(fileIndex)\n        , line(line)\n    {\n    }\n    size_t functionIndex;\n    size_t fileIndex;\n    int line;\n};\n\nstruct ResolvedIP\n{\n    size_t moduleIndex = 0;\n    ResolvedFrame frame;\n    vector<ResolvedFrame> inlined;\n};\n\nstruct Module\n{\n    Module(string fileName, uintptr_t addressStart, uintptr_t addressEnd, backtrace_state* backtraceState,\n           size_t moduleIndex)\n        : fileName(fileName)\n        , addressStart(addressStart)\n        , addressEnd(addressEnd)\n        , moduleIndex(moduleIndex)\n        , backtraceState(backtraceState)\n    {\n    }\n\n    AddressInformation resolveAddress(uintptr_t address) const\n    {\n        AddressInformation info;\n        if (!backtraceState) {\n            return info;\n        }\n\n        // try to find frame information from debug information\n        backtrace_pcinfo(backtraceState, address,\n                         [](void* data, uintptr_t /*addr*/, const char* file, int line, const char* function) -> int {\n                             Frame frame(demangle(function), file ? file : "", line);\n                             auto info = reinterpret_cast<AddressInformation*>(data);\n                             if (!info->frame.isValid()) {\n                                 info->frame = frame;\n                             } else {\n                                 info->inlined.push_back(frame);\n                             }\n                             return 0;\n                         },\n                         [](void* /*data*/, const char* /*msg*/, int /*errnum*/) {}, &info);\n\n        // no debug information available? try to fallback on the symbol table information\n        if (!info.frame.isValid()) {\n            struct Data\n            {\n                AddressInformation* info;\n                const Module* module;\n                uintptr_t address;\n            };\n            Data data = {&info, this, address};\n            backtrace_syminfo(\n                backtraceState, address,\n                [](void* data, uintptr_t /*pc*/, const char* symname, uintptr_t /*symval*/, uintptr_t /*symsize*/) {\n                    if (symname) {\n                        reinterpret_cast<Data*>(data)->info->frame.function = demangle(symname);\n                    }\n                },\n                [](void* _data, const char* msg, int errnum) {\n                    auto* data = reinterpret_cast<const Data*>(_data);\n                    error_out << "Module backtrace error for address " << hex << data->address << dec << " in module "\n                              << data->module->fileName << " (code " << errnum << "): " << msg << endl;\n                },\n                &data);\n        }\n\n        return info;\n    }\n\n    bool operator<(const Module& module) const\n    {\n        return tie(addressStart, addressEnd, moduleIndex)\n            < tie(module.addressStart, module.addressEnd, module.moduleIndex);\n    }\n\n    bool operator!=(const Module& module) const\n    {\n        return tie(addressStart, addressEnd, moduleIndex)\n            != tie(module.addressStart, module.addressEnd, module.moduleIndex);\n    }\n\n    string fileName;\n    uintptr_t addressStart;\n    uintptr_t addressEnd;\n    size_t moduleIndex;\n    backtrace_state* backtraceState;\n};\n\nstruct AccumulatedTraceData\n{\n    AccumulatedTraceData()\n        : out(fileno(stdout))\n    {\n        m_modules.reserve(256);\n        m_backtraceStates.reserve(64);\n        m_internedData.reserve(4096);\n        m_encounteredIps.reserve(32768);\n    }\n\n    ~AccumulatedTraceData()\n    {\n        out.write("# strings: %zu\\n# ips: %zu\\n", m_internedData.size(), m_encounteredIps.size());\n        out.flush();\n    }\n\n    ResolvedIP resolve(const uintptr_t ip)\n    {\n        if (m_modulesDirty) {\n            // sort by addresses, required for binary search below\n            sort(m_modules.begin(), m_modules.end());\n\n#ifndef NDEBUG\n            for (size_t i = 0; i < m_modules.size(); ++i) {\n                const auto& m1 = m_modules[i];\n                for (size_t j = i + 1; j < m_modules.size(); ++j) {\n                    if (i == j) {\n                        continue;\n                    }\n                    const auto& m2 = m_modules[j];\n                    if ((m1.addressStart <= m2.addressStart && m1.addressEnd > m2.addressStart)\n                        || (m1.addressStart < m2.addressEnd && m1.addressEnd >= m2.addressEnd)) {\n                        cerr << "OVERLAPPING MODULES: " << hex << m1.moduleIndex << " (" << m1.addressStart << " to "\n                             << m1.addressEnd << ") and " << m1.moduleIndex << " (" << m2.addressStart << " to "\n                             << m2.addressEnd << ")\\n"\n                             << dec;\n                    } else if (m2.addressStart >= m1.addressEnd) {\n                        break;\n                    }\n                }\n            }\n#endif\n\n            m_modulesDirty = false;\n        }\n\n        auto resolveFrame = [this](const Frame& frame) {\n            return ResolvedFrame{intern(frame.function), intern(frame.file), frame.line};\n        };\n\n        ResolvedIP data;\n        // find module for this instruction pointer\n        auto module =\n            lower_bound(m_modules.begin(), m_modules.end(), ip,\n                        [](const Module& module, const uintptr_t ip) -> bool { return module.addressEnd < ip; });\n        if (module != m_modules.end() && module->addressStart <= ip && module->addressEnd >= ip) {\n            data.moduleIndex = module->moduleIndex;\n            const auto info = module->resolveAddress(ip);\n            data.frame = resolveFrame(info.frame);\n            std::transform(info.inlined.begin(), info.inlined.end(), std::back_inserter(data.inlined), resolveFrame);\n        }\n        return data;\n    }\n\n    size_t intern(const string& str, const char** internedString = nullptr)\n    {\n        if (str.empty()) {\n            return 0;\n        }\n\n        const size_t id = m_internedData.size() + 1;\n        auto inserted = m_internedData.insert({str, id});\n        if (internedString) {\n            *internedString = inserted.first->first.data();\n        }\n\n        if (!inserted.second) {\n            return inserted.first->second;\n        }\n\n        out.write("s ");\n        out.write(str);\n        out.write("\\n");\n        return id;\n    }\n\n    void addModule(string fileName, backtrace_state* backtraceState, const size_t moduleIndex,\n                   const uintptr_t addressStart, const uintptr_t addressEnd)\n    {\n        m_modules.emplace_back(fileName, addressStart, addressEnd, backtraceState, moduleIndex);\n        m_modulesDirty = true;\n    }\n\n    void clearModules()\n    {\n        // TODO: optimize this, reuse modules that are still valid\n        m_modules.clear();\n        m_modulesDirty = true;\n    }\n\n    size_t addIp(const uintptr_t instructionPointer)\n    {\n        if (!instructionPointer) {\n            return 0;\n        }\n\n        const size_t ipId = m_encounteredIps.size() + 1;\n        auto inserted = m_encounteredIps.insert({instructionPointer, ipId});\n        if (!inserted.second) {\n            return inserted.first->second;\n        }\n\n        const auto ip = resolve(instructionPointer);\n        out.write("i %zx %zx", instructionPointer, ip.moduleIndex);\n        if (ip.frame.functionIndex || ip.frame.fileIndex) {\n            out.write(" %zx", ip.frame.functionIndex);\n            if (ip.frame.fileIndex) {\n                out.write(" %zx %x", ip.frame.fileIndex, ip.frame.line);\n                for (const auto& inlined : ip.inlined) {\n                    out.write(" %zx %zx %x", inlined.functionIndex, inlined.fileIndex, inlined.line);\n                }\n            }\n        }\n        out.write("\\n");\n        return ipId;\n    }\n\n    /**\n     * Prevent the same file from being initialized multiple times.\n     * This drastically cuts the memory consumption down\n     */\n    backtrace_state* findBacktraceState(const char* fileName, uintptr_t addressStart)\n    {\n        if (startsWith(fileName, "linux-vdso.so")) {\n            // prevent warning, since this will always fail\n            return nullptr;\n        }\n\n        auto it = m_backtraceStates.find(fileName);\n        if (it != m_backtraceStates.end()) {\n            return it->second;\n        }\n\n        struct CallbackData\n        {\n            const char* fileName;\n        };\n        CallbackData data = {fileName};\n\n        auto errorHandler = [](void* rawData, const char* msg, int errnum) {\n            auto data = reinterpret_cast<const CallbackData*>(rawData);\n            error_out << "Failed to create backtrace state for module " << data->fileName << ": " << msg << " / "\n                      << strerror(errnum) << " (error code " << errnum << ")" << endl;\n        };\n\n        auto state = backtrace_create_state(data.fileName, /* we are single threaded, so: not thread safe */ false,\n                                            errorHandler, &data);\n\n        if (state) {\n            const int descriptor = backtrace_open(data.fileName, errorHandler, &data, nullptr);\n            if (descriptor >= 1) {\n                int foundSym = 0;\n                int foundDwarf = 0;\n                auto ret = elf_add(state, data.fileName, descriptor, NULL, 0, addressStart, errorHandler, &data,\n                                   &state->fileline_fn, &foundSym, &foundDwarf, nullptr, false, false, nullptr, 0);\n                if (ret && foundSym) {\n                    state->syminfo_fn = &elf_syminfo;\n                } else {\n                    state->syminfo_fn = &elf_nosyms;\n                }\n            }\n        }\n\n        m_backtraceStates.insert(it, make_pair(fileName, state));\n\n        return state;\n    }\n\n    LineWriter out;\n\nprivate:\n    vector<Module> m_modules;\n    tsl::robin_map<std::string, backtrace_state*> m_backtraceStates;\n    bool m_modulesDirty = false;\n\n    tsl::robin_map<string, size_t> m_internedData;\n    tsl::robin_map<uintptr_t, size_t> m_encounteredIps;\n};\n\nstruct Stats\n{\n    uint64_t allocations = 0;\n    uint64_t leakedAllocations = 0;\n    uint64_t temporaryAllocations = 0;\n} c_stats;\n\nvoid exitHandler()\n{\n    fflush(stdout);\n    fprintf(stderr,\n            "heaptrack stats:\\n"\n            "\\tallocations:          \\t%" PRIu64 "\\n"\n            "\\tleaked allocations:   \\t%" PRIu64 "\\n"\n            "\\ttemporary allocations:\\t%" PRIu64 "\\n",\n            c_stats.allocations, c_stats.leakedAllocations, c_stats.temporaryAllocations);\n}\n}\n\nint main(int /*argc*/, char** /*argv*/)\n{\n    // optimize: we only have a single thread\n    ios_base::sync_with_stdio(false);\n#ifdef __linux__\n    __fsetlocking(stdout, FSETLOCKING_BYCALLER);\n    __fsetlocking(stdin, FSETLOCKING_BYCALLER);\n#endif\n\n    // output data at end, even when we get terminated\n    std::atexit(exitHandler);\n\n    AccumulatedTraceData data;\n\n    LineReader reader;\n\n    string exe;\n\n    PointerMap ptrToIndex;\n    uint64_t lastPtr = 0;\n    AllocationInfoSet allocationInfos;\n\n    while (reader.getLine(cin)) {\n        if (reader.mode() == \'v\') {\n            unsigned int heaptrackVersion = 0;\n            reader >> heaptrackVersion;\n            unsigned int fileVersion = 0;\n            reader >> fileVersion;\n            if (fileVersion >= 3) {\n                reader.setExpectedSizedStrings(true);\n            }\n            data.out.write("%s\\n", reader.line().c_str());\n        } else if (reader.mode() == \'x\') {\n            if (!exe.empty()) {\n                error_out << "received duplicate exe event - child process tracking is not yet supported" << endl;\n                return 1;\n            }\n            reader >> exe;\n        } else if (reader.mode() == \'m\') {\n            string fileName;\n            reader >> fileName;\n            if (fileName == "-") {\n                data.clearModules();\n            } else {\n                if (fileName == "x") {\n                    fileName = exe;\n                }\n                const char* internedString = nullptr;\n                const auto moduleIndex = data.intern(fileName, &internedString);\n                uintptr_t addressStart = 0;\n                if (!(reader >> addressStart)) {\n                    error_out << "failed to parse line: " << reader.line() << endl;\n                    return 1;\n                }\n                auto state = data.findBacktraceState(internedString, addressStart);\n                uintptr_t vAddr = 0;\n                uintptr_t memSize = 0;\n                while ((reader >> vAddr) && (reader >> memSize)) {\n                    data.addModule(fileName, state, moduleIndex, addressStart + vAddr, addressStart + vAddr + memSize);\n                }\n            }\n        } else if (reader.mode() == \'t\') {\n            uintptr_t instructionPointer = 0;\n            size_t parentIndex = 0;\n            if (!(reader >> instructionPointer) || !(reader >> parentIndex)) {\n                error_out << "failed to parse line: " << reader.line() << endl;\n                return 1;\n            }\n            // ensure ip is encountered\n            const auto ipId = data.addIp(instructionPointer);\n            // trace point, map current output index to parent index\n            data.out.writeHexLine(\'t\', ipId, parentIndex);\n        } else if (reader.mode() == \'+\') {\n            ++c_stats.allocations;\n            ++c_stats.leakedAllocations;\n            uint64_t size = 0;\n            TraceIndex traceId;\n            uint64_t ptr = 0;\n            if (!(reader >> size) || !(reader >> traceId.index) || !(reader >> ptr)) {\n                error_out << "failed to parse line: " << reader.line() << endl;\n                continue;\n            }\n\n            AllocationInfoIndex index;\n            if (allocationInfos.add(size, traceId, &index)) {\n                data.out.writeHexLine(\'a\', size, traceId.index);\n            }\n            ptrToIndex.addPointer(ptr, index);\n            lastPtr = ptr;\n            data.out.writeHexLine(\'+\', index.index);\n        } else if (reader.mode() == \'-\') {\n            uint64_t ptr = 0;\n            if (!(reader >> ptr)) {\n                error_out << "failed to parse line: " << reader.line() << endl;\n                continue;\n            }\n            bool temporary = lastPtr == ptr;\n            lastPtr = 0;\n            auto allocation = ptrToIndex.takePointer(ptr);\n            if (!allocation.second) {\n                continue;\n            }\n            data.out.writeHexLine(\'-\', allocation.first.index);\n            if (temporary) {\n                ++c_stats.temporaryAllocations;\n            }\n            --c_stats.leakedAllocations;\n        } else {\n            data.out.write("%s\\n", reader.line().c_str());\n        }\n    }\n\n    return 0;\n}\n'