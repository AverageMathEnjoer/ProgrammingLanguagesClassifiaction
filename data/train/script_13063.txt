b'package com.bennyhuo.kotlin.measuretime\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlin.concurrent.fixedRateTimer\nimport kotlin.time.*\n\n\ninline fun timeCost(block: ()-> Unit): Long {\n    val startTime = System.currentTimeMillis()\n    block()\n    return System.currentTimeMillis() - startTime\n}\n\ninline fun <T> timeCostReturns(block: () -> T): Pair<T, Long> {\n    val startTime = System.currentTimeMillis()\n    val result = block()\n    return result to (System.currentTimeMillis() - startTime)\n}\n\n@OptIn(ExperimentalTime::class)\nsuspend fun main() {\n\n    val duration = measureTime {\n        Thread.sleep(100)\n    }\n    println(duration)\n\n    val timeCost = timeCost {\n        Thread.sleep(100)\n    }\n    println(timeCost)\n\n//    val (value, duration2) = measureTimedValue {\n//        Thread.sleep(500)\n//\n//        1000\n//    }\n\n    val (value, duration2) = timeCostReturns {\n        Thread.sleep(500)\n\n        1000\n    }\n\n    println(value)\n    println(duration2)\n\n    val scope = CoroutineScope(Dispatchers.IO)\n    scope.launch {\n\n        val duration = measureTime {\n            delay(1000)\n        }\n        println(duration)\n\n        val mark = TimeSource.Monotonic.markNow()\n        delay(1000)\n        println(mark.elapsedNow())\n    }.join()\n\n\n\n}'