b'{-# LANGUAGE OverloadedStrings #-}\n\n-- | This module contains parsers for pdf objects\n\nmodule Pdf.Core.Parsers.Object\n( -- * Parse any object\n  parseObject\n  -- * Parse object of specific type\n, parseDict\n, parseArray\n, parseName\n, parseString\n, parseHexString\n, parseRef\n, parseNumber\n, parseBool\n  -- * Other\n, parseTillStreamData\n, parseIndirectObject\n, isRegularChar\n)\nwhere\n\nimport Pdf.Core.Object\nimport qualified Pdf.Core.Name as Name\nimport Pdf.Core.Parsers.Util\n\nimport Data.Char\nimport Data.List\nimport Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS8\nimport Data.Attoparsec.ByteString (Parser)\nimport qualified Data.Attoparsec.ByteString.Char8 as P\nimport Data.Scientific (Scientific)\nimport qualified Data.Scientific as Scientific\nimport qualified Data.Vector as Vector\nimport qualified Data.HashMap.Strict as HashMap\nimport Control.Applicative\nimport Control.Monad\n\n-- | Parse a dictionary\nparseDict :: Parser Dict\nparseDict = do\n  void $ P.string "<<"\n  dict <- many parseKey\n  skipSpace\n  void $ P.string ">>"\n  return $ HashMap.fromList dict\n\nparseKey :: Parser (Name, Object)\nparseKey = do\n  skipSpace\n  key <- parseName\n  val <- parseObject\n  return (key, val)\n\n-- | Parse an array\nparseArray :: Parser Array\nparseArray = do\n  void $ P.char \'[\'\n  array <- many parseObject\n  skipSpace\n  void $ P.char \']\'\n  return $ Vector.fromList array\n\n-- | Parse number\nparseNumber :: Parser Scientific\nparseNumber = P.choice [\n  P.scientific,\n  Scientific.fromFloatDigits <$>\n    (P.signed\n      $ read\n      . ("0."++)\n      . BS8.unpack <$>\n        (P.char \'.\' >> P.takeWhile1 isDigit) :: Parser Double)\n  ]\n\n-- | Parse literal string\nparseString :: Parser ByteString\nparseString = do\n  void $ P.char \'(\'\n  str <- takeStr 0 []\n  return $ BS8.pack str\n  where\n  takeStr :: Int -> String -> Parser String\n  takeStr lvl res = do\n    ch <- P.anyChar\n    case ch of\n      \'(\' -> takeStr (lvl + 1) (ch : res)\n      \')\' -> if lvl == 0\n               then return $ reverse res\n               else takeStr (lvl - 1) (ch : res)\n      \'\\\\\' -> do\n        ch\' <- P.anyChar\n        if ch\' `elem` ("()\\\\" :: String)\n          then takeStr lvl (ch\' : res)\n          else case ch\' of\n                 \'r\' -> takeStr lvl (\'\\r\' : res)\n                 \'n\' -> takeStr lvl (\'\\n\' : res)\n                 \'f\' -> takeStr lvl (\'\\f\' : res)\n                 \'b\' -> takeStr lvl (\'\\b\' : res)\n                 \'t\' -> takeStr lvl (\'\\t\' : res)\n                 \'\\r\' -> takeStr lvl res\n                 _ -> do\n                   ds <- take3Digits [ch\']\n                   let i = toEnum\n                         . foldl\'\n                             (\\acc (a, b) -> acc + a * charToInt b)\n                             0\n                         . zip [1, 8, 64]\n                         $ ds\n                   takeStr lvl (i : res)\n      _ -> takeStr lvl (ch : res)\n  charToInt ch = fromEnum ch - 48\n  take3Digits ds\n    | length ds >= 3\n    = return ds\n    | otherwise\n    = do\n      d <- P.peekChar\'\n      if isDigit d\n        then do\n          void P.anyChar\n          take3Digits (d : ds)\n        else\n          return (ds ++ repeat \'0\')\n\n-- | Parse hex string\nparseHexString :: Parser ByteString\nparseHexString = do\n  void $ P.char \'<\'\n  str <- many takeHex\n  void $ P.char \'>\'\n  return $ BS.pack str\n  where\n  takeHex = do\n    ch1 <- P.satisfy isHexDigit\n    ch2 <- P.satisfy isHexDigit\n    return $ fromIntegral $ digitToInt ch1 * 16 + digitToInt ch2\n\n-- | Parse a reference\nparseRef :: Parser Ref\nparseRef = do\n  obj <- P.decimal\n  skipSpace\n  gen <- P.decimal\n  skipSpace\n  void $ P.char \'R\'\n  return $ R obj gen\n\n-- | Parse a name\nparseName :: Parser Name\nparseName = do\n  void $ P.char \'/\'\n  -- XXX: escaping\n  bs <- P.takeWhile1 isRegularChar\n  either fail return $\n    Name.make bs\n\n-- | Whether the character can appear in \'Name\'\nisRegularChar :: Char -> Bool\nisRegularChar = (`notElem` ("[]()/<>{}% \\n\\r" :: String))\n\n-- | Parse bool value\nparseBool :: Parser Bool\nparseBool = P.choice [\n  P.string "true" >> return True,\n  P.string "false" >> return False\n  ]\n\n-- | Consumes input till stream\'s data\n--\n-- Use \'parseDict\' then \'parseTillStreamData\'\n-- to determine whether the object is dictionary or stream.\n-- If \'parseTillStreamData\' fails, then it is a dictionary.\n-- Otherwise it is stream, and current position in input data\n-- will point to stream\'s data start\n--\n-- >>> parse (parseDict >>= \\dict -> parseTillStreamData >> return dict) "<</Key 123>>\\nstream\\n1234\\nendstream"\n-- Done "1234\\nendstream" Dict [(Name "Key",ONumber (NumInt 123))]\nparseTillStreamData :: Parser ()\nparseTillStreamData = do\n  skipSpace\n  void $ P.string "stream"\n  endOfLine\n\n-- | Parse any \'Object\' except \'Stream\'\n-- because for \'Stream\' we need offset of data in file\n--\n-- >>> parseOnly parseObject "/Name"\n-- Right (OName (Name "Name"))\nparseObject :: Parser Object\nparseObject = do\n  skipSpace\n  P.choice [\n    const Null <$> P.string "null",\n    Name <$> parseName,\n    Bool <$> parseBool,\n    Dict <$> parseDict,\n    Array <$> parseArray,\n    String <$> parseString,\n    String <$> parseHexString,\n    Ref <$> parseRef,\n    Number <$> parseNumber\n    ]\n\n-- | Parse object. Input position should point\n-- to offset defined in XRef\n--\n-- >>> parseOnly parseIndirectObject "1 2 obj\\n12"\n-- Right (Ref 1 2,ONumber (NumInt 12))\nparseIndirectObject :: Parser (Ref, Object)\nparseIndirectObject = do\n  skipSpace\n  index <- P.decimal :: Parser Int\n  skipSpace\n  gen <- P.decimal :: Parser Int\n  skipSpace\n  void $ P.string "obj"\n  skipSpace\n  obj <- parseObject\n  let ref = R index gen\n  case obj of\n    Dict d -> P.choice [\n      parseTillStreamData >> return (ref, Stream (S d 0)),\n      return (ref, Dict d)\n      ]\n    _ -> return (ref, obj)\n'