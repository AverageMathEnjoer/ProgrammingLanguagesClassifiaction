b'{-# LANGUAGE LambdaCase #-}\n\nmodule Database.Beam.Postgres.Test.Select (tests) where\n\nimport           Data.Aeson\nimport           Data.ByteString (ByteString)\nimport           Data.Int\nimport qualified Data.Vector as V\nimport           Test.Tasty\nimport           Test.Tasty.HUnit\nimport           Data.UUID (UUID, nil)\nimport qualified Data.UUID.V5 as V5\n\nimport           Database.Beam\nimport           Database.Beam.Backend.SQL.SQL92\nimport           Database.Beam.Migrate\nimport           Database.Beam.Postgres\nimport           Database.Beam.Postgres.Extensions.UuidOssp\n\nimport           Database.Beam.Postgres.Test\n\ntests :: IO ByteString -> TestTree\ntests getConn = testGroup "Selection Tests"\n  [ testGroup "JSON"\n      [ testPgArrayToJSON getConn\n      ]\n  , testGroup "UUID"\n      [ testUuidFunction getConn "uuid_nil" $ \\ext -> pgUuidNil ext\n      , testUuidFunction getConn "uuid_ns_dns" $ \\ext -> pgUuidNsDns ext\n      , testUuidFunction getConn "uuid_ns_url" $ \\ext -> pgUuidNsUrl ext\n      , testUuidFunction getConn "uuid_ns_oid" $ \\ext -> pgUuidNsOid ext\n      , testUuidFunction getConn "uuid_ns_x500" $ \\ext -> pgUuidNsX500 ext\n      , testUuidFunction getConn "uuid_generate_v1" $ \\ext ->\n          pgUuidGenerateV1 ext\n      , testUuidFunction getConn "uuid_generate_v1mc" $ \\ext ->\n          pgUuidGenerateV1Mc ext\n      , testUuidFunction getConn "uuid_generate_v3" $ \\ext ->\n          pgUuidGenerateV3 ext (val_ nil) "nil"\n      , testUuidFunction getConn "uuid_generate_v4" $ \\ext ->\n          pgUuidGenerateV4 ext\n      , testUuidFunction getConn "uuid_generate_v5" $ \\ext ->\n          pgUuidGenerateV5 ext (val_ nil) "nil"\n      , testUuuidInValues getConn\n      ]\n  , testInRowValues getConn\n  , testInSelect getConn\n  , testReturningMany getConn\n  , testPgUnnest getConn\n  ]\n\ntestPgArrayToJSON :: IO ByteString -> TestTree\ntestPgArrayToJSON getConn = testFunction getConn "array_to_json" $ \\conn -> do\n  let values :: [Int32] = [1, 2, 3]\n  actual :: [PgJSON Value] <-\n    runBeamPostgres conn $ runSelectReturningList $ select $\n      return $ pgArrayToJson $ val_ $ V.fromList values\n  assertEqual "JSON list" [PgJSON $ toJSON values] actual\n\ndata UuidSchema f = UuidSchema\n  { _uuidOssp :: f (PgExtensionEntity UuidOssp)\n  } deriving (Generic, Database Postgres)\n\ntestUuidFunction\n  :: IO ByteString\n  -> String\n  -> (forall s. UuidOssp -> QExpr Postgres s UUID)\n  -> TestTree\ntestUuidFunction getConn name mkUuid = testFunction getConn name $ \\conn ->\n  runBeamPostgres conn $ do\n    db <- executeMigration runNoReturn $ UuidSchema <$>\n      pgCreateExtension @UuidOssp\n    [_] <- runSelectReturningList $ select $\n      return $ mkUuid $ getPgExtension $ _uuidOssp $ unCheckDatabase db\n    return ()\n\n-- | Regression test for <https://github.com/haskell-beam/beam/issues/555 #555>\ntestUuuidInValues :: IO ByteString -> TestTree\ntestUuuidInValues getConn = testCase "UUID in values_ works" $\n  withTestPostgres "uuid_values" getConn $ \\conn -> do\n    result <- runBeamPostgres conn $ do\n      db <- executeMigration runNoReturn $ UuidSchema <$>\n        pgCreateExtension @UuidOssp\n      let ext = getPgExtension $ _uuidOssp $ unCheckDatabase db\n      runSelectReturningList $ select $ do\n        v <- values_ [val_ nil]\n        return $ pgUuidGenerateV5 ext v ""\n    assertEqual "result" [V5.generateNamed nil []] result\n\ndata Pair f = Pair\n  { _left :: C f Bool\n  , _right :: C f Bool\n  } deriving (Generic, Beamable)\n\ntestInRowValues :: IO ByteString -> TestTree\ntestInRowValues getConn = testCase "IN with row values works" $\n  withTestPostgres "db_in_row_values" getConn $ \\conn -> do\n    result <- runBeamPostgres conn $ runSelectReturningList $ select $ do\n      let pair :: forall ctx s. Pair (QGenExpr ctx Postgres s)\n          pair = val_ $ Pair False False\n      return $ pair `in_` [pair, pair]\n    assertEqual "result" [True] result\n\ntestInSelect :: IO ByteString -> TestTree\ntestInSelect getConn = testCase "IN (SELECT ...) works" $\n  withTestPostgres "db_in_row_values" getConn $ \\conn -> do\n    result <- runBeamPostgres conn $ runSelectReturningList $ select $ do\n      let x  = as_ @Int32 (val_ 1)\n      return $ x `inQuery_` ( pgUnnestArray $ array_ $ (as_ @Int32 . val_) <$> [0..100])\n    assertEqual "result" [True] result\n\ntestReturningMany :: IO ByteString -> TestTree\ntestReturningMany getConn = testCase "runReturningMany (batching via cursor) works" $\n  withTestPostgres "run_returning_many_cursor" getConn $ \\conn -> do\n    result <- runBeamPostgres conn $ runSelectReturningMany\n      (select $ pgUnnestArray $ array_ $ (as_ @Int32 . val_) <$> [0..rowCount - 1])\n      (\\fetch ->\n        let count n = fetch >>= \\case\n              Nothing -> pure n\n              Just _  -> count (n + 1)\n        in count 0)\n    assertEqual "result" rowCount result\n where\n  rowCount = 500\n  runSelectReturningMany ::\n    (FromBackendRow Postgres x) =>\n    SqlSelect Postgres x -> (Pg (Maybe x) -> Pg a) -> Pg a\n  runSelectReturningMany (SqlSelect s) =\n    runReturningMany (selectCmd s)\n\ntestFunction :: IO ByteString -> String -> (Connection -> Assertion) -> TestTree\ntestFunction getConn name mkAssertion = testCase name $\n  withTestPostgres name getConn mkAssertion\n\n-- | Regression test for <https://github.com/haskell-beam/beam/issues/541 #541>\ntestPgUnnest :: IO ByteString -> TestTree\ntestPgUnnest getConn = testCase "pgUnnest works" $\n  withTestPostgres "pg_unnest" getConn $ \\conn -> do\n    let values = [Bool True, Number 1]\n    result <- runBeamPostgres conn $ runSelectReturningList $ select $\n      pgUnnest $ pgJsonArrayElements $ val_ $\n        PgJSONB $ Array $ V.fromList values\n    assertEqual "result" (PgJSONB <$> values) $ pgJsonElement <$> result\n'