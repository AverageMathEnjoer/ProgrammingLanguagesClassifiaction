b'{-# LANGUAGE CPP #-}\n#if defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Safe #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Map.Lazy\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n--\n-- = Finite Maps (lazy interface)\n--\n-- The @\'Map\' k v@ type represents a finite map (sometimes called a dictionary)\n-- from keys of type @k@ to values of type @v@. A \'Map\' is strict in its keys but lazy\n-- in its values.\n--\n-- The functions in "Data.Map.Strict" are careful to force values before\n-- installing them in a \'Map\'. This is usually more efficient in cases where\n-- laziness is not essential. The functions in this module do not do so.\n--\n-- When deciding if this is the correct data structure to use, consider:\n--\n-- * If you are using \'Prelude.Int\' keys, you will get much better performance for most\n-- operations using "Data.IntMap.Lazy".\n--\n-- * If you don\'t care about ordering, consider using @Data.HashMap.Lazy@ from the\n-- <https://hackage.haskell.org/package/unordered-containers unordered-containers>\n-- package instead.\n--\n-- For a walkthrough of the most commonly used functions see the\n-- <https://haskell-containers.readthedocs.io/en/latest/map.html maps introduction>.\n--\n-- This module is intended to be imported qualified, to avoid name clashes with\n-- Prelude functions:\n--\n-- > import qualified Data.Map.Lazy as Map\n--\n-- Note that the implementation is generally /left-biased/. Functions that take\n-- two maps as arguments and combine them, such as `union` and `intersection`,\n-- prefer the values in the first argument to those in the second.\n--\n--\n-- == Detailed performance information\n--\n-- The amortized running time is given for each operation, with \\(n\\) referring to\n-- the number of entries in the map.\n--\n-- Benchmarks comparing "Data.Map.Lazy" with other dictionary implementations\n-- can be found at https://github.com/haskell-perf/dictionaries.\n--\n--\n-- == Warning\n--\n-- The size of a \'Map\' must not exceed @\'Prelude.maxBound\' :: \'Prelude.Int\'@.\n-- Violation of this condition is not detected and if the size limit is exceeded,\n-- its behaviour is undefined.\n--\n--\n-- == Implementation\n--\n-- The implementation of \'Map\' is based on /size balanced/ binary trees (or\n-- trees of /bounded balance/) as described by:\n--\n--    * Stephen Adams, \\"/Efficient sets: a balancing act/\\",\n--     Journal of Functional Programming 3(4):553-562, October 1993,\n--     <http://www.swiss.ai.mit.edu/~adams/BB/>.\n--    * J. Nievergelt and E.M. Reingold,\n--      \\"/Binary search trees of bounded balance/\\",\n--      SIAM journal of computing 2(1), March 1973.\n--\n--  Bounds for \'union\', \'intersection\', and \'difference\' are as given\n--  by\n--\n--    * Guy Blelloch, Daniel Ferizovic, and Yihan Sun,\n--      \\"/Just Join for Parallel Ordered Sets/\\",\n--      <https://arxiv.org/abs/1602.02120v3>.\n--\n-----------------------------------------------------------------------------\n\nmodule Data.Map.Lazy (\n    -- * Map type\n    Map              -- instance Eq,Show,Read\n\n    -- * Construction\n    , empty\n    , singleton\n    , fromSet\n    , fromArgSet\n\n    -- ** From Unordered Lists\n    , fromList\n    , fromListWith\n    , fromListWithKey\n\n    -- ** From Ascending Lists\n    , fromAscList\n    , fromAscListWith\n    , fromAscListWithKey\n    , fromDistinctAscList\n\n    -- ** From Descending Lists\n    , fromDescList\n    , fromDescListWith\n    , fromDescListWithKey\n    , fromDistinctDescList\n\n    -- * Insertion\n    , insert\n    , insertWith\n    , insertWithKey\n    , insertLookupWithKey\n\n    -- * Deletion\\/Update\n    , delete\n    , adjust\n    , adjustWithKey\n    , update\n    , updateWithKey\n    , updateLookupWithKey\n    , alter\n    , alterF\n\n    -- * Query\n    -- ** Lookup\n    , lookup\n    , (!?)\n    , (!)\n    , findWithDefault\n    , member\n    , notMember\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n\n    -- ** Size\n    , null\n    , size\n\n    -- * Combine\n\n    -- ** Union\n    , union\n    , unionWith\n    , unionWithKey\n    , unions\n    , unionsWith\n\n    -- ** Difference\n    , difference\n    , (\\\\)\n    , differenceWith\n    , differenceWithKey\n\n    -- ** Intersection\n    , intersection\n    , intersectionWith\n    , intersectionWithKey\n\n    -- ** Disjoint\n    , disjoint\n\n    -- ** Compose\n    , compose\n\n    -- ** General combining functions\n    -- | See "Data.Map.Merge.Lazy"\n\n    -- ** Unsafe general combining function\n\n    , mergeWithKey\n\n    -- * Traversal\n    -- ** Map\n    , map\n    , mapWithKey\n    , traverseWithKey\n    , traverseMaybeWithKey\n    , mapAccum\n    , mapAccumWithKey\n    , mapAccumRWithKey\n    , mapKeys\n    , mapKeysWith\n    , mapKeysMonotonic\n\n    -- * Folds\n    , foldr\n    , foldl\n    , foldrWithKey\n    , foldlWithKey\n    , foldMapWithKey\n\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    , foldrWithKey\'\n    , foldlWithKey\'\n\n    -- * Conversion\n    , elems\n    , keys\n    , assocs\n    , keysSet\n    , argSet\n\n    -- ** Lists\n    , toList\n\n    -- ** Ordered lists\n    , toAscList\n    , toDescList\n\n    -- * Filter\n    , filter\n    , filterWithKey\n    , restrictKeys\n    , withoutKeys\n    , partition\n    , partitionWithKey\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , mapMaybe\n    , mapMaybeWithKey\n    , mapEither\n    , mapEitherWithKey\n\n    , split\n    , splitLookup\n    , splitRoot\n\n    -- * Submap\n    , isSubmapOf, isSubmapOfBy\n    , isProperSubmapOf, isProperSubmapOfBy\n\n    -- * Indexed\n    , lookupIndex\n    , findIndex\n    , elemAt\n    , updateAt\n    , deleteAt\n    , take\n    , drop\n    , splitAt\n\n    -- * Min\\/Max\n    , lookupMin\n    , lookupMax\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , updateMin\n    , updateMax\n    , updateMinWithKey\n    , updateMaxWithKey\n    , minView\n    , maxView\n    , minViewWithKey\n    , maxViewWithKey\n\n    -- * Debugging\n#ifdef __GLASGOW_HASKELL__\n    , showTree\n    , showTreeWith\n#endif\n    , valid\n    ) where\n\nimport Data.Map.Internal\nimport Data.Map.Internal.DeprecatedShowTree (showTree, showTreeWith)\nimport Data.Map.Internal.Debug (valid)\nimport Prelude ()\n'