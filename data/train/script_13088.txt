b"class Solution {\n    bool matches(string word, string pattern) {\n        int n = word.size();\n        vector<int> forward(26, -1), backward(26, -1);\n        // map<char, char> forward, backward; unordered_map\n        for(int i = 0; i < n; i++) {\n            int x = word[i] - 'a', y = pattern[i] - 'a';\n            // I am trying to map x to y\n            if(forward[x] != -1 && forward[x] != y) return false;\n            if(backward[y] != -1 && backward[y] != x) return false;\n            forward[x] = y;\n            backward[y] = x;\n        }\n        \n        return true;\n    }\n    \npublic:\n    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {\n        vector<string> ans = {};\n        // O(n * k) k is avg word size\n        for (auto word: words) {\n            if (matches(word, pattern)) ans.push_back(word);\n        }\n        \n        return ans;\n    }\n};\n\n/* abb xyy yxx \n\n// abbccc \n// matches - xyyzzz yzzxxx\n// does not match - xyyxxx\n\nabbccc yzzxxx\nabbccc xyyxxx\n\nif a is mapped to y, then - \n    - a shall never be mapped to anything else\n    - no other char shall be mapped to y\n    \nmath background - \n1:1 mapping\n*/"