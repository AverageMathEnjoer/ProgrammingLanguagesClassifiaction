b'using System;\nusing System.Diagnostics;\nusing System.IO;\n\nusing i16 = System.Int16;\nusing u32 = System.UInt32;\nusing Pgno = System.UInt32;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2008 August 05\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    ** This header file defines the interface that the sqlite page cache\n    ** subsystem.\n    **\n    ** @(#) $Id: pcache.h,v 1.20 2009/07/25 11:46:49 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n\n#if !_PCACHE_H_\n\n    //typedef struct PgHdr PgHdr;\n    //typedef struct PCache PCache;\n\n    /*\n    ** Every page in the cache is controlled by an instance of the following\n    ** structure.\n    */\n    public class PgHdr\n    {\n      public byte[] pData;          /* Content of this page */\n      public MemPage pExtra;        /* Extra content */\n      public PgHdr pDirty;          /* Transient list of dirty pages */\n      public Pgno pgno;             /* The page number for this page */\n      public Pager pPager;          /* The pager to which this page belongs */\n#if SQLITE_CHECK_PAGES || (SQLITE_DEBUG)\n      public int pageHash;          /* Hash of page content */\n#endif\n      public int flags;             /* PGHDR flags defined below */\n      /**********************************************************************\n      ** Elements above are public.  All that follows is private to pcache.c\n      ** and should not be accessed by other modules.\n      */\n      public int nRef;              /* Number of users of this page */\n      public PCache pCache;         /* Cache that owns this page */\n      public bool CacheAllocated;   /* True, if allocated from cache */\n\n      public PgHdr pDirtyNext;      /* Next element in list of dirty pages */\n      public PgHdr pDirtyPrev;      /* Previous element in list of dirty pages */\n      public PgHdr1 pPgHdr1;        /* Cache page header this this page */\n\n      public static implicit operator bool( PgHdr b )\n      {\n        return ( b != null );\n      }\n\n\n      public void Clear()\n      {\n        this.pData = null;\n        this.pExtra = null;\n        this.pDirty = null;\n        this.pgno = 0;\n        this.pPager = null;\n#if SQLITE_CHECK_PAGES\nthis.pageHash=0;\n#endif\n        this.flags = 0;\n        this.nRef = 0;\n        this.pCache = null;\n        this.pDirtyNext = null;\n        this.pDirtyPrev = null;\n        this.pPgHdr1 = null;\n      }\n    };\n\n    /* Bit values for PgHdr.flags */\n    //#define PGHDR_DIRTY             0x002  /* Page has changed */\n    //#define PGHDR_NEED_SYNC         0x004  /* Fsync the rollback journal before\n    //                                       ** writing this page to the database */\n    //#define PGHDR_NEED_READ         0x008  /* Content is unread */\n    //#define PGHDR_REUSE_UNLIKELY    0x010  /* A hint that reuse is unlikely */\n    //#define PGHDR_DONT_WRITE        0x020  /* Do not write content to disk */\n\n    const int PGHDR_DIRTY = 0x002; /* Page has changed */\n    const int PGHDR_NEED_SYNC = 0x004;/* Fsync the rollback journal before\n** writing this page to the database */\n    const int PGHDR_NEED_READ = 0x008;/* Content is unread */\n    const int PGHDR_REUSE_UNLIKELY = 0x010;/* A hint that reuse is unlikely */\n    const int PGHDR_DONT_WRITE = 0x020;/* Do not write content to disk */\n\n    /* Initialize and shutdown the page cache subsystem */\n    //int sqlite3PcacheInitialize(void);\n    //void sqlite3PcacheShutdown(void);\n\n    /* Page cache buffer management:\n    ** These routines implement SQLITE_CONFIG_PAGECACHE.\n    */\n    //void sqlite3PCacheBufferSetup(void *, int sz, int n);\n\n    /* Create a new pager cache.\n    ** Under memory stress, invoke xStress to try to make pages clean.\n    ** Only clean and unpinned pages can be reclaimed.\n    */\n    //void sqlite3PcacheOpen(\n    //  int szPage,                    /* Size of every page */\n    //  int szExtra,                   /* Extra space associated with each page */\n    //  int bPurgeable,                /* True if pages are on backing store */\n    //  int (*xStress)(void*, PgHdr*), /* Call to try to make pages clean */\n    //  void pStress,                 /* Argument to xStress */\n    //  PCache pToInit                /* Preallocated space for the PCache */\n    //);\n\n    /* Modify the page-size after the cache has been created. */\n    //void sqlite3PcacheSetPageSize(PCache *, int);\n\n    /* Return the size in bytes of a PCache object.  Used to preallocate\n    ** storage space.\n    */\n    //int sqlite3PcacheSize(void);\n\n    /* One release per successful fetch.  Page is pinned until released.\n    ** Reference counted.\n    */\n    //int sqlite3PcacheFetch(PCache*, Pgno, int createFlag, PgHdr**);\n    //void sqlite3PcacheRelease(PgHdr*);\n\n    //void sqlite3PcacheDrop(PgHdr*);         /* Remove page from cache */\n    //void sqlite3PcacheMakeDirty(PgHdr*);    /* Make sure page is marked dirty */\n    //void sqlite3PcacheMakeClean(PgHdr*);    /* Mark a single page as clean */\n    //void sqlite3PcacheCleanAll(PCache*);    /* Mark all dirty list pages as clean */\n\n    /* Change a page number.  Used by incr-vacuum. */\n    //void sqlite3PcacheMove(PgHdr*, Pgno);\n\n    /* Remove all pages with pgno>x.  Reset the cache if x==0 */\n    //void sqlite3PcacheTruncate(PCache*, Pgno x);\n\n    /* Get a list of all dirty pages in the cache, sorted by page number */\n    //PgHdr *sqlite3PcacheDirtyList(PCache*);\n\n    /* Reset and close the cache object */\n    //void sqlite3PcacheClose(PCache*);\n\n    /* Clear flags from pages of the page cache */\n    //void sqlite3PcacheClearSyncFlags(PCache *);\n\n    /* Discard the contents of the cache */\n    //void sqlite3PcacheClear(PCache*);\n\n    /* Return the total number of outstanding page references */\n    //int sqlite3PcacheRefCount(PCache*);\n\n    /* Increment the reference count of an existing page */\n    //void sqlite3PcacheRef(PgHdr*);\n\n    //int sqlite3PcachePageRefcount(PgHdr*);\n\n\n    /* Return the total number of pages stored in the cache */\n    //int sqlite3PcachePagecount(PCache*);\n\n#if SQLITE_CHECK_PAGES\n/* Iterate through all dirty pages currently stored in the cache. This\n** interface is only available if SQLITE_CHECK_PAGES is defined when the\n** library is built.\n*/\n\n//void sqlite3PcacheIterateDirty(PCache pCache, void (*xIter)(PgHdr *));\n#endif\n\n    /* Set and get the suggested cache-size for the specified pager-cache.\n**\n** If no global maximum is configured, then the system attempts to limit\n** the total number of pages cached by purgeable pager-caches to the sum\n** of the suggested cache-sizes.\n*/\n    //void sqlite3PcacheSetCachesize(PCache *, int);\n#if SQLITE_TEST\n    //int sqlite3PcacheGetCachesize(PCache *);\n#endif\n\n#if SQLITE_ENABLE_MEMORY_MANAGEMENT\n/* Try to return memory used by the pcache module to the main memory heap */\n//int sqlite3PcacheReleaseMemory(int);\n#endif\n\n#if SQLITE_TEST\n    //void sqlite3PcacheStats(int*,int*,int*,int*);\n#endif\n\n    //void sqlite3PCacheSetDefault(void);\n\n#endif //* _PCACHE_H_ */\n  }\n}\n'