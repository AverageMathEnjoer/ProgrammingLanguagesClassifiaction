b'struct cht{\n    struct Line{\n        int a;\n        long long b;\n        long long val;\n        double xLeft;\n        bool type;\n        Line(long long _a = 0 , long long _b = 0){\n            a = _a;\n            b = _b;\n            xLeft = -1e16;\n            type = 0;\n            val = 0;\n        }\n        long long valueAt(int x) const{\n            return 1LL * a * x + b;\n        }\n        friend bool areParallel(const Line &l1, const Line &l2){\n            return l1.a == l2.a;\n        }\n        friend double intersectX(const Line &l1 , const Line &l2){\n            return areParallel(l1 , l2) ? 1e16 : 1.0 * (l2.b - l1.b) / (l1.a - l2.a);\n        }\n        bool operator < (const Line &l2) const{\n            if(!l2.type)\n                return a < l2.a;\n            return xLeft > l2.val;\n        }\n    };\n    set < Line >  hull;\n    bool hasPrev(set < Line > :: iterator it){\n        return it != hull.begin();\n    }\n    bool hasNext(set < Line > :: iterator it){\n        return it != hull.end() && next(it) != hull.end();\n    }\n    bool irrelevant(const Line &l1 , const Line &l2 , const Line &l3){\n        return intersectX(l1,l3) <= intersectX(l1,l2);\n    }\n    bool irrelevant(set < Line > :: iterator it){\n        return hasPrev(it) && hasNext(it) && (irrelevant(*next(it) , *it , *prev(it)));\n    }\n    set < Line > :: iterator updateLeftBorder(set < Line > :: iterator it){\n        if(!hasNext(it)){\n            return it;\n        }\n        double val = intersectX(*it , *next(it));\n        Line buf(*it);\n        it = hull.erase(it);\n        buf.xLeft = val;\n        it = hull.insert(it, buf);\n        return it;\n    }\n    void addLine(int a , long long b){\n        Line l3 = Line(a, b);\n        auto it = hull.lower_bound(l3);\n        if(it != hull.end() && areParallel(*it , l3)){\n            if(it -> b > b){\n                it = hull.erase(it);\n            }\n            else{\n                return;\n            }\n        }\n        it = hull.insert(it, l3);\n        if(irrelevant(it)){\n            hull.erase(it);\n            return;\n        }\n        while(hasPrev(it) && irrelevant(prev(it))){\n            hull.erase(prev(it));\n        }\n        while(hasNext(it) && irrelevant(next(it))){\n            hull.erase(next(it));\n        }\n        it = updateLeftBorder(it);\n        if(hasPrev(it)){\n            updateLeftBorder(prev(it));\n        }\n        if(hasNext(it)){\n            updateLeftBorder(next(it));\n        }\n    }\n    long long getBest(int x){\n        Line q;\n        q.val = x;\n        q.type = 1;\n        auto bestLine = hull.lower_bound(q);\n        if(bestLine == hull.end()){\n            return 1e16;\n        }\n        return bestLine -> valueAt(x);\n    }\n};\n'