b'{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n{-# OPTIONS_GHC -fno-warn-deprecations -fno-warn-incomplete-uni-patterns #-}\n\nmodule Text.Xournal.Parse.Conduit where\n\nimport Control.Applicative ()\nimport Control.Category (id, (.))\nimport Control.Monad ((>=>))\nimport Control.Monad.Catch (MonadThrow)\nimport Control.Monad.Trans (MonadIO (..))\nimport qualified Data.ByteString as S\nimport Data.Conduit (Sink, ($$), (=$=))\nimport Data.Conduit.Binary (sourceHandle)\nimport qualified Data.Conduit.List as CL\nimport Data.Conduit.Zlib (ungzip)\nimport Data.List (foldl\')\nimport Data.Strict.Tuple (Pair (..))\nimport qualified Data.Text as T\nimport Data.Text.Encoding (encodeUtf8)\nimport Data.Text.Read (decimal, double)\nimport Data.XML.Types\n  ( Content (..),\n    Event (..),\n    nameLocalName,\n  )\nimport Data.Xournal.Simple\n  ( Background (..),\n    Dimension (..),\n    Layer (..),\n    Page (..),\n    Stroke (..),\n    Xournal (..),\n    s_color,\n    s_tool,\n  )\nimport Lens.Micro (set)\nimport System.IO (Handle, IOMode (..), withFile)\nimport Text.XML.Stream.Parse (def, parseBytes)\n-- hiding (many)\nimport Text.Xournal.Parse.Zlib (checkIfBinary)\nimport Prelude hiding (dropWhile, id, (.))\n\n-- * utils\n\n-- |\ndropWhile :: (Show a, Monad m) => (a -> Bool) -> Sink a m ()\ndropWhile p = do\n  x <- CL.peek\n  case x of\n    Nothing -> return ()\n    Just e ->\n      if p e\n        then CL.drop 1 >> dropWhile p\n        else return ()\n\n-- |\nflipap :: a -> (a -> b) -> b\nflipap = flip ($)\n\n-- |\nunit :: (Monad m) => m ()\nunit = return ()\n\n-- |\nskipspace :: T.Text -> T.Text\nskipspace = T.dropWhile (\\c -> (c == \' \') || (c == \'\\n\') || (c == \'\\r\'))\n\n-- |\nmany0event ::\n  Monad m =>\n  (T.Text, T.Text) ->\n  (Event -> Sink Event m (Either String a)) ->\n  Sink Event m (Either String [a])\nmany0event (start, end) iter = many1eventWrkr (start, end) id iter\n\n-- |\nmany1event ::\n  Monad m =>\n  (T.Text, T.Text) ->\n  (Event -> Sink Event m (Either String a)) ->\n  Sink Event m (Either String [a])\nmany1event (start, end) iter = do\n  dropWhile (not . isStart start)\n  CL.head\n    >>= maybe\n      (return (Left ("error in " ++ T.unpack start)))\n      ( \\ev -> do\n          ex <- iter ev\n          case ex of\n            Left err -> return (Left err)\n            Right x ->\n              let acc = (x :)\n               in many1eventWrkr (start, end) acc iter\n      )\n\n-- |\nmany1eventWrkr ::\n  Monad m =>\n  (T.Text, T.Text) ->\n  ([a] -> [a]) ->\n  (Event -> Sink Event m (Either String a)) ->\n  Sink Event m (Either String [a])\nmany1eventWrkr (start, end) acc iter =\n  drop2NextStartOrEnd >>= \\e -> do\n    case e of\n      Left (txt, ev) ->\n        if txt == start\n          then do\n            CL.drop 1\n            ex <- iter ev\n            case ex of\n              Left err -> return (Left err)\n              Right x ->\n                many1eventWrkr (start, end) (acc . (x :)) iter\n          else return (Left ("got " ++ T.unpack txt))\n      Right txt ->\n        if txt == end\n          then do return (Right (acc []))\n          else return (Left ("got " ++ T.unpack txt))\n\n-- |\ndrop2NextStartOrEnd ::\n  (Monad m) =>\n  Sink Event m (Either (T.Text, Event) T.Text)\ndrop2NextStartOrEnd = do\n  dropWhile (not . isEventStartEnd)\n  melm <- CL.peek\n  case melm of\n    Just elm@(EventBeginElement name _) ->\n      return (Left (nameLocalName name, elm))\n    Just (EventEndElement name) ->\n      return (Right (nameLocalName name))\n    Just _ -> error "this is impossible in drop2NextStartOrEnd"\n    Nothing -> error "no more item in drop2NextStartOrEnd"\n\n-- * parsers\n\n-- | parse whole xournal file\npXournal :: Monad m => Sink Event m (Either String Xournal)\npXournal = do\n  dropWhile (not . isStart "xournal")\n  CL.head\n    >>= maybe\n      ( return (Left "no xournal")\n      )\n      ( const $ do\n          title <- pTitle\n          pages <- many1event ("page", "xournal") pPage\n          (return $ Xournal <$> title <*> pages)\n      )\n\n-- | parse one page\npPage :: Monad m => Event -> Sink Event m (Either String Page)\npPage ev = do\n  let dim = getDimension ev\n  bkg <- pBkg\n  layers <- many1event ("layer", "page") pLayer\n  dropWhile (not . isEnd "page")\n  CL.drop 1\n  return (Page <$> dim <*> bkg <*> layers)\n\n-- |\npTitle :: Monad m => Sink Event m (Either String S.ByteString)\npTitle = do\n  dropWhile (not . isStart "title")\n  CL.drop 1\n  CL.head\n    >>= maybe\n      (return (Left "not title"))\n      ( \\ev -> do\n          let title = getContent ev\n          dropWhile (not . isEnd "title")\n          CL.drop 1\n          return (encodeUtf8 <$> title)\n      )\n\n-- |\npBkg :: Monad m => Sink Event m (Either String Background)\npBkg = do\n  dropWhile (not . isStart "background")\n  -- CL.drop 1\n  CL.head\n    >>= maybe\n      (return (Left "not background"))\n      ( \\ev -> do\n          let bkg = getBackground ev\n          dropWhile (not . isEnd "background")\n          CL.drop 1\n          return bkg\n      )\n\n-- |\npLayer :: Monad m => Event -> Sink Event m (Either String Layer)\npLayer _ev = do\n  strokes <- many0event ("stroke", "layer") pStroke\n  dropWhile (not . isEnd "layer")\n  CL.drop 1\n  return (Layer <$> strokes)\n\n-- |\npStroke :: Monad m => Event -> Sink Event m (Either String Stroke)\npStroke ev = do\n  let estr1wdth = getStroke ev\n  -- trc "pStroke" estr1wdth unit\n  CL.head\n    >>= maybe\n      (return (Left "pStroke ecoord"))\n      ( \\elm -> do\n          let txt = getContent elm :: Either String T.Text\n              ctnt = getStrokeContent id =<< txt\n          dropWhile (not . isEnd "stroke")\n          CL.drop 1\n          let f23 (x :!: y) z = (x, y, z)\n          let rfunc d\' (Stroke t c _ _, sw) = case sw of\n                SingleWidth w\' -> Stroke t c w\' d\'\n                VarWidth ws -> VWStroke t c (zipWith f23 d\' ws)\n              rfunc _ (VWStroke _ _ _, _) =\n                error "this should not happen in pStroke"\n          return $ rfunc <$> ctnt <*> estr1wdth\n      )\n\n-- * for each event\n\n-- |\ngetStrokeContent ::\n  ([Pair Double Double] -> [Pair Double Double]) ->\n  T.Text ->\n  Either String [Pair Double Double]\ngetStrokeContent acc txt =\n  let eaction = do\n        (x, rest1) <- double (skipspace txt)\n        (y, rest2) <- double (skipspace rest1)\n        return (x :!: y, rest2)\n   in case eaction of\n        Left _str -> return (acc [])\n        Right (pxy, rest2) -> getStrokeContent (acc . (pxy :)) rest2\n\n-- |\ngetStroke :: Event -> Either String (Stroke, StrokeWidth)\ngetStroke (EventBeginElement _name namecontent) =\n  foldl\' f (Right (Stroke "" "" 0 [], SingleWidth 0)) namecontent\n  where\n    f acc@(Left _) _ = acc\n    f acc@(Right (str@(Stroke _t _c _w _d), wdth)) (name, contents) =\n      if nameLocalName name == "tool"\n        then\n          let ContentText txt = Prelude.head contents\n           in Right (flip (set s_tool) str . encodeUtf8 $ txt, wdth)\n        else\n          if nameLocalName name == "color"\n            then\n              let ContentText txt = Prelude.head contents\n               in Right (flip (set s_color) str . encodeUtf8 $ txt, wdth)\n            else\n              if nameLocalName name == "width"\n                then\n                  let ContentText txt = Prelude.head contents\n                   in (,) str <$> getWidth id txt\n                else acc\n    f (Right (VWStroke _ _ _, _)) (_, _) = error "this should not happen in getStroke"\ngetStroke _ = Left "not a stroke"\n\n--    (str { stroke_tool = encodeUtf8 txt})\n\n-- |\ndata StrokeWidth = SingleWidth Double | VarWidth [Double]\n  deriving (Show)\n\n-- |\ngetWidth ::\n  ([Double] -> [Double]) ->\n  T.Text ->\n  Either String StrokeWidth\ngetWidth acc txt =\n  case double (skipspace txt) of\n    Left _str -> case acc [] of\n      [] -> Left "no width in stroke"\n      w : [] -> Right (SingleWidth w)\n      ws -> Right (VarWidth ws)\n    Right (x, rest1) -> getWidth (acc . (x :)) rest1\n\n-- |\ngetBackground :: Event -> Either String Background\ngetBackground (EventBeginElement _name namecontent) =\n  foldl\' f (Right (Background "" "" "")) namecontent\n  where\n    toBkgPdf (Background _t _c _s) = BackgroundPdf "pdf" Nothing Nothing 0\n    toBkgPdf bkg@(BackgroundPdf _t _d _f _p) = bkg\n    toBkgNoPdf _t bkg@(Background _ _ _) = bkg\n    toBkgNoPdf t (BackgroundPdf _t _d _f _p) = Background t "" ""\n    f acc@(Left _) _ = acc\n    f acc@(Right bkg@(Background t c s)) (name, contents) =\n      if nameLocalName name == "type"\n        then\n          let ContentText txt = Prelude.head contents\n           in if txt == "pdf"\n                then Right (toBkgPdf bkg)\n                else Right (toBkgNoPdf (encodeUtf8 txt) bkg)\n        else\n          if nameLocalName name == "color"\n            then\n              let ContentText txt = Prelude.head contents\n               in Right . (\\x -> Background t x s) . encodeUtf8 $ txt\n            else\n              if nameLocalName name == "style"\n                then\n                  let ContentText txt = Prelude.head contents\n                   in Right . (\\x -> Background t c x) . encodeUtf8 $ txt\n                else acc\n    f acc@(Right bkg@(BackgroundPdf t d fi p)) (name, contents) =\n      if nameLocalName name == "type"\n        then\n          let ContentText txt = Prelude.head contents\n           in if txt == "pdf"\n                then Right (toBkgPdf bkg)\n                else Right (toBkgNoPdf (encodeUtf8 txt) bkg)\n        else\n          if nameLocalName name == "domain"\n            then\n              let ContentText txt = Prelude.head contents\n               in Right . (\\x -> BackgroundPdf t x fi p) . Just . encodeUtf8 $ txt\n            else\n              if nameLocalName name == "filename"\n                then\n                  let ContentText txt = Prelude.head contents\n                   in Right . (\\x -> BackgroundPdf t d x p) . Just . encodeUtf8 $ txt\n                else\n                  if nameLocalName name == "pageno"\n                    then\n                      let ContentText txt = Prelude.head contents\n                       in (\\x -> BackgroundPdf t d fi x) . fst <$> decimal txt\n                    else acc\ngetBackground _ = Left "not a background"\n\n-- |\ngetDimension :: Event -> Either String Dimension\ngetDimension (EventBeginElement _name namecontent) =\n  foldl\' f (Right (Dim 0 0)) namecontent\n  where\n    f acc@(Left _) _ = acc\n    f acc@(Right (Dim w h)) (nm, contents) =\n      if nameLocalName nm == "width"\n        then\n          let ContentText txt = Prelude.head contents\n           in (flip Dim h) . fst <$> double txt\n        else\n          if nameLocalName nm == "height"\n            then\n              let ContentText txt = Prelude.head contents\n               in (Dim w) . fst <$> double txt\n            else acc\ngetDimension r = Left ("not a dimension : " ++ show r)\n\n-- | get Content\ngetContent :: Event -> Either String T.Text\ngetContent (EventContent (ContentText txt)) = Right txt\ngetContent r = Left ("no content" ++ show r)\n\n-- * predicates\n\n-- |\nisEventStartEnd :: Event -> Bool\nisEventStartEnd (EventBeginElement _ _) = True\nisEventStartEnd (EventEndElement _) = True\nisEventStartEnd _ = False\n\n-- | check start of element with name txt\nisStart :: T.Text -> Event -> Bool\nisStart txt (EventBeginElement name _) = nameLocalName name == txt\nisStart _ _ = False\n\n-- | check end of element with name txt\nisEnd :: T.Text -> Event -> Bool\nisEnd txt (EventEndElement name) = nameLocalName name == txt\nisEnd _ _ = False\n\n-- * driver routines\n\n-- | generic xml file driver\nparseXmlFile :: (MonadThrow m, MonadIO m) => Handle -> Sink Event m a -> m a\nparseXmlFile h iter = sourceHandle h =$= parseBytes def $$ iter\n\n-- enumHandle 4096 h $$ joinI $ parseBytes def $$ iter\n\n-- | for xournal\nparseXojFile :: FilePath -> IO (Either String Xournal)\nparseXojFile fp = withFile fp ReadMode $ \\ih -> parseXmlFile ih pXournal\n\n-- |\nparseXojGzFile :: FilePath -> IO (Either String Xournal)\nparseXojGzFile fp = withFile fp ReadMode $ \\h ->\n  sourceHandle h =$= ungzip =$= parseBytes def $$ pXournal\n\n-- |\nparseXournal :: FilePath -> IO (Either String Xournal)\nparseXournal fname =\n  checkIfBinary fname >>= \\b ->\n    if b then parseXojGzFile fname else parseXojFile fname\n\n-- | printing for debug\niterPrint :: (Show s, MonadIO m) => Sink s m ()\niterPrint = do\n  x <- CL.head\n  maybe (return ()) (liftIO . print >=> \\_ -> iterPrint) x\n'