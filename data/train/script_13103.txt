b'/* \n * Fast QR Code generator library\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/fast-qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the "Software"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided "as is", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\npackage io.nayuki.fastqrcodegen;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n\n/**\n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * <p>The mid-level way to create a segment is to take the payload data and call a\n * static factory function such as {@link QrSegment#makeNumeric(String)}. The low-level\n * way to create a segment is to custom-make the bit buffer and call the {@link\n * QrSegment#QrSegment(Mode,int,int[],int) constructor} with appropriate values.</p>\n * <p>This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n * This class can represent kanji mode segments, but provides no help in encoding them\n * - see {@link QrSegmentAdvanced} for full kanji support.</p>\n */\npublic final class QrSegment {\n\t\n\t/*---- Static factory functions (mid level) ----*/\n\t\n\t/**\n\t * Returns a segment representing the specified binary data\n\t * encoded in byte mode. All input byte arrays are acceptable.\n\t * <p>Any text string can be converted to UTF-8 bytes ({@code\n\t * s.getBytes(StandardCharsets.UTF_8)}) and encoded as a byte mode segment.</p>\n\t * @param data the binary data (not {@code null})\n\t * @return a segment (not {@code null}) containing the data\n\t * @throws NullPointerException if the array is {@code null}\n\t */\n\tpublic static QrSegment makeBytes(byte[] data) {\n\t\tObjects.requireNonNull(data);\n\t\tif (data.length * 8L > Integer.MAX_VALUE)\n\t\t\tthrow new IllegalArgumentException("Data too long");\n\t\tint[] bits = new int[(data.length + 3) / 4];\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tbits[i >>> 2] |= (data[i] & 0xFF) << (~i << 3);\n\t\treturn new QrSegment(Mode.BYTE, data.length, bits, data.length * 8);\n\t}\n\t\n\t\n\t/**\n\t * Returns a segment representing the specified string of decimal digits encoded in numeric mode.\n\t * @param digits the text (not {@code null}), with only digits from 0 to 9 allowed\n\t * @return a segment (not {@code null}) containing the text\n\t * @throws NullPointerException if the string is {@code null}\n\t * @throws IllegalArgumentException if the string contains non-digit characters\n\t */\n\tpublic static QrSegment makeNumeric(String digits) {\n\t\tObjects.requireNonNull(digits);\n\t\tBitBuffer bb = new BitBuffer();\n\t\tint accumData = 0;\n\t\tint accumCount = 0;\n\t\tfor (int i = 0; i < digits.length(); i++) {\n\t\t\tchar c = digits.charAt(i);\n\t\t\tif (c < \'0\' || c > \'9\')\n\t\t\t\tthrow new IllegalArgumentException("String contains non-numeric characters");\n\t\t\taccumData = accumData * 10 + (c - \'0\');\n\t\t\taccumCount++;\n\t\t\tif (accumCount == 3) {\n\t\t\t\tbb.appendBits(accumData, 10);\n\t\t\t\taccumData = 0;\n\t\t\t\taccumCount = 0;\n\t\t\t}\n\t\t}\n\t\tif (accumCount > 0)  // 1 or 2 digits remaining\n\t\t\tbb.appendBits(accumData, accumCount * 3 + 1);\n\t\treturn new QrSegment(Mode.NUMERIC, digits.length(), bb.data, bb.bitLength);\n\t}\n\t\n\t\n\t/**\n\t * Returns a segment representing the specified text string encoded in alphanumeric mode.\n\t * The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n\t * dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t * @param text the text (not {@code null}), with only certain characters allowed\n\t * @return a segment (not {@code null}) containing the text\n\t * @throws NullPointerException if the string is {@code null}\n\t * @throws IllegalArgumentException if the string contains non-encodable characters\n\t */\n\tpublic static QrSegment makeAlphanumeric(String text) {\n\t\tObjects.requireNonNull(text);\n\t\tBitBuffer bb = new BitBuffer();\n\t\tint accumData = 0;\n\t\tint accumCount = 0;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tchar c = text.charAt(i);\n\t\t\tif (c >= ALPHANUMERIC_MAP.length || ALPHANUMERIC_MAP[c] == -1)\n\t\t\t\tthrow new IllegalArgumentException("String contains unencodable characters in alphanumeric mode");\n\t\t\taccumData = accumData * 45 + ALPHANUMERIC_MAP[c];\n\t\t\taccumCount++;\n\t\t\tif (accumCount == 2) {\n\t\t\t\tbb.appendBits(accumData, 11);\n\t\t\t\taccumData = 0;\n\t\t\t\taccumCount = 0;\n\t\t\t}\n\t\t}\n\t\tif (accumCount > 0)  // 1 character remaining\n\t\t\tbb.appendBits(accumData, 6);\n\t\treturn new QrSegment(Mode.ALPHANUMERIC, text.length(), bb.data, bb.bitLength);\n\t}\n\t\n\t\n\t/**\n\t * Returns a list of zero or more segments to represent the specified Unicode text string.\n\t * The result may use various segment modes and switch modes to optimize the length of the bit stream.\n\t * @param text the text to be encoded, which can be any Unicode string\n\t * @return a new mutable list (not {@code null}) of segments (not {@code null}) containing the text\n\t * @throws NullPointerException if the text is {@code null}\n\t */\n\tpublic static List<QrSegment> makeSegments(String text) {\n\t\tObjects.requireNonNull(text);\n\t\t\n\t\t// Select the most efficient segment encoding automatically\n\t\tList<QrSegment> result = new ArrayList<>();\n\t\tif (text.equals(""));  // Leave result empty\n\t\telse if (isNumeric(text))\n\t\t\tresult.add(makeNumeric(text));\n\t\telse if (isAlphanumeric(text))\n\t\t\tresult.add(makeAlphanumeric(text));\n\t\telse\n\t\t\tresult.add(makeBytes(text.getBytes(StandardCharsets.UTF_8)));\n\t\treturn result;\n\t}\n\t\n\t\n\t/**\n\t * Returns a segment representing an Extended Channel Interpretation\n\t * (ECI) designator with the specified assignment value.\n\t * @param assignVal the ECI assignment number (see the AIM ECI specification)\n\t * @return a segment (not {@code null}) containing the data\n\t * @throws IllegalArgumentException if the value is outside the range [0, 10<sup>6</sup>)\n\t */\n\tpublic static QrSegment makeEci(int assignVal) {\n\t\tBitBuffer bb = new BitBuffer();\n\t\tif (assignVal < 0)\n\t\t\tthrow new IllegalArgumentException("ECI assignment value out of range");\n\t\telse if (assignVal < (1 << 7))\n\t\t\tbb.appendBits(assignVal, 8);\n\t\telse if (assignVal < (1 << 14)) {\n\t\t\tbb.appendBits(2, 2);\n\t\t\tbb.appendBits(assignVal, 14);\n\t\t} else if (assignVal < 1_000_000) {\n\t\t\tbb.appendBits(6, 3);\n\t\t\tbb.appendBits(assignVal, 21);\n\t\t} else\n\t\t\tthrow new IllegalArgumentException("ECI assignment value out of range");\n\t\treturn new QrSegment(Mode.ECI, 0, bb.data, bb.bitLength);\n\t}\n\t\n\t\n\t/**\n\t * Tests whether the specified string can be encoded as a segment in numeric mode.\n\t * A string is encodable iff each character is in the range 0 to 9.\n\t * @param text the string to test for encodability (not {@code null})\n\t * @return {@code true} iff each character is in the range 0 to 9.\n\t * @throws NullPointerException if the string is {@code null}\n\t * @see #makeNumeric(String)\n\t */\n\tpublic static boolean isNumeric(String text) {\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tchar c = text.charAt(i);\n\t\t\tif (c < \'0\' || c > \'9\')\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t\n\t/**\n\t * Tests whether the specified string can be encoded as a segment in alphanumeric mode.\n\t * A string is encodable iff each character is in the following set: 0 to 9, A to Z\n\t * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\t * @param text the string to test for encodability (not {@code null})\n\t * @return {@code true} iff each character is in the alphanumeric mode character set\n\t * @throws NullPointerException if the string is {@code null}\n\t * @see #makeAlphanumeric(String)\n\t */\n\tpublic static boolean isAlphanumeric(String text) {\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tchar c = text.charAt(i);\n\t\t\tif (c >= ALPHANUMERIC_MAP.length || ALPHANUMERIC_MAP[c] == -1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t\n\t\n\t/*---- Instance fields ----*/\n\t\n\t/** The mode indicator of this segment. Not {@code null}. */\n\tpublic final Mode mode;\n\t\n\t/** The length of this segment\'s unencoded data. Measured in characters for\n\t * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t * Always zero or positive. Not the same as the data\'s bit length. */\n\tpublic final int numChars;\n\t\n\t// The data bits of this segment. Not null.\n\tfinal int[] data;\n\t\n\t// Requires 0 <= bitLength <= data.length * 32.\n\tfinal int bitLength;\n\t\n\t\n\t/*---- Constructor (low level) ----*/\n\t\n\t/**\n\t * Constructs a QR Code segment with the specified attributes and data.\n\t * The character count (numCh) must agree with the mode and the bit buffer length,\n\t * but the constraint isn\'t checked. The specified bit buffer is cloned and stored.\n\t * @param md the mode (not {@code null})\n\t * @param numCh the data length in characters or bytes, which is non-negative\n\t * @param data the data bits (not {@code null})\n\t * @param bitLen the number of valid prefix bits in the data array\n\t * @throws NullPointerException if the mode or data is {@code null}\n\t * @throws IllegalArgumentException if the character count is negative\n\t */\n\tpublic QrSegment(Mode md, int numCh, int[] data, int bitLen) {\n\t\tmode = Objects.requireNonNull(md);\n\t\tthis.data = Objects.requireNonNull(data);\n\t\tif (numCh < 0 || bitLen < 0 || bitLen > data.length * 32L)\n\t\t\tthrow new IllegalArgumentException("Invalid value");\n\t\tnumChars = numCh;\n\t\tbitLength = bitLen;\n\t}\n\t\n\t\n\t// Calculates the number of bits needed to encode the given segments at the given version.\n\t// Returns a non-negative number if successful. Otherwise returns -1 if a segment has too\n\t// many characters to fit its length field, or the total bits exceeds Integer.MAX_VALUE.\n\tstatic int getTotalBits(List<QrSegment> segs, int version) {\n\t\tObjects.requireNonNull(segs);\n\t\tlong result = 0;\n\t\tfor (QrSegment seg : segs) {\n\t\t\tObjects.requireNonNull(seg);\n\t\t\tint ccbits = seg.mode.numCharCountBits(version);\n\t\t\tif (seg.numChars >= (1 << ccbits))\n\t\t\t\treturn -1;  // The segment\'s length doesn\'t fit the field\'s bit width\n\t\t\tresult += 4L + ccbits + seg.bitLength;\n\t\t\tif (result > Integer.MAX_VALUE)\n\t\t\t\treturn -1;  // The sum will overflow an int type\n\t\t}\n\t\treturn (int)result;\n\t}\n\t\n\t\n\t/*---- Constants ----*/\n\t\n\tstatic final int[] ALPHANUMERIC_MAP;\n\t\n\tstatic {\n\t\tfinal String ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";\n\t\tint maxCh = -1;\n\t\tfor (int i = 0; i < ALPHANUMERIC_CHARSET.length(); i++)\n\t\t\tmaxCh = Math.max(ALPHANUMERIC_CHARSET.charAt(i), maxCh);\n\t\tALPHANUMERIC_MAP = new int[maxCh + 1];\n\t\tArrays.fill(ALPHANUMERIC_MAP, -1);\n\t\tfor (int i = 0; i < ALPHANUMERIC_CHARSET.length(); i++)\n\t\t\tALPHANUMERIC_MAP[ALPHANUMERIC_CHARSET.charAt(i)] = i;\n\t}\n\t\n\t\n\t\n\t/*---- Public helper enumeration ----*/\n\t\n\t/**\n\t * Describes how a segment\'s data bits are interpreted.\n\t */\n\tpublic enum Mode {\n\t\t\n\t\t/*-- Constants --*/\n\t\t\n\t\tNUMERIC     (0x1, 10, 12, 14),\n\t\tALPHANUMERIC(0x2,  9, 11, 13),\n\t\tBYTE        (0x4,  8, 16, 16),\n\t\tKANJI       (0x8,  8, 10, 12),\n\t\tECI         (0x7,  0,  0,  0);\n\t\t\n\t\t\n\t\t/*-- Fields --*/\n\t\t\n\t\t// The mode indicator bits, which is a uint4 value (range 0 to 15).\n\t\tfinal int modeBits;\n\t\t\n\t\t// Number of character count bits for three different version ranges.\n\t\tprivate final int[] numBitsCharCount;\n\t\t\n\t\t\n\t\t/*-- Constructor --*/\n\t\t\n\t\tprivate Mode(int mode, int... ccbits) {\n\t\t\tmodeBits = mode;\n\t\t\tnumBitsCharCount = ccbits;\n\t\t}\n\t\t\n\t\t\n\t\t/*-- Method --*/\n\t\t\n\t\t// Returns the bit width of the character count field for a segment in this mode\n\t\t// in a QR Code at the given version number. The result is in the range [0, 16].\n\t\tint numCharCountBits(int ver) {\n\t\t\tassert QrCode.MIN_VERSION <= ver && ver <= QrCode.MAX_VERSION;\n\t\t\treturn numBitsCharCount[(ver + 7) / 17];\n\t\t}\n\t\t\n\t}\n\t\n}\n'