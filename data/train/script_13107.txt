b'{-# LANGUAGE\n    CPP\n  , DataKinds\n  , DeriveDataTypeable\n  , GADTs\n  , KindSignatures\n  , NoImplicitPrelude\n  , TupleSections\n  , TypeFamilies\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\n-- | Handlers for endpoints in a \'Resource\'.\nmodule Rest.Handler\n  ( -- * Single handlers.\n    mkHandler\n  , mkInputHandler\n  , mkConstHandler\n  , mkIdHandler\n\n    -- * Listings.\n  , mkListing\n  , mkOrderedListing\n    -- ** Parameter parsers for listings.\n  , Range (..)\n  , range\n  , orderedRange\n\n    -- * Generic handlers and core data types.\n  , Env (..)\n  , GenHandler (..)\n  , mkGenHandler\n  , Apply\n  , Handler\n  , ListHandler\n\n    -- * Convenience functions.\n  , secureHandler\n  ) where\n\nimport Prelude.Compat\n\nimport Control.Arrow\nimport Control.Monad.Except ()\nimport Control.Monad.Identity\nimport Control.Monad.Reader\nimport Control.Monad.Trans.Except\nimport Rest.Types.Range\nimport Safe\n\nimport Rest.Dictionary\nimport Rest.Error\nimport Rest.Types.Void\n\n-------------------------------------------------------------------------------\n\n-- | An environment of inputs passed to a handler. Contains\n-- information from the \'header\'s, the \'param\'eters and the body\n-- \'input\'.\n\ndata Env h p i = Env\n  { header :: h\n  , param  :: p\n  , input  :: i\n  }\n\n-- | A handler for some endpoint. The input and output types are\n-- specified by the \'dictionary\', which can be created using the\n-- combinators from "Rest.Dictionary.Combinators". The inputs\n-- (headers, parameters and body) are passed as an \'Env\' to the\n-- \'handler\'. This handler runs in monad @m@, combined with the\n-- ability to throw errors. The result is either the output value, or\n-- a list of them for list handlers.\n-- If the \'secure\' flag is set, this suggests to clients that the\n-- resource should only be served over https. It has no effect when\n-- running the API.\n\ndata GenHandler m f where\n  GenHandler :: (i ~ FromMaybe () i\', o ~ FromMaybe () o\', e ~ FromMaybe Void e\') =>\n    { dictionary :: Dict h p i\' o\' e\'\n    , handler    :: Env h p i -> ExceptT (Reason e) m (Apply f o)\n    , secure     :: Bool\n    } -> GenHandler m f\n\n-- | Construct a \'GenHandler\' using a \'Modifier\' instead of a \'Dict\'.\n-- The \'secure\' flag will be \'False\'.\n\nmkGenHandler :: (Monad m, i ~ FromMaybe () i\', o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n             => Modifier h p i\' o\' e\'\n             -> (Env h p i -> ExceptT (Reason e) m (Apply f o))\n             -> GenHandler m f\nmkGenHandler d a = GenHandler (d empty) a False\n\n-- | Apply a Functor @f@ to a type @a@. In general will result in @f\n-- a@, except if @f@ is \'Identity\', in which case it will result in\n-- @a@. This prevents a lot of \'Identity\' wrapping/unwrapping.\n\ntype family Apply (f :: * -> *) a :: *\ntype instance Apply Identity a = a\ntype instance Apply []       a = [a]\n\n-- | A \'Handler\' returning a single item.\ntype Handler     m = GenHandler m Identity\n-- | A \'Handler\' returning a list of items.\ntype ListHandler m = GenHandler m []\n\n-- | Set \'secure\' to \'True\'.\n\nsecureHandler :: Handler m -> Handler m\nsecureHandler h = h { secure = True }\n\n-- | Smart constructor for creating a list handler.\n-- Restricts the type of the \'Input\' dictionary to \'None\'\n\nmkListing\n  :: (Monad m, o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n  => Modifier h p \'Nothing o\' e\'\n  -> (Range -> ExceptT (Reason e) m [o])\n  -> ListHandler m\nmkListing d a = mkGenHandler (mkPar range . d) (a . param)\n\n-- | Dictionary for taking \'Range\' parameters. Allows two query\n-- parameters, @offset@ and @count@. If not passed, the defaults are 0\n-- and 100. The maximum range that can be passed is 1000.\n\nrange :: Param Range\nrange = Param ["offset", "count"] $ \\xs ->\n  maybe (Left (ParseError "range"))\n        (Right . normalize)\n    $ case xs of\n        [Just o, Just c] -> Range         <$> readMay o <*> readMay c\n        [_     , Just c] -> Range 0       <$> readMay c\n        [Just o, _     ] -> (`Range` 100) <$> readMay o\n        _                -> Just $ Range 0 100\n  where normalize r = Range { offset = max 0 . offset $ r\n                            , count  = min 1000 . max 0 . count $ r\n                            }\n\n-- | Create a list handler that accepts ordering information.\n-- Restricts the type of the \'Input\' dictionary to \'None\'\n\nmkOrderedListing\n  :: (Monad m, o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n  => Modifier h p \'Nothing o\' e\'\n  -> ((Range, Maybe String, Maybe String) -> ExceptT (Reason e) m [o])\n  -> ListHandler m\nmkOrderedListing d a = mkGenHandler (mkPar orderedRange . d) (a . param)\n\n-- | Dictionary for taking ordering information. In addition to the\n-- parameters accepted by \'range\', this accepts @order@ and\n-- @direction@.\norderedRange :: Param (Range, Maybe String, Maybe String)\norderedRange = Param ["offset", "count", "order", "direction"] $ \\xs ->\n  case xs of\n    [mo, mc, mor, md] ->\n      maybe (Left (ParseError "range"))\n            (Right . (\\(o, c) -> (Range o c, mor, md)) . normalize)\n        $ case (mo, mc) of\n            (Just o, Just c) -> (,)    <$> readMay o <*> readMay c\n            (_     , Just c) -> (0,)   <$> readMay c\n            (Just o, _     ) -> (,100) <$> readMay o\n            _                -> Just (0, 100)\n    _ -> error "Internal error in orderedRange rest parameters"\n  where normalize = (max 0 *** (min 1000 . max 0))\n\n-- | Create a handler for a single resource. Takes the entire\n-- environmend as input.\n\nmkHandler :: (Monad m, i ~ FromMaybe () i\', o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n          => Modifier h p i\' o\' e\' -> (Env h p i -> ExceptT (Reason e) m o) -> Handler m\nmkHandler = mkGenHandler\n\n-- | Create a handler for a single resource. Takes only the body\n-- information as input.\n\nmkInputHandler :: (Monad m, i ~ FromMaybe () i\', o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n               => Modifier () () i\' o\' e\' -> (i -> ExceptT (Reason e) m o) -> Handler m\nmkInputHandler d a = mkHandler d (a . input)\n\n-- | Create a handler for a single resource. Doesn\'t take any input.\n\nmkConstHandler :: (Monad m, o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n               => Modifier () () \'Nothing o\' e\' -> ExceptT (Reason e) m o -> Handler m\nmkConstHandler d a = mkHandler d (const a)\n\n-- | Create a handler for a single resource. Take body information and\n-- the resource identifier as input. The monad @m@ must be a\n-- \'Reader\'-like type containing the idenfier.\n\nmkIdHandler :: (MonadReader id m, i ~ FromMaybe () i\', o ~ FromMaybe () o\', e ~ FromMaybe Void e\')\n            => Modifier h p i\' o\' e\' -> (i -> id -> ExceptT (Reason e) m o) -> Handler m\nmkIdHandler d a = mkHandler d (\\env -> ask >>= a (input env))\n'