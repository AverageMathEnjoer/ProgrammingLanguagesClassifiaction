b'#include "stdafx.h"\n#include "Win32AppContext.h"\n#include <assert.h>\n#include <mCtrl\\treelist.h>\n#include <mCtrl\\mditab.h>\n#include "BatchImportDialog.h"\n#include "Win32PluginManager.h"\n\nWin32AppContext::Win32AppContext(HINSTANCE hInstance, const std::string &baseDir)\n\t: mainWindow(hInstance), baseDir(baseDir), handlingMessages(false), messagePosted(false),\n\tgcMemoryLimit(0), gcMinAge(0)\n{\n\tInitializeCriticalSection(&this->messageMutex);\n\tmainWindow.setContext(this);\n}\nWin32AppContext::~Win32AppContext()\n{\n\tDeleteCriticalSection(&this->messageMutex);\n}\n\nvoid Win32AppContext::signalMainThread(EAppContextMsg message, void *args)\n{\n\tbool notifyMainThread = true;\n\tEnterCriticalSection(&this->messageMutex);\n\tif (!this->messageQueue.empty() && messagePosted)\n\t\tnotifyMainThread = false; //No need to send another notification.\n\tthis->messageQueue.push_back(std::pair<EAppContextMsg,void*>(message, args));\n\tif (mainWindow.hDlg != NULL)\n\t{\n\t\tif (notifyMainThread)\n\t\t\tmessagePosted = mainWindow.onAppContextMessageAsync() || messagePosted;\n\t}\n\telse\n\t{\n\t\t//The program is probably exiting, waiting for the last tasks to complete.\n\t\t//Since the main thread is inactive, it is sufficient to call handleMessages in a critical section.\n\t\t//(Note: Enter-/LeaveCriticalSection allows recursion)\n\t\thandleMessages();\n\t}\n\tLeaveCriticalSection(&this->messageMutex);\n}\nvoid Win32AppContext::handleMessages()\n{\n\tstd::vector<std::pair<EAppContextMsg,void*>> messageQueue;\n\tEnterCriticalSection(&this->messageMutex);\n\tif (handlingMessages)\n\t{\n\t\t//May be called in parallel only if the window is destructed (by signalMainThread).\n\t\tLeaveCriticalSection(&this->messageMutex);\n\t\treturn;\n\t}\n\tmessagePosted = false;\n\thandlingMessages = true;\n\n\twhile (this->messageQueue.size() > 0) {\n\t\tthis->messageQueue.swap(messageQueue);\n\t\tLeaveCriticalSection(&this->messageMutex);\n\t\tfor (size_t i = 0; i < messageQueue.size(); ++i)\n\t\t{\n\t\t\tEAppContextMsg message = messageQueue[i].first;\n\t\t\tvoid *args = messageQueue[i].second;\n\t\t\tthis->processMessage(message, args);\n\t\t}\n\t\tmessageQueue.clear();\n\t\tEnterCriticalSection(&this->messageMutex);\n\t}\n\thandlingMessages = false;\n\tLeaveCriticalSection(&this->messageMutex);\n}\nbool Win32AppContext::processMessage(EAppContextMsg message, void *args)\n{\n\t//switch ((EWin32AppContextMsg)message)\n\t//{\n\t//\tdefault:\n\t\t\treturn AppContext::processMessage(message, args);\n\t//}\n}\n\nvoid Win32AppContext::OnUpdateContainers(AssetsFileContextInfo *info)\n{\n\tmainWindow.OnUpdateContainers(info);\n}\nvoid Win32AppContext::OnChangeAsset(AssetsFileContextInfo *pFile, pathid_t pathID, bool wasRemoved)\n{\n\tAppContext::OnChangeAsset(pFile, pathID, wasRemoved);\n\tmainWindow.OnChangeAsset(pFile, pathID, wasRemoved);\n}\nvoid Win32AppContext::OnChangeBundleEntry(BundleFileContextInfo *pFile, size_t index)\n{\n\tAppContext::OnChangeBundleEntry(pFile, index);\n\tmainWindow.OnChangeBundleEntry(pFile, index);\n}\nvoid Win32AppContext::OnUpdateDependencies(AssetsFileContextInfo *info, size_t from, size_t to)\n{\n\tAppContext::OnUpdateDependencies(info, from, to);\n\tmainWindow.OnUpdateDependencies(info, from, to);\n} //from/to: indices for info->references\nstd::shared_ptr<FileContextInfo> Win32AppContext::OnFileOpenAsBundle(std::shared_ptr<FileOpenTask> pTask, BundleFileContext *pContext,\n\tEBundleFileOpenStatus openStatus, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tstd::shared_ptr<FileContextInfo> pInfo = AppContext::OnFileOpenAsBundle(pTask, pContext, openStatus, parentFileID, directoryEntryIdx);\n\tif (pInfo == nullptr)\n\t\treturn nullptr;\n\tBundleFileContextInfo *pInfo_Bundle = reinterpret_cast<BundleFileContextInfo*>(pInfo.get());\n\tif (openStatus != BundleFileOpenStatus_CompressedDirectory)\n\t\tpInfo_Bundle->onDirectoryReady(*this);\n\tif (!mainWindow.OnFileEntryLoadSuccess(pTask.get(), pInfo, static_cast<TaskResult>(openStatus)))\n\t\tRemoveContextInfo(pInfo.get());\n\treturn pInfo;\n}\nstd::shared_ptr<FileContextInfo> Win32AppContext::OnFileOpenAsAssets(std::shared_ptr<FileOpenTask> pTask, AssetsFileContext *pContext,\n\tEAssetsFileOpenStatus openStatus, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tstd::shared_ptr<FileContextInfo> pInfo = AppContext::OnFileOpenAsAssets(pTask, pContext, openStatus, parentFileID, directoryEntryIdx);\n\tif (pInfo == nullptr)\n\t\treturn nullptr;\n\tAssetsFileContextInfo *pInfo_Assets = reinterpret_cast<AssetsFileContextInfo*>(pInfo.get());\n\tif (mainWindow.OnFileEntryLoadSuccess(pTask.get(), pInfo, static_cast<TaskResult>(openStatus)))\n\t{\n\t\tif (!pInfo_Assets->FindClassDatabase(classPackage))\n\t\t\tmainWindow.OnFindClassDatabaseFailure(pInfo_Assets, classPackage);\n\t\tpInfo_Assets->EnqueueContainersTask(*this, std::shared_ptr<AssetsFileContextInfo>(pInfo, pInfo_Assets));\n\t}\n\telse\n\t\tRemoveContextInfo(pInfo.get());\n\treturn pInfo;\n}\nstd::shared_ptr<FileContextInfo> Win32AppContext::OnFileOpenAsResources(std::shared_ptr<FileOpenTask> pTask, ResourcesFileContext *pContext,\n\tunsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tstd::shared_ptr<FileContextInfo> pInfo = AppContext::OnFileOpenAsResources(pTask, pContext, parentFileID, directoryEntryIdx);\n\tif (pInfo == nullptr)\n\t\treturn nullptr;\n\tif (!mainWindow.OnFileEntryLoadSuccess(pTask.get(), pInfo, static_cast<TaskResult>(0)))\n\t\tRemoveContextInfo(pInfo.get());\n\treturn pInfo;\n}\nstd::shared_ptr<FileContextInfo> Win32AppContext::OnFileOpenAsGeneric(std::shared_ptr<FileOpenTask> pTask, GenericFileContext *pContext, unsigned int parentFileID, unsigned int directoryEntryIdx)\n{\n\tstd::shared_ptr<FileContextInfo> pInfo = AppContext::OnFileOpenAsGeneric(pTask, pContext, parentFileID, directoryEntryIdx);\n\tif (pInfo == nullptr)\n\t\treturn nullptr;\n\tif (!mainWindow.OnFileEntryLoadSuccess(pTask.get(), pInfo, static_cast<TaskResult>(0)))\n\t\tRemoveContextInfo(pInfo.get());\n\treturn pInfo;\n}\nvoid Win32AppContext::OnFileOpenFail(std::shared_ptr<FileOpenTask> pTask, std::string &logText)\n{\n\tmainWindow.OnFileEntryLoadFailure(pTask.get(), logText);\n}\nvoid Win32AppContext::OnDecompressBundle(BundleFileContextInfo::DecompressTask *pTask, TaskResult result)\n{\n\tif (result >= 0)\n\t\tmainWindow.OnDecompressSuccess(pTask);\n\telse\n\t\tmainWindow.OnDecompressFailure(pTask);\n}\nvoid Win32AppContext::RemoveContextInfo(FileContextInfo *info)\n{\n\tAppContext::RemoveContextInfo(info);\n\tmainWindow.OnRemoveContextInfo(info);\n}\n\nvoid Win32AppContext::LoadSettings()\n{\n\tgcMinAge = 15;\n#ifdef __X64\n\tgcMemoryLimit = 2 * 1024 * 1024 * 1024ULL; //2GiB default\n#else\n\tgcMemoryLimit = 1 * 1024 * 1024 * 1024; //1GiB default\n#endif\n\tautoDetectDependencies = true;\n\t//TODO: Load from settings file.\n}\n\nint Win32AppContext::Run(size_t argc, char **argv)\n{\n\tLoadSettings();\n\tstd::string loadErrorMessage;\n\tif (!this->LoadClassDatabasePackage(baseDir, loadErrorMessage))\n\t{\n\t\tif (loadErrorMessage.size() == 0)\n\t\t\tloadErrorMessage = "Unable to load the class database package file (classdata.tpk).";\n\t\tMessageBoxA(NULL, loadErrorMessage.c_str(), "UABE", 16);\n\t}\n\ttaskManager.setMaxThreads(4);\n\tmcTreeList_Initialize();\n\tmcMditab_Initialize();\n\n\tINITCOMMONCONTROLSEX init;\n\tinit.dwSize = sizeof(init);\n\tinit.dwICC = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_BAR_CLASSES | ICC_TAB_CLASSES | ICC_PROGRESS_CLASS | ICC_STANDARD_CLASSES | ICC_UPDOWN_CLASS;\n\tInitCommonControlsEx(&init);\n\n\tmainWindow.Initialize();\n\tloadAllPlugins(*this, this->plugins, this->getBaseDir() + "./Plugins");\n\tint ret = mainWindow.HandleMessages();\n    mcTreeList_Terminate();\n\t//Wait for all tasks to complete.\n\ttaskManager.setMaxThreads(0);\n\treturn ret;\n}\n\nbool Win32AppContext::ShowAssetBatchImportDialog(IAssetBatchImportDesc* pDesc, std::string _basePath)\n{\n\tCBatchImportDialog dialog(mainWindow.getHInstance(), pDesc, nullptr, std::move(_basePath));\n\treturn dialog.ShowModal(mainWindow.getWindow());\n}\n\nbool Win32AppContext::ShowAssetBatchImportDialog(IAssetBatchImportDesc* pDesc, IWin32AssetBatchImportDesc* pDescWin32, std::string _basePath)\n{\n\tCBatchImportDialog dialog(mainWindow.getHInstance(), pDesc, pDescWin32, std::move(_basePath));\n\treturn dialog.ShowModal(mainWindow.getWindow());\n}\n\nstd::string Win32AppContext::QueryAssetExportLocation(const std::vector<struct AssetUtilDesc>& assets,\n\tconst std::string &extension, const std::string &extensionFilter)\n{\n\tif (assets.empty())\n\t\treturn "";\n\tif (assets.size() > 1)\n\t{\n\t\tWCHAR* folderPathW = nullptr;\n\t\tif (!ShowFolderSelectDialog(this->getMainWindow().getWindow(), &folderPathW, L"Select an output directory", UABE_FILEDIALOG_EXPIMPASSET_GUID))\n\t\t\treturn "";\n\t\tauto pFolderPath8 = unique_WideToMultiByte(folderPathW);\n\t\tFreeCOMFilePathBuf(&folderPathW);\n\n\t\treturn std::string(pFolderPath8.get());\n\t}\n\telse\n\t{\n\t\tconst AssetUtilDesc& assetToExport = assets[0];\n\t\tif (assetToExport.asset.pathID == 0)\n\t\t{\n\t\t\tMessageBox(this->getMainWindow().getWindow(),\n\t\t\t\tTEXT("Unable to resolve the selected asset!"),\n\t\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\t\tMB_ICONERROR);\n\t\t\treturn "";\n\t\t}\n\t\tstd::unordered_map<std::string, size_t> _tmp;\n\t\tstd::string exportPath = assetToExport.makeExportFilePath(_tmp, extension);\n\t\tauto pExportPathT = unique_MultiByteToTCHAR(exportPath.c_str());\n\n\t\tauto pExtensionFilterW = unique_MultiByteToWide(extensionFilter.c_str());\n\t\tWCHAR* filePathW = nullptr;\n\t\tif (FAILED(ShowFileSaveDialog(this->getMainWindow().getWindow(), &filePathW, pExtensionFilterW.get(), nullptr,\n\t\t\tpExportPathT.get(), TEXT("Export an asset"),\n\t\t\tUABE_FILEDIALOG_EXPIMPASSET_GUID)))\n\t\t\treturn "";\n\t\tauto pFilePath8 = unique_WideToMultiByte(filePathW);\n\t\tFreeCOMFilePathBuf(&filePathW);\n\n\t\treturn std::string(pFilePath8.get());\n\t}\n}\n\nstd::vector<std::string> Win32AppContext::QueryAssetImportLocation(std::vector<AssetUtilDesc>& assets,\n\tstd::string extension, std::string _extensionRegex, std::string extensionFilter)\n{\n\n\tif (assets.empty())\n\t\treturn {};\n\tCWin32GenericBatchImportDialogDesc importDesc(assets, std::move(_extensionRegex), extensionFilter);\n\tif (importDesc.getElements().size() > 1)\n\t{\n\t\tWCHAR* folderPathW = nullptr;\n\t\tif (!ShowFolderSelectDialog(this->getMainWindow().getWindow(), &folderPathW, L"Select an input directory", UABE_FILEDIALOG_EXPIMPASSET_GUID))\n\t\t\treturn {};\n\t\tauto pFolderPath8 = unique_WideToMultiByte(folderPathW);\n\t\tFreeCOMFilePathBuf(&folderPathW);\n\t\tbool doImport = this->ShowAssetBatchImportDialog(&importDesc, &importDesc, std::string(pFolderPath8.get()));\n\t\tif (!doImport)\n\t\t\treturn {};\n\t}\n\telse\n\t{\n\t\tconst AssetUtilDesc& assetToImport = importDesc.getElements().front();\n\t\tif (assetToImport.asset.pathID == 0)\n\t\t{\n\t\t\tMessageBox(this->getMainWindow().getWindow(),\n\t\t\t\tTEXT("Unable to resolve the selected asset!"),\n\t\t\t\tTEXT("Asset Bundle Extractor"),\n\t\t\t\tMB_ICONERROR);\n\t\t\treturn {};\n\t\t}\n\t\tstd::unordered_map<std::string, size_t> _tmp;\n\t\tstd::string exportPath = assetToImport.makeExportFilePath(_tmp, extension);\n\t\tauto pExportPathT = unique_MultiByteToTCHAR(exportPath.c_str());\n\n\t\tauto pExtensionFilterW = unique_MultiByteToWide(extensionFilter.c_str());\n\t\tWCHAR* filePathW = nullptr;\n\t\tif (FAILED(ShowFileOpenDialog(this->getMainWindow().getWindow(), &filePathW, pExtensionFilterW.get(), nullptr,\n\t\t\tpExportPathT.get(), TEXT("Import an asset"),\n\t\t\tUABE_FILEDIALOG_EXPIMPASSET_GUID)))\n\t\t\treturn {};\n\t\tauto pFilePath8 = unique_WideToMultiByte(filePathW);\n\t\tFreeCOMFilePathBuf(&filePathW);\n\n\t\timportDesc.importFilePaths[0].assign(pFilePath8.get());\n\t}\n\tstd::vector<std::string> importFilePaths = importDesc.getImportFilePaths();\n\tassets = importDesc.clearAndGetElements();\n\treturn importFilePaths;\n}\n'