b'#\' print.summarytools\n#\'\n#\' Display \\code{summarytools} objects in the console, in Web Browser or in\n#\'  \\emph{RStudio}\'s Viewer, or write content to file.\n#\'\n#\' @usage\n#\'  \\method{print}{summarytools}(x, method = "pander", file = "",\n#\'    append = FALSE, report.title = NA, table.classes = NA,\n#\'    bootstrap.css = st_options(\'bootstrap.css\'),\n#\'    custom.css = st_options(\'custom.css\'), silent = FALSE,\n#\'    footnote = st_options(\'footnote\'), max.tbl.height = Inf,\n#\'    collapse = 0, escape.pipe = st_options("escape.pipe"), \\dots)\n#\'\n#\' @param x A \\emph{summarytools} object, created by one of the four core\n#\'   functions (\\code{\\link{freq}}, \\code{\\link{descr}}, \\code{\\link{ctable}},\n#\'   or \\code{\\link{dfSummary}}).\n#\' @param method Character. One of \\dQuote{pander}, \\dQuote{viewer}, \n#\'   \\dQuote{browser}, or \\dQuote{render}. Default value for the \\code{print()}\n#\'   method is \\dQuote{pander}; for \\code{view()}/\\code{stview()}, default is\n#\'   \\dQuote{viewer} if session is running in \\emph{RStudio}, \\dQuote{browser}\n#\'   otherwise. The main use for \\dQuote{render} is in \\emph{R Markdown}\n#\'   documents.\n#\' @param file Character. File name to write output to. Defaults to \\dQuote{}.\n#\' @param append Logical. Append output to existing file (specified using the\n#\'   \\emph{file} argument). \\code{FALSE} by default.\n#\' @param report.title Character. For \\emph{html} reports, this goes into the\n#\'   \\code{<title>} tag. When left to \\code{NA} (default), the first line of the\n#\'   heading section is used (\\emph{e.g.}: \\dQuote{Data Frame Summary}).\n#\' @param table.classes Character. Additional \\emph{html} classes to assign to\n#\'   output tables. \\emph{Bootstrap css} classes can be used. User-defined\n#\'   classes (see the \\emph{custom.css} argument) are also specified here. See\n#\'   \\emph{details} section. \\code{NA} by default.\n#\' @param bootstrap.css Logical. When generating an \\emph{html} document, \n#\'   include the \\dQuote{\\emph{includes/stylesheets/bootstrap.min.css"}} file\n#\'   content inside a \\code{<style type="text/css">} tag in the document\'s\n#\'   \\code{<head>}. \\code{TRUE} by default. Can be set globally with \n#\'   \\code{\\link{st_options}}.\n#\' @param custom.css Character. Path to a custom \\emph{.css} file. Classes\n#\'   defined in this must also appear in the \\code{table.classes} parameter\n#\'   in order to be applied to the table(s). Can be set globally with\n#\'   \\code{\\link{st_options}}. \\code{NA} by default.\n#\' @param silent Logical. Set to \\code{TRUE} to hide console messages \n#\'   (\\emph{e.g.}: ignored variables or \\code{NaN} to \\code{NA}\n#\'   transformations). \\code{FALSE} by default.\n#\' @param footnote Character. Text to display just after \\emph{html} output\n#\'   tables. The default value (\\dQuote{\\emph{default}}) produces a two-line\n#\'   footnote indicating the package\'s name and version, the R version, and\n#\'   the current date. Has no effect on \\emph{ascii} or \\emph{markdown}\n#\'   content. Can contain standard \\emph{html} tags. Set to \\code{NA} to omit.\n#\'   Can be set globally with \\code{\\link{st_options}}.\n#\' @param max.tbl.height Numeric. Maximum table height \\emph{in pixels} allowed\n#\'  in rendered \\code{dfSummary()} tables. When this argument is used, results \n#\'  will show up in a \\code{<div>} with the specified height and a scroll bar.\n#\'  Intended to be used in \\emph{Rmd} documents with \\code{method = "render"}.\n#\'  \\code{Inf} by default.\n#\' @param collapse Numeric. \\code{0} by default. Set to \\code{1} to make\n#\'  \\code{freq()} sections collapsible (when clicking on the variable name).\n#\'  Future versions might provide alternate collapsing options.\n#\' @param escape.pipe Logical. Set to \\code{TRUE} when \\code{style="grid"}\n#\'   and \\code{file} argument is supplied if the intent is to generate a text\n#\'   file that can be converted to other formats using \\emph{Pandoc}. Can be\n#\'   set globally with \\code{\\link{st_options}}.\n#\' @param \\dots Additional arguments used to override attributes stored in the\n#\'   object, or to change formatting via \\code{\\link[base]{format}} or \n#\'   \\code{\\link[pander]{pander}}. See \\emph{Details}.\n#\'\n#\' @return \\code{NULL} when \\code{method="pander"}; A file path returned\n#\'   invisibly when \\code{method="viewer"} or \\code{"browser"}. In the\n#\'   latter case, the file path is also passed to \\code{shell.exec} \n#\'   (\\emph{Windows}) or \\code{\\link{system}} (\\emph{*nix}), causing\n#\'   the document to be opened in default Web browser.\n#\'\n#\' @details\n#\'   \\code{Ascii} and \\emph{markdown} tables are generated using\n#\'   \\code{\\link[pander]{pander}}. \n#\'\n#\' The following arguments can be used to override formatting attributes stored\n#\' in the object:\n#\'    \\itemize{\n#\'      \\item \\code{style}\n#\'      \\item \\code{round.digits} (except for \\emph{dfSummary} objects)\n#\'      \\item \\code{plain.ascii}\n#\'      \\item \\code{justify}\n#\'      \\item \\code{split.tables}\n#\'      \\item \\code{headings}\n#\'      \\item \\code{display.labels}\n#\'      \\item \\code{varnumbers}    (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{labels.col}    (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{graph.col}     (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{valid.col}     (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{na.col}        (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{col.widths}    (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{keep.grp.vars} (\\code{\\link{dfSummary}} objects only)\n#\'      \\item \\code{report.nas}    (\\code{\\link{freq}} objects only)\n#\'      \\item \\code{display.type}  (\\code{\\link{freq}} objects only)\n#\'      \\item \\code{missing}       (\\code{\\link{freq}} objects only)\n#\'      \\item \\code{totals}        (\\code{\\link{freq}} and \\code{\\link{ctable}} objects)\n#\'      \\item \\code{caption}       (\\code{\\link{freq}} and \\code{\\link{ctable}} objects)\n#\'    }\n#\'\n#\' The following arguments can be used to override heading elements:\n#\' \n#\'    \\itemize{\n#\'      \\item \\code{Data.frame}\n#\'      \\item \\code{Data.frame.label}\n#\'      \\item \\code{Variable}\n#\'      \\item \\code{Variable.label}\n#\'      \\item \\code{Group}\n#\'      \\item \\code{date}\n#\'      \\item \\code{Weights}   (\\code{\\link{freq}} & \\code{\\link{descr}} objects)\n#\'      \\item \\code{Data.type} (\\code{\\link{freq}} objects only)\n#\'      \\item \\code{Row.variable} (\\code{\\link{ctable}} objects only)\n#\'      \\item \\code{Col.variable} (\\code{\\link{ctable}} objects only)\n#\'    }\n#\'\n#\' @method print summarytools\n#\'\n#\' @references\n#\' \\href{https://www.rstudio.com/}{RStudio}\n#\' \\href{https://github.com/dcomtois/summarytools/}{Summarytools on GitHub}\n#\' \\href{http://rapporter.github.io/pander/#general-options/}{List of pander options}\n#\' \\href{https://getbootstrap.com/docs/4.3/getting-started/introduction/}{Bootstrap Cascading Stylesheets}\n#\'\n#\' @author Dominic Comtois, \\email{dominic.comtois@@gmail.com}\n#\'\n#\' @seealso\n#\' \\code{\\link[pander]{pander}}\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' data(tobacco)\n#\' view(dfSummary(tobacco), footnote = NA)\n#\' }\n#\' data(exams)\n#\' print(freq(exams$gender), style = \'rmarkdown\')\n#\' print(descr(exams), headings = FALSE)\n#\'\n#\' @keywords print methods\n#\' @import htmltools\n#\' @importFrom pander pander panderOptions\n#\' @importFrom utils capture.output packageVersion head\n#\' @importFrom checkmate test_logical test_path_for_output test_choice\n#\'             test_string check_file_exists\n#\' @export\nprint.summarytools <- function(x,\n                               method         = "pander",\n                               file           = "",\n                               append         = FALSE,\n                               report.title   = NA,\n                               table.classes  = NA,\n                               bootstrap.css  = st_options("bootstrap.css"),\n                               custom.css     = st_options("custom.css"),\n                               silent         = FALSE,\n                               footnote       = st_options("footnote"),\n                               max.tbl.height = Inf,\n                               collapse       = 0,\n                               escape.pipe    = st_options("escape.pipe"),\n                               ...) {\n\n  # For list objects (generally created in one of the following ways:\n  # - using lapply(df, FUN), where FUN is [ctable() | descr() | dfSummary()]\n  # - using freq(x) where x is a data frame\n  # - using dplyr::group_by() %>% FUN, FUN in [ctable(), descr(), dfSummary()]\n  #\n  # ... we dispatch x [possibly back] to view()\n  if (is.list(x) &&\n      !attr(x, "st_type") %in% c("ctable", "descr", "dfSummary")) {\n\n    view(x,\n         method        = method,\n         file          = file,\n         append        = append,\n         report.title  = report.title,\n         table.classes = table.classes,\n         bootstrap.css = bootstrap.css,\n         custom.css    = custom.css,\n         silent        = silent,\n         footnote      = footnote,\n         collapse      = collapse,\n         escape.pipe   = escape.pipe,\n         ...)\n\n    return(invisible())\n  }\n\n  knitr.auto.asis.value <- panderOptions("knitr.auto.asis")\n  panderOptions("knitr.auto.asis", FALSE)\n  on.exit(panderOptions("knitr.auto.asis", knitr.auto.asis.value))\n\n  dotArgs <- list(...)\n\n  # Recuperate internal arguments passed from view() if present ----------------\n  if ("open.doc" %in% names(dotArgs)) {\n    open.doc <- eval(dotArgs[["open.doc"]])\n    dotArgs$open.doc <- NULL\n  } else {\n    open.doc <- FALSE\n  }\n\n  if ("group.only" %in% names(dotArgs)) {\n    attr(x, "format_info")$group.only <- eval(dotArgs[["group.only"]])\n    dotArgs$group.only <- NULL\n  }\n\n  if ("var.only" %in% names(dotArgs)) {\n    attr(x, "format_info")$var.only <- eval(dotArgs[["var.only"]])\n    dotArgs$var.only <- NULL\n  }\n\n  # Set st_option(lang) to the language that was active when the object was\n  # created (as indicated by attr(x, "lang")\n  if (isTRUE(st_options("lang") != attr(x, "lang"))) {\n    current_lang <- st_options("lang")\n    st_options(lang = attr(x, "lang"))\n    on.exit(st_options(lang = current_lang), add = TRUE)\n  }\n\n  method <- switch(tolower(substr(method, 1, 1)),\n                   p = "pander",\n                   b = "browser",\n                   v = "viewer",\n                   r = "render")\n\n  # Change method to browser when file name has .html extension\n  if (grepl("\\\\.html$", file, ignore.case = TRUE, perl = TRUE) &&\n      !grepl(pattern = tempdir(), x = file, fixed = TRUE) &&\n      method == "pander") {\n    method <- "browser"\n    # message("Switching method to \'browser\'")\n  }\n\n  # Parameter validation -------------------------------------------------------\n  mc <- match.call()\n  errmsg <- check_args_print(mc)\n  \n  if (length(errmsg) > 0) {\n    stop(paste(errmsg, collapse = "\\n  "))\n  }\n\n  # Display message if list object is being printed (console) with base print()\n  # (thus not taking advantage of print.summarytools() which makes results\n  # much cleaner in the console)\n  if (method == "pander" &&\n      (identical(deparse(sys.calls()[[max(sys.nframe() - 1, 1)]][2]), "x[[i]]()") ||\n       any(grepl(pattern = "fn_call = FUN(x = X[[i]]",\n                 x = deparse(sys.calls()[[max(sys.nframe() - 1, 1)]]), fixed = TRUE)))) {\n    message("For best results printing list objects with summarytools, ",\n            "use print(x); if by() was used, use stby() instead")\n  }\n\n  # Apply / override parameters - first deal with "meta" information -----------\n  # date is a stand-alone attribute so we treat it separately\n  if ("date" %in% names(dotArgs)) {\n    attr(x, "date") <- dotArgs[["date"]]\n    dotArgs$date <- NULL\n  }\n\n  # Check for elements with modified names - will be removed in next release\n  if ("dataframe" %in% tolower(names(dotArgs))) {\n    attr(x, "data_info")$Data.frame <- dotArgs$Dataframe\n    dotArgs$Dataframe <- NULL\n    message("Attribute \'Dataframe\' has been renamed to \'Data.frame\'; ",\n            "please use the latter in the future")\n  }\n\n  if ("dataframe.label" %in% tolower(names(dotArgs))) {\n    attr(x, "data_info")$Data.frame.label <- dotArgs$Dataframe.label\n    dotArgs$Dataframe.label <- NULL\n    message("Attribute \'Dataframe.label\' has been renamed to ",\n            "\'Data.frame.label\'; please use the latter in the future")\n  }\n\n  # Scan "dotArgs" for metadata elements\n  overrided_data_info <- character()\n  data_info_elements <- c("Data.frame", "Data.frame.label", "Variable",\n                          "Variable.label", "Data.type", "Group", "Weights",\n                          "Row.variable", "Col.variable")\n\n  for (data_info_element in data_info_elements) {\n    if (length(dotArgs) > 0) {\n      if (tolower(data_info_element) %in% tolower(names(dotArgs))) {\n        # Get matching index if present\n        elem_ind <- grep(paste0("^", data_info_element, "$"),\n                         names(dotArgs), ignore.case = TRUE)\n        if (length(elem_ind) > 0) {\n          elem_ind_last <- tail(elem_ind, 1) # take last if more than one match\n          # Display message if argument not spelled exactly as supposed\n          if (names(dotArgs)[elem_ind_last] != data_info_element) {\n            message("Argument ", data_info_element, " misspelled as ",\n                    names(dotArgs)[elem_ind_last])\n            names(dotArgs)[elem_ind_last] <- data_info_element\n          }\n          attr(x, "data_info")[[data_info_element]] <- dotArgs[[elem_ind_last]]\n          for (ind in elem_ind) {\n            dotArgs[[elem_ind]] <- NULL\n          }\n          overrided_data_info <- c(overrided_data_info, data_info_element)\n        }\n      }\n    }\n  }\n\n  # Assume all remaining arguments have to do with formatting. Put everything\n  # into a list and eliminate redundant items, keeping only the last one,\n  # giving priority to \n  # \n  #  1. "dotArgs", then to \n  #  2. explicit arguments used when creating the object, as given by the\n  #     \'fn_call\' attribute.\n  # \n  # The remaining arguments will be obtained from the st_options() function\n  # so that changes in summarytools options made after the object\'s creation\n  # will be applied.\n  format_info <-\n    append(list(scientific       = FALSE,\n                decimal.mark     = getOption("OutDec"),\n                keep.line.breaks = TRUE,\n                max.tbl.height   = max.tbl.height,\n                collapse         = collapse),\n           attr(x, "format_info"))\n\n  if (length(attr(x, "user_fmt")) > 0) {\n    format_info <- append(format_info, attr(x, "user_fmt"))\n  }\n\n  if (length(dotArgs) > 0) {\n    format_info <- append(format_info, dotArgs)\n  }\n\n  # Keep only last instance of repeated items\n  format_info <- format_info[which(!duplicated(names(format_info),\n                                               fromLast = TRUE))]\n\n  # For parameters that were not explicit, get their value from\n  # st_options().\n  list_fmt_elements <- c("style", "plain.ascii", "round.digits", "headings",\n                         "display.labels")\n  for (format_element in list_fmt_elements) {\n    if (!format_element %in% c(names(attr(x, "fn_call")), names(dotArgs))) {\n      if (!(format_element == "style" &&\n            attr(x, "st_type") == "dfSummary") &&\n          !(format_element == "round.digits" &&\n            attr(x, "st_type") == "ctable")) {\n        format_info[[format_element]] <- st_options(format_element)\n      }\n    }\n  }\n\n  # Global options specific to the type of st object being printed\n  prefix <- paste0(attr(x, "st_type"), ".")\n  for (format_element in sub(prefix, "",\n                             grep(prefix, names(st_options()), value = TRUE,\n                                  fixed = TRUE),\n                             fixed = TRUE)) {\n\n    if (!format_element %in% c(names(attr(x, "fn_call")), names(dotArgs))) {\n      format_info[[format_element]] <-\n        st_options(paste0(prefix, format_element))\n    }\n  }\n\n  # When style == \'rmarkdown\', set plain.ascii to FALSE unless\n  # explicitly specified otherwise\n  if (method == "pander" && format_info$style == "rmarkdown" &&\n      isTRUE(format_info$plain.ascii) &&\n      (!"plain.ascii" %in% (names(dotArgs)))) {\n    format_info$plain.ascii <- FALSE\n  }\n\n  # Evaluate formatting attributes that are symbols at this stage (F, T)\n  for (i in seq_along(format_info)) {\n    if (is.symbol(format_info[[i]])) {\n      format_info[[i]] <- eval(format_info[[i]])\n    }\n  }\n\n  # Fix the value of justify - default depends on method\n  if (method == "pander") {\n    format_info$justify <- switch(tolower(substring(format_info$justify, 1, 1)),\n                                  l = "left",\n                                  c = "center",\n                                  d = "right",\n                                  r = "right")\n  } else {\n    format_info$justify <- switch(tolower(substring(format_info$justify, 1, 1)),\n                                  l = "left",\n                                  c = "center",\n                                  d = "center",\n                                  r = "right")\n  }\n\n  format_info$missing <- ifelse("missing" %in% names(format_info),\n                                format_info$missing, "NA")\n\n  # Keep last when multiple values\n  format_info <- format_info[which(!duplicated(names(format_info),\n                                               fromLast = TRUE))]\n\n  # Add nsmall and digits to format_info if not already there\n  if (!"nsmall" %in% names(format_info)) {\n    format_info$nsmall <- format_info$round.digits\n  }\n\n  if (!"digits" %in% names(format_info)) {\n    format_info$digits <- max(c(1, format_info$round.digits))\n  }\n\n  # Put modified attributes back into x\n  attr(x, "format_info") <- format_info\n  format_args <- \n    format_info[which(names(format_info) %in% names(formals(format.default)))]\n  format_args$justify <- sub("center", "centre", format_args$justify)\n  attr(x, "format_args") <- format_args\n\n  pander_args <- append(\n    format_info[which(names(format_info) %in%\n                        c(sub("^table\\\\.", "", names(panderOptions())),\n                          "style", "caption", "justify", "missing",\n                          "split.tables", "split.cells", "keep.line.breaks"))],\n    attr(x, "user_fmt"))\n  \n  attr(x, "pander_args") <-\n    pander_args[which(!duplicated(names(pander_args), fromLast = TRUE))]\n\n  # Build default footnote\n  if (method %in% c("browser", "viewer", "render") && footnote == "default") {\n    footnote <-\n      paste0(\n        conv_non_ascii(trs("generated.by")),\n        " <a href=\'https://github.com/dcomtois/summarytools\'>",\n        "summarytools</a> ", packageVersion(pkg = "summarytools"),\n        " (<a href=\'https://www.r-project.org/\'>R</a> ", trs("version"), " ",\n        getRversion(), ")", "<br/>", strftime(attr(x, "date"), trs("date.fmt"))\n      )\n  }\n\n  # Concatenate data frame + $ + variable name where appropriate\n  if (!("Variable" %in% overrided_data_info) &&\n      length(attr(x, "data_info")$Data.frame) == 1 &&\n      "Variable" %in% names(attr(x, "data_info")) &&\n      !("by_var_special" %in% names(attr(x, "data_info")))) {\n    attr(x, "data_info")$Variable <- paste(attr(x, "data_info")$Data.frame,\n                                           attr(x, "data_info")$Variable,\n                                           sep = "$")\n  }\n\n  # Dispatch to the right function for preparing output ------------------------\n  if (attr(x, "st_type") == "freq") {\n    res <- print_freq(x, method)\n    if (is.na(report.title)) {\n      if (!("Weights" %in% names(attr(x, "data_info")))) {\n        report.title <- trs("title.freq")\n      } else {\n        report.title <- trs("title.freq.weighted")\n      }\n    }\n  } else if (attr(x, "st_type") == "ctable") {\n    res <- print_ctable(x, method)\n    if (is.na(report.title)) {\n      report.title <- trs("title.ctable")\n    }\n  } else if (attr(x, "st_type") == "descr") {\n    res <- print_descr(x, method)\n    if (is.na(report.title)) {\n      if (!("Weights" %in% names(attr(x, "data_info")))) {\n        report.title <- trs("title.descr")\n      } else {\n        report.title <- trs("title.descr.weighted")\n      }\n    }\n  } else if (attr(x, "st_type") == "dfSummary") {\n    res <- print_dfs(x, method)\n    if (is.na(report.title)) {\n      report.title <- trs("title.dfSummary")\n    }\n  }\n\n  # Print or write to file - pander --------------------------------------------\n  if (method == "pander") {\n\n    # Remove double-linefeeds\n    res[[length(res)]] <-\n      sub("^\\\\n\\\\n", "\\n", res[[length(res)]])\n\n    file <- normalizePath(file, mustWork = FALSE)\n    cat(do.call(paste0, res), file = file, append = append)\n\n    if (file != "" && !isTRUE(silent)) {\n      if (isTRUE(append))\n        message("Output file appended: ", file)\n      else\n        message("Output file written: ", file)\n      return(invisible())\n    }\n\n  } else {\n\n    # Print or write to file - html --------------------------------------------\n\n    if (isTRUE(append)) {\n      f <- file(file, open = "r", encoding = "utf-8")\n      html_content_in <- paste(readLines(f, warn = FALSE, encoding = "utf-8"),\n                               collapse = "\\n")\n      close(f)\n      top_part    <- sub("(^.+)(</body>.+)", "\\\\1", html_content_in)\n      bottom_part <- sub("(^.+)(</body>.+)", "\\\\2", html_content_in)\n      insert_part <-\n        iconv(paste(capture.output(tags$div(class = "container st-container",\n                                            res)),\n                    collapse = "\\n"), to = "utf-8")\n      html_content <- paste(capture.output(cat(top_part, insert_part,\n                                               bottom_part)), collapse = "\\n")\n\n    } else {\n\n      if (method %in% c("browser", "viewer")) {\n        html_content <-\n          tags$div(\n            class = "container st-container",\n            tags$head(\n              includeHTML(system.file(\n                package = "summarytools", "includes/favicon.html"\n              )),\n              tags$title(HTML(conv_non_ascii(report.title))),\n              if (collapse)\n                includeScript(system.file(\n                  "includes/scripts/jquery-3.4.0.slim.min.js",\n                  package = "summarytools"\n                )),\n              if (collapse)\n                includeScript(system.file(\n                  "includes/scripts/bootstrap.min.js",\n                  package = "summarytools"\n                )),\n              if (isTRUE(bootstrap.css))\n                includeCSS(system.file(\n                  "includes/stylesheets/bootstrap.min.css",\n                  package = "summarytools"\n                )),\n              includeCSS(system.file(\n                "includes/stylesheets/summarytools.css",\n                package = "summarytools"\n              )),\n              if (!is.na(custom.css))\n                includeCSS(path = custom.css)\n            ),\n            res)\n\n      } else {\n        # method == "render"\n        html_content <-\n          tags$div(\n            class = "container st-container",\n            tags$head(\n              includeCSS(system.file(package = "summarytools",\n                                     "includes/stylesheets/summarytools.css")),\n              if (!is.na(custom.css))\n                includeCSS(path = custom.css)\n            ),\n            res)\n      }\n    }\n\n    if (method == "render") {\n      return(html_content)\n    }\n\n    outfile_path <- ifelse(file == "", paste0(tempfile(),".html"), file)\n    outfile_path <- normalizePath(outfile_path, mustWork = FALSE)\n\n    if (isTRUE(append)) {\n      capture.output(cat(html_content, "\\n"), file = outfile_path)\n    } else {\n      save_html(html = html_content, file = outfile_path)\n    }\n\n    if (method == "viewer") {\n      if (file == "" || isTRUE(open.doc)) {\n        if (.Platform$GUI == "RStudio") {\n          viewer <- getOption("viewer")\n          if (!is.null(viewer)) {\n            viewer(outfile_path)\n          } else {\n            message("To view html content in RStudio, please install ",\n                    "the \'rstudioapi\' package")\n            message("Switching method to \'browser\'")\n            method <- "browser"\n          }\n        } else {\n          message("Switching method to \'browser\'")\n          method <- "browser"\n        }\n      }\n    }\n\n    # For method "browser", we don\'t use utils::browseURL() because of\n    # compatibility issues with RStudio\n    if (method == "browser") {\n      if (file == "" || isTRUE(open.doc)) {\n        switch(.st_env$sysname,\n               Windows = {shell.exec(file = paste0("file:///", outfile_path))},\n               Linux   = {system(paste("/usr/bin/xdg-open", outfile_path),\n                                 wait = FALSE, ignore.stdout = TRUE)},\n               Darwin  = {system(paste("open", outfile_path), wait = FALSE,\n                                 ignore.stderr = TRUE)})\n      }\n    }\n\n    # return file path and update tmpfiles vector when method = browser / viewer\n    if (file == "" && method %in% c("browser", "viewer")) {\n      .st_env$tmpfiles <- c(.st_env$tmpfiles, outfile_path)\n      if (!silent) {\n        message("Output file written: ", outfile_path)\n      }\n      return(invisible(outfile_path))\n    } else if (file != "") {\n      if (!silent) {\n        if (isTRUE(append)) {\n          message("Output file appended: ", outfile_path)\n        } else {\n          message("Output file written: ", outfile_path)\n        }\n      }\n      return(invisible())\n    }\n  }\n}\n\n# Prepare freq objects for printing --------------------------------------------\n#\' @import htmltools\nprint_freq <- function(x, method) {\n\n  data_info   <- attr(x, "data_info")\n  format_info <- attr(x, "format_info")\n  format_args <- attr(x, "format_args")\n  pander_args <- attr(x, "pander_args")\n\n  if (!isTRUE(parent.frame()$silent) && !isTRUE(format_info$group.only) &&\n     (!"by_first" %in% names(data_info) ||\n      isTRUE(as.logical(data_info$by_first))) &&\n     "ignored" %in% names(attributes(x))) {\n    message("Non-categorical variable(s) ignored: ",\n            paste(attr(x, "ignored"), collapse = ", "))\n  }\n\n  if (!isTRUE(format_info$report.nas) && !isTRUE(format_info$cumul)) {\n    # Subtract NA counts from total\n    x[nrow(x), 1] <- x[nrow(x), 1] - x[nrow(x) - 1, 1]\n    # Remove NA row and keep only desired columns\n    x <- x[-(nrow(x) - 1), 1:2]\n    colnames(x) <- c(trs("freq"), trs("pct"))\n\n  } else if (!isTRUE(format_info$report.nas) && isTRUE(format_info$cumul)) {\n    # Subtract NA counts from total\n    x[nrow(x), 1] <- x[nrow(x), 1] - x[nrow(x) - 1, 1]\n    # Remove NA row and keep only desired columns\n    x <- x[-(nrow(x) - 1), 1:3]\n    colnames(x) <- c(trs("freq"), trs("pct"), trs("pct.cum"))\n\n  } else if (isTRUE(format_info$report.nas) && !isTRUE(format_info$cumul)) {\n    x <- x[ ,-c(3,5)]\n    colnames(x) <- c(trs("freq"), trs("pct.valid.f"), trs("pct.total"))\n  }\n\n  if (!isTRUE(format_info$totals)) {\n    x <- x[-nrow(x),]\n  }\n\n  # Use format() on row names when x is numeric\n  if (data_info$Data.type == trs("numeric")) {\n    temp_rownames <- suppressWarnings(as.numeric(rownames(x)))\n    temp_rownames_nas <- which(is.na(temp_rownames))\n\n    # Check if all row names are integers (if so, decimals will be removed)\n    rownames_are_int <- all(as.integer(temp_rownames) == temp_rownames,\n                            na.rm = TRUE)\n\n    if (rownames_are_int) {\n      temp_rownames <- do.call(format, append(format_args,\n                                              list(x = quote(temp_rownames))))\n      temp_rownames <- sub(paste0("^(.+)\\\\", format_info$decimal.mark, \n                                  #  "0+$"),\n                                  "(0(0|\\\\D)*$)"),\n                           "\\\\1", temp_rownames)\n    } else {\n      temp_rownames <- format(rownames(x), justify = format_args$justify)\n    }\n    temp_rownames[temp_rownames_nas] <- rownames(x)[temp_rownames_nas]\n    row.names(x) <- temp_rownames\n  }\n\n  if (method == "pander") {\n\n    # Escape "<" and ">" when used in pairs in rownames\n    if (!isTRUE(pander_args$plain.ascii)) {\n      row.names(x) <- gsub(pattern = "\\\\<(.*)\\\\>",\n                           replacement = "\\\\\\\\<\\\\1\\\\\\\\>",\n                           x = row.names(x), perl = TRUE)\n    }\n\n    # Translate the "(Other)" category (when "rows" was used to filter out\n    # some values\n    rownames(x)[which(rownames(x) == "(Other)")] <- trs("other")\n\n    # set encoding to native to allow proper display of accentuated characters\n    if (parent.frame()$file == "") {\n      row.names(x) <- enc2native(row.names(x))\n      colnames(x)  <- enc2native(colnames(x))\n    }\n\n    main_sect <- build_heading_pander()\n\n    is_na_x   <- is.na(x)\n\n    x <- do.call(format, append(format_args, x = quote(x)))\n\n    if (!"Weights" %in% names(data_info)) {\n      x[ ,1] <- sub(paste0("\\\\", format_info$decimal.mark, "0+$"), "", x[ ,1])\n    }\n\n    x[is_na_x] <- format_info$missing\n\n    main_sect %+=%\n      paste(\n        capture.output(\n          do.call(pander, append(pander_args, list(x = quote(x))))\n        ),\n        collapse = "\\n")\n\n    if (isTRUE(parent.frame()$escape.pipe) && format_info$style == "grid") {\n      main_sect[[length(main_sect)]] <- gsub("\\\\|","\\\\\\\\|",\n                                             main_sect[[length(main_sect)]])\n    }\n\n    return(main_sect)\n\n  } else {\n\n    # print_freq -- html method ------------------------------------------------\n\n    table_head <- list()\n    table_rows <- list()\n\n    for (ro in seq_len(nrow(x))) {\n      table_row <- list()\n      for (co in seq_len(ncol(x))) {\n        cell <- do.call(format, append(format_args, x = quote(x[ro,co])))\n        if (co == 1) {\n          table_row %+=% list(tags$th(trimws(row.names(x)[ro]),\n                                      align = "center",\n                                      class = "st-protect-top-border"))\n\n          if (!"Weights" %in% names(data_info)) {\n            cell <- sub(paste0(format_info$decimal.mark, "0+$"), "", cell)\n          }\n          table_row %+=% list(tags$td(cell, align = format_info$justify))\n          next\n        }\n\n        if (is.na(x[ro,co])) {\n          table_row %+=% list(tags$td(format_info$missing,\n                                      align = format_info$justify))\n        } else {\n          table_row %+=% list(tags$td(cell, align = format_info$justify))\n        }\n\n        if (co == ncol(x)) {\n          table_rows %+=% list(tags$tr(table_row))\n        }\n      }\n    }\n\n    if (isTRUE(format_info$report.nas) && isTRUE(format_info$cumul)) {\n      table_head[[1]] <- list(tags$th("", colspan = 2),\n                              tags$th(HTML(conv_non_ascii(trs("valid"))),\n                                      colspan = 2, align = "center",\n                                      class = "st-protect-top-border"),\n                              tags$th(HTML(conv_non_ascii(trs("total"))),\n                                      colspan = 2, align = "center",\n                                      class = "st-protect-top-border"))\n      table_head[[2]] <- list(tags$th(HTML(conv_non_ascii(\n                                            sub("^.*\\\\$(.+)$", "\\\\1",\n                                            data_info$Variable))),\n                                      align = "center"),\n                              tags$th(HTML(conv_non_ascii(trs("freq"))),\n                                      align = "center"),\n                              tags$th(HTML(conv_non_ascii(trs("pct"))),\n                                      align = "center"),\n                              tags$th(HTML(conv_non_ascii(trs("pct.cum"))),\n                                      align = "center"),\n                              tags$th(HTML(conv_non_ascii(trs("pct"))),\n                                      align = "center"),\n                              tags$th(HTML(conv_non_ascii(trs("pct.cum"))),\n                                      align = "center"))\n\n      freq_table_html <-\n        tags$table(\n          tags$thead(tags$tr(table_head[[1]]),\n                     tags$tr(table_head[[2]])),\n          tags$tbody(table_rows),\n          class = paste(\n            "table table-striped table-bordered",\n            "st-table st-table-striped st-table-bordered st-freq-table",\n            ifelse(is.na(parent.frame()$table.classes),\n                   "", parent.frame()$table.classes)\n          )\n        )\n\n    } else {\n      if (isTRUE(format_info$cumul) && !isTRUE(format_info$report.nas)) {\n\n        # No NA reporting\n        table_head <-\n          list(tags$th(HTML(conv_non_ascii(sub("^.*\\\\$(.+)$", "\\\\1",\n                                               data_info$Variable))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("freq"))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("pct"))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("pct.cum"))),\n                       align = "center",\n                       class = "st-protect-top-border"))\n      } else if (isTRUE(format_info$report.nas) && !isTRUE(format_info$cumul)) {\n\n        # No cumulative proportions\n        table_head <-\n          list(tags$th(HTML(conv_non_ascii(sub("^.*\\\\$(.+)$", "\\\\1",\n                                               data_info$Variable))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("freq"))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("pct.valid.f"))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("pct.total"))),\n                       align = "center",\n                       class = "st-protect-top-border"))\n\n      } else {\n\n        # No cumulative proportions, no NA reporting\n        table_head <-\n          list(tags$th(HTML(conv_non_ascii(sub("^.*\\\\$(.+)$", "\\\\1",\n                                               data_info$Variable))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("freq"))),\n                       align = "center",\n                       class = "st-protect-top-border"),\n               tags$th(HTML(conv_non_ascii(trs("pct")))))\n      }\n\n      freq_table_html <-\n        tags$table(\n          tags$thead(tags$tr(table_head)),\n          tags$tbody(table_rows),\n          class = paste(\n            "table table-striped table-bordered",\n            "st-table st-table-striped st-table-bordered st-freq-table-nomiss",\n            ifelse(is.na(parent.frame()$table.classes),\n                   "", parent.frame()$table.classes)\n          )\n        )\n    }\n\n    # Encapsulate the table in a collapsible div if necessary\n    if (format_info$collapse) {\n      div_id <- paste0(sample(c(letters, LETTERS), size = 1),\n                      paste(sample(c(letters, LETTERS, 0:9), size = 11),\n                            collapse = ""))\n      freq_table_html <- div(freq_table_html,\n                             class = "collapse show",\n                             id    = div_id)\n    } else {\n      div_id <- NA\n    }\n\n    # Cleanup extra spacing and linefeeds in html to correct layout issues\n    freq_table_html <- gsub(pattern = "</span>\\\\s*</span>",\n                            replacement = "</span></span>",\n                            x = freq_table_html,\n                            perl = TRUE)\n\n    # Change visual aspect of "white space" symbol\n    freq_table_html <-\n      gsub(pattern = paste0("(",intToUtf8(183),"+)"),\n           replacement = "&thinsp;<span class=\'st-ws-char\'>\\\\1</span>",\n           x = freq_table_html,\n           perl = TRUE)\n\n    # Prepare the main "div" for the html report\n    div_list <- build_heading_html(format_info, data_info, method, div_id)\n\n    if (length(div_list) > 0 &&\n        !("shiny.tag" %in% class(div_list[[length(div_list)]]))) {\n      div_list %+=% list(HTML(text = "<br/>"))\n    }\n\n    div_list %+=% list(HTML(text = conv_non_ascii(freq_table_html)))\n\n    if (parent.frame()$footnote != "") {\n      footn <- conv_non_ascii(parent.frame()[["footnote"]])\n      div_list %+=% list(HTML(text = paste0("<p>", footn, "</p>")))\n    }\n  }\n\n  return(div_list)\n}\n\n# Prepare ctable objects for printing ------------------------------------------\n#\' @import htmltools\n#\' @keywords internal\nprint_ctable <- function(x, method) {\n\n  data_info   <- attr(x, "data_info")\n  format_info <- attr(x, "format_info")\n  format_args <- attr(x, "format_args")\n  pander_args <- attr(x, "pander_args")\n\n  # Use format() on row names when x is numeric\n  if (data_info$Data.type.x %in% c(trs("numeric"), trs("integer"))) {\n    temp_rownames <- suppressWarnings(as.numeric(rownames(x[[1]])))\n    temp_rownames_nas <- which(is.na(temp_rownames))\n    \n    # Check if all row names are integers (if so, decimals will be removed)\n    rownames_are_int <- all(as.integer(temp_rownames) == temp_rownames,\n                            na.rm = TRUE)\n    \n    if (rownames_are_int) {\n      format_args_tmp <- format_args\n      format_args_tmp$digits <- 1\n      format_args_tmp$nsmall <- 0\n    } else {\n      # Make sure no decimals are lost b/c of format options\n      format_args_tmp <- format_args\n      format_args_tmp$digits <- max(\n        c(1, nchar(sub(".+\\\\.(.*)0*", "\\\\1", temp_rownames))),\n        na.rm = TRUE\n      )\n      format_args_tmp$nsmall <- format_args_tmp$digits\n    }\n    \n    temp_rownames <- do.call(\n      format,\n      append(format_args_tmp, list(x = quote(temp_rownames)))\n    )\n    \n    # Replace non-numeric names by original values\n    temp_rownames[temp_rownames_nas] <- rownames(x[[1]])[temp_rownames_nas]\n    row.names(x[[1]]) <- temp_rownames\n    if (!is.null(x[[2]])) {\n      row.names(x[[2]]) <- temp_rownames\n    }\n  }\n  \n  # Use format() on col names when y is numeric\n  if (data_info$Data.type.y %in% c(trs("numeric"), trs("integer"))) {\n    temp_colnames <- suppressWarnings(as.numeric(colnames(x[[1]])))\n    temp_colnames_nas <- which(is.na(temp_colnames))\n    \n    # Check if all row names are integers (if so, decimals will be removed)\n    colnames_are_int <- all(as.integer(temp_colnames) == temp_colnames,\n                            na.rm = TRUE)\n    \n    if (colnames_are_int) {\n      format_args_tmp <- format_args\n      format_args_tmp$digits <- 1\n      format_args_tmp$nsmall <- 0\n    } else {\n      format_args_tmp <- format_args\n      format_args_tmp$digits <- max(\n        c(1, nchar(sub(".+\\\\.(.*)0*", "\\\\1", temp_rownames))),\n        na.rm = TRUE\n      )\n      format_args_tmp$nsmall <- format_args_tmp$digits\n    }\n    \n    temp_colnames <- do.call(\n      format,\n      append(format_args_tmp, list(x = quote(temp_colnames)))\n    )\n    \n    # Replace non-numeric names with original values    \n    temp_colnames[temp_colnames_nas] <- colnames(x[[1]])[temp_colnames_nas]\n    colnames(x[[1]]) <- temp_colnames\n    if (!is.null(x[[2]])) {\n      colnames(x[[2]]) <- temp_colnames\n    }\n  }\n  \n\n  # align_numbers() ------------------------------------------------------------\n  # Create vertically aligned strings for counts and proportions\n  align_numbers <- function(counts, props) {\n    res <- sapply(seq_len(ncol(counts)), function(colnum) {\n    \n      if ("Weights" %in% names(data_info)) {\n        counts_fmted <- do.call(\n          format, append(format_args, list(x = counts[ ,colnum]))\n          )\n      } else {\n        counts_fmted <- do.call(\n          format, append(format_args[-which(names(format_args) == "nsmall")],\n                         list(x = counts[ ,colnum]))  # use quote? list(x = quote(counts[,colnum]\n        )\n      }      \n      props_fmted  <- do.call(\n        format, \n        append(format_args, list(x = props[ ,colnum] * 100))\n      )\n      \n      return(\n        paste0(\n          pad(counts_fmted, max(nchar(counts_fmted))),\n          " (",\n          pad(props_fmted, max(nchar(props_fmted))),\n          "%)"\n        )\n      )\n    })\n\n    dim(res) <- dim(counts)\n    dimnames(res) <- dimnames(counts)\n\n    return(res)\n  }\n\n  if (!isTRUE(format_info$totals)) {\n    x$cross_table <-\n      x$cross_table[which(rownames(x$cross_table) != trs("total")),\n                    which(colnames(x$cross_table) != trs("total"))]\n    if (data_info$Proportions != "None") {\n      x$proportions <-\n        x$proportions[which(rownames(x$proportions) != trs("total")),\n                      which(colnames(x$proportions) != trs("total"))]\n    }\n  }\n\n  if (data_info$Proportions %in% c("Row", "Column", "Total")) {\n    cross_table <- align_numbers(x$cross_table, x$proportions)\n  } else {\n    cross_table <- x$cross_table\n  }\n\n  # print_ctable -- pander method ----------------------------------------------\n  if (method == "pander") {\n\n    # Escape "<" and ">" when used in pairs in rownames or colnames\n    if (!isTRUE(pander_args$plain.ascii)) {\n      row.names(cross_table) <-\n        gsub(pattern = "\\\\<(.*)\\\\>", replacement = "\\\\\\\\<\\\\1\\\\\\\\>",\n             x = row.names(cross_table), perl = TRUE)\n      colnames(cross_table) <-\n        gsub(pattern = "\\\\<(.*)\\\\>", replacement = "\\\\\\\\<\\\\1\\\\\\\\>",\n             x = colnames(cross_table), perl = TRUE)\n    }\n\n    main_sect <- build_heading_pander()\n\n    main_sect %+=%\n      paste(\n        capture.output(\n          do.call(pander, append(pander_args,\n                                 list(x = quote(ftable(cross_table)))))\n        ),\n        collapse = "\\n")\n\n    if (isTRUE(format_info$headings) && pander_args$style != "grid") {\n      main_sect[[length(main_sect)]] <- sub("^\\n", "\\n\\n",\n                                            main_sect[[length(main_sect)]])\n    }\n\n    if ("chisq" %in% names(attributes(x))) {\n      main_sect %+=% paste(\n        capture.output(\n          pander::pander(\n            c(format(attr(x, "chisq")["Chi.squared"], \n                     decimal.mark = format_args$decimal.mark),\n              format(attr(x, "chisq")["df"]),\n              format(attr(x, "chisq")["p.value"], \n                     decimal.mark = format_args$decimal.mark)\n            )\n          )\n        ),\n        collapse = "\\n"\n      )\n    }\n    \n    if ("OR" %in% names(attributes(x))) {\n      main_sect %+=% paste(\n        capture.output(\n          pander::pander(\n            #do.call(format, append(format_args, list(x = attr(x, "OR"))))\n            format(attr(x, "OR"), digits = 2, nsmall = 2, \n                   decimal.mark = format_args$decimal.mark),\n          )\n        ),\n        collapse = "\\n"\n      )\n    }\n    \n    if ("RR" %in% names(attributes(x))) {\n      main_sect %+=% paste(\n        capture.output(\n          pander::pander(\n            #do.call(format, append(format_args, list(x = attr(x, "RR"))))\n            format(attr(x, "RR"), digits = 2, nsmall = 2,\n                   decimal.mark = format_args$decimal.mark)\n          )\n        ),\n        collapse = "\\n"\n      )\n    }\n\n    if (isTRUE(parent.frame()$escape.pipe) && format_info$style == "grid") {\n      main_sect[[length(main_sect)]] <-\n        gsub("\\\\|","\\\\\\\\|", main_sect[[length(main_sect)]])\n    }\n\n    return(main_sect)\n\n  } else {\n\n    # print_ctable -- html method ----------------------------------------------\n    dnn <- names(dimnames(cross_table))\n\n    table_head <- list()\n    table_rows <- list()\n\n    has_prop <- length(x$proportions) > 0\n\n    table_head[[1]] <-\n      list(tags$th(""),\n           tags$th(\n             dnn[2],\n             colspan = (1 + has_prop*3) *\n               (ncol(cross_table) - as.numeric(isTRUE(format_info$totals))),\n             align = "center", class = "st-protect-top-border"\n             )\n           )\n\n    if (isTRUE(format_info$totals)) {\n      table_head[[1]][[3]] <- tags$th("", colspan = (1 + has_prop*3))\n    }\n\n    table_head[[2]] <- list(tags$td(tags$strong(dnn[1]), align = "center"))\n\n    for (cn in colnames(cross_table)) {\n      flag_split <- FALSE\n      if (nchar(cn) > st_options("char.split")) {\n        flag_split <- TRUE\n      }\n      cn <- sub("<", "&lt;", cn, fixed = TRUE)\n      cn <- sub(">", "&gt;", cn, fixed = TRUE)\n      if (isTRUE(flag_split)) {\n        cn <- smart_split(cn, st_options("char.split"))\n      }\n      table_head[[2]][[length(table_head[[2]]) + 1]] <-\n        tags$th(HTML(conv_non_ascii(cn)),\n                colspan = (1 + has_prop*3), align = "center")\n    }\n\n    table_rows <- list()\n    for (ro in seq_len(nrow(cross_table))) {\n      table_row <- list()\n      for (co in seq_len(ncol(cross_table))) {\n        if (co == 1) {\n\n          rn <- row.names(cross_table)[ro]\n          rn <- sub("<", "&lt;", rn, fixed = TRUE)\n          rn <- sub(">", "&gt;", rn, fixed = TRUE)\n\n          table_row %+=%\n            list(\n              tags$td(\n                tags$strong(\n                  HTML(conv_non_ascii(rn)),\n                  align = "center"\n                  )\n                )\n              )\n        }\n\n        # No proportions\n        if (!isTRUE(has_prop)) {\n          cell <- cross_table[ro,co]\n          table_row %+=% list(tags$td(tags$span(cell)))\n        } else {\n          cell <- gsub(" ", "", cross_table[ro,co])\n          cell <- sub(")$", "", cell)\n          cell <- strsplit(cell, "\\\\(")[[1]]\n\n          table_row %+=% list(\n            tags$td(\n              cell[1],\n              align = "right",\n              style = "padding:0 0 0 15px;border-right:0;text-align:right"\n            )\n          )\n\n          table_row %+=% list(\n            tags$td(\n              "(", align = "left",\n              style = paste0("padding:0 1px 0 4px;border-left:0;",\n                             "border-right:0;text-align:left")\n              )\n            )\n\n          table_row %+=% list(\n            tags$td(\n              HTML(cell[2]),\n              align = "left",\n              style = "padding:0;border-left:0;border-right:0;text-align:right"\n            )\n          )\n\n          table_row %+=% list(\n            tags$td(")",\n                    align = "left",\n                    style = "padding:0 15px 0 1px;border-left:0;text-align:right"\n            )\n          )\n        }\n\n        # On last col, insert row into list\n        if (co == ncol(cross_table)) {\n          table_rows %+=% list(tags$tr(table_row))\n        }\n      }\n    }\n\n    # Build table footer containing stats\n    if (any(c("chisq", "OR", "RR") %in% names(attributes(x)))) {\n\n      stats_str <- ""\n\n      if ("chisq" %in% names(attributes(x))) {\n        chisq <- attr(x, "chisq")\n        stats_str <- paste0(\n          stats_str,\n          "<em><strong>&nbsp;&#935;<sup>2</sup></strong> = ",\n          sub("\\\\.", format_args$decimal.mark, sprintf("%.4f", chisq[[1]])),\n          "&nbsp;&nbsp;&nbsp;<strong>df</strong> = ", chisq[[2]],\n          "&nbsp;&nbsp;&nbsp;<strong>p</strong> = ",\n          sub("^0\\\\.", format_args$decimal.mark,\n          sprintf("%.4f", chisq[[3]])), "</em><br/>"\n        )\n      }\n\n      if ("OR" %in% names(attributes(x))) {\n        OR <- attr(x, "OR")\n        stats_str <- paste0(\n          stats_str,\n          "<em><strong>O.R. </strong>(", \n          attr(x, "OR-level")*100, "% C.I.) = <strong>",\n          format(OR[[1]], digits = 2, nsmall = 2,\n                 decimal.mark = format_args$decimal.mark), \n          "</strong>&nbsp;&nbsp;(",\n          format(OR[[2]], digits = 2, nsmall = 2,\n                 decimal.mark = format_args$decimal.mark),\n          " - ",\n          format(OR[[3]], digits = 2, nsmall = 2,\n                 decimal.mark = format_args$decimal.mark),\n          ")</em><br/>\n        ")\n      }\n\n      if ("RR" %in% names(attributes(x))) {\n        RR <- attr(x, "RR")\n        stats_str <- paste0(\n          stats_str,\n          "<em><strong>R.R. </strong>(",\n          attr(x, "RR-level")*100, "% C.I.) = <strong>",\n          format(RR[[1]], digits = 2, nsmall = 2, \n                 decimal.mark = format_args$decimal.mark), \n          "</strong>&nbsp;&nbsp;(",\n          format(RR[[2]], digits = 2, nsmall = 2,\n                 decimal.mark = format_args$decimal.mark), \n          " - ",\n          format(RR[[3]], digits = 2, nsmall = 2,\n                 decimal.mark = format_args$decimal.mark), \n          ")</em>")\n      }\n    }\n\n    cross_table_html <-\n      tags$table(\n        tags$thead(\n          tags$tr(table_head[[1]]),\n          tags$tr(table_head[[2]])\n        ),\n        tags$tbody(\n          table_rows\n        ),\n        if (exists("stats_str"))\n          tags$tfoot(tags$tr(tags$td(HTML(stats_str), colspan = 100))),\n        class = paste(\n          "table table-bordered st-table st-table-bordered st-cross-table",\n          ifelse(is.na(parent.frame()$table.classes), "",\n                 parent.frame()$table.classes)\n        )\n      )\n\n    div_list <- build_heading_html(format_info, data_info, method)\n\n    if (length(div_list) > 0 &&\n        !("shiny.tag" %in% class(div_list[[length(div_list)]]))) {\n      div_list %+=% list(HTML(text = "<br/>"))\n    }\n\n    div_list %+=% list(cross_table_html)\n\n    if (parent.frame()$footnote != "") {\n      footn <- conv_non_ascii(parent.frame()[["footnote"]])\n      div_list %+=% list(HTML(text = paste0("<p>", footn, "</p>")))\n    }\n  }\n\n  return(div_list)\n}\n\n# Prepare descr objects for printing -------------------------------------------\n#\' @import htmltools\n#\' @keywords internal\nprint_descr <- function(x, method) {\n\n  data_info   <- attr(x, "data_info")\n  format_info <- attr(x, "format_info")\n  format_args <- attr(x, "format_args")\n  pander_args <- attr(x, "pander_args")\n\n  # determine whether to display message re: ignored variables\n  display_msg <- FALSE\n  if ("ignored" %in% names(attributes(x)) &&\n      (("by_first" %in% names(data_info) && isTRUE(data_info$by_first)) ||\n       !"by_first" %in% names(data_info))) {\n    if ("silent" %in% names(parent.frame())) {\n      if (!isTRUE(parent.frame()$silent)) {\n        display_msg <- TRUE\n      }\n    } else {\n      if (!isTRUE(st_options("descr.silent"))) {\n        display_msg <- TRUE\n      }\n    }\n  }\n  \n  if (display_msg) {\n    message("Non-numerical variable(s) ignored: ",\n            paste(attr(x, "ignored"), collapse = ", "))\n  }\n\n  if (method == "pander") {\n\n    # print_descr -- pander method ---------------------------------------------\n\n    # set encoding to native to allow proper display of accentuated characters\n    if (parent.frame()$file == "") {\n      row.names(x) <- enc2native(row.names(x))\n      if (!is.null(colnames(x)))\n        colnames(x)  <- enc2native(colnames(x))\n    }\n\n    main_sect <- build_heading_pander()\n\n    x <- round(x, format_info$digits)\n    x <- do.call(format, append(format_args, list(x = quote(x))))\n\n    #if (!"Weights" %in% names(data_info)) {\n    #  row_ind <- which(trs("n.valid") == rownames(x))\n    #  x[row_ind, ] <- sub("\\\\.0+", "", x[row_ind, ])\n    #}\n\n    main_sect %+=%\n      paste(\n        capture.output(\n          do.call(pander, append(pander_args, list(x = quote(x))))\n        ),\n        collapse = "\\n")\n\n\n    if (isTRUE(parent.frame()$escape.pipe) && format_info$style == "grid") {\n      main_sect[[length(main_sect)]] <-\n        gsub("\\\\|","\\\\\\\\|", main_sect[[length(main_sect)]])\n    }\n\n    return(main_sect)\n\n  } else {\n    # print_descr -- html method -----------------------------------------------\n    x <- round(x, format_info$digits)\n\n    table_head <- list(tags$th(""))\n\n    for (cn in colnames(x)) {\n      if (nchar(cn) > st_options("char.split")) {\n        cn <- smart_split(cn, st_options("char.split"))\n      }\n      table_head %+=% list(tags$th(HTML(cn), align = "center",\n                                   class = "st-protect-top-border"))\n    }\n\n    table_rows <- list()\n    for (ro in seq_len(nrow(x))) {\n      table_row <- list(tags$td(tags$strong(rownames(x)[ro])))\n      for (co in seq_len(ncol(x))) {\n        # cell is NA\n        if (is.na(x[ro,co])) {\n          table_row %+=% list(tags$td(format_info$missing))\n        } else {\n          # When not NA format cell content\n          cell <- do.call(format, append(format_args, x = quote(x[ro,co])))\n          if ((rownames(x)[ro] == trs("n.valid") ||\n               colnames(x)[co] == trs("n.valid")) &&\n              !"Weights" %in% names(data_info)) {\n            cell <- sub(paste0(format_info$decimal.mark, "0+$"), "", cell)\n          }\n          table_row %+=% list(tags$td(tags$span(cell)))\n        }\n        # On last column, insert row to table_rows list\n        if (co == ncol(x)) {\n          table_rows %+=% list(tags$tr(table_row))\n        }\n      }\n    }\n\n    descr_table_html <-\n      tags$table(\n        tags$thead(tags$tr(table_head)),\n        tags$tbody(table_rows),\n        class = paste(\n          "table table-bordered table-striped",\n          "st-table st-table-bordered st-table-striped st-descr-table",\n          ifelse(is.na(parent.frame()$table.classes), "",\n                 parent.frame()$table.classes))\n      )\n\n    # Cleanup some extra spacing & html linefeeds to avoid weirdness in layout\n    # of source code\n    descr_table_html <- as.character(descr_table_html)\n    descr_table_html <- gsub(pattern = "\\\\s*(\\\\-?\\\\d*)\\\\s*(<span|</td>)",\n                             replacement = "\\\\1\\\\2", x = descr_table_html,\n                             perl = TRUE)\n    descr_table_html <- gsub(pattern = "</span>\\\\s*</span>",\n                             replacement = "</span></span>",\n                             x = descr_table_html,\n                             perl = TRUE)\n    descr_table_html <- gsub(pattern = "<strong>\\\\s*</strong>",\n                             replacement = "",\n                             x = descr_table_html,\n                             perl = TRUE)\n    descr_table_html <- gsub(pattern = \'(<td align="right">)\\\\s+(<)\',\n                             replacement = "\\\\1\\\\2",\n                             x = descr_table_html,\n                             perl = TRUE)\n    descr_table_html <- conv_non_ascii(descr_table_html)\n\n    # Prepare the main "div" for the html report\n    div_list <- build_heading_html(format_info, data_info, method)\n    if (length(div_list) > 0 &&\n        !("shiny.tag" %in% class(div_list[[length(div_list)]]))) {\n      div_list %+=% list(HTML(text = "<br/>"))\n    }\n\n    div_list %+=% list(HTML(text = descr_table_html))\n\n    if (parent.frame()$footnote != "") {\n      footn <- conv_non_ascii(parent.frame()[["footnote"]])\n      div_list %+=% list(HTML(text = paste0("<p>", footn, "</p>")))\n    }\n  }\n\n  return(div_list)\n}\n\n# Prepare dfSummary objects for printing ---------------------------------------\n#\' @import htmltools\n#\' @keywords internal\nprint_dfs <- function(x, method) {\n\n  data_info   <- attr(x, "data_info")\n  format_info <- attr(x, "format_info")\n  format_args <- attr(x, "format_args")\n  pander_args <- attr(x, "pander_args")\n\n  if (!isTRUE(parent.frame()$silent) &&\n      "png_message" %in% names(attributes(x)) &&\n      method != "render" &&\n      !isTRUE(format_info$group.only) &&\n      (!"by_first" %in% names(data_info) ||\n       isTRUE(as.logical(data_info$by_first)))) {\n    message("text graphs are displayed; set \'tmp.img.dir\' ",\n            "parameter to activate png graphs")\n  }\n\n  # make_vals_cell -------------------------------------------------------------\n  # Function to split lines of the values cell into table rows and return\n  # the table which will become the td (cell content). By doing this, we make\n  # sure its content is well aligned with the freqs cell since it has the same\n  # number of rows. If we don\'t do this, free text with line breaks will\n  # sometimes use more or less vertical space than a table with the same\n  # number of rows as it has line breaks.\n  make_vals_cell <- function(cell) {\n  \n    if (!grepl("\\\\n", cell)) {\n      return(HTML(paste0(\'<td align="left">\', cell, \'</td>\')))\n    }\n    \n    rows <- strsplit(cell, "\\\\n")[[1]]\n    rows <- gsub("\\\\\\\\$", "", rows)\n    \n    # replace the "<" in "min < med < max:" line for the lte (<=) html code \n    mmmstr <- tolower(paste0("^", trs("min"), " < ", \n                             trs("med.short"), " < ",\n                             trs("max"), ":$"))\n    if (any(grepl(mmmstr, rows)) && grep(mmmstr, rows) == 2) {\n      rows[2] <- gsub("<", "&le;", rows[2])\n      rows[3] <- gsub("<", "&le;", rows[3]) # alternative to &le; is &#8828;\n    }\n\n    cell <- \n      paste0(\n        paste0(\n          \'<tr style="background-color:transparent">\',\n          \'<td style="padding:0;margin:0;border:0" align="left">\'\n        ), #padding:0 5px 0 7px\n        rows,\n        \'</td></tr>\',\n        collapse = "")\n\n    return(HTML(\n      paste0(\'<td align="left" style="padding:8;vertical-align:middle">\',\n             \'<table style="border-collapse:collapse;border:none;margin:0">\',\n             cell, \'</table></td>\')\n    ))\n  }\n  \n  # make_freq_cell -------------------------------------------------------------\n  # Function to align the freqs / proportions in html outputs\n  # A table is built to fit in a single cell in the final table\n  make_freq_cell <- function(cell) {\n\n    if (identical(cell, conv_non_ascii(trs("all.nas")))) {\n      return(HTML(paste0(\'<td align="left">\', cell, \'</td>\')))\n    }\n\n    rows <- strsplit(cell, "\\\\\\n")[[1]]\n    rows <- gsub("\\\\", "", rows, fixed = TRUE)\n    rows <- gsub(" " , "", rows, fixed = TRUE)\n    rows <- gsub(")$", "", rows)\n    rows <- strsplit(rows, "[(:]")\n\n    if (grepl(":", cell)) {\n      # notice for rounded values\n      notice <- NA\n      if (length(rows[[length(rows)]]) == 1) {\n        notice <- sub("!", "!&thinsp;", rows[[length(rows)]])\n        length(rows) <- length(rows) - 1\n      }\n\n      vals <- vapply(X = rows, FUN = `[`,  FUN.VALUE = " ", 1)\n      cnts <- vapply(X = rows, FUN = `[`,  FUN.VALUE = " ", 2)\n      prps <- vapply(X = rows, FUN = `[`,  FUN.VALUE = " ", 3)\n\n      if (!is.na(notice)) {\n        vals <- sub("!", "&thinsp;!", vals)\n        vals <- sub("(\\\\d)$", "\\\\1&thinsp;&thinsp;", vals)\n      }\n\n      cell <-\n        paste0(\n          paste0(\n            \'<tr style="background-color:transparent">\',\n            \'<td style="padding:0 2px 0 7px;margin:0;border:0" align="right">\'\n          ),\n          vals,\n          paste0(\n            \'</td><td style="padding:0 2px;border:0;" align="left">:</td>\',\n            \'<td style="padding:0 4px 0 6px;margin:0;border:0" align="right">\'\n          ),\n          cnts,\n          paste0(\n            \'</td><td style="padding:0;border:0" align="left">(</td>\',\n            \'<td style="padding:0 2px;margin:0;border:0" align="right">\'\n          ),\n          prps,\n          paste0(\'</td><td style="padding:0 4px 0 0;border:0" align="left">)\',\n                 \'</td></tr>\'\n          ),\n          collapse = ""\n        )\n\n      if (!is.na(notice)) {\n        cell <-\n          paste0(cell, \'<tr style="background-color:transparent">\',\n                 \'<td style="padding:0 0 0 7px;border:0;margin:0" colspan="5">\',\n                 notice, "</td></tr>", collapse = "")\n      }\n    } else {\n\n      cnts <- vapply(X = rows, FUN = `[`, FUN.VALUE = " ", 1)\n      prps <- vapply(X = rows, FUN = `[`, FUN.VALUE = " ", 2)\n\n      cell <-\n        paste0(\n          paste0(\n            \'<tr style="background-color:transparent">\',\n            \'<td style="padding:0 5px 0 7px;margin:0;border:0" align="right">\'\n          ),\n          cnts,\n          paste0(\n            \'</td><td style="padding:0 2px 0 0;border:0;" align="left">(</td>\',\n            \'<td style="padding:0;border:0" align="right">\'\n          ),\n          prps,\n          \'</td><td style="padding:0 4px 0 2px;border:0" align="left">)</td></tr>\',\n          collapse = ""\n        )\n    }\n\n    return(\n      HTML(\n        paste0(\n          \'<td align="left" style="padding:0;vertical-align:middle">\',\n          \'<table style="border-collapse:collapse;border:none;margin:0">\',\n          cell, \'</table></td>\'\n          )\n        )\n      )\n  }\n\n  # Remove Var number ("No") column if specified in call to print/view\n  if (trs("no") %in% names(x) &&\n      "varnumbers" %in% names(format_info) &&\n      !isTRUE(format_info$varnumbers)) {\n    x <- x[ ,-which(names(x) == trs("no"))]\n  }\n\n  # Remove Label column if specified in call to print/view\n  if (trs("label") %in% names(x) &&\n      "labels.col" %in% names(format_info) &&\n      !isTRUE(format_info$labels.col)) {\n    x <- x[ ,-which(names(x) == trs("label"))]\n  }\n\n  # Remove Valid column if specified in call to print/view\n  if (trs("valid") %in% names(x) &&\n      "valid.col" %in% names(format_info) &&\n      !isTRUE(format_info$valid.col)) {\n    x <- x[ ,-which(names(x) == trs("valid"))]\n  }\n\n  # Remove Missing column if specified in call to print/view\n  if (trs("missing") %in% names(x) &&\n      "na.col" %in% names(format_info) &&\n      !isTRUE(format_info$na.col)) {\n    x <- x[ ,-which(names(x) == trs("missing"))]\n  }\n  \n  # Remove grouping variable rows when appropriate\n  if ("keep.grp.vars" %in% names(format_info) &&\n      !isTRUE(format_info$keep.grp.vars) &&\n      "by_var" %in% names(data_info)) {\n    x <- x[-grep(paste0("\\\\b", data_info$by_var, "\\\\b", collapse = "|"), \n                 x[[trs("variable")]]),]\n    row.names(x) <- NULL\n  }\n\n  # print_dfSummary - pander method --------------------------------------------\n  if (method == "pander") {\n\n    # remove html graphs\n    if (trs("graph") %in% names(x)) {\n      x <- x[ ,-which(names(x) == trs("graph"))]\n    }\n\n    # Remove graph if specified in call to print/view\n    if ("text.graph" %in% names(x) && "graph.col" %in% names(format_info) &&\n        !isTRUE(format_info$graph.col)) {\n      x <- x[ ,-which(names(x) == "text.graph")]\n    } else {\n      colnames(x)[which(names(x) == "text.graph")] <- trs("graph")\n    }\n\n    # Check that style is not "simple" or "rmarkdown"\n    if (isTRUE(pander_args$style %in% c("simple", "rmarkdown"))) {\n      pander_args$style <- "multiline"\n    }\n\n    if (!isTRUE(pander_args$plain.ascii)) {\n      # Escape symbols for words between <>\'s to allow <NA> or factor\n      # levels such as <ABC> to be rendered correctly\n      if (trs("label") %in% names(x)) {\n        x[[trs("label")]] <-\n          gsub(pattern = "\\\\<(\\\\w*)\\\\>", replacement = "\\\\\\\\<\\\\1\\\\\\\\>",\n               x = x[[trs("label")]], perl = TRUE)\n      }\n\n      x[[trs("stats.values")]] <-\n        gsub(pattern = "\\\\<(\\\\w*)\\\\>", replacement = "\\\\\\\\<\\\\1\\\\\\\\>",\n             x = x[[trs("stats.values")]], perl = TRUE)\n\n      x[[trs("freqs.pct.valid")]] <-\n        gsub(pattern = "\\\\<(\\\\w*)\\\\>", replacement = "\\\\\\\\<\\\\1\\\\\\\\>",\n             x = x[[trs("freqs.pct.valid")]], perl = TRUE)\n\n\n      # Remove leading characters used for alignment in plain.ascii\n      x[[trs("freqs.pct.valid")]] <-\n        gsub(pattern = "^\\\\\\\\ *", replacement = "",\n             x = x[[trs("freqs.pct.valid")]], perl = TRUE)\n\n      x[[trs("freqs.pct.valid")]] <-\n        gsub(pattern = "\\\\n\\\\\\\\ *", replacement = "\\n",\n             x = x[[trs("freqs.pct.valid")]], perl = TRUE)\n    }\n\n    # set column names encoding to native to allow proper display of non-ascii\n    if (parent.frame()$file == "") {\n      colnames(x) <- enc2native(colnames(x))\n    }\n\n    main_sect <- build_heading_pander()\n\n    main_sect %+=%\n      paste(\n        capture.output(\n          do.call(pander, append(pander_args, list(x = quote(x))))\n        ),\n        collapse = "\\n")\n\n    if (isTRUE(parent.frame()$escape.pipe) && format_info$style == "grid") {\n      main_sect[[length(main_sect)]] <-\n        gsub("\\\\|","\\\\\\\\|", main_sect[[length(main_sect)]])\n    }\n\n    return(main_sect)\n\n  } else {\n\n    # print_dfs - html method --------------------------------------------------\n\n    # remove text graph\n    if ("text.graph" %in% names(x)) {\n      x <- x[ ,-which(names(x) == "text.graph")]\n    }\n\n    # Remove graph if specified in call to print/view\n    # or if use.x11 set to FALSE\n    if (trs("graph") %in% names(x) &&\n        ("graph.col" %in% names(format_info) &&\n        !isTRUE(format_info$graph.col)) ||\n        isFALSE(st_options("use.x11"))) {\n      x <- x[ ,-which(names(x) == trs("graph"))]\n    }\n\n    table_head <- list()\n    for (cn in colnames(x)) {\n      table_head %+=% list(tags$th(tags$strong(HTML(conv_non_ascii(cn))),\n                                   align = "center",\n                                   class = "st-protect-top-border"))\n    }\n\n    colgroup <- NA\n    if ("col.widths" %in% names(format_info)) {\n      if (length(format_info$col.widths) != ncol(x)) {\n        stop("Number of elements in \'col.widths\', (",\n             (length(format_info$col.widths)), ") is not equal to number of ",\n             "columns to display (", ncol(x), ")")\n      }\n      colgroup <- tags$colgroup()\n      if (is.numeric(format_info$col.widths)) {\n        for (i in format_info$col.widths) {\n          colgroup <- tagAppendChild(\n            colgroup, tags$col(style = paste0("width:", i, "px"))\n          )\n        }\n      } else {\n        for (i in format_info$col.widths) {\n          colgroup <- tagAppendChild(\n            colgroup, tags$col(style = paste("width", i, sep = ":"))\n          )\n        }\n      }\n    }\n\n    table_rows <- list()\n    for (ro in seq_len(nrow(x))) {\n      table_row <- list()\n      for (co in seq_len(ncol(x))) {\n        cell <- x[ro,co]\n        cell <- gsub("\\\\\\\\\\n", "\\n", cell)\n        if (colnames(x)[co] %in% c(trs("no"), trs("valid"), trs("missing"))) {\n          table_row %+=% list(tags$td(HTML(conv_non_ascii(cell)),\n                                      align = "center"))\n        } else if (colnames(x)[co] == trs("label")) {\n          cell <- gsub("(\\\\d+)\\\\\\\\\\\\.", "\\\\1.", cell)\n          cell <- paste(strwrap(cell, width = format_info$split.cells,\n                                simplify = TRUE), collapse = "\\n")\n          table_row %+=% list(\n            tags$td(HTML(conv_non_ascii(cell)), align = "left")\n          )\n        } else if (colnames(x)[co] == trs("variable")){\n          cell <- gsub("[ \\t]{2,}", " ", cell)\n          table_row %+=% list(\n            tags$td(HTML(conv_non_ascii(cell)), align = "left")\n          )\n        } else if (colnames(x)[co] == trs("stats.values")) {\n          cell <- gsub("(\\\\d+)\\\\\\\\\\\\.", "\\\\1.", cell)\n          table_row %+=% list(make_vals_cell(conv_non_ascii(cell)))\n        }  else if (colnames(x)[co] == trs("freqs.pct.valid")) {\n          if (grepl(paste0("(",trs("distinct.value"), "|",\n                           trs("distinct.values"), ")"), cell) || cell == "") {\n            table_row %+=% list(\n              tags$td(HTML(conv_non_ascii(cell)), align = "left",\n                      style = "vertical-align:middle")\n            )\n          } else {\n            table_row %+=% list(make_freq_cell(conv_non_ascii(cell)))\n          }\n        } else if (colnames(x)[co] == trs("graph")) {\n          table_row %+=% list(\n            tags$td(HTML(cell), align = "left",\n                    style = paste0("vertical-align:middle;padding:0;",\n                                   "background-color:transparent;"))\n          )\n        }\n      }\n      table_rows %+=% list(tags$tr(table_row))\n    }\n\n    if (is.infinite(format_info$max.tbl.height)) {\n      dfs_table_html <-\n        tags$table(\n          if (!identical(colgroup, NA))\n            colgroup,\n          tags$thead(tags$tr(table_head)),\n          tags$tbody(table_rows),\n          class = paste(\n            "table table-striped table-bordered",\n            "st-table st-table-striped st-table-bordered st-multiline",\n            ifelse(is.na(parent.frame()$table.classes),\n                   "", parent.frame()$table.classes)\n          )\n        )\n    } else {\n      dfs_table_html <-\n        tags$div(\n          tags$table(\n            if (!identical(colgroup, NA))\n              colgroup,\n            tags$thead(tags$tr(table_head)),\n            tags$tbody(table_rows),\n            class = paste(\n              "table table-striped table-bordered",\n              "st-table st-table-striped st-table-bordered st-multiline",\n              ifelse(is.na(parent.frame()$table.classes),\n                     "", parent.frame()$table.classes)\n            )\n          ), style = paste0("max-height:", format_info$max.tbl.height,\n                            "px;overflow-y:scroll;margin:10px 2px")\n        )\n    }\n\n    # cleanup source html for redundant space\n    dfs_table_html <-\n      gsub(pattern = "(<th.*?>)\\\\s+(<strong>.*?</strong>)\\\\s+(</th>)",\n           replacement = "\\\\1\\\\2\\\\3",\n           x = dfs_table_html)\n\n    # Change visual aspect of "white space" symbol\n    dfs_table_html <-\n      gsub(pattern = "((&#0183;)+)",\n           replacement = "&thinsp;<div class=\'st-ws-char\'>\\\\1</div>",\n           x = dfs_table_html,\n           perl = TRUE)\n\n\n    # Prepare the main "div" for the html report\n    div_list <- build_heading_html(format_info, data_info, method)\n\n    if (length(div_list) > 0 &&\n        !("shiny.tag" %in% class(div_list[[length(div_list)]]))) {\n      div_list %+=% list(HTML(text = "<br/>"))\n    }\n\n    div_list %+=% list(HTML(text = dfs_table_html))\n\n    if (parent.frame()$footnote != "") {\n      footn <- conv_non_ascii(parent.frame()[["footnote"]])\n      div_list %+=% list(HTML(text = paste0("<p>", footn, "</p>")))\n    }\n  }\n\n  return(div_list)\n}\n\n\n# Build headings (pander) ------------------------------------------------------\n#\' @keywords internal\nbuild_heading_pander <- function() {\n\n  format_info <- parent.frame()$format_info\n  data_info   <- parent.frame()$data_info\n\n  caller <- as.character(sys.call(-1))[1]\n  head1  <- NA # Main title (e.g. "Data Frame Summary")\n  head2  <- NA # The data frame, the variable, or the 2 variables for ctable\n  head3  <- NA # Additional elements (includes Variable exceptionnaly when\n               # headings = FALSE and by() or lapply() were used\n\n  add_markup <- function(str, h = 0) {\n    if (!isTRUE(format_info$plain.ascii)) {\n      if (h == 0) {\n        re <- paste0("^(\\\\s*\\\\n)(.+)\\\\s", trs("by"), "\\\\s(.+)$")\n        if (grepl(re, str, perl = TRUE)) {\n          str <- sub(re, paste0("\\\\1**", "\\\\2** ", trs("by"), " **\\\\3**"),\n                     str, perl = TRUE)\n        } else {\n          str <- sub(pattern = "^(\\\\s*)(.+?)((:)\\\\s(.+))?\\\\s*$",\n                     replacement = "\\\\1**\\\\2\\\\4** \\\\5",\n                     x = str, perl = TRUE)\n        }\n      } else {\n        str <- paste(paste0(rep(x = "#", times = h), collapse = ""), str)\n      }\n    }\n    return(str)\n  }\n\n  append_items <- function(items, h = 0) {\n    appended <- c()\n    for (item in items) {\n      if (names(item) %in% names(data_info)) {\n        if ((grepl(pattern = "label", names(item)) &&\n             isTRUE(format_info$display.labels)) ||\n            (names(item) == "Data.type" &&\n             isTRUE(format_info$display.type)) ||\n            !grepl("(label|Data\\\\.type)", names(item))) {\n\n          # Apply formatting to numeric values\n          value <- data_info[[names(item)]]\n          tmpargs <- c("big.mark", "small.mark", "decimal.mark",\n                       "small.interval", "big.interval")\n          if (isTRUE(is.numeric(value)) && \n              any(names(format_info) %in% tmpargs)) {\n            value <- do.call(\n              format, \n              append(format_info[which(names(format_info) %in% tmpargs)],\n                     x = quote(value))\n              )\n\n            if (names(item) == "Dimensions") {\n              value <- paste(trimws(value[1]), trimws(value[2]), sep = " x ")\n            }\n          }\n\n          # Create pairing (example: "N: 500") when both name and value exist\n          # and add markup characters\n          if (item != "") {\n            appended <- append(\n              appended,\n              paste0(add_markup(paste(item, value, sep = ": "), h),\n                     "  \\n")\n            )\n          } else {\n            appended <- append(appended, paste0(add_markup(value, h), "  \\n"))\n          }\n        }\n      }\n    }\n    return(paste(appended, collapse = ""))\n  }\n\n  # Special cases where no primary heading (title) is needed\n  if (isTRUE(format_info$var.only)) {\n    \n    head2 <- append_items(\n      list(c(Variable = "")),\n      h = ifelse(isTRUE(st_options(\'subtitle.emphasis\')), 4, 0)\n    )\n    head2 <- paste0("\\n", enc2native(head2))\n\n    if (isTRUE(format_info$headings)) {\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Data.type      = trs("type")),\n                                 c(N.obs          = trs("n"))))\n    }\n\n    if (!is.na(head3)) {\n      head3 <- enc2native(head3)\n    }\n\n    tmp <- list(head2, head3)\n    return(tmp[which(!is.na(tmp))])\n\n  } else if (isTRUE(format_info$group.only)) {\n    \n    if (isTRUE(format_info$headings)) {\n      head3 <- append_items(list(c(Group = trs("group")),\n                                 c(N.Obs = trs("n")),\n                                 c(Dimensions = trs("dimensions")),\n                                 c(Duplicates = trs("duplicates"))))\n    } else {\n      head3 <- append_items(list(c(Group = trs("group"))))\n    }\n\n    head3[[1]] <- paste0("\\n", enc2native(head3[[1]]))\n    return(list(head3))\n\n  } else if (!isTRUE(format_info$headings)) {\n    \n    if ("var.only" %in% names(format_info)) {\n      head2 <- append_items(\n        list(c(Variable = "")),\n        h = ifelse(isTRUE(st_options(\'subtitle.emphasis\')), 4, 0))\n      return(list(enc2native(head2)))\n    } else if ("Group" %in% names(data_info)) {\n      head3 <- append_items(list(c(Group = trs("group"))))\n      return(list(enc2native(head3)))\n    } else {\n      return(list())\n    }\n  }\n  # (End special cases)\n\n  # Regular cases - Build the 3 heading elementss\n  if (caller == "print_freq") {\n\n    if ("Weights" %in% names(data_info)) {\n      if (trs("title.freq.weighted") == "") {\n        head1 <- NA\n      } else {\n        head1 <- paste(add_markup(trs("title.freq.weighted"), h = 3), " \\n")\n      }\n    } else {\n      if (trs("title.freq") == "") {\n        head1 <- NA\n      } else {\n        head1 <- paste(add_markup(trs("title.freq"), h = 3), " \\n")\n      }\n    }\n    \n    if ("Variable" %in% names(data_info)) {\n      head2 <- append_items(\n        list(c(Variable = "")),\n        h = ifelse(isTRUE(st_options("subtitle.emphasis")), 4, 0)\n      )\n\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Data.type      = trs("type")),\n                                 c(Weights        = trs("weights")),\n                                 c(Group          = trs("group"))))\n\n    }\n\n  } else if (caller == "print_ctable") {\n    \n    head1 <- paste(\n      add_markup(\n        switch(data_info$Proportions,\n               Row    = paste(trs("title.ctable"), trs("title.ctable.row"),\n                              sep = ", "),\n               Column = paste(trs("title.ctable"), trs("title.ctable.col"),\n                              sep = ", "),\n               Total  = paste(trs("title.ctable"), trs("title.ctable.tot"),\n                              sep = ", "),\n               None   = trs("title.ctable")),\n        h = 3),\n      " \\n")\n    \n    if (grepl("^#*\\\\s*,", head1))\n      head1 <- NA\n    \n    head2 <- append_items(\n      list(c(Row.x.Col = "")),\n      h = ifelse(isTRUE(st_options("subtitle.emphasis")), 4, 0)\n    )\n    head3 <- append_items(list(c(Data.frame       = trs("data.frame")),\n                               c(Data.frame.label = trs("label")),\n                               c(Group            = trs("group"))))\n\n  } else if (caller == "print_descr") {\n    \n    if ("Weights" %in% names(data_info)) {\n      if (trs("title.descr.weighted") == "") {\n        head1 <- NA\n      } else {\n        head1 <- paste(add_markup(trs("title.descr.weighted"), h = 3), " \\n")\n      }\n    } else {\n      if (trs("title.freq") == "") {\n        head1 <- NA\n      } else {\n        head1 <- paste(add_markup(trs("title.descr"), h = 3), " \\n")\n      }\n    }\n    \n    if ("by_var_special" %in% names(data_info)) {\n      head2 <- paste(\n        add_markup(\n          paste(data_info$Variable, trs("by"), data_info$by_var_special),\n          h = ifelse(isTRUE(st_options("subtitle.emphasis")), 4, 0)),\n        " \\n")\n      head3 <- append_items(list(c(Data.frame     = trs("data.frame")),\n                                 c(Variable.label = trs("label")),\n                                 c(Weights        = trs("weights")),\n                                 c(Group          = trs("group")),\n                                 c(N.Obs          = trs("n"))))\n\n    } else if ("Variable" %in% names(data_info)) {\n      head2 <- append_items(\n        list(c(Variable = "")),\n        h = ifelse(isTRUE(st_options("subtitle.emphasis")), 4, 0)\n      )\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Weights        = trs("weights")),\n                                 c(Group          = trs("group")),\n                                 c(N.Obs          = trs("n"))))\n\n    } else if ("Data.frame" %in% names(data_info)) {\n      head2 <- append_items(\n        list(c(Data.frame = "")),\n        h = ifelse(isTRUE(st_options("subtitle.emphasis")), 4, 0)\n      )\n      head3 <- append_items(list(c(Data.frame.label = trs("label")),\n                                 c(Weights          = trs("weights")),\n                                 c(Group            = trs("group")),\n                                 c(N.Obs            = trs("n"))))\n\n    }\n    \n  } else if (caller == "print_dfs") {\n    \n    head1 <- paste(add_markup(trs("title.dfSummary"), h = 3), " \\n")\n    if ("Data.frame" %in% names(data_info)) {\n      head2 <- append_items(\n        list(c(Data.frame = "")),\n        h = ifelse(isTRUE(st_options("subtitle.emphasis")), 4, 0)\n      )\n    }\n    head3 <- append_items(list(c(Data.frame.label = trs("label")),\n                               c(Group            = trs("group")),\n                               c(Dimensions       = trs("dimensions")),\n                               c(Duplicates       = trs("duplicates"))))\n  }\n\n  if (!is.na(head1) &&\n      length(setdiff(unique(strsplit(head1, "")[[1]]), c(" ", "\\r", "\\n")))) {\n    head1 <- enc2native(head1)\n  } else {\n    head1 <- NA\n  }\n  \n  if (!is.na(head2) &&\n      length(setdiff(unique(strsplit(head2, "")[[1]]), c(" ", "\\r", "\\n")))) {\n    head2 <- enc2native(head2)\n  } else {\n    head2 <- NA\n  }\n  \n  if (!is.na(head3) &&\n      length(setdiff(unique(strsplit(head3, "")[[1]]), c(" ", "\\r", "\\n")))) {\n    head3 <- enc2native(head3)\n  } else {\n    head3 <- NA\n  }\n\n  tmp <- list(head1, head2, head3)\n  return(tmp[which(!is.na(tmp))])\n}\n\n# Build headings (html) --------------------------------------------------------\n#\' @keywords internal\n#\' @import htmltools\nbuild_heading_html <- function(format_info, data_info, method, div_id = NA) {\n\n  caller <- as.character(sys.call(-1))[1]\n  head1  <- NA # uses h3()\n  head2  <- NA # uses h4() or <strong> (see option subtitle.emphasis)\n  head3  <- NA # uses <strong>...</strong>\n\n  append_items <- function(items) {\n    appended <- character()\n    for (item in items) {\n      if (names(item) %in% names(data_info)) {\n        if ((grepl(pattern = "label", names(item)) &&\n             isTRUE(format_info$display.labels)) ||\n            (names(item) == "Data.type" &&\n             isTRUE(format_info$display.type)) ||\n            !grepl("(label|Data\\\\.type)", names(item))) {\n\n          value <- data_info[[names(item)]]\n          tmpargs <- c("big.mark", "small.mark", "decimal.mark",\n                       "small.interval", "big.interval")\n          if (isTRUE(is.numeric(value)) && any(names(format_info) %in% tmpargs)) {\n            value <-\n              do.call(format, append(format_info[which(names(format_info) %in% tmpargs)],\n                                     x = quote(value)))\n\n            if (names(item) == "Dimensions") {\n              value <- paste(trimws(value[1]), trimws(value[2]), sep = " x ")\n            }\n          }\n\n          div_str_item <-\n            paste(paste0("<strong>", HTML(conv_non_ascii(item)), "</strong>"),\n                  ifelse(is.character(value), conv_non_ascii(value), value),\n                  sep = ": ")\n\n          if (identical(appended, character())) {\n            appended <- div_str_item\n          } else {\n            appended <- paste(appended,\n                              div_str_item,\n                              sep = "\\n  <br/>")\n          }\n        }\n      }\n    }\n\n    if (identical(appended, character())) {\n      return(NA)\n    }\n\n    return(HTML(appended))\n  }\n\n  # Special cases where no primary heading (title) is needed\n  if (isTRUE(format_info$var.only)) {\n    if (!isTRUE(format_info$headings)) {\n      return(list())\n    } else {\n      if ("Variable" %in% names(data_info)) {\n        if (isTRUE(st_options("subtitle.emphasis"))) {\n          if (!is.na(div_id)) {\n            head2 <-\n              h4(HTML(paste0(\n                \'<p data-toggle="collapse" aria-expanded="true" \',\n                \'aria-controls="\', div_id, \'" href="#\', div_id, \'">\',\n                conv_non_ascii(data_info$Variable),\n                "</p>")))\n          } else {\n            head2 <- h4(HTML(conv_non_ascii(data_info$Variable)))\n          }\n        } else {\n          if (!is.na(div_id)) {\n            head2 <-\n              strong(HTML(paste0(\n                \'<p data-toggle="collapse" aria-expanded="true" \',\n                \'aria-controls="\', div_id, \'" href="#\', div_id, \'">\',\n                conv_non_ascii(data_info$Variable),\n                "</p>")))\n          } else {\n            head2 <- strong(HTML(conv_non_ascii(data_info$Variable)), br())\n          }\n        }\n      }\n\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Data.type      = trs("type"))))\n      tmp <- list(head2, head3)\n      return(tmp[which(!is.na(tmp))])\n    }\n  } else if (isTRUE(format_info$group.only)) {\n    if (isTRUE(format_info$headings)) {\n      head3 <- append_items(list(c(Group      = trs("group")),\n                                 c(N.Obs      = trs("n")),\n                                 c(Dimensions = trs("dimensions")),\n                                 c(Duplicates = trs("duplicates"))))\n    } else {\n      head3 <- append_items(list(c(Group = trs("group"))))\n    }\n    return(list(head3))\n  } else if (!isTRUE(format_info$headings)) {\n    if ("Group" %in% names(data_info)) {\n      head3 <- append_items(list(c(Group = trs("group"))))\n      return(list(head3))\n    } else {\n      return(list())\n    }\n  }\n\n  # Regular cases - Build the 3 heading elements\n  if (caller == "print_freq") {\n    \n    if ("Weights" %in% names(data_info)) {\n      if (trs("title.freq.weighted") == "") {\n        head1 <- NA\n      } else {\n        head1 <- h3(HTML(conv_non_ascii(trs("title.freq.weighted"))))\n      }\n    } else {\n      if (trs("title.freq") == "") {\n        head1 <- NA\n      } else {\n        head1 <- h3(HTML(conv_non_ascii(trs("title.freq"))))\n      }\n    }\n\n    if ("Variable" %in% names(data_info)) {\n      if (isTRUE(st_options("subtitle.emphasis"))) {\n        if (!is.na(div_id)) {\n          head2 <-\n            h4(HTML(paste0(\n              \'<p data-toggle="collapse" aria-expanded="true" \',\n              \'aria-controls="\', div_id, \'" href="#\', div_id, \'">\',\n              conv_non_ascii(data_info$Variable),\n              "</p>")))\n        } else {\n        head2 <- h4(HTML(conv_non_ascii(data_info$Variable)))\n        }\n      } else {\n        if (!is.na(div_id)) {\n            head2 <-\n              strong(HTML(paste0(\n                \'<p data-toggle="collapse" aria-expanded="true" \',\n                \'aria-controls="\', div_id, \'" href="#\', div_id, \'">\',\n                conv_non_ascii(data_info$Variable),\n                "</p>")))\n      } else {\n        head2 <- strong(HTML(conv_non_ascii(data_info$Variable)), br())\n      }\n    }\n    }\n\n    if ("var.only" %in% names(format_info)) {\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Data.type      = trs("type"))))\n    } else {\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Data.type      = trs("type")),\n                                 c(Weights        = trs("weights")),\n                                 c(Group          = trs("group"))))\n    }\n    \n  } else if (caller == "print_ctable") {\n\n    head1 <- switch(data_info$Proportions,\n                    Row    = paste(trs("title.ctable"), trs("title.ctable.row"),\n                                   sep = ", "),\n                    Column = paste(trs("title.ctable"), trs("title.ctable.col"),\n                                   sep = ", "),\n                    Total  = paste(trs("title.ctable"), trs("title.ctable.tot"),\n                                   sep = ", "),\n                    None   = trs("title.ctable"))\n\n    # Check that head1 is not empty (if define_keywords was used)\n    head1 <- sub("^, ", "", head1)\n    \n    if (head1 == ", ") {\n      head1 <- NA\n    } else {\n      head1 <- h3(HTML(conv_non_ascii(head1)))\n    }\n    \n    if ("Row.x.Col" %in% names(data_info)) {\n      if (isTRUE(st_options("subtitle.emphasis"))) {\n        head2 <- h4(HTML(conv_non_ascii(data_info$Row.x.Col)))\n      } else {\n        head2 <- strong(HTML(conv_non_ascii(data_info$Row.x.Col)), br())\n      }\n    }\n\n    head3 <- append_items(list(c(Data.frame       = trs("data.frame")),\n                               c(Data.frame.label = trs("label")),\n                               c(Group            = trs("group"))))\n\n  } else if (caller == "print_descr") {\n\n    if ("Weights" %in% names(data_info)) {\n      if (trs("title.descr.weighted") == "") {\n        head1 <- NA\n      } else {\n        head1 <- h3(HTML(conv_non_ascii(trs("title.descr.weighted"))))\n      }\n    } else {\n      if (trs("title.descr") == "") {\n        head1 <- NA\n      } else {\n        head1 <- h3(HTML(conv_non_ascii(trs("title.descr"))))\n      }\n    }\n    \n    if ("by_var_special" %in% names(data_info)) {\n      if (isTRUE(st_options("subtitle.emphasis"))) {\n        head2 <- HTML(paste("<h4>", conv_non_ascii(data_info$Variable),\n                            conv_non_ascii(trs("by")),\n                            conv_non_ascii(data_info$by_var_special),\n                            "</h4>"))\n      } else {\n        head2 <- HTML(paste("<strong>", conv_non_ascii(data_info$Variable),\n                            "</strong>", conv_non_ascii(trs("by")), "<strong>",\n                            conv_non_ascii(data_info$by_var_special),\n                            "</strong><br/>"))\n      }\n\n      head3 <- append_items(list(c(Data.frame     = trs("data.frame")),\n                                 c(Variable.label = trs("label")),\n                                 c(Weights        = trs("weights")),\n                                 c(Group          = trs("group")),\n                                 c(N.Obs          = trs("n"))))\n\n    } else if ("Variable" %in% names(data_info)) {\n      if (isTRUE(st_options("subtitle.emphasis"))) {\n        head2 <- h4(HTML(conv_non_ascii(data_info$Variable)))\n      } else {\n        head2 <- strong(HTML(conv_non_ascii(data_info$Variable)), br())\n      }\n\n      head3 <- append_items(list(c(Variable.label = trs("label")),\n                                 c(Weights        = trs("weights")),\n                                 c(Group          = trs("group")),\n                                 c(N.Obs          = trs("n"))))\n    } else {\n\n      if ("Data.frame" %in% names(data_info)) {\n        if (isTRUE(st_options("subtitle.emphasis"))) {\n          head2 <- h4(HTML(conv_non_ascii(data_info$Data.frame)))\n        } else {\n          head2 <- strong(HTML(conv_non_ascii(data_info$Data.frame)), br())\n        }\n      }\n\n      head3 <- append_items(list(c(Data.frame.label = trs("label")),\n                                 c(Weights          = trs("weights")),\n                                 c(Group            = trs("group")),\n                                 c(N.Obs            = trs("n"))))\n    }\n\n  } else if (caller == "print_dfs") {\n\n    if (trs("title.dfSummary") == "") { \n      head1 <- NA\n    } else {\n      head1 <- h3(HTML(conv_non_ascii(trs("title.dfSummary"))))\n    }\n    \n    if ("Data.frame" %in% names(data_info)) {\n      if (isTRUE(st_options("subtitle.emphasis"))) {\n        head2 <- h4(HTML(conv_non_ascii(data_info$Data.frame)))\n      } else {\n        head2 <- strong(HTML(conv_non_ascii(data_info$Data.frame)), br())\n      }\n    }\n\n    head3 <- append_items(list(c(Data.frame.label = trs("label")),\n                               c(Group            = trs("group")),\n                               c(Dimensions       = trs("dimensions")),\n                               c(Duplicates       = trs("duplicates"))))\n  }\n\n  tmp <- list(head1, head2, head3)\n  return(tmp[which(!is.na(tmp))])\n}\n'