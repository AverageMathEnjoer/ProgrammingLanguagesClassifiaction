b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE PatternGuards #-}\n#ifdef __GLASGOW_HASKELL__\n{-# LANGUAGE DeriveLift #-}\n{-# LANGUAGE MagicHash #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeFamilies #-}\n#endif\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Trustworthy #-}\n#endif\n\n{-# OPTIONS_HADDOCK not-home #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.IntMap.Internal\n-- Copyright   :  (c) Daan Leijen 2002\n--                (c) Andriy Palamarchuk 2008\n--                (c) wren romano 2016\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n-- = WARNING\n--\n-- This module is considered __internal__.\n--\n-- The Package Versioning Policy __does not apply__.\n--\n-- The contents of this module may change __in any way whatsoever__\n-- and __without any warning__ between minor versions of this package.\n--\n-- Authors importing this module are expected to track development\n-- closely.\n--\n-- = Description\n--\n-- This defines the data structures and core (hidden) manipulations\n-- on representations.\n--\n-- @since 0.5.9\n-----------------------------------------------------------------------------\n\n-- [Note: INLINE bit fiddling]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- It is essential that the bit fiddling functions like mask, zero, branchMask\n-- etc are inlined. If they do not, the memory allocation skyrockets. The GHC\n-- usually gets it right, but it is disastrous if it does not. Therefore we\n-- explicitly mark these functions INLINE.\n\n\n-- [Note: Local \'go\' functions and capturing]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- Care must be taken when using \'go\' function which captures an argument.\n-- Sometimes (for example when the argument is passed to a data constructor,\n-- as in insert), GHC heap-allocates more than necessary. Therefore C-- code\n-- must be checked for increased allocation when creating and modifying such\n-- functions.\n\n\n-- [Note: Order of constructors]\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- The order of constructors of IntMap matters when considering performance.\n-- Currently in GHC 7.0, when type has 3 constructors, they are matched from\n-- the first to the last -- the best performance is achieved when the\n-- constructors are ordered by frequency.\n-- On GHC 7.0, reordering constructors from Nil | Tip | Bin to Bin | Tip | Nil\n-- improves the benchmark by circa 10%.\n--\n\nmodule Data.IntMap.Internal (\n    -- * Map type\n      IntMap(..), Key          -- instance Eq,Show\n\n    -- * Operators\n    , (!), (!?), (\\\\)\n\n    -- * Query\n    , null\n    , size\n    , member\n    , notMember\n    , lookup\n    , findWithDefault\n    , lookupLT\n    , lookupGT\n    , lookupLE\n    , lookupGE\n    , disjoint\n\n    -- * Construction\n    , empty\n    , singleton\n\n    -- ** Insertion\n    , insert\n    , insertWith\n    , insertWithKey\n    , insertLookupWithKey\n\n    -- ** Delete\\/Update\n    , delete\n    , adjust\n    , adjustWithKey\n    , update\n    , updateWithKey\n    , updateLookupWithKey\n    , alter\n    , alterF\n\n    -- * Combine\n\n    -- ** Union\n    , union\n    , unionWith\n    , unionWithKey\n    , unions\n    , unionsWith\n\n    -- ** Difference\n    , difference\n    , differenceWith\n    , differenceWithKey\n\n    -- ** Intersection\n    , intersection\n    , intersectionWith\n    , intersectionWithKey\n\n    -- ** Compose\n    , compose\n\n    -- ** General combining function\n    , SimpleWhenMissing\n    , SimpleWhenMatched\n    , runWhenMatched\n    , runWhenMissing\n    , merge\n    -- *** @WhenMatched@ tactics\n    , zipWithMaybeMatched\n    , zipWithMatched\n    -- *** @WhenMissing@ tactics\n    , mapMaybeMissing\n    , dropMissing\n    , preserveMissing\n    , mapMissing\n    , filterMissing\n\n    -- ** Applicative general combining function\n    , WhenMissing (..)\n    , WhenMatched (..)\n    , mergeA\n    -- *** @WhenMatched@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , zipWithMaybeAMatched\n    , zipWithAMatched\n    -- *** @WhenMissing@ tactics\n    -- | The tactics described for \'merge\' work for\n    -- \'mergeA\' as well. Furthermore, the following\n    -- are available.\n    , traverseMaybeMissing\n    , traverseMissing\n    , filterAMissing\n\n    -- ** Deprecated general combining function\n    , mergeWithKey\n    , mergeWithKey\'\n\n    -- * Traversal\n    -- ** Map\n    , map\n    , mapWithKey\n    , traverseWithKey\n    , traverseMaybeWithKey\n    , mapAccum\n    , mapAccumWithKey\n    , mapAccumRWithKey\n    , mapKeys\n    , mapKeysWith\n    , mapKeysMonotonic\n\n    -- * Folds\n    , foldr\n    , foldl\n    , foldrWithKey\n    , foldlWithKey\n    , foldMapWithKey\n\n    -- ** Strict folds\n    , foldr\'\n    , foldl\'\n    , foldrWithKey\'\n    , foldlWithKey\'\n\n    -- * Conversion\n    , elems\n    , keys\n    , assocs\n    , keysSet\n    , fromSet\n\n    -- ** Lists\n    , toList\n    , fromList\n    , fromListWith\n    , fromListWithKey\n\n    -- ** Ordered lists\n    , toAscList\n    , toDescList\n    , fromAscList\n    , fromAscListWith\n    , fromAscListWithKey\n    , fromDistinctAscList\n\n    -- * Filter\n    , filter\n    , filterWithKey\n    , restrictKeys\n    , withoutKeys\n    , partition\n    , partitionWithKey\n\n    , takeWhileAntitone\n    , dropWhileAntitone\n    , spanAntitone\n\n    , mapMaybe\n    , mapMaybeWithKey\n    , mapEither\n    , mapEitherWithKey\n\n    , split\n    , splitLookup\n    , splitRoot\n\n    -- * Submap\n    , isSubmapOf, isSubmapOfBy\n    , isProperSubmapOf, isProperSubmapOfBy\n\n    -- * Min\\/Max\n    , lookupMin\n    , lookupMax\n    , findMin\n    , findMax\n    , deleteMin\n    , deleteMax\n    , deleteFindMin\n    , deleteFindMax\n    , updateMin\n    , updateMax\n    , updateMinWithKey\n    , updateMaxWithKey\n    , minView\n    , maxView\n    , minViewWithKey\n    , maxViewWithKey\n\n    -- * Debugging\n    , showTree\n    , showTreeWith\n\n    -- * Internal types\n    , Mask, Prefix, Nat\n\n    -- * Utility\n    , natFromInt\n    , intFromNat\n    , link\n    , linkWithMask\n    , bin\n    , binCheckLeft\n    , binCheckRight\n    , zero\n    , nomatch\n    , match\n    , mask\n    , maskW\n    , shorter\n    , branchMask\n    , highestBitMask\n\n    -- * Used by "IntMap.Merge.Lazy" and "IntMap.Merge.Strict"\n    , mapWhenMissing\n    , mapWhenMatched\n    , lmapWhenMissing\n    , contramapFirstWhenMatched\n    , contramapSecondWhenMatched\n    , mapGentlyWhenMissing\n    , mapGentlyWhenMatched\n    ) where\n\nimport Data.Functor.Identity (Identity (..))\nimport Data.Semigroup (Semigroup(stimes))\n#if !(MIN_VERSION_base(4,11,0))\nimport Data.Semigroup (Semigroup((<>)))\n#endif\nimport Data.Semigroup (stimesIdempotentMonoid)\nimport Data.Functor.Classes\n\nimport Control.DeepSeq (NFData(rnf))\nimport Data.Bits\nimport qualified Data.Foldable as Foldable\nimport Data.Maybe (fromMaybe)\nimport Utils.Containers.Internal.Prelude hiding\n  (lookup, map, filter, foldr, foldl, null)\nimport Prelude ()\n\nimport Data.IntSet.Internal (Key)\nimport qualified Data.IntSet.Internal as IntSet\nimport Utils.Containers.Internal.BitUtil\nimport Utils.Containers.Internal.StrictPair\n\n#ifdef __GLASGOW_HASKELL__\nimport Data.Coerce\nimport Data.Data (Data(..), Constr, mkConstr, constrIndex, Fixity(Prefix),\n                  DataType, mkDataType, gcast1)\nimport GHC.Exts (build)\nimport qualified GHC.Exts as GHCExts\nimport Text.Read\nimport Language.Haskell.TH.Syntax (Lift)\n-- See Note [ Template Haskell Dependencies ]\nimport Language.Haskell.TH ()\n#endif\nimport qualified Control.Category as Category\n\n\n-- A "Nat" is a natural machine word (an unsigned Int)\ntype Nat = Word\n\nnatFromInt :: Key -> Nat\nnatFromInt = fromIntegral\n{-# INLINE natFromInt #-}\n\nintFromNat :: Nat -> Key\nintFromNat = fromIntegral\n{-# INLINE intFromNat #-}\n\n{--------------------------------------------------------------------\n  Types\n--------------------------------------------------------------------}\n\n\n-- | A map of integers to values @a@.\n\n-- See Note: Order of constructors\ndata IntMap a = Bin {-# UNPACK #-} !Prefix\n                    {-# UNPACK #-} !Mask\n                    !(IntMap a)\n                    !(IntMap a)\n-- Fields:\n--   prefix: The most significant bits shared by all keys in this Bin.\n--   mask: The switching bit to determine if a key should follow the left\n--         or right subtree of a \'Bin\'.\n-- Invariant: Nil is never found as a child of Bin.\n-- Invariant: The Mask is a power of 2. It is the largest bit position at which\n--            two keys of the map differ.\n-- Invariant: Prefix is the common high-order bits that all elements share to\n--            the left of the Mask bit.\n-- Invariant: In (Bin prefix mask left right), left consists of the elements that\n--            don\'t have the mask bit set; right is all the elements that do.\n              | Tip {-# UNPACK #-} !Key a\n              | Nil\n\ntype Prefix = Int\ntype Mask   = Int\n\n\n-- Some stuff from "Data.IntSet.Internal", for \'restrictKeys\' and\n-- \'withoutKeys\' to use.\ntype IntSetPrefix = Int\ntype IntSetBitMap = Word\n\n-- | @since 0.6.6\nderiving instance Lift a => Lift (IntMap a)\n\nbitmapOf :: Int -> IntSetBitMap\nbitmapOf x = shiftLL 1 (x .&. IntSet.suffixBitMask)\n{-# INLINE bitmapOf #-}\n\n{--------------------------------------------------------------------\n  Operators\n--------------------------------------------------------------------}\n\n-- | \\(O(\\min(n,W))\\). Find the value at a key.\n-- Calls \'error\' when the element can not be found.\n--\n-- > fromList [(5,\'a\'), (3,\'b\')] ! 1    Error: element not in the map\n-- > fromList [(5,\'a\'), (3,\'b\')] ! 5 == \'a\'\n\n(!) :: IntMap a -> Key -> a\n(!) m k = find k m\n\n-- | \\(O(\\min(n,W))\\). Find the value at a key.\n-- Returns \'Nothing\' when the element can not be found.\n--\n-- > fromList [(5,\'a\'), (3,\'b\')] !? 1 == Nothing\n-- > fromList [(5,\'a\'), (3,\'b\')] !? 5 == Just \'a\'\n--\n-- @since 0.5.11\n\n(!?) :: IntMap a -> Key -> Maybe a\n(!?) m k = lookup k m\n\n-- | Same as \'difference\'.\n(\\\\) :: IntMap a -> IntMap b -> IntMap a\nm1 \\\\ m2 = difference m1 m2\n\ninfixl 9 !?,\\\\{-This comment teaches CPP correct behaviour -}\n\n{--------------------------------------------------------------------\n  Types\n--------------------------------------------------------------------}\n\ninstance Monoid (IntMap a) where\n    mempty  = empty\n    mconcat = unions\n    mappend = (<>)\n\n-- | @since 0.5.7\ninstance Semigroup (IntMap a) where\n    (<>)    = union\n    stimes  = stimesIdempotentMonoid\n\n-- | Folds in order of increasing key.\ninstance Foldable.Foldable IntMap where\n  fold = go\n    where go Nil = mempty\n          go (Tip _ v) = v\n          go (Bin _ m l r)\n            | m < 0     = go r `mappend` go l\n            | otherwise = go l `mappend` go r\n  {-# INLINABLE fold #-}\n  foldr = foldr\n  {-# INLINE foldr #-}\n  foldl = foldl\n  {-# INLINE foldl #-}\n  foldMap f t = go t\n    where go Nil = mempty\n          go (Tip _ v) = f v\n          go (Bin _ m l r)\n            | m < 0     = go r `mappend` go l\n            | otherwise = go l `mappend` go r\n  {-# INLINE foldMap #-}\n  foldl\' = foldl\'\n  {-# INLINE foldl\' #-}\n  foldr\' = foldr\'\n  {-# INLINE foldr\' #-}\n  length = size\n  {-# INLINE length #-}\n  null   = null\n  {-# INLINE null #-}\n  toList = elems -- NB: Foldable.toList /= IntMap.toList\n  {-# INLINE toList #-}\n  elem = go\n    where go !_ Nil = False\n          go x (Tip _ y) = x == y\n          go x (Bin _ _ l r) = go x l || go x r\n  {-# INLINABLE elem #-}\n  maximum = start\n    where start Nil = error "Data.Foldable.maximum (for Data.IntMap): empty map"\n          start (Tip _ y) = y\n          start (Bin _ m l r)\n            | m < 0     = go (start r) l\n            | otherwise = go (start l) r\n\n          go !m Nil = m\n          go m (Tip _ y) = max m y\n          go m (Bin _ _ l r) = go (go m l) r\n  {-# INLINABLE maximum #-}\n  minimum = start\n    where start Nil = error "Data.Foldable.minimum (for Data.IntMap): empty map"\n          start (Tip _ y) = y\n          start (Bin _ m l r)\n            | m < 0     = go (start r) l\n            | otherwise = go (start l) r\n\n          go !m Nil = m\n          go m (Tip _ y) = min m y\n          go m (Bin _ _ l r) = go (go m l) r\n  {-# INLINABLE minimum #-}\n  sum = foldl\' (+) 0\n  {-# INLINABLE sum #-}\n  product = foldl\' (*) 1\n  {-# INLINABLE product #-}\n\n-- | Traverses in order of increasing key.\ninstance Traversable IntMap where\n    traverse f = traverseWithKey (\\_ -> f)\n    {-# INLINE traverse #-}\n\ninstance NFData a => NFData (IntMap a) where\n    rnf Nil = ()\n    rnf (Tip _ v) = rnf v\n    rnf (Bin _ _ l r) = rnf l `seq` rnf r\n\n#if __GLASGOW_HASKELL__\n\n{--------------------------------------------------------------------\n  A Data instance\n--------------------------------------------------------------------}\n\n-- This instance preserves data abstraction at the cost of inefficiency.\n-- We provide limited reflection services for the sake of data abstraction.\n\ninstance Data a => Data (IntMap a) where\n  gfoldl f z im = z fromList `f` (toList im)\n  toConstr _     = fromListConstr\n  gunfold k z c  = case constrIndex c of\n    1 -> k (z fromList)\n    _ -> error "gunfold"\n  dataTypeOf _   = intMapDataType\n  dataCast1 f    = gcast1 f\n\nfromListConstr :: Constr\nfromListConstr = mkConstr intMapDataType "fromList" [] Prefix\n\nintMapDataType :: DataType\nintMapDataType = mkDataType "Data.IntMap.Internal.IntMap" [fromListConstr]\n\n#endif\n\n{--------------------------------------------------------------------\n  Query\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). Is the map empty?\n--\n-- > Data.IntMap.null (empty)           == True\n-- > Data.IntMap.null (singleton 1 \'a\') == False\n\nnull :: IntMap a -> Bool\nnull Nil = True\nnull _   = False\n{-# INLINE null #-}\n\n-- | \\(O(n)\\). Number of elements in the map.\n--\n-- > size empty                                   == 0\n-- > size (singleton 1 \'a\')                       == 1\n-- > size (fromList([(1,\'a\'), (2,\'c\'), (3,\'b\')])) == 3\nsize :: IntMap a -> Int\nsize = go 0\n  where\n    go !acc (Bin _ _ l r) = go (go acc l) r\n    go acc (Tip _ _) = 1 + acc\n    go acc Nil = acc\n\n-- | \\(O(\\min(n,W))\\). Is the key a member of the map?\n--\n-- > member 5 (fromList [(5,\'a\'), (3,\'b\')]) == True\n-- > member 1 (fromList [(5,\'a\'), (3,\'b\')]) == False\n\n-- See Note: Local \'go\' functions and capturing]\nmember :: Key -> IntMap a -> Bool\nmember !k = go\n  where\n    go (Bin p m l r) | nomatch k p m = False\n                     | zero k m  = go l\n                     | otherwise = go r\n    go (Tip kx _) = k == kx\n    go Nil = False\n\n-- | \\(O(\\min(n,W))\\). Is the key not a member of the map?\n--\n-- > notMember 5 (fromList [(5,\'a\'), (3,\'b\')]) == False\n-- > notMember 1 (fromList [(5,\'a\'), (3,\'b\')]) == True\n\nnotMember :: Key -> IntMap a -> Bool\nnotMember k m = not $ member k m\n\n-- | \\(O(\\min(n,W))\\). Lookup the value at a key in the map. See also \'Data.Map.lookup\'.\n\n-- See Note: Local \'go\' functions and capturing\nlookup :: Key -> IntMap a -> Maybe a\nlookup !k = go\n  where\n    go (Bin _p m l r) | zero k m  = go l\n                      | otherwise = go r\n    go (Tip kx x) | k == kx   = Just x\n                  | otherwise = Nothing\n    go Nil = Nothing\n\n-- See Note: Local \'go\' functions and capturing]\nfind :: Key -> IntMap a -> a\nfind !k = go\n  where\n    go (Bin _p m l r) | zero k m  = go l\n                      | otherwise = go r\n    go (Tip kx x) | k == kx   = x\n                  | otherwise = not_found\n    go Nil = not_found\n\n    not_found = error ("IntMap.!: key " ++ show k ++ " is not an element of the map")\n\n-- | \\(O(\\min(n,W))\\). The expression @(\'findWithDefault\' def k map)@\n-- returns the value at key @k@ or returns @def@ when the key is not an\n-- element of the map.\n--\n-- > findWithDefault \'x\' 1 (fromList [(5,\'a\'), (3,\'b\')]) == \'x\'\n-- > findWithDefault \'x\' 5 (fromList [(5,\'a\'), (3,\'b\')]) == \'a\'\n\n-- See Note: Local \'go\' functions and capturing]\nfindWithDefault :: a -> Key -> IntMap a -> a\nfindWithDefault def !k = go\n  where\n    go (Bin p m l r) | nomatch k p m = def\n                     | zero k m  = go l\n                     | otherwise = go r\n    go (Tip kx x) | k == kx   = x\n                  | otherwise = def\n    go Nil = def\n\n-- | \\(O(\\min(n,W))\\). Find largest key smaller than the given one and return the\n-- corresponding (key, value) pair.\n--\n-- > lookupLT 3 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\n-- > lookupLT 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (3, \'a\')\n\n-- See Note: Local \'go\' functions and capturing.\nlookupLT :: Key -> IntMap a -> Maybe (Key, a)\nlookupLT !k t = case t of\n    Bin _ m l r | m < 0 -> if k >= 0 then go r l else go Nil r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r)\n      | nomatch k p m = if k < p then unsafeFindMax def else unsafeFindMax r\n      | zero k m  = go def l\n      | otherwise = go l r\n    go def (Tip ky y)\n      | k <= ky   = unsafeFindMax def\n      | otherwise = Just (ky, y)\n    go def Nil = unsafeFindMax def\n\n-- | \\(O(\\min(n,W))\\). Find smallest key greater than the given one and return the\n-- corresponding (key, value) pair.\n--\n-- > lookupGT 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (5, \'b\')\n-- > lookupGT 5 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\n\n-- See Note: Local \'go\' functions and capturing.\nlookupGT :: Key -> IntMap a -> Maybe (Key, a)\nlookupGT !k t = case t of\n    Bin _ m l r | m < 0 -> if k >= 0 then go Nil l else go l r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r)\n      | nomatch k p m = if k < p then unsafeFindMin l else unsafeFindMin def\n      | zero k m  = go r l\n      | otherwise = go def r\n    go def (Tip ky y)\n      | k >= ky   = unsafeFindMin def\n      | otherwise = Just (ky, y)\n    go def Nil = unsafeFindMin def\n\n-- | \\(O(\\min(n,W))\\). Find largest key smaller or equal to the given one and return\n-- the corresponding (key, value) pair.\n--\n-- > lookupLE 2 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\n-- > lookupLE 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (3, \'a\')\n-- > lookupLE 5 (fromList [(3,\'a\'), (5,\'b\')]) == Just (5, \'b\')\n\n-- See Note: Local \'go\' functions and capturing.\nlookupLE :: Key -> IntMap a -> Maybe (Key, a)\nlookupLE !k t = case t of\n    Bin _ m l r | m < 0 -> if k >= 0 then go r l else go Nil r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r)\n      | nomatch k p m = if k < p then unsafeFindMax def else unsafeFindMax r\n      | zero k m  = go def l\n      | otherwise = go l r\n    go def (Tip ky y)\n      | k < ky    = unsafeFindMax def\n      | otherwise = Just (ky, y)\n    go def Nil = unsafeFindMax def\n\n-- | \\(O(\\min(n,W))\\). Find smallest key greater or equal to the given one and return\n-- the corresponding (key, value) pair.\n--\n-- > lookupGE 3 (fromList [(3,\'a\'), (5,\'b\')]) == Just (3, \'a\')\n-- > lookupGE 4 (fromList [(3,\'a\'), (5,\'b\')]) == Just (5, \'b\')\n-- > lookupGE 6 (fromList [(3,\'a\'), (5,\'b\')]) == Nothing\n\n-- See Note: Local \'go\' functions and capturing.\nlookupGE :: Key -> IntMap a -> Maybe (Key, a)\nlookupGE !k t = case t of\n    Bin _ m l r | m < 0 -> if k >= 0 then go Nil l else go l r\n    _ -> go Nil t\n  where\n    go def (Bin p m l r)\n      | nomatch k p m = if k < p then unsafeFindMin l else unsafeFindMin def\n      | zero k m  = go r l\n      | otherwise = go def r\n    go def (Tip ky y)\n      | k > ky    = unsafeFindMin def\n      | otherwise = Just (ky, y)\n    go def Nil = unsafeFindMin def\n\n\n-- Helper function for lookupGE and lookupGT. It assumes that if a Bin node is\n-- given, it has m > 0.\nunsafeFindMin :: IntMap a -> Maybe (Key, a)\nunsafeFindMin Nil = Nothing\nunsafeFindMin (Tip ky y) = Just (ky, y)\nunsafeFindMin (Bin _ _ l _) = unsafeFindMin l\n\n-- Helper function for lookupLE and lookupLT. It assumes that if a Bin node is\n-- given, it has m > 0.\nunsafeFindMax :: IntMap a -> Maybe (Key, a)\nunsafeFindMax Nil = Nothing\nunsafeFindMax (Tip ky y) = Just (ky, y)\nunsafeFindMax (Bin _ _ _ r) = unsafeFindMax r\n\n{--------------------------------------------------------------------\n  Disjoint\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). Check whether the key sets of two maps are disjoint\n-- (i.e. their \'intersection\' is empty).\n--\n-- > disjoint (fromList [(2,\'a\')]) (fromList [(1,()), (3,())])   == True\n-- > disjoint (fromList [(2,\'a\')]) (fromList [(1,\'a\'), (2,\'b\')]) == False\n-- > disjoint (fromList [])        (fromList [])                 == True\n--\n-- > disjoint a b == null (intersection a b)\n--\n-- @since 0.6.2.1\ndisjoint :: IntMap a -> IntMap b -> Bool\ndisjoint Nil _ = True\ndisjoint _ Nil = True\ndisjoint (Tip kx _) ys = notMember kx ys\ndisjoint xs (Tip ky _) = notMember ky xs\ndisjoint t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n  | shorter m1 m2 = disjoint1\n  | shorter m2 m1 = disjoint2\n  | p1 == p2      = disjoint l1 l2 && disjoint r1 r2\n  | otherwise     = True\n  where\n    disjoint1 | nomatch p2 p1 m1 = True\n              | zero p2 m1       = disjoint l1 t2\n              | otherwise        = disjoint r1 t2\n    disjoint2 | nomatch p1 p2 m2 = True\n              | zero p1 m2       = disjoint t1 l2\n              | otherwise        = disjoint t1 r2\n\n{--------------------------------------------------------------------\n  Compose\n--------------------------------------------------------------------}\n-- | Relate the keys of one map to the values of\n-- the other, by using the values of the former as keys for lookups\n-- in the latter.\n--\n-- Complexity: \\( O(n * \\min(m,W)) \\), where \\(m\\) is the size of the first argument\n--\n-- > compose (fromList [(\'a\', "A"), (\'b\', "B")]) (fromList [(1,\'a\'),(2,\'b\'),(3,\'z\')]) = fromList [(1,"A"),(2,"B")]\n--\n-- @\n-- (\'compose\' bc ab \'!?\') = (bc \'!?\') <=< (ab \'!?\')\n-- @\n--\n-- __Note:__ Prior to v0.6.4, "Data.IntMap.Strict" exposed a version of\n-- \'compose\' that forced the values of the output \'IntMap\'. This version does\n-- not force these values.\n--\n-- @since 0.6.3.1\ncompose :: IntMap c -> IntMap Int -> IntMap c\ncompose bc !ab\n  | null bc = empty\n  | otherwise = mapMaybe (bc !?) ab\n\n{--------------------------------------------------------------------\n  Construction\n--------------------------------------------------------------------}\n-- | \\(O(1)\\). The empty map.\n--\n-- > empty      == fromList []\n-- > size empty == 0\n\nempty :: IntMap a\nempty\n  = Nil\n{-# INLINE empty #-}\n\n-- | \\(O(1)\\). A map of one element.\n--\n-- > singleton 1 \'a\'        == fromList [(1, \'a\')]\n-- > size (singleton 1 \'a\') == 1\n\nsingleton :: Key -> a -> IntMap a\nsingleton k x\n  = Tip k x\n{-# INLINE singleton #-}\n\n{--------------------------------------------------------------------\n  Insert\n--------------------------------------------------------------------}\n-- | \\(O(\\min(n,W))\\). Insert a new key\\/value pair in the map.\n-- If the key is already present in the map, the associated value is\n-- replaced with the supplied value, i.e. \'insert\' is equivalent to\n-- @\'insertWith\' \'const\'@.\n--\n-- > insert 5 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'x\')]\n-- > insert 7 \'x\' (fromList [(5,\'a\'), (3,\'b\')]) == fromList [(3, \'b\'), (5, \'a\'), (7, \'x\')]\n-- > insert 5 \'x\' empty                         == singleton 5 \'x\'\n\ninsert :: Key -> a -> IntMap a -> IntMap a\ninsert !k x t@(Bin p m l r)\n  | nomatch k p m = link k (Tip k x) p t\n  | zero k m      = Bin p m (insert k x l) r\n  | otherwise     = Bin p m l (insert k x r)\ninsert k x t@(Tip ky _)\n  | k==ky         = Tip k x\n  | otherwise     = link k (Tip k x) ky t\ninsert k x Nil = Tip k x\n\n-- right-biased insertion, used by \'union\'\n-- | \\(O(\\min(n,W))\\). Insert with a combining function.\n-- @\'insertWith\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert @f new_value old_value@.\n--\n-- > insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]\n-- > insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"\n\ninsertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a\ninsertWith f k x t\n  = insertWithKey (\\_ x\' y\' -> f x\' y\') k x t\n\n-- | \\(O(\\min(n,W))\\). Insert with a combining function.\n-- @\'insertWithKey\' f key value mp@\n-- will insert the pair (key, value) into @mp@ if key does\n-- not exist in the map. If the key does exist, the function will\n-- insert @f key new_value old_value@.\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]\n-- > insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]\n-- > insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"\n\ninsertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a\ninsertWithKey f !k x t@(Bin p m l r)\n  | nomatch k p m = link k (Tip k x) p t\n  | zero k m      = Bin p m (insertWithKey f k x l) r\n  | otherwise     = Bin p m l (insertWithKey f k x r)\ninsertWithKey f k x t@(Tip ky y)\n  | k == ky       = Tip k (f k x y)\n  | otherwise     = link k (Tip k x) ky t\ninsertWithKey _ k x Nil = Tip k x\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'insertLookupWithKey\' f k x map@)\n-- is a pair where the first element is equal to (@\'lookup\' k map@)\n-- and the second element equal to (@\'insertWithKey\' f k x map@).\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])\n-- > insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])\n-- > insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")\n--\n-- This is how to define @insertLookup@ using @insertLookupWithKey@:\n--\n-- > let insertLookup kx x t = insertLookupWithKey (\\_ a _ -> a) kx x t\n-- > insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])\n-- > insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])\n\ninsertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)\ninsertLookupWithKey f !k x t@(Bin p m l r)\n  | nomatch k p m = (Nothing,link k (Tip k x) p t)\n  | zero k m      = let (found,l\') = insertLookupWithKey f k x l\n                    in (found,Bin p m l\' r)\n  | otherwise     = let (found,r\') = insertLookupWithKey f k x r\n                    in (found,Bin p m l r\')\ninsertLookupWithKey f k x t@(Tip ky y)\n  | k == ky       = (Just y,Tip k (f k x y))\n  | otherwise     = (Nothing,link k (Tip k x) ky t)\ninsertLookupWithKey _ k x Nil = (Nothing,Tip k x)\n\n\n{--------------------------------------------------------------------\n  Deletion\n--------------------------------------------------------------------}\n-- | \\(O(\\min(n,W))\\). Delete a key and its value from the map. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > delete 5 empty                         == empty\n\ndelete :: Key -> IntMap a -> IntMap a\ndelete !k t@(Bin p m l r)\n  | nomatch k p m = t\n  | zero k m      = binCheckLeft p m (delete k l) r\n  | otherwise     = binCheckRight p m l (delete k r)\ndelete k t@(Tip ky _)\n  | k == ky       = Nil\n  | otherwise     = t\ndelete _k Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). Adjust a value at a specific key. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjust ("new " ++) 7 empty                         == empty\n\nadjust ::  (a -> a) -> Key -> IntMap a -> IntMap a\nadjust f k m\n  = adjustWithKey (\\_ x -> f x) k m\n\n-- | \\(O(\\min(n,W))\\). Adjust a value at a specific key. When the key is not\n-- a member of the map, the original map is returned.\n--\n-- > let f key x = (show key) ++ ":new " ++ x\n-- > adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > adjustWithKey f 7 empty                         == empty\n\nadjustWithKey ::  (Key -> a -> a) -> Key -> IntMap a -> IntMap a\nadjustWithKey f !k (Bin p m l r)\n  | zero k m      = Bin p m (adjustWithKey f k l) r\n  | otherwise     = Bin p m l (adjustWithKey f k r)\nadjustWithKey f k t@(Tip ky y)\n  | k == ky       = Tip ky (f k y)\n  | otherwise     = t\nadjustWithKey _ _ Nil = Nil\n\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'update\' f k map@) updates the value @x@\n-- at @k@ (if it is in the map). If (@f x@) is \'Nothing\', the element is\n-- deleted. If it is (@\'Just\' y@), the key @k@ is bound to the new value @y@.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]\n-- > update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdate ::  (a -> Maybe a) -> Key -> IntMap a -> IntMap a\nupdate f\n  = updateWithKey (\\_ x -> f x)\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'update\' f k map@) updates the value @x@\n-- at @k@ (if it is in the map). If (@f k x@) is \'Nothing\', the element is\n-- deleted. If it is (@\'Just\' y@), the key @k@ is bound to the new value @y@.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]\n-- > updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]\n-- > updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a\nupdateWithKey f !k (Bin p m l r)\n  | zero k m      = binCheckLeft p m (updateWithKey f k l) r\n  | otherwise     = binCheckRight p m l (updateWithKey f k r)\nupdateWithKey f k t@(Tip ky y)\n  | k == ky       = case (f k y) of\n                      Just y\' -> Tip ky y\'\n                      Nothing -> Nil\n  | otherwise     = t\nupdateWithKey _ _ Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). Lookup and update.\n-- The function returns original value, if it is updated.\n-- This is different behavior than \'Data.Map.updateLookupWithKey\'.\n-- Returns the original key value if the map entry is deleted.\n--\n-- > let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing\n-- > updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:new a")])\n-- > updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])\n-- > updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")\n\nupdateLookupWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a,IntMap a)\nupdateLookupWithKey f !k (Bin p m l r)\n  | zero k m      = let !(found,l\') = updateLookupWithKey f k l\n                    in (found,binCheckLeft p m l\' r)\n  | otherwise     = let !(found,r\') = updateLookupWithKey f k r\n                    in (found,binCheckRight p m l r\')\nupdateLookupWithKey f k t@(Tip ky y)\n  | k==ky         = case (f k y) of\n                      Just y\' -> (Just y,Tip ky y\')\n                      Nothing -> (Just y,Nil)\n  | otherwise     = (Nothing,t)\nupdateLookupWithKey _ _ Nil = (Nothing,Nil)\n\n\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'alter\' f k map@) alters the value @x@ at @k@, or absence thereof.\n-- \'alter\' can be used to insert, delete, or update a value in an \'IntMap\'.\n-- In short : @\'lookup\' k (\'alter\' f k m) = f (\'lookup\' k m)@.\nalter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a\nalter f !k t@(Bin p m l r)\n  | nomatch k p m = case f Nothing of\n                      Nothing -> t\n                      Just x -> link k (Tip k x) p t\n  | zero k m      = binCheckLeft p m (alter f k l) r\n  | otherwise     = binCheckRight p m l (alter f k r)\nalter f k t@(Tip ky y)\n  | k==ky         = case f (Just y) of\n                      Just x -> Tip ky x\n                      Nothing -> Nil\n  | otherwise     = case f Nothing of\n                      Just x -> link k (Tip k x) ky t\n                      Nothing -> Tip ky y\nalter f k Nil     = case f Nothing of\n                      Just x -> Tip k x\n                      Nothing -> Nil\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'alterF\' f k map@) alters the value @x@ at\n-- @k@, or absence thereof.  \'alterF\' can be used to inspect, insert, delete,\n-- or update a value in an \'IntMap\'.  In short : @\'lookup\' k <$> \'alterF\' f k m = f\n-- (\'lookup\' k m)@.\n--\n-- Example:\n--\n-- @\n-- interactiveAlter :: Int -> IntMap String -> IO (IntMap String)\n-- interactiveAlter k m = alterF f k m where\n--   f Nothing = do\n--      putStrLn $ show k ++\n--          " was not found in the map. Would you like to add it?"\n--      getUserResponse1 :: IO (Maybe String)\n--   f (Just old) = do\n--      putStrLn $ "The key is currently bound to " ++ show old ++\n--          ". Would you like to change or delete it?"\n--      getUserResponse2 :: IO (Maybe String)\n-- @\n--\n-- \'alterF\' is the most general operation for working with an individual\n-- key that may or may not be in a given map.\n--\n-- Note: \'alterF\' is a flipped version of the @at@ combinator from\n-- @Control.Lens.At@.\n--\n-- @since 0.5.8\n\nalterF :: Functor f\n       => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)\n-- This implementation was stolen from \'Control.Lens.At\'.\nalterF f k m = (<$> f mv) $ \\fres ->\n  case fres of\n    Nothing -> maybe m (const (delete k m)) mv\n    Just v\' -> insert k v\' m\n  where mv = lookup k m\n\n{--------------------------------------------------------------------\n  Union\n--------------------------------------------------------------------}\n-- | The union of a list of maps.\n--\n-- > unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n-- >     == fromList [(3, "b"), (5, "a"), (7, "C")]\n-- > unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]\n-- >     == fromList [(3, "B3"), (5, "A3"), (7, "C")]\n\nunions :: Foldable f => f (IntMap a) -> IntMap a\nunions xs\n  = Foldable.foldl\' union empty xs\n\n-- | The union of a list of maps, with a combining operation.\n--\n-- > unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]\n-- >     == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]\n\nunionsWith :: Foldable f => (a->a->a) -> f (IntMap a) -> IntMap a\nunionsWith f ts\n  = Foldable.foldl\' (unionWith f) empty ts\n\n-- | \\(O(n+m)\\). The (left-biased) union of two maps.\n-- It prefers the first map when duplicate keys are encountered,\n-- i.e. (@\'union\' == \'unionWith\' \'const\'@).\n--\n-- > union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]\n\nunion :: IntMap a -> IntMap a -> IntMap a\nunion m1 m2\n  = mergeWithKey\' Bin const id id m1 m2\n\n-- | \\(O(n+m)\\). The union with a combining function.\n--\n-- > unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]\n\nunionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a\nunionWith f m1 m2\n  = unionWithKey (\\_ x y -> f x y) m1 m2\n\n-- | \\(O(n+m)\\). The union with a combining function.\n--\n-- > let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value\n-- > unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]\n\nunionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a\nunionWithKey f m1 m2\n  = mergeWithKey\' Bin (\\(Tip k1 x1) (Tip _k2 x2) -> Tip k1 (f k1 x1 x2)) id id m1 m2\n\n{--------------------------------------------------------------------\n  Difference\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). Difference between two maps (based on keys).\n--\n-- > difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"\n\ndifference :: IntMap a -> IntMap b -> IntMap a\ndifference m1 m2\n  = mergeWithKey (\\_ _ _ -> Nothing) id (const Nil) m1 m2\n\n-- | \\(O(n+m)\\). Difference with a combining function.\n--\n-- > let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing\n-- > differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])\n-- >     == singleton 3 "b:B"\n\ndifferenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a\ndifferenceWith f m1 m2\n  = differenceWithKey (\\_ x y -> f x y) m1 m2\n\n-- | \\(O(n+m)\\). Difference with a combining function. When two equal keys are\n-- encountered, the combining function is applied to the key and both values.\n-- If it returns \'Nothing\', the element is discarded (proper set difference).\n-- If it returns (@\'Just\' y@), the element is updated with a new value @y@.\n--\n-- > let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing\n-- > differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])\n-- >     == singleton 3 "3:b|B"\n\ndifferenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a\ndifferenceWithKey f m1 m2\n  = mergeWithKey f id (const Nil) m1 m2\n\n\n-- TODO(wrengr): re-verify that asymptotic bound\n-- | \\(O(n+m)\\). Remove all the keys in a given set from a map.\n--\n-- @\n-- m \\`withoutKeys\\` s = \'filterWithKey\' (\\\\k _ -> k ``IntSet.notMember`` s) m\n-- @\n--\n-- @since 0.5.8\nwithoutKeys :: IntMap a -> IntSet.IntSet -> IntMap a\nwithoutKeys t1@(Bin p1 m1 l1 r1) t2@(IntSet.Bin p2 m2 l2 r2)\n    | shorter m1 m2  = difference1\n    | shorter m2 m1  = difference2\n    | p1 == p2       = bin p1 m1 (withoutKeys l1 l2) (withoutKeys r1 r2)\n    | otherwise      = t1\n    where\n    difference1\n        | nomatch p2 p1 m1  = t1\n        | zero p2 m1        = binCheckLeft p1 m1 (withoutKeys l1 t2) r1\n        | otherwise         = binCheckRight p1 m1 l1 (withoutKeys r1 t2)\n    difference2\n        | nomatch p1 p2 m2  = t1\n        | zero p1 m2        = withoutKeys t1 l2\n        | otherwise         = withoutKeys t1 r2\nwithoutKeys t1@(Bin p1 m1 _ _) (IntSet.Tip p2 bm2) =\n    let minbit = bitmapOf p1\n        lt_minbit = minbit - 1\n        maxbit = bitmapOf (p1 .|. (m1 .|. (m1 - 1)))\n        gt_maxbit = (-maxbit) `xor` maxbit\n    -- TODO(wrengr): should we manually inline/unroll \'updatePrefix\'\n    -- and \'withoutBM\' here, in order to avoid redundant case analyses?\n    in updatePrefix p2 t1 $ withoutBM (bm2 .|. lt_minbit .|. gt_maxbit)\nwithoutKeys t1@(Bin _ _ _ _) IntSet.Nil = t1\nwithoutKeys t1@(Tip k1 _) t2\n    | k1 `IntSet.member` t2 = Nil\n    | otherwise = t1\nwithoutKeys Nil _ = Nil\n\n\nupdatePrefix\n    :: IntSetPrefix -> IntMap a -> (IntMap a -> IntMap a) -> IntMap a\nupdatePrefix !kp t@(Bin p m l r) f\n    | m .&. IntSet.suffixBitMask /= 0 =\n        if p .&. IntSet.prefixBitMask == kp then f t else t\n    | nomatch kp p m = t\n    | zero kp m      = binCheckLeft p m (updatePrefix kp l f) r\n    | otherwise      = binCheckRight p m l (updatePrefix kp r f)\nupdatePrefix kp t@(Tip kx _) f\n    | kx .&. IntSet.prefixBitMask == kp = f t\n    | otherwise = t\nupdatePrefix _ Nil _ = Nil\n\n\nwithoutBM :: IntSetBitMap -> IntMap a -> IntMap a\nwithoutBM 0 t = t\nwithoutBM bm (Bin p m l r) =\n    let leftBits = bitmapOf (p .|. m) - 1\n        bmL = bm .&. leftBits\n        bmR = bm `xor` bmL -- = (bm .&. complement leftBits)\n    in  bin p m (withoutBM bmL l) (withoutBM bmR r)\nwithoutBM bm t@(Tip k _)\n    -- TODO(wrengr): need we manually inline \'IntSet.Member\' here?\n    | k `IntSet.member` IntSet.Tip (k .&. IntSet.prefixBitMask) bm = Nil\n    | otherwise = t\nwithoutBM _ Nil = Nil\n\n\n{--------------------------------------------------------------------\n  Intersection\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). The (left-biased) intersection of two maps (based on keys).\n--\n-- > intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"\n\nintersection :: IntMap a -> IntMap b -> IntMap a\nintersection m1 m2\n  = mergeWithKey\' bin const (const Nil) (const Nil) m1 m2\n\n\n-- TODO(wrengr): re-verify that asymptotic bound\n-- | \\(O(n+m)\\). The restriction of a map to the keys in a set.\n--\n-- @\n-- m \\`restrictKeys\\` s = \'filterWithKey\' (\\\\k _ -> k ``IntSet.member`` s) m\n-- @\n--\n-- @since 0.5.8\nrestrictKeys :: IntMap a -> IntSet.IntSet -> IntMap a\nrestrictKeys t1@(Bin p1 m1 l1 r1) t2@(IntSet.Bin p2 m2 l2 r2)\n    | shorter m1 m2  = intersection1\n    | shorter m2 m1  = intersection2\n    | p1 == p2       = bin p1 m1 (restrictKeys l1 l2) (restrictKeys r1 r2)\n    | otherwise      = Nil\n    where\n    intersection1\n        | nomatch p2 p1 m1  = Nil\n        | zero p2 m1        = restrictKeys l1 t2\n        | otherwise         = restrictKeys r1 t2\n    intersection2\n        | nomatch p1 p2 m2  = Nil\n        | zero p1 m2        = restrictKeys t1 l2\n        | otherwise         = restrictKeys t1 r2\nrestrictKeys t1@(Bin p1 m1 _ _) (IntSet.Tip p2 bm2) =\n    let minbit = bitmapOf p1\n        ge_minbit = complement (minbit - 1)\n        maxbit = bitmapOf (p1 .|. (m1 .|. (m1 - 1)))\n        le_maxbit = maxbit .|. (maxbit - 1)\n    -- TODO(wrengr): should we manually inline/unroll \'lookupPrefix\'\n    -- and \'restrictBM\' here, in order to avoid redundant case analyses?\n    in restrictBM (bm2 .&. ge_minbit .&. le_maxbit) (lookupPrefix p2 t1)\nrestrictKeys (Bin _ _ _ _) IntSet.Nil = Nil\nrestrictKeys t1@(Tip k1 _) t2\n    | k1 `IntSet.member` t2 = t1\n    | otherwise = Nil\nrestrictKeys Nil _ = Nil\n\n\n-- | \\(O(\\min(n,W))\\). Restrict to the sub-map with all keys matching\n-- a key prefix.\nlookupPrefix :: IntSetPrefix -> IntMap a -> IntMap a\nlookupPrefix !kp t@(Bin p m l r)\n    | m .&. IntSet.suffixBitMask /= 0 =\n        if p .&. IntSet.prefixBitMask == kp then t else Nil\n    | nomatch kp p m = Nil\n    | zero kp m      = lookupPrefix kp l\n    | otherwise      = lookupPrefix kp r\nlookupPrefix kp t@(Tip kx _)\n    | (kx .&. IntSet.prefixBitMask) == kp = t\n    | otherwise = Nil\nlookupPrefix _ Nil = Nil\n\n\nrestrictBM :: IntSetBitMap -> IntMap a -> IntMap a\nrestrictBM 0 _ = Nil\nrestrictBM bm (Bin p m l r) =\n    let leftBits = bitmapOf (p .|. m) - 1\n        bmL = bm .&. leftBits\n        bmR = bm `xor` bmL -- = (bm .&. complement leftBits)\n    in  bin p m (restrictBM bmL l) (restrictBM bmR r)\nrestrictBM bm t@(Tip k _)\n    -- TODO(wrengr): need we manually inline \'IntSet.Member\' here?\n    | k `IntSet.member` IntSet.Tip (k .&. IntSet.prefixBitMask) bm = t\n    | otherwise = Nil\nrestrictBM _ Nil = Nil\n\n\n-- | \\(O(n+m)\\). The intersection with a combining function.\n--\n-- > intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"\n\nintersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c\nintersectionWith f m1 m2\n  = intersectionWithKey (\\_ x y -> f x y) m1 m2\n\n-- | \\(O(n+m)\\). The intersection with a combining function.\n--\n-- > let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar\n-- > intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"\n\nintersectionWithKey :: (Key -> a -> b -> c) -> IntMap a -> IntMap b -> IntMap c\nintersectionWithKey f m1 m2\n  = mergeWithKey\' bin (\\(Tip k1 x1) (Tip _k2 x2) -> Tip k1 (f k1 x1 x2)) (const Nil) (const Nil) m1 m2\n\n{--------------------------------------------------------------------\n  MergeWithKey\n--------------------------------------------------------------------}\n\n-- | \\(O(n+m)\\). A high-performance universal combining function. Using\n-- \'mergeWithKey\', all combining functions can be defined without any loss of\n-- efficiency (with exception of \'union\', \'difference\' and \'intersection\',\n-- where sharing of some nodes is lost with \'mergeWithKey\').\n--\n-- Please make sure you know what is going on when using \'mergeWithKey\',\n-- otherwise you can be surprised by unexpected code growth or even\n-- corruption of the data structure.\n--\n-- When \'mergeWithKey\' is given three arguments, it is inlined to the call\n-- site. You should therefore use \'mergeWithKey\' only to define your custom\n-- combining functions. For example, you could define \'unionWithKey\',\n-- \'differenceWithKey\' and \'intersectionWithKey\' as\n--\n-- > myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) id id m1 m2\n-- > myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n-- > myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -> Just (f k x1 x2)) (const empty) (const empty) m1 m2\n--\n-- When calling @\'mergeWithKey\' combine only1 only2@, a function combining two\n-- \'IntMap\'s is created, such that\n--\n-- * if a key is present in both maps, it is passed with both corresponding\n--   values to the @combine@ function. Depending on the result, the key is either\n--   present in the result with specified value, or is left out;\n--\n-- * a nonempty subtree present only in the first map is passed to @only1@ and\n--   the output is added to the result;\n--\n-- * a nonempty subtree present only in the second map is passed to @only2@ and\n--   the output is added to the result.\n--\n-- The @only1@ and @only2@ methods /must return a map with a subset (possibly empty) of the keys of the given map/.\n-- The values can be modified arbitrarily. Most common variants of @only1@ and\n-- @only2@ are \'id\' and @\'const\' \'empty\'@, but for example @\'map\' f@ or\n-- @\'filterWithKey\' f@ could be used for any @f@.\n\nmergeWithKey :: (Key -> a -> b -> Maybe c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c)\n             -> IntMap a -> IntMap b -> IntMap c\nmergeWithKey f g1 g2 = mergeWithKey\' bin combine g1 g2\n  where -- We use the lambda form to avoid non-exhaustive pattern matches warning.\n        combine = \\(Tip k1 x1) (Tip _k2 x2) ->\n          case f k1 x1 x2 of\n            Nothing -> Nil\n            Just x -> Tip k1 x\n        {-# INLINE combine #-}\n{-# INLINE mergeWithKey #-}\n\n-- Slightly more general version of mergeWithKey. It differs in the following:\n--\n-- * the combining function operates on maps instead of keys and values. The\n--   reason is to enable sharing in union, difference and intersection.\n--\n-- * mergeWithKey\' is given an equivalent of bin. The reason is that in union*,\n--   Bin constructor can be used, because we know both subtrees are nonempty.\n\nmergeWithKey\' :: (Prefix -> Mask -> IntMap c -> IntMap c -> IntMap c)\n              -> (IntMap a -> IntMap b -> IntMap c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c)\n              -> IntMap a -> IntMap b -> IntMap c\nmergeWithKey\' bin\' f g1 g2 = go\n  where\n    go t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n      | shorter m1 m2  = merge1\n      | shorter m2 m1  = merge2\n      | p1 == p2       = bin\' p1 m1 (go l1 l2) (go r1 r2)\n      | otherwise      = maybe_link p1 (g1 t1) p2 (g2 t2)\n      where\n        merge1 | nomatch p2 p1 m1  = maybe_link p1 (g1 t1) p2 (g2 t2)\n               | zero p2 m1        = bin\' p1 m1 (go l1 t2) (g1 r1)\n               | otherwise         = bin\' p1 m1 (g1 l1) (go r1 t2)\n        merge2 | nomatch p1 p2 m2  = maybe_link p1 (g1 t1) p2 (g2 t2)\n               | zero p1 m2        = bin\' p2 m2 (go t1 l2) (g2 r2)\n               | otherwise         = bin\' p2 m2 (g2 l2) (go t1 r2)\n\n    go t1\'@(Bin _ _ _ _) t2\'@(Tip k2\' _) = merge0 t2\' k2\' t1\'\n      where\n        merge0 t2 k2 t1@(Bin p1 m1 l1 r1)\n          | nomatch k2 p1 m1 = maybe_link p1 (g1 t1) k2 (g2 t2)\n          | zero k2 m1 = bin\' p1 m1 (merge0 t2 k2 l1) (g1 r1)\n          | otherwise  = bin\' p1 m1 (g1 l1) (merge0 t2 k2 r1)\n        merge0 t2 k2 t1@(Tip k1 _)\n          | k1 == k2 = f t1 t2\n          | otherwise = maybe_link k1 (g1 t1) k2 (g2 t2)\n        merge0 t2 _  Nil = g2 t2\n\n    go t1@(Bin _ _ _ _) Nil = g1 t1\n\n    go t1\'@(Tip k1\' _) t2\' = merge0 t1\' k1\' t2\'\n      where\n        merge0 t1 k1 t2@(Bin p2 m2 l2 r2)\n          | nomatch k1 p2 m2 = maybe_link k1 (g1 t1) p2 (g2 t2)\n          | zero k1 m2 = bin\' p2 m2 (merge0 t1 k1 l2) (g2 r2)\n          | otherwise  = bin\' p2 m2 (g2 l2) (merge0 t1 k1 r2)\n        merge0 t1 k1 t2@(Tip k2 _)\n          | k1 == k2 = f t1 t2\n          | otherwise = maybe_link k1 (g1 t1) k2 (g2 t2)\n        merge0 t1 _  Nil = g1 t1\n\n    go Nil t2 = g2 t2\n\n    maybe_link _ Nil _ t2 = t2\n    maybe_link _ t1 _ Nil = t1\n    maybe_link p1 t1 p2 t2 = link p1 t1 p2 t2\n    {-# INLINE maybe_link #-}\n{-# INLINE mergeWithKey\' #-}\n\n\n{--------------------------------------------------------------------\n  mergeA\n--------------------------------------------------------------------}\n\n-- | A tactic for dealing with keys present in one map but not the\n-- other in \'merge\' or \'mergeA\'.\n--\n-- A tactic of type @WhenMissing f k x z@ is an abstract representation\n-- of a function of type @Key -> x -> f (Maybe z)@.\n--\n-- @since 0.5.9\n\ndata WhenMissing f x y = WhenMissing\n  { missingSubtree :: IntMap x -> f (IntMap y)\n  , missingKey :: Key -> x -> f (Maybe y)}\n\n-- | @since 0.5.9\ninstance (Applicative f, Monad f) => Functor (WhenMissing f x) where\n  fmap = mapWhenMissing\n  {-# INLINE fmap #-}\n\n\n-- | @since 0.5.9\ninstance (Applicative f, Monad f) => Category.Category (WhenMissing f)\n  where\n    id = preserveMissing\n    f . g =\n      traverseMaybeMissing $ \\ k x -> do\n        y <- missingKey g k x\n        case y of\n          Nothing -> pure Nothing\n          Just q  -> missingKey f k q\n    {-# INLINE id #-}\n    {-# INLINE (.) #-}\n\n\n-- | Equivalent to @ReaderT k (ReaderT x (MaybeT f))@.\n--\n-- @since 0.5.9\ninstance (Applicative f, Monad f) => Applicative (WhenMissing f x) where\n  pure x = mapMissing (\\ _ _ -> x)\n  f <*> g =\n    traverseMaybeMissing $ \\k x -> do\n      res1 <- missingKey f k x\n      case res1 of\n        Nothing -> pure Nothing\n        Just r  -> (pure $!) . fmap r =<< missingKey g k x\n  {-# INLINE pure #-}\n  {-# INLINE (<*>) #-}\n\n\n-- | Equivalent to @ReaderT k (ReaderT x (MaybeT f))@.\n--\n-- @since 0.5.9\ninstance (Applicative f, Monad f) => Monad (WhenMissing f x) where\n  m >>= f =\n    traverseMaybeMissing $ \\k x -> do\n      res1 <- missingKey m k x\n      case res1 of\n        Nothing -> pure Nothing\n        Just r  -> missingKey (f r) k x\n  {-# INLINE (>>=) #-}\n\n\n-- | Map covariantly over a @\'WhenMissing\' f x@.\n--\n-- @since 0.5.9\nmapWhenMissing\n  :: (Applicative f, Monad f)\n  => (a -> b)\n  -> WhenMissing f x a\n  -> WhenMissing f x b\nmapWhenMissing f t = WhenMissing\n  { missingSubtree = \\m -> missingSubtree t m >>= \\m\' -> pure $! fmap f m\'\n  , missingKey     = \\k x -> missingKey t k x >>= \\q -> (pure $! fmap f q) }\n{-# INLINE mapWhenMissing #-}\n\n\n-- | Map covariantly over a @\'WhenMissing\' f x@, using only a\n-- \'Functor f\' constraint.\nmapGentlyWhenMissing\n  :: Functor f\n  => (a -> b)\n  -> WhenMissing f x a\n  -> WhenMissing f x b\nmapGentlyWhenMissing f t = WhenMissing\n  { missingSubtree = \\m -> fmap f <$> missingSubtree t m\n  , missingKey     = \\k x -> fmap f <$> missingKey t k x }\n{-# INLINE mapGentlyWhenMissing #-}\n\n\n-- | Map covariantly over a @\'WhenMatched\' f k x@, using only a\n-- \'Functor f\' constraint.\nmapGentlyWhenMatched\n  :: Functor f\n  => (a -> b)\n  -> WhenMatched f x y a\n  -> WhenMatched f x y b\nmapGentlyWhenMatched f t =\n  zipWithMaybeAMatched $ \\k x y -> fmap f <$> runWhenMatched t k x y\n{-# INLINE mapGentlyWhenMatched #-}\n\n\n-- | Map contravariantly over a @\'WhenMissing\' f _ x@.\n--\n-- @since 0.5.9\nlmapWhenMissing :: (b -> a) -> WhenMissing f a x -> WhenMissing f b x\nlmapWhenMissing f t = WhenMissing\n  { missingSubtree = \\m -> missingSubtree t (fmap f m)\n  , missingKey     = \\k x -> missingKey t k (f x) }\n{-# INLINE lmapWhenMissing #-}\n\n\n-- | Map contravariantly over a @\'WhenMatched\' f _ y z@.\n--\n-- @since 0.5.9\ncontramapFirstWhenMatched\n  :: (b -> a)\n  -> WhenMatched f a y z\n  -> WhenMatched f b y z\ncontramapFirstWhenMatched f t =\n  WhenMatched $ \\k x y -> runWhenMatched t k (f x) y\n{-# INLINE contramapFirstWhenMatched #-}\n\n\n-- | Map contravariantly over a @\'WhenMatched\' f x _ z@.\n--\n-- @since 0.5.9\ncontramapSecondWhenMatched\n  :: (b -> a)\n  -> WhenMatched f x a z\n  -> WhenMatched f x b z\ncontramapSecondWhenMatched f t =\n  WhenMatched $ \\k x y -> runWhenMatched t k x (f y)\n{-# INLINE contramapSecondWhenMatched #-}\n\n\n-- | A tactic for dealing with keys present in one map but not the\n-- other in \'merge\'.\n--\n-- A tactic of type @SimpleWhenMissing x z@ is an abstract\n-- representation of a function of type @Key -> x -> Maybe z@.\n--\n-- @since 0.5.9\ntype SimpleWhenMissing = WhenMissing Identity\n\n\n-- | A tactic for dealing with keys present in both maps in \'merge\'\n-- or \'mergeA\'.\n--\n-- A tactic of type @WhenMatched f x y z@ is an abstract representation\n-- of a function of type @Key -> x -> y -> f (Maybe z)@.\n--\n-- @since 0.5.9\nnewtype WhenMatched f x y z = WhenMatched\n  { matchedKey :: Key -> x -> y -> f (Maybe z) }\n\n\n-- | Along with zipWithMaybeAMatched, witnesses the isomorphism\n-- between @WhenMatched f x y z@ and @Key -> x -> y -> f (Maybe z)@.\n--\n-- @since 0.5.9\nrunWhenMatched :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)\nrunWhenMatched = matchedKey\n{-# INLINE runWhenMatched #-}\n\n\n-- | Along with traverseMaybeMissing, witnesses the isomorphism\n-- between @WhenMissing f x y@ and @Key -> x -> f (Maybe y)@.\n--\n-- @since 0.5.9\nrunWhenMissing :: WhenMissing f x y -> Key-> x -> f (Maybe y)\nrunWhenMissing = missingKey\n{-# INLINE runWhenMissing #-}\n\n\n-- | @since 0.5.9\ninstance Functor f => Functor (WhenMatched f x y) where\n  fmap = mapWhenMatched\n  {-# INLINE fmap #-}\n\n\n-- | @since 0.5.9\ninstance (Monad f, Applicative f) => Category.Category (WhenMatched f x)\n  where\n    id = zipWithMatched (\\_ _ y -> y)\n    f . g =\n      zipWithMaybeAMatched $ \\k x y -> do\n        res <- runWhenMatched g k x y\n        case res of\n          Nothing -> pure Nothing\n          Just r  -> runWhenMatched f k x r\n    {-# INLINE id #-}\n    {-# INLINE (.) #-}\n\n\n-- | Equivalent to @ReaderT Key (ReaderT x (ReaderT y (MaybeT f)))@\n--\n-- @since 0.5.9\ninstance (Monad f, Applicative f) => Applicative (WhenMatched f x y) where\n  pure x = zipWithMatched (\\_ _ _ -> x)\n  fs <*> xs =\n    zipWithMaybeAMatched $ \\k x y -> do\n      res <- runWhenMatched fs k x y\n      case res of\n        Nothing -> pure Nothing\n        Just r  -> (pure $!) . fmap r =<< runWhenMatched xs k x y\n  {-# INLINE pure #-}\n  {-# INLINE (<*>) #-}\n\n\n-- | Equivalent to @ReaderT Key (ReaderT x (ReaderT y (MaybeT f)))@\n--\n-- @since 0.5.9\ninstance (Monad f, Applicative f) => Monad (WhenMatched f x y) where\n  m >>= f =\n    zipWithMaybeAMatched $ \\k x y -> do\n      res <- runWhenMatched m k x y\n      case res of\n        Nothing -> pure Nothing\n        Just r  -> runWhenMatched (f r) k x y\n  {-# INLINE (>>=) #-}\n\n\n-- | Map covariantly over a @\'WhenMatched\' f x y@.\n--\n-- @since 0.5.9\nmapWhenMatched\n  :: Functor f\n  => (a -> b)\n  -> WhenMatched f x y a\n  -> WhenMatched f x y b\nmapWhenMatched f (WhenMatched g) =\n  WhenMatched $ \\k x y -> fmap (fmap f) (g k x y)\n{-# INLINE mapWhenMatched #-}\n\n\n-- | A tactic for dealing with keys present in both maps in \'merge\'.\n--\n-- A tactic of type @SimpleWhenMatched x y z@ is an abstract\n-- representation of a function of type @Key -> x -> y -> Maybe z@.\n--\n-- @since 0.5.9\ntype SimpleWhenMatched = WhenMatched Identity\n\n\n-- | When a key is found in both maps, apply a function to the key\n-- and values and use the result in the merged map.\n--\n-- > zipWithMatched\n-- >   :: (Key -> x -> y -> z)\n-- >   -> SimpleWhenMatched x y z\n--\n-- @since 0.5.9\nzipWithMatched\n  :: Applicative f\n  => (Key -> x -> y -> z)\n  -> WhenMatched f x y z\nzipWithMatched f = WhenMatched $ \\ k x y -> pure . Just $ f k x y\n{-# INLINE zipWithMatched #-}\n\n\n-- | When a key is found in both maps, apply a function to the key\n-- and values to produce an action and use its result in the merged\n-- map.\n--\n-- @since 0.5.9\nzipWithAMatched\n  :: Applicative f\n  => (Key -> x -> y -> f z)\n  -> WhenMatched f x y z\nzipWithAMatched f = WhenMatched $ \\ k x y -> Just <$> f k x y\n{-# INLINE zipWithAMatched #-}\n\n\n-- | When a key is found in both maps, apply a function to the key\n-- and values and maybe use the result in the merged map.\n--\n-- > zipWithMaybeMatched\n-- >   :: (Key -> x -> y -> Maybe z)\n-- >   -> SimpleWhenMatched x y z\n--\n-- @since 0.5.9\nzipWithMaybeMatched\n  :: Applicative f\n  => (Key -> x -> y -> Maybe z)\n  -> WhenMatched f x y z\nzipWithMaybeMatched f = WhenMatched $ \\ k x y -> pure $ f k x y\n{-# INLINE zipWithMaybeMatched #-}\n\n\n-- | When a key is found in both maps, apply a function to the key\n-- and values, perform the resulting action, and maybe use the\n-- result in the merged map.\n--\n-- This is the fundamental \'WhenMatched\' tactic.\n--\n-- @since 0.5.9\nzipWithMaybeAMatched\n  :: (Key -> x -> y -> f (Maybe z))\n  -> WhenMatched f x y z\nzipWithMaybeAMatched f = WhenMatched $ \\ k x y -> f k x y\n{-# INLINE zipWithMaybeAMatched #-}\n\n\n-- | Drop all the entries whose keys are missing from the other\n-- map.\n--\n-- > dropMissing :: SimpleWhenMissing x y\n--\n-- prop> dropMissing = mapMaybeMissing (\\_ _ -> Nothing)\n--\n-- but @dropMissing@ is much faster.\n--\n-- @since 0.5.9\ndropMissing :: Applicative f => WhenMissing f x y\ndropMissing = WhenMissing\n  { missingSubtree = const (pure Nil)\n  , missingKey     = \\_ _ -> pure Nothing }\n{-# INLINE dropMissing #-}\n\n\n-- | Preserve, unchanged, the entries whose keys are missing from\n-- the other map.\n--\n-- > preserveMissing :: SimpleWhenMissing x x\n--\n-- prop> preserveMissing = Merge.Lazy.mapMaybeMissing (\\_ x -> Just x)\n--\n-- but @preserveMissing@ is much faster.\n--\n-- @since 0.5.9\npreserveMissing :: Applicative f => WhenMissing f x x\npreserveMissing = WhenMissing\n  { missingSubtree = pure\n  , missingKey     = \\_ v -> pure (Just v) }\n{-# INLINE preserveMissing #-}\n\n\n-- | Map over the entries whose keys are missing from the other map.\n--\n-- > mapMissing :: (k -> x -> y) -> SimpleWhenMissing x y\n--\n-- prop> mapMissing f = mapMaybeMissing (\\k x -> Just $ f k x)\n--\n-- but @mapMissing@ is somewhat faster.\n--\n-- @since 0.5.9\nmapMissing :: Applicative f => (Key -> x -> y) -> WhenMissing f x y\nmapMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapWithKey f m\n  , missingKey     = \\k x -> pure $ Just (f k x) }\n{-# INLINE mapMissing #-}\n\n\n-- | Map over the entries whose keys are missing from the other\n-- map, optionally removing some. This is the most powerful\n-- \'SimpleWhenMissing\' tactic, but others are usually more efficient.\n--\n-- > mapMaybeMissing :: (Key -> x -> Maybe y) -> SimpleWhenMissing x y\n--\n-- prop> mapMaybeMissing f = traverseMaybeMissing (\\k x -> pure (f k x))\n--\n-- but @mapMaybeMissing@ uses fewer unnecessary \'Applicative\'\n-- operations.\n--\n-- @since 0.5.9\nmapMaybeMissing\n  :: Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y\nmapMaybeMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! mapMaybeWithKey f m\n  , missingKey     = \\k x -> pure $! f k x }\n{-# INLINE mapMaybeMissing #-}\n\n\n-- | Filter the entries whose keys are missing from the other map.\n--\n-- > filterMissing :: (k -> x -> Bool) -> SimpleWhenMissing x x\n--\n-- prop> filterMissing f = Merge.Lazy.mapMaybeMissing $ \\k x -> guard (f k x) *> Just x\n--\n-- but this should be a little faster.\n--\n-- @since 0.5.9\nfilterMissing\n  :: Applicative f => (Key -> x -> Bool) -> WhenMissing f x x\nfilterMissing f = WhenMissing\n  { missingSubtree = \\m -> pure $! filterWithKey f m\n  , missingKey     = \\k x -> pure $! if f k x then Just x else Nothing }\n{-# INLINE filterMissing #-}\n\n\n-- | Filter the entries whose keys are missing from the other map\n-- using some \'Applicative\' action.\n--\n-- > filterAMissing f = Merge.Lazy.traverseMaybeMissing $\n-- >   \\k x -> (\\b -> guard b *> Just x) <$> f k x\n--\n-- but this should be a little faster.\n--\n-- @since 0.5.9\nfilterAMissing\n  :: Applicative f => (Key -> x -> f Bool) -> WhenMissing f x x\nfilterAMissing f = WhenMissing\n  { missingSubtree = \\m -> filterWithKeyA f m\n  , missingKey     = \\k x -> bool Nothing (Just x) <$> f k x }\n{-# INLINE filterAMissing #-}\n\n\n-- | \\(O(n)\\). Filter keys and values using an \'Applicative\' predicate.\nfilterWithKeyA\n  :: Applicative f => (Key -> a -> f Bool) -> IntMap a -> f (IntMap a)\nfilterWithKeyA _ Nil           = pure Nil\nfilterWithKeyA f t@(Tip k x)   = (\\b -> if b then t else Nil) <$> f k x\nfilterWithKeyA f (Bin p m l r)\n  | m < 0     = liftA2 (flip (bin p m)) (filterWithKeyA f r) (filterWithKeyA f l)\n  | otherwise = liftA2 (bin p m) (filterWithKeyA f l) (filterWithKeyA f r)\n\n-- | This wasn\'t in Data.Bool until 4.7.0, so we define it here\nbool :: a -> a -> Bool -> a\nbool f _ False = f\nbool _ t True  = t\n\n\n-- | Traverse over the entries whose keys are missing from the other\n-- map.\n--\n-- @since 0.5.9\ntraverseMissing\n  :: Applicative f => (Key -> x -> f y) -> WhenMissing f x y\ntraverseMissing f = WhenMissing\n  { missingSubtree = traverseWithKey f\n  , missingKey = \\k x -> Just <$> f k x }\n{-# INLINE traverseMissing #-}\n\n\n-- | Traverse over the entries whose keys are missing from the other\n-- map, optionally producing values to put in the result. This is\n-- the most powerful \'WhenMissing\' tactic, but others are usually\n-- more efficient.\n--\n-- @since 0.5.9\ntraverseMaybeMissing\n  :: Applicative f => (Key -> x -> f (Maybe y)) -> WhenMissing f x y\ntraverseMaybeMissing f = WhenMissing\n  { missingSubtree = traverseMaybeWithKey f\n  , missingKey = f }\n{-# INLINE traverseMaybeMissing #-}\n\n\n-- | \\(O(n)\\). Traverse keys\\/values and collect the \'Just\' results.\n--\n-- @since 0.6.4\ntraverseMaybeWithKey\n  :: Applicative f => (Key -> a -> f (Maybe b)) -> IntMap a -> f (IntMap b)\ntraverseMaybeWithKey f = go\n    where\n    go Nil           = pure Nil\n    go (Tip k x)     = maybe Nil (Tip k) <$> f k x\n    go (Bin p m l r)\n      | m < 0     = liftA2 (flip (bin p m)) (go r) (go l)\n      | otherwise = liftA2 (bin p m) (go l) (go r)\n\n\n-- | Merge two maps.\n--\n-- \'merge\' takes two \'WhenMissing\' tactics, a \'WhenMatched\' tactic\n-- and two maps. It uses the tactics to merge the maps. Its behavior\n-- is best understood via its fundamental tactics, \'mapMaybeMissing\'\n-- and \'zipWithMaybeMatched\'.\n--\n-- Consider\n--\n-- @\n-- merge (mapMaybeMissing g1)\n--              (mapMaybeMissing g2)\n--              (zipWithMaybeMatched f)\n--              m1 m2\n-- @\n--\n-- Take, for example,\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'), (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 = [(1, "one"), (2, "two"), (4, "three")]\n-- @\n--\n-- \'merge\' will first \\"align\\" these maps by key:\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'),               (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 =           [(1, "one"), (2, "two"),           (4, "three")]\n-- @\n--\n-- It will then pass the individual entries and pairs of entries\n-- to @g1@, @g2@, or @f@ as appropriate:\n--\n-- @\n-- maybes = [g1 0 \\\'a\\\', f 1 \\\'b\\\' "one", g2 2 "two", g1 3 \\\'c\\\', f 4 \\\'d\\\' "three"]\n-- @\n--\n-- This produces a \'Maybe\' for each key:\n--\n-- @\n-- keys =     0        1          2           3        4\n-- results = [Nothing, Just True, Just False, Nothing, Just True]\n-- @\n--\n-- Finally, the @Just@ results are collected into a map:\n--\n-- @\n-- return value = [(1, True), (2, False), (4, True)]\n-- @\n--\n-- The other tactics below are optimizations or simplifications of\n-- \'mapMaybeMissing\' for special cases. Most importantly,\n--\n-- * \'dropMissing\' drops all the keys.\n-- * \'preserveMissing\' leaves all the entries alone.\n--\n-- When \'merge\' is given three arguments, it is inlined at the call\n-- site. To prevent excessive inlining, you should typically use\n-- \'merge\' to define your custom combining functions.\n--\n--\n-- Examples:\n--\n-- prop> unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)\n-- prop> intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)\n-- prop> differenceWith f = merge diffPreserve diffDrop f\n-- prop> symmetricDifference = merge diffPreserve diffPreserve (\\ _ _ _ -> Nothing)\n-- prop> mapEachPiece f g h = merge (diffMapWithKey f) (diffMapWithKey g)\n--\n-- @since 0.5.9\nmerge\n  :: SimpleWhenMissing a c -- ^ What to do with keys in @m1@ but not @m2@\n  -> SimpleWhenMissing b c -- ^ What to do with keys in @m2@ but not @m1@\n  -> SimpleWhenMatched a b c -- ^ What to do with keys in both @m1@ and @m2@\n  -> IntMap a -- ^ Map @m1@\n  -> IntMap b -- ^ Map @m2@\n  -> IntMap c\nmerge g1 g2 f m1 m2 =\n  runIdentity $ mergeA g1 g2 f m1 m2\n{-# INLINE merge #-}\n\n\n-- | An applicative version of \'merge\'.\n--\n-- \'mergeA\' takes two \'WhenMissing\' tactics, a \'WhenMatched\'\n-- tactic and two maps. It uses the tactics to merge the maps.\n-- Its behavior is best understood via its fundamental tactics,\n-- \'traverseMaybeMissing\' and \'zipWithMaybeAMatched\'.\n--\n-- Consider\n--\n-- @\n-- mergeA (traverseMaybeMissing g1)\n--               (traverseMaybeMissing g2)\n--               (zipWithMaybeAMatched f)\n--               m1 m2\n-- @\n--\n-- Take, for example,\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'), (3,\\\'c\\\'), (4, \\\'d\\\')]\n-- m2 = [(1, "one"), (2, "two"), (4, "three")]\n-- @\n--\n-- \'mergeA\' will first \\"align\\" these maps by key:\n--\n-- @\n-- m1 = [(0, \\\'a\\\'), (1, \\\'b\\\'),               (3, \\\'c\\\'), (4, \\\'d\\\')]\n-- m2 =           [(1, "one"), (2, "two"),           (4, "three")]\n-- @\n--\n-- It will then pass the individual entries and pairs of entries\n-- to @g1@, @g2@, or @f@ as appropriate:\n--\n-- @\n-- actions = [g1 0 \\\'a\\\', f 1 \\\'b\\\' "one", g2 2 "two", g1 3 \\\'c\\\', f 4 \\\'d\\\' "three"]\n-- @\n--\n-- Next, it will perform the actions in the @actions@ list in order from\n-- left to right.\n--\n-- @\n-- keys =     0        1          2           3        4\n-- results = [Nothing, Just True, Just False, Nothing, Just True]\n-- @\n--\n-- Finally, the @Just@ results are collected into a map:\n--\n-- @\n-- return value = [(1, True), (2, False), (4, True)]\n-- @\n--\n-- The other tactics below are optimizations or simplifications of\n-- \'traverseMaybeMissing\' for special cases. Most importantly,\n--\n-- * \'dropMissing\' drops all the keys.\n-- * \'preserveMissing\' leaves all the entries alone.\n-- * \'mapMaybeMissing\' does not use the \'Applicative\' context.\n--\n-- When \'mergeA\' is given three arguments, it is inlined at the call\n-- site. To prevent excessive inlining, you should generally only use\n-- \'mergeA\' to define custom combining functions.\n--\n-- @since 0.5.9\nmergeA\n  :: (Applicative f)\n  => WhenMissing f a c -- ^ What to do with keys in @m1@ but not @m2@\n  -> WhenMissing f b c -- ^ What to do with keys in @m2@ but not @m1@\n  -> WhenMatched f a b c -- ^ What to do with keys in both @m1@ and @m2@\n  -> IntMap a -- ^ Map @m1@\n  -> IntMap b -- ^ Map @m2@\n  -> f (IntMap c)\nmergeA\n    WhenMissing{missingSubtree = g1t, missingKey = g1k}\n    WhenMissing{missingSubtree = g2t, missingKey = g2k}\n    WhenMatched{matchedKey = f}\n    = go\n  where\n    go t1  Nil = g1t t1\n    go Nil t2  = g2t t2\n\n    -- This case is already covered below.\n    -- go (Tip k1 x1) (Tip k2 x2) = mergeTips k1 x1 k2 x2\n\n    go (Tip k1 x1) t2\' = merge2 t2\'\n      where\n        merge2 t2@(Bin p2 m2 l2 r2)\n          | nomatch k1 p2 m2 = linkA k1 (subsingletonBy g1k k1 x1) p2 (g2t t2)\n          | zero k1 m2       = binA p2 m2 (merge2 l2) (g2t r2)\n          | otherwise        = binA p2 m2 (g2t l2) (merge2 r2)\n        merge2 (Tip k2 x2)   = mergeTips k1 x1 k2 x2\n        merge2 Nil           = subsingletonBy g1k k1 x1\n\n    go t1\' (Tip k2 x2) = merge1 t1\'\n      where\n        merge1 t1@(Bin p1 m1 l1 r1)\n          | nomatch k2 p1 m1 = linkA p1 (g1t t1) k2 (subsingletonBy g2k k2 x2)\n          | zero k2 m1       = binA p1 m1 (merge1 l1) (g1t r1)\n          | otherwise        = binA p1 m1 (g1t l1) (merge1 r1)\n        merge1 (Tip k1 x1)   = mergeTips k1 x1 k2 x2\n        merge1 Nil           = subsingletonBy g2k k2 x2\n\n    go t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n      | shorter m1 m2  = merge1\n      | shorter m2 m1  = merge2\n      | p1 == p2       = binA p1 m1 (go l1 l2) (go r1 r2)\n      | otherwise      = linkA p1 (g1t t1) p2 (g2t t2)\n      where\n        merge1 | nomatch p2 p1 m1  = linkA p1 (g1t t1) p2 (g2t t2)\n               | zero p2 m1        = binA p1 m1 (go  l1 t2) (g1t r1)\n               | otherwise         = binA p1 m1 (g1t l1)    (go  r1 t2)\n        merge2 | nomatch p1 p2 m2  = linkA p1 (g1t t1) p2 (g2t t2)\n               | zero p1 m2        = binA p2 m2 (go  t1 l2) (g2t    r2)\n               | otherwise         = binA p2 m2 (g2t    l2) (go  t1 r2)\n\n    subsingletonBy gk k x = maybe Nil (Tip k) <$> gk k x\n    {-# INLINE subsingletonBy #-}\n\n    mergeTips k1 x1 k2 x2\n      | k1 == k2  = maybe Nil (Tip k1) <$> f k1 x1 x2\n      | k1 <  k2  = liftA2 (subdoubleton k1 k2) (g1k k1 x1) (g2k k2 x2)\n        {-\n        = link_ k1 k2 <$> subsingletonBy g1k k1 x1 <*> subsingletonBy g2k k2 x2\n        -}\n      | otherwise = liftA2 (subdoubleton k2 k1) (g2k k2 x2) (g1k k1 x1)\n    {-# INLINE mergeTips #-}\n\n    subdoubleton _ _   Nothing Nothing     = Nil\n    subdoubleton _ k2  Nothing (Just y2)   = Tip k2 y2\n    subdoubleton k1 _  (Just y1) Nothing   = Tip k1 y1\n    subdoubleton k1 k2 (Just y1) (Just y2) = link k1 (Tip k1 y1) k2 (Tip k2 y2)\n    {-# INLINE subdoubleton #-}\n\n    -- | A variant of \'link_\' which makes sure to execute side-effects\n    -- in the right order.\n    linkA\n        :: Applicative f\n        => Prefix -> f (IntMap a)\n        -> Prefix -> f (IntMap a)\n        -> f (IntMap a)\n    linkA p1 t1 p2 t2\n      | zero p1 m = binA p m t1 t2\n      | otherwise = binA p m t2 t1\n      where\n        m = branchMask p1 p2\n        p = mask p1 m\n    {-# INLINE linkA #-}\n\n    -- A variant of \'bin\' that ensures that effects for negative keys are executed\n    -- first.\n    binA\n        :: Applicative f\n        => Prefix\n        -> Mask\n        -> f (IntMap a)\n        -> f (IntMap a)\n        -> f (IntMap a)\n    binA p m a b\n      | m < 0     = liftA2 (flip (bin p m)) b a\n      | otherwise = liftA2       (bin p m)  a b\n    {-# INLINE binA #-}\n{-# INLINE mergeA #-}\n\n\n{--------------------------------------------------------------------\n  Min\\/Max\n--------------------------------------------------------------------}\n\n-- | \\(O(\\min(n,W))\\). Update the value at the minimal key.\n--\n-- > updateMinWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]\n-- > updateMinWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMinWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a\nupdateMinWithKey f t =\n  case t of Bin p m l r | m < 0 -> binCheckRight p m l (go f r)\n            _ -> go f t\n  where\n    go f\' (Bin p m l r) = binCheckLeft p m (go f\' l) r\n    go f\' (Tip k y) = case f\' k y of\n                        Just y\' -> Tip k y\'\n                        Nothing -> Nil\n    go _ Nil = error "updateMinWithKey Nil"\n\n-- | \\(O(\\min(n,W))\\). Update the value at the maximal key.\n--\n-- > updateMaxWithKey (\\ k a -> Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]\n-- > updateMaxWithKey (\\ _ _ -> Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMaxWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a\nupdateMaxWithKey f t =\n  case t of Bin p m l r | m < 0 -> binCheckLeft p m (go f l) r\n            _ -> go f t\n  where\n    go f\' (Bin p m l r) = binCheckRight p m l (go f\' r)\n    go f\' (Tip k y) = case f\' k y of\n                        Just y\' -> Tip k y\'\n                        Nothing -> Nil\n    go _ Nil = error "updateMaxWithKey Nil"\n\n\ndata View a = View {-# UNPACK #-} !Key a !(IntMap a)\n\n-- | \\(O(\\min(n,W))\\). Retrieves the maximal (key,value) pair of the map, and\n-- the map stripped of that element, or \'Nothing\' if passed an empty map.\n--\n-- > maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")\n-- > maxViewWithKey empty == Nothing\n\nmaxViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)\nmaxViewWithKey t = case t of\n  Nil -> Nothing\n  _ -> Just $ case maxViewWithKeySure t of\n                View k v t\' -> ((k, v), t\')\n{-# INLINE maxViewWithKey #-}\n\nmaxViewWithKeySure :: IntMap a -> View a\nmaxViewWithKeySure t =\n  case t of\n    Nil -> error "maxViewWithKeySure Nil"\n    Bin p m l r | m < 0 ->\n      case go l of View k a l\' -> View k a (binCheckLeft p m l\' r)\n    _ -> go t\n  where\n    go (Bin p m l r) =\n        case go r of View k a r\' -> View k a (binCheckRight p m l r\')\n    go (Tip k y) = View k y Nil\n    go Nil = error "maxViewWithKey_go Nil"\n-- See note on NOINLINE at minViewWithKeySure\n{-# NOINLINE maxViewWithKeySure #-}\n\n-- | \\(O(\\min(n,W))\\). Retrieves the minimal (key,value) pair of the map, and\n-- the map stripped of that element, or \'Nothing\' if passed an empty map.\n--\n-- > minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")\n-- > minViewWithKey empty == Nothing\n\nminViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)\nminViewWithKey t =\n  case t of\n    Nil -> Nothing\n    _ -> Just $ case minViewWithKeySure t of\n                  View k v t\' -> ((k, v), t\')\n-- We inline this to give GHC the best possible chance of\n-- getting rid of the Maybe, pair, and Int constructors, as\n-- well as a thunk under the Just. That is, we really want to\n-- be certain this inlines!\n{-# INLINE minViewWithKey #-}\n\nminViewWithKeySure :: IntMap a -> View a\nminViewWithKeySure t =\n  case t of\n    Nil -> error "minViewWithKeySure Nil"\n    Bin p m l r | m < 0 ->\n      case go r of\n        View k a r\' -> View k a (binCheckRight p m l r\')\n    _ -> go t\n  where\n    go (Bin p m l r) =\n        case go l of View k a l\' -> View k a (binCheckLeft p m l\' r)\n    go (Tip k y) = View k y Nil\n    go Nil = error "minViewWithKey_go Nil"\n-- There\'s never anything significant to be gained by inlining\n-- this. Sufficiently recent GHC versions will inline the wrapper\n-- anyway, which should be good enough.\n{-# NOINLINE minViewWithKeySure #-}\n\n-- | \\(O(\\min(n,W))\\). Update the value at the maximal key.\n--\n-- > updateMax (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]\n-- > updateMax (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n\nupdateMax :: (a -> Maybe a) -> IntMap a -> IntMap a\nupdateMax f = updateMaxWithKey (const f)\n\n-- | \\(O(\\min(n,W))\\). Update the value at the minimal key.\n--\n-- > updateMin (\\ a -> Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]\n-- > updateMin (\\ _ -> Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nupdateMin :: (a -> Maybe a) -> IntMap a -> IntMap a\nupdateMin f = updateMinWithKey (const f)\n\n-- | \\(O(\\min(n,W))\\). Retrieves the maximal key of the map, and the map\n-- stripped of that element, or \'Nothing\' if passed an empty map.\nmaxView :: IntMap a -> Maybe (a, IntMap a)\nmaxView t = fmap (\\((_, x), t\') -> (x, t\')) (maxViewWithKey t)\n\n-- | \\(O(\\min(n,W))\\). Retrieves the minimal key of the map, and the map\n-- stripped of that element, or \'Nothing\' if passed an empty map.\nminView :: IntMap a -> Maybe (a, IntMap a)\nminView t = fmap (\\((_, x), t\') -> (x, t\')) (minViewWithKey t)\n\n-- | \\(O(\\min(n,W))\\). Delete and find the maximal element.\n-- This function throws an error if the map is empty. Use \'maxViewWithKey\'\n-- if the map may be empty.\ndeleteFindMax :: IntMap a -> ((Key, a), IntMap a)\ndeleteFindMax = fromMaybe (error "deleteFindMax: empty map has no maximal element") . maxViewWithKey\n\n-- | \\(O(\\min(n,W))\\). Delete and find the minimal element.\n-- This function throws an error if the map is empty. Use \'minViewWithKey\'\n-- if the map may be empty.\ndeleteFindMin :: IntMap a -> ((Key, a), IntMap a)\ndeleteFindMin = fromMaybe (error "deleteFindMin: empty map has no minimal element") . minViewWithKey\n\n-- | \\(O(\\min(n,W))\\). The minimal key of the map. Returns \'Nothing\' if the map is empty.\nlookupMin :: IntMap a -> Maybe (Key, a)\nlookupMin Nil = Nothing\nlookupMin (Tip k v) = Just (k,v)\nlookupMin (Bin _ m l r)\n  | m < 0     = go r\n  | otherwise = go l\n    where go (Tip k v)      = Just (k,v)\n          go (Bin _ _ l\' _) = go l\'\n          go Nil            = Nothing\n\n-- | \\(O(\\min(n,W))\\). The minimal key of the map. Calls \'error\' if the map is empty.\n-- Use \'minViewWithKey\' if the map may be empty.\nfindMin :: IntMap a -> (Key, a)\nfindMin t\n  | Just r <- lookupMin t = r\n  | otherwise = error "findMin: empty map has no minimal element"\n\n-- | \\(O(\\min(n,W))\\). The maximal key of the map. Returns \'Nothing\' if the map is empty.\nlookupMax :: IntMap a -> Maybe (Key, a)\nlookupMax Nil = Nothing\nlookupMax (Tip k v) = Just (k,v)\nlookupMax (Bin _ m l r)\n  | m < 0     = go l\n  | otherwise = go r\n    where go (Tip k v)      = Just (k,v)\n          go (Bin _ _ _ r\') = go r\'\n          go Nil            = Nothing\n\n-- | \\(O(\\min(n,W))\\). The maximal key of the map. Calls \'error\' if the map is empty.\n-- Use \'maxViewWithKey\' if the map may be empty.\nfindMax :: IntMap a -> (Key, a)\nfindMax t\n  | Just r <- lookupMax t = r\n  | otherwise = error "findMax: empty map has no maximal element"\n\n-- | \\(O(\\min(n,W))\\). Delete the minimal key. Returns an empty map if the map is empty.\n--\n-- Note that this is a change of behaviour for consistency with \'Data.Map.Map\' &#8211;\n-- versions prior to 0.5 threw an error if the \'IntMap\' was already empty.\ndeleteMin :: IntMap a -> IntMap a\ndeleteMin = maybe Nil snd . minView\n\n-- | \\(O(\\min(n,W))\\). Delete the maximal key. Returns an empty map if the map is empty.\n--\n-- Note that this is a change of behaviour for consistency with \'Data.Map.Map\' &#8211;\n-- versions prior to 0.5 threw an error if the \'IntMap\' was already empty.\ndeleteMax :: IntMap a -> IntMap a\ndeleteMax = maybe Nil snd . maxView\n\n\n{--------------------------------------------------------------------\n  Submap\n--------------------------------------------------------------------}\n-- | \\(O(n+m)\\). Is this a proper submap? (ie. a submap but not equal).\n-- Defined as (@\'isProperSubmapOf\' = \'isProperSubmapOfBy\' (==)@).\nisProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool\nisProperSubmapOf m1 m2\n  = isProperSubmapOfBy (==) m1 m2\n\n{- | \\(O(n+m)\\). Is this a proper submap? (ie. a submap but not equal).\n The expression (@\'isProperSubmapOfBy\' f m1 m2@) returns \'True\' when\n @keys m1@ and @keys m2@ are not equal,\n all keys in @m1@ are in @m2@, and when @f@ returns \'True\' when\n applied to their respective values. For example, the following\n expressions are all \'True\':\n\n  > isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n  > isProperSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n\n But the following are all \'False\':\n\n  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])\n  > isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])\n  > isProperSubmapOfBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])\n-}\nisProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool\nisProperSubmapOfBy predicate t1 t2\n  = case submapCmp predicate t1 t2 of\n      LT -> True\n      _  -> False\n\nsubmapCmp :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Ordering\nsubmapCmp predicate t1@(Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  | shorter m1 m2  = GT\n  | shorter m2 m1  = submapCmpLt\n  | p1 == p2       = submapCmpEq\n  | otherwise      = GT  -- disjoint\n  where\n    submapCmpLt | nomatch p1 p2 m2  = GT\n                | zero p1 m2        = submapCmp predicate t1 l2\n                | otherwise         = submapCmp predicate t1 r2\n    submapCmpEq = case (submapCmp predicate l1 l2, submapCmp predicate r1 r2) of\n                    (GT,_ ) -> GT\n                    (_ ,GT) -> GT\n                    (EQ,EQ) -> EQ\n                    _       -> LT\n\nsubmapCmp _         (Bin _ _ _ _) _  = GT\nsubmapCmp predicate (Tip kx x) (Tip ky y)\n  | (kx == ky) && predicate x y = EQ\n  | otherwise                   = GT  -- disjoint\nsubmapCmp predicate (Tip k x) t\n  = case lookup k t of\n     Just y | predicate x y -> LT\n     _                      -> GT -- disjoint\nsubmapCmp _    Nil Nil = EQ\nsubmapCmp _    Nil _   = LT\n\n-- | \\(O(n+m)\\). Is this a submap?\n-- Defined as (@\'isSubmapOf\' = \'isSubmapOfBy\' (==)@).\nisSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool\nisSubmapOf m1 m2\n  = isSubmapOfBy (==) m1 m2\n\n{- | \\(O(n+m)\\).\n The expression (@\'isSubmapOfBy\' f m1 m2@) returns \'True\' if\n all keys in @m1@ are in @m2@, and when @f@ returns \'True\' when\n applied to their respective values. For example, the following\n expressions are all \'True\':\n\n  > isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n  > isSubmapOfBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n  > isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])\n\n But the following are all \'False\':\n\n  > isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])\n  > isSubmapOfBy (<) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n  > isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])\n-}\nisSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool\nisSubmapOfBy predicate t1@(Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  | shorter m1 m2  = False\n  | shorter m2 m1  = match p1 p2 m2 &&\n                       if zero p1 m2\n                       then isSubmapOfBy predicate t1 l2\n                       else isSubmapOfBy predicate t1 r2\n  | otherwise      = (p1==p2) && isSubmapOfBy predicate l1 l2 && isSubmapOfBy predicate r1 r2\nisSubmapOfBy _         (Bin _ _ _ _) _ = False\nisSubmapOfBy predicate (Tip k x) t     = case lookup k t of\n                                         Just y  -> predicate x y\n                                         Nothing -> False\nisSubmapOfBy _         Nil _           = True\n\n{--------------------------------------------------------------------\n  Mapping\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]\n\nmap :: (a -> b) -> IntMap a -> IntMap b\nmap f = go\n  where\n    go (Bin p m l r) = Bin p m (go l) (go r)\n    go (Tip k x)     = Tip k (f x)\n    go Nil           = Nil\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] map #-}\n{-# RULES\n"map/map" forall f g xs . map f (map g xs) = map (f . g) xs\n"map/coerce" map coerce = coerce\n #-}\n#endif\n\n-- | \\(O(n)\\). Map a function over all values in the map.\n--\n-- > let f key x = (show key) ++ ":" ++ x\n-- > mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]\n\nmapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b\nmapWithKey f t\n  = case t of\n      Bin p m l r -> Bin p m (mapWithKey f l) (mapWithKey f r)\n      Tip k x     -> Tip k (f k x)\n      Nil         -> Nil\n\n#ifdef __GLASGOW_HASKELL__\n{-# NOINLINE [1] mapWithKey #-}\n{-# RULES\n"mapWithKey/mapWithKey" forall f g xs . mapWithKey f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f k (g k a)) xs\n"mapWithKey/map" forall f g xs . mapWithKey f (map g xs) =\n  mapWithKey (\\k a -> f k (g a)) xs\n"map/mapWithKey" forall f g xs . map f (mapWithKey g xs) =\n  mapWithKey (\\k a -> f (g k a)) xs\n #-}\n#endif\n\n-- | \\(O(n)\\).\n-- @\'traverseWithKey\' f s == \'fromList\' <$> \'traverse\' (\\(k, v) -> (,) k <$> f k v) (\'toList\' m)@\n-- That is, behaves exactly like a regular \'traverse\' except that the traversing\n-- function also has access to the key associated with a value.\n--\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(1, \'a\'), (5, \'e\')]) == Just (fromList [(1, \'b\'), (5, \'f\')])\n-- > traverseWithKey (\\k v -> if odd k then Just (succ v) else Nothing) (fromList [(2, \'c\')])           == Nothing\ntraverseWithKey :: Applicative t => (Key -> a -> t b) -> IntMap a -> t (IntMap b)\ntraverseWithKey f = go\n  where\n    go Nil = pure Nil\n    go (Tip k v) = Tip k <$> f k v\n    go (Bin p m l r)\n      | m < 0     = liftA2 (flip (Bin p m)) (go r) (go l)\n      | otherwise = liftA2 (Bin p m) (go l) (go r)\n{-# INLINE traverseWithKey #-}\n\n-- | \\(O(n)\\). The function @\'mapAccum\'@ threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a b = (a ++ b, b ++ "X")\n-- > mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])\n\nmapAccum :: (a -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccum f = mapAccumWithKey (\\a\' _ x -> f a\' x)\n\n-- | \\(O(n)\\). The function @\'mapAccumWithKey\'@ threads an accumulating\n-- argument through the map in ascending order of keys.\n--\n-- > let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")\n-- > mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])\n\nmapAccumWithKey :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccumWithKey f a t\n  = mapAccumL f a t\n\n-- | \\(O(n)\\). The function @\'mapAccumL\'@ threads an accumulating\n-- argument through the map in ascending order of keys.\nmapAccumL :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccumL f a t\n  = case t of\n      Bin p m l r\n        | m < 0 ->\n            let (a1,r\') = mapAccumL f a r\n                (a2,l\') = mapAccumL f a1 l\n            in (a2,Bin p m l\' r\')\n        | otherwise  ->\n            let (a1,l\') = mapAccumL f a l\n                (a2,r\') = mapAccumL f a1 r\n            in (a2,Bin p m l\' r\')\n      Tip k x     -> let (a\',x\') = f a k x in (a\',Tip k x\')\n      Nil         -> (a,Nil)\n\n-- | \\(O(n)\\). The function @\'mapAccumRWithKey\'@ threads an accumulating\n-- argument through the map in descending order of keys.\nmapAccumRWithKey :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)\nmapAccumRWithKey f a t\n  = case t of\n      Bin p m l r\n        | m < 0 ->\n            let (a1,l\') = mapAccumRWithKey f a l\n                (a2,r\') = mapAccumRWithKey f a1 r\n            in (a2,Bin p m l\' r\')\n        | otherwise  ->\n            let (a1,r\') = mapAccumRWithKey f a r\n                (a2,l\') = mapAccumRWithKey f a1 l\n            in (a2,Bin p m l\' r\')\n      Tip k x     -> let (a\',x\') = f a k x in (a\',Tip k x\')\n      Nil         -> (a,Nil)\n\n-- | \\(O(n \\min(n,W))\\).\n-- @\'mapKeys\' f s@ is the map obtained by applying @f@ to each key of @s@.\n--\n-- The size of the result may be smaller if @f@ maps two or more distinct\n-- keys to the same new key.  In this case the value at the greatest of the\n-- original keys is retained.\n--\n-- > mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]\n-- > mapKeys (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"\n-- > mapKeys (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"\n\nmapKeys :: (Key->Key) -> IntMap a -> IntMap a\nmapKeys f = fromList . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n\n-- | \\(O(n \\min(n,W))\\).\n-- @\'mapKeysWith\' c f s@ is the map obtained by applying @f@ to each key of @s@.\n--\n-- The size of the result may be smaller if @f@ maps two or more distinct\n-- keys to the same new key.  In this case the associated values will be\n-- combined using @c@.\n--\n-- > mapKeysWith (++) (\\ _ -> 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"\n-- > mapKeysWith (++) (\\ _ -> 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"\n\nmapKeysWith :: (a -> a -> a) -> (Key->Key) -> IntMap a -> IntMap a\nmapKeysWith c f\n  = fromListWith c . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n\n-- | \\(O(n \\min(n,W))\\).\n-- @\'mapKeysMonotonic\' f s == \'mapKeys\' f s@, but works only when @f@\n-- is strictly monotonic.\n-- That is, for any values @x@ and @y@, if @x@ < @y@ then @f x@ < @f y@.\n-- /The precondition is not checked./\n-- Semi-formally, we have:\n--\n-- > and [x < y ==> f x < f y | x <- ls, y <- ls]\n-- >                     ==> mapKeysMonotonic f s == mapKeys f s\n-- >     where ls = keys s\n--\n-- This means that @f@ maps distinct original keys to distinct resulting keys.\n-- This function has slightly better performance than \'mapKeys\'.\n--\n-- > mapKeysMonotonic (\\ k -> k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]\n\nmapKeysMonotonic :: (Key->Key) -> IntMap a -> IntMap a\nmapKeysMonotonic f\n  = fromDistinctAscList . foldrWithKey (\\k x xs -> (f k, x) : xs) []\n\n{--------------------------------------------------------------------\n  Filter\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Filter all values that satisfy some predicate.\n--\n-- > filter (> "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"\n-- > filter (> "x") (fromList [(5,"a"), (3,"b")]) == empty\n-- > filter (< "a") (fromList [(5,"a"), (3,"b")]) == empty\n\nfilter :: (a -> Bool) -> IntMap a -> IntMap a\nfilter p m\n  = filterWithKey (\\_ x -> p x) m\n\n-- | \\(O(n)\\). Filter all keys\\/values that satisfy some predicate.\n--\n-- > filterWithKey (\\k _ -> k > 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"\n\nfilterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a\nfilterWithKey predicate = go\n    where\n    go Nil           = Nil\n    go t@(Tip k x)   = if predicate k x then t else Nil\n    go (Bin p m l r) = bin p m (go l) (go r)\n\n-- | \\(O(n)\\). Partition the map according to some predicate. The first\n-- map contains all elements that satisfy the predicate, the second all\n-- elements that fail the predicate. See also \'split\'.\n--\n-- > partition (> "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")\n-- > partition (< "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)\n-- > partition (> "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])\n\npartition :: (a -> Bool) -> IntMap a -> (IntMap a,IntMap a)\npartition p m\n  = partitionWithKey (\\_ x -> p x) m\n\n-- | \\(O(n)\\). Partition the map according to some predicate. The first\n-- map contains all elements that satisfy the predicate, the second all\n-- elements that fail the predicate. See also \'split\'.\n--\n-- > partitionWithKey (\\ k _ -> k > 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")\n-- > partitionWithKey (\\ k _ -> k < 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)\n-- > partitionWithKey (\\ k _ -> k > 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])\n\npartitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a,IntMap a)\npartitionWithKey predicate0 t0 = toPair $ go predicate0 t0\n  where\n    go predicate t =\n      case t of\n        Bin p m l r ->\n          let (l1 :*: l2) = go predicate l\n              (r1 :*: r2) = go predicate r\n          in bin p m l1 r1 :*: bin p m l2 r2\n        Tip k x\n          | predicate k x -> (t :*: Nil)\n          | otherwise     -> (Nil :*: t)\n        Nil -> (Nil :*: Nil)\n\n-- | \\(O(\\min(n,W))\\). Take while a predicate on the keys holds.\n-- The user is responsible for ensuring that for all @Int@s, @j \\< k ==\\> p j \\>= p k@.\n-- See note at \'spanAntitone\'.\n--\n-- @\n-- takeWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.takeWhile\' (p . fst) . \'toList\'\n-- takeWhileAntitone p = \'filterWithKey\' (\\\\k _ -> p k)\n-- @\n--\n-- @since 0.6.7\ntakeWhileAntitone :: (Key -> Bool) -> IntMap a -> IntMap a\ntakeWhileAntitone predicate t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if predicate 0 -- handle negative numbers.\n        then bin p m (go predicate l) r\n        else go predicate r\n    _ -> go predicate t\n  where\n    go predicate\' (Bin p m l r)\n      | predicate\' $! p+m = bin p m l (go predicate\' r)\n      | otherwise         = go predicate\' l\n    go predicate\' t\'@(Tip ky _)\n      | predicate\' ky = t\'\n      | otherwise     = Nil\n    go _ Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). Drop while a predicate on the keys holds.\n-- The user is responsible for ensuring that for all @Int@s, @j \\< k ==\\> p j \\>= p k@.\n-- See note at \'spanAntitone\'.\n--\n-- @\n-- dropWhileAntitone p = \'fromDistinctAscList\' . \'Data.List.dropWhile\' (p . fst) . \'toList\'\n-- dropWhileAntitone p = \'filterWithKey\' (\\\\k _ -> not (p k))\n-- @\n--\n-- @since 0.6.7\ndropWhileAntitone :: (Key -> Bool) -> IntMap a -> IntMap a\ndropWhileAntitone predicate t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if predicate 0 -- handle negative numbers.\n        then go predicate l\n        else bin p m l (go predicate r)\n    _ -> go predicate t\n  where\n    go predicate\' (Bin p m l r)\n      | predicate\' $! p+m = go predicate\' r\n      | otherwise         = bin p m (go predicate\' l) r\n    go predicate\' t\'@(Tip ky _)\n      | predicate\' ky = Nil\n      | otherwise     = t\'\n    go _ Nil = Nil\n\n-- | \\(O(\\min(n,W))\\). Divide a map at the point where a predicate on the keys stops holding.\n-- The user is responsible for ensuring that for all @Int@s, @j \\< k ==\\> p j \\>= p k@.\n--\n-- @\n-- spanAntitone p xs = (\'takeWhileAntitone\' p xs, \'dropWhileAntitone\' p xs)\n-- spanAntitone p xs = \'partitionWithKey\' (\\\\k _ -> p k) xs\n-- @\n--\n-- Note: if @p@ is not actually antitone, then @spanAntitone@ will split the map\n-- at some /unspecified/ point.\n--\n-- @since 0.6.7\nspanAntitone :: (Key -> Bool) -> IntMap a -> (IntMap a, IntMap a)\nspanAntitone predicate t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if predicate 0 -- handle negative numbers.\n        then\n          case go predicate l of\n            (lt :*: gt) ->\n              let !lt\' = bin p m lt r\n              in (lt\', gt)\n        else\n          case go predicate r of\n            (lt :*: gt) ->\n              let !gt\' = bin p m l gt\n              in (lt, gt\')\n    _ -> case go predicate t of\n          (lt :*: gt) -> (lt, gt)\n  where\n    go predicate\' (Bin p m l r)\n      | predicate\' $! p+m = case go predicate\' r of (lt :*: gt) -> bin p m l lt :*: gt\n      | otherwise         = case go predicate\' l of (lt :*: gt) -> lt :*: bin p m gt r\n    go predicate\' t\'@(Tip ky _)\n      | predicate\' ky = (t\' :*: Nil)\n      | otherwise     = (Nil :*: t\')\n    go _ Nil = (Nil :*: Nil)\n\n-- | \\(O(n)\\). Map values and collect the \'Just\' results.\n--\n-- > let f x = if x == "a" then Just "new a" else Nothing\n-- > mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"\n\nmapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b\nmapMaybe f = mapMaybeWithKey (\\_ x -> f x)\n\n-- | \\(O(n)\\). Map keys\\/values and collect the \'Just\' results.\n--\n-- > let f k _ = if k < 5 then Just ("key : " ++ (show k)) else Nothing\n-- > mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"\n\nmapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b\nmapMaybeWithKey f (Bin p m l r)\n  = bin p m (mapMaybeWithKey f l) (mapMaybeWithKey f r)\nmapMaybeWithKey f (Tip k x) = case f k x of\n  Just y  -> Tip k y\n  Nothing -> Nil\nmapMaybeWithKey _ Nil = Nil\n\n-- | \\(O(n)\\). Map values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f a = if a < "c" then Left a else Right a\n-- > mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])\n-- >\n-- > mapEither (\\ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n\nmapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)\nmapEither f m\n  = mapEitherWithKey (\\_ x -> f x) m\n\n-- | \\(O(n)\\). Map keys\\/values and separate the \'Left\' and \'Right\' results.\n--\n-- > let f k a = if k < 5 then Left (k * 2) else Right (a ++ a)\n-- > mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])\n-- >\n-- > mapEitherWithKey (\\_ a -> Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])\n-- >     == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])\n\nmapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)\nmapEitherWithKey f0 t0 = toPair $ go f0 t0\n  where\n    go f (Bin p m l r) =\n      bin p m l1 r1 :*: bin p m l2 r2\n      where\n        (l1 :*: l2) = go f l\n        (r1 :*: r2) = go f r\n    go f (Tip k x) = case f k x of\n      Left y  -> (Tip k y :*: Nil)\n      Right z -> (Nil :*: Tip k z)\n    go _ Nil = (Nil :*: Nil)\n\n-- | \\(O(\\min(n,W))\\). The expression (@\'split\' k map@) is a pair @(map1,map2)@\n-- where all keys in @map1@ are lower than @k@ and all keys in\n-- @map2@ larger than @k@. Any key equal to @k@ is found in neither @map1@ nor @map2@.\n--\n-- > split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])\n-- > split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")\n-- > split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")\n-- > split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)\n-- > split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)\n\nsplit :: Key -> IntMap a -> (IntMap a, IntMap a)\nsplit k t =\n  case t of\n    Bin p m l r\n      | m < 0 ->\n        if k >= 0 -- handle negative numbers.\n        then\n          case go k l of\n            (lt :*: gt) ->\n              let !lt\' = bin p m lt r\n              in (lt\', gt)\n        else\n          case go k r of\n            (lt :*: gt) ->\n              let !gt\' = bin p m l gt\n              in (lt, gt\')\n    _ -> case go k t of\n          (lt :*: gt) -> (lt, gt)\n  where\n    go k\' t\'@(Bin p m l r)\n      | nomatch k\' p m = if k\' > p then t\' :*: Nil else Nil :*: t\'\n      | zero k\' m = case go k\' l of (lt :*: gt) -> lt :*: bin p m gt r\n      | otherwise = case go k\' r of (lt :*: gt) -> bin p m l lt :*: gt\n    go k\' t\'@(Tip ky _)\n      | k\' > ky   = (t\' :*: Nil)\n      | k\' < ky   = (Nil :*: t\')\n      | otherwise = (Nil :*: Nil)\n    go _ Nil = (Nil :*: Nil)\n\n\ndata SplitLookup a = SplitLookup !(IntMap a) !(Maybe a) !(IntMap a)\n\nmapLT :: (IntMap a -> IntMap a) -> SplitLookup a -> SplitLookup a\nmapLT f (SplitLookup lt fnd gt) = SplitLookup (f lt) fnd gt\n{-# INLINE mapLT #-}\n\nmapGT :: (IntMap a -> IntMap a) -> SplitLookup a -> SplitLookup a\nmapGT f (SplitLookup lt fnd gt) = SplitLookup lt fnd (f gt)\n{-# INLINE mapGT #-}\n\n-- | \\(O(\\min(n,W))\\). Performs a \'split\' but also returns whether the pivot\n-- key was found in the original map.\n--\n-- > splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])\n-- > splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")\n-- > splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")\n-- > splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)\n-- > splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)\n\nsplitLookup :: Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)\nsplitLookup k t =\n  case\n    case t of\n      Bin p m l r\n        | m < 0 ->\n          if k >= 0 -- handle negative numbers.\n          then mapLT (flip (bin p m) r) (go k l)\n          else mapGT (bin p m l) (go k r)\n      _ -> go k t\n  of SplitLookup lt fnd gt -> (lt, fnd, gt)\n  where\n    go k\' t\'@(Bin p m l r)\n      | nomatch k\' p m =\n          if k\' > p\n          then SplitLookup t\' Nothing Nil\n          else SplitLookup Nil Nothing t\'\n      | zero k\' m = mapGT (flip (bin p m) r) (go k\' l)\n      | otherwise = mapLT (bin p m l) (go k\' r)\n    go k\' t\'@(Tip ky y)\n      | k\' > ky   = SplitLookup t\'  Nothing  Nil\n      | k\' < ky   = SplitLookup Nil Nothing  t\'\n      | otherwise = SplitLookup Nil (Just y) Nil\n    go _ Nil      = SplitLookup Nil Nothing  Nil\n\n{--------------------------------------------------------------------\n  Fold\n--------------------------------------------------------------------}\n-- | \\(O(n)\\). Fold the values in the map using the given right-associative\n-- binary operator, such that @\'foldr\' f z == \'Prelude.foldr\' f z . \'elems\'@.\n--\n-- For example,\n--\n-- > elems map = foldr (:) [] map\n--\n-- > let f a len = len + (length a)\n-- > foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4\nfoldr :: (a -> b -> b) -> b -> IntMap a -> b\nfoldr f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z l) r -- put negative numbers before\n      | otherwise -> go (go z r) l\n    _ -> go z t\n  where\n    go z\' Nil           = z\'\n    go z\' (Tip _ x)     = f x z\'\n    go z\' (Bin _ _ l r) = go (go z\' r) l\n{-# INLINE foldr #-}\n\n-- | \\(O(n)\\). A strict version of \'foldr\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldr\' :: (a -> b -> b) -> b -> IntMap a -> b\nfoldr\' f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z l) r -- put negative numbers before\n      | otherwise -> go (go z r) l\n    _ -> go z t\n  where\n    go !z\' Nil          = z\'\n    go z\' (Tip _ x)     = f x z\'\n    go z\' (Bin _ _ l r) = go (go z\' r) l\n{-# INLINE foldr\' #-}\n\n-- | \\(O(n)\\). Fold the values in the map using the given left-associative\n-- binary operator, such that @\'foldl\' f z == \'Prelude.foldl\' f z . \'elems\'@.\n--\n-- For example,\n--\n-- > elems = reverse . foldl (flip (:)) []\n--\n-- > let f len a = len + (length a)\n-- > foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4\nfoldl :: (a -> b -> a) -> a -> IntMap b -> a\nfoldl f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z r) l -- put negative numbers before\n      | otherwise -> go (go z l) r\n    _ -> go z t\n  where\n    go z\' Nil           = z\'\n    go z\' (Tip _ x)     = f z\' x\n    go z\' (Bin _ _ l r) = go (go z\' l) r\n{-# INLINE foldl #-}\n\n-- | \\(O(n)\\). A strict version of \'foldl\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldl\' :: (a -> b -> a) -> a -> IntMap b -> a\nfoldl\' f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z r) l -- put negative numbers before\n      | otherwise -> go (go z l) r\n    _ -> go z t\n  where\n    go !z\' Nil          = z\'\n    go z\' (Tip _ x)     = f z\' x\n    go z\' (Bin _ _ l r) = go (go z\' l) r\n{-# INLINE foldl\' #-}\n\n-- | \\(O(n)\\). Fold the keys and values in the map using the given right-associative\n-- binary operator, such that\n-- @\'foldrWithKey\' f z == \'Prelude.foldr\' (\'uncurry\' f) z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > keys map = foldrWithKey (\\k x ks -> k:ks) [] map\n--\n-- > let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"\n-- > foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"\nfoldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b\nfoldrWithKey f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z l) r -- put negative numbers before\n      | otherwise -> go (go z r) l\n    _ -> go z t\n  where\n    go z\' Nil           = z\'\n    go z\' (Tip kx x)    = f kx x z\'\n    go z\' (Bin _ _ l r) = go (go z\' r) l\n{-# INLINE foldrWithKey #-}\n\n-- | \\(O(n)\\). A strict version of \'foldrWithKey\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldrWithKey\' :: (Key -> a -> b -> b) -> b -> IntMap a -> b\nfoldrWithKey\' f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z l) r -- put negative numbers before\n      | otherwise -> go (go z r) l\n    _ -> go z t\n  where\n    go !z\' Nil          = z\'\n    go z\' (Tip kx x)    = f kx x z\'\n    go z\' (Bin _ _ l r) = go (go z\' r) l\n{-# INLINE foldrWithKey\' #-}\n\n-- | \\(O(n)\\). Fold the keys and values in the map using the given left-associative\n-- binary operator, such that\n-- @\'foldlWithKey\' f z == \'Prelude.foldl\' (\\\\z\' (kx, x) -> f z\' kx x) z . \'toAscList\'@.\n--\n-- For example,\n--\n-- > keys = reverse . foldlWithKey (\\ks k x -> k:ks) []\n--\n-- > let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"\n-- > foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"\nfoldlWithKey :: (a -> Key -> b -> a) -> a -> IntMap b -> a\nfoldlWithKey f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z r) l -- put negative numbers before\n      | otherwise -> go (go z l) r\n    _ -> go z t\n  where\n    go z\' Nil           = z\'\n    go z\' (Tip kx x)    = f z\' kx x\n    go z\' (Bin _ _ l r) = go (go z\' l) r\n{-# INLINE foldlWithKey #-}\n\n-- | \\(O(n)\\). A strict version of \'foldlWithKey\'. Each application of the operator is\n-- evaluated before using the result in the next application. This\n-- function is strict in the starting value.\nfoldlWithKey\' :: (a -> Key -> b -> a) -> a -> IntMap b -> a\nfoldlWithKey\' f z = \\t ->      -- Use lambda t to be inlinable with two arguments only.\n  case t of\n    Bin _ m l r\n      | m < 0 -> go (go z r) l -- put negative numbers before\n      | otherwise -> go (go z l) r\n    _ -> go z t\n  where\n    go !z\' Nil          = z\'\n    go z\' (Tip kx x)    = f z\' kx x\n    go z\' (Bin _ _ l r) = go (go z\' l) r\n{-# INLINE foldlWithKey\' #-}\n\n-- | \\(O(n)\\). Fold the keys and values in the map using the given monoid, such that\n--\n-- @\'foldMapWithKey\' f = \'Prelude.fold\' . \'mapWithKey\' f@\n--\n-- This can be an asymptotically faster than \'foldrWithKey\' or \'foldlWithKey\' for some monoids.\n--\n-- @since 0.5.4\nfoldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m\nfoldMapWithKey f = go\n  where\n    go Nil           = mempty\n    go (Tip kx x)    = f kx x\n    go (Bin _ m l r)\n      | m < 0     = go r `mappend` go l\n      | otherwise = go l `mappend` go r\n{-# INLINE foldMapWithKey #-}\n\n{--------------------------------------------------------------------\n  List variations\n--------------------------------------------------------------------}\n-- | \\(O(n)\\).\n-- Return all elements of the map in the ascending order of their keys.\n-- Subject to list fusion.\n--\n-- > elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]\n-- > elems empty == []\n\nelems :: IntMap a -> [a]\nelems = foldr (:) []\n\n-- | \\(O(n)\\). Return all keys of the map in ascending order. Subject to list\n-- fusion.\n--\n-- > keys (fromList [(5,"a"), (3,"b")]) == [3,5]\n-- > keys empty == []\n\nkeys  :: IntMap a -> [Key]\nkeys = foldrWithKey (\\k _ ks -> k : ks) []\n\n-- | \\(O(n)\\). An alias for \'toAscList\'. Returns all key\\/value pairs in the\n-- map in ascending key order. Subject to list fusion.\n--\n-- > assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]\n-- > assocs empty == []\n\nassocs :: IntMap a -> [(Key,a)]\nassocs = toAscList\n\n-- | \\(O(n \\min(n,W))\\). The set of all keys of the map.\n--\n-- > keysSet (fromList [(5,"a"), (3,"b")]) == Data.IntSet.fromList [3,5]\n-- > keysSet empty == Data.IntSet.empty\n\nkeysSet :: IntMap a -> IntSet.IntSet\nkeysSet Nil = IntSet.Nil\nkeysSet (Tip kx _) = IntSet.singleton kx\nkeysSet (Bin p m l r)\n  | m .&. IntSet.suffixBitMask == 0 = IntSet.Bin p m (keysSet l) (keysSet r)\n  | otherwise = IntSet.Tip (p .&. IntSet.prefixBitMask) (computeBm (computeBm 0 l) r)\n  where computeBm !acc (Bin _ _ l\' r\') = computeBm (computeBm acc l\') r\'\n        computeBm acc (Tip kx _) = acc .|. IntSet.bitmapOf kx\n        computeBm _   Nil = error "Data.IntSet.keysSet: Nil"\n\n-- | \\(O(n)\\). Build a map from a set of keys and a function which for each key\n-- computes its value.\n--\n-- > fromSet (\\k -> replicate k \'a\') (Data.IntSet.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]\n-- > fromSet undefined Data.IntSet.empty == empty\n\nfromSet :: (Key -> a) -> IntSet.IntSet -> IntMap a\nfromSet _ IntSet.Nil = Nil\nfromSet f (IntSet.Bin p m l r) = Bin p m (fromSet f l) (fromSet f r)\nfromSet f (IntSet.Tip kx bm) = buildTree f kx bm (IntSet.suffixBitMask + 1)\n  where\n    -- This is slightly complicated, as we to convert the dense\n    -- representation of IntSet into tree representation of IntMap.\n    --\n    -- We are given a nonzero bit mask \'bmask\' of \'bits\' bits with\n    -- prefix \'prefix\'. We split bmask into halves corresponding\n    -- to left and right subtree. If they are both nonempty, we\n    -- create a Bin node, otherwise exactly one of them is nonempty\n    -- and we construct the IntMap from that half.\n    buildTree g !prefix !bmask bits = case bits of\n      0 -> Tip prefix (g prefix)\n      _ -> case intFromNat ((natFromInt bits) `shiftRL` 1) of\n        bits2\n          | bmask .&. ((1 `shiftLL` bits2) - 1) == 0 ->\n              buildTree g (prefix + bits2) (bmask `shiftRL` bits2) bits2\n          | (bmask `shiftRL` bits2) .&. ((1 `shiftLL` bits2) - 1) == 0 ->\n              buildTree g prefix bmask bits2\n          | otherwise ->\n              Bin prefix bits2\n                (buildTree g prefix bmask bits2)\n                (buildTree g (prefix + bits2) (bmask `shiftRL` bits2) bits2)\n\n{--------------------------------------------------------------------\n  Lists\n--------------------------------------------------------------------}\n\n#ifdef __GLASGOW_HASKELL__\n-- | @since 0.5.6.2\ninstance GHCExts.IsList (IntMap a) where\n  type Item (IntMap a) = (Key,a)\n  fromList = fromList\n  toList   = toList\n#endif\n\n-- | \\(O(n)\\). Convert the map to a list of key\\/value pairs. Subject to list\n-- fusion.\n--\n-- > toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]\n-- > toList empty == []\n\ntoList :: IntMap a -> [(Key,a)]\ntoList = toAscList\n\n-- | \\(O(n)\\). Convert the map to a list of key\\/value pairs where the\n-- keys are in ascending order. Subject to list fusion.\n--\n-- > toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]\n\ntoAscList :: IntMap a -> [(Key,a)]\ntoAscList = foldrWithKey (\\k x xs -> (k,x):xs) []\n\n-- | \\(O(n)\\). Convert the map to a list of key\\/value pairs where the keys\n-- are in descending order. Subject to list fusion.\n--\n-- > toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]\n\ntoDescList :: IntMap a -> [(Key,a)]\ntoDescList = foldlWithKey (\\xs k x -> (k,x):xs) []\n\n-- List fusion for the list generating functions.\n#if __GLASGOW_HASKELL__\n-- The foldrFB and foldlFB are fold{r,l}WithKey equivalents, used for list fusion.\n-- They are important to convert unfused methods back, see mapFB in prelude.\nfoldrFB :: (Key -> a -> b -> b) -> b -> IntMap a -> b\nfoldrFB = foldrWithKey\n{-# INLINE[0] foldrFB #-}\nfoldlFB :: (a -> Key -> b -> a) -> a -> IntMap b -> a\nfoldlFB = foldlWithKey\n{-# INLINE[0] foldlFB #-}\n\n-- Inline assocs and toList, so that we need to fuse only toAscList.\n{-# INLINE assocs #-}\n{-# INLINE toList #-}\n\n-- The fusion is enabled up to phase 2 included. If it does not succeed,\n-- convert in phase 1 the expanded elems,keys,to{Asc,Desc}List calls back to\n-- elems,keys,to{Asc,Desc}List.  In phase 0, we inline fold{lr}FB (which were\n-- used in a list fusion, otherwise it would go away in phase 1), and let compiler\n-- do whatever it wants with elems,keys,to{Asc,Desc}List -- it was forbidden to\n-- inline it before phase 0, otherwise the fusion rules would not fire at all.\n{-# NOINLINE[0] elems #-}\n{-# NOINLINE[0] keys #-}\n{-# NOINLINE[0] toAscList #-}\n{-# NOINLINE[0] toDescList #-}\n{-# RULES "IntMap.elems" [~1] forall m . elems m = build (\\c n -> foldrFB (\\_ x xs -> c x xs) n m) #-}\n{-# RULES "IntMap.elemsBack" [1] foldrFB (\\_ x xs -> x : xs) [] = elems #-}\n{-# RULES "IntMap.keys" [~1] forall m . keys m = build (\\c n -> foldrFB (\\k _ xs -> c k xs) n m) #-}\n{-# RULES "IntMap.keysBack" [1] foldrFB (\\k _ xs -> k : xs) [] = keys #-}\n{-# RULES "IntMap.toAscList" [~1] forall m . toAscList m = build (\\c n -> foldrFB (\\k x xs -> c (k,x) xs) n m) #-}\n{-# RULES "IntMap.toAscListBack" [1] foldrFB (\\k x xs -> (k, x) : xs) [] = toAscList #-}\n{-# RULES "IntMap.toDescList" [~1] forall m . toDescList m = build (\\c n -> foldlFB (\\xs k x -> c (k,x) xs) n m) #-}\n{-# RULES "IntMap.toDescListBack" [1] foldlFB (\\xs k x -> (k, x) : xs) [] = toDescList #-}\n#endif\n\n\n-- | \\(O(n \\min(n,W))\\). Create a map from a list of key\\/value pairs.\n--\n-- > fromList [] == empty\n-- > fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]\n-- > fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]\n\nfromList :: [(Key,a)] -> IntMap a\nfromList xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t (k,x)  = insert k x t\n\n-- | \\(O(n \\min(n,W))\\). Create a map from a list of key\\/value pairs with a combining function. See also \'fromAscListWith\'.\n--\n-- > fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "ab"), (5, "cba")]\n-- > fromListWith (++) [] == empty\n\nfromListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a\nfromListWith f xs\n  = fromListWithKey (\\_ x y -> f x y) xs\n\n-- | \\(O(n \\min(n,W))\\). Build a map from a list of key\\/value pairs with a combining function. See also fromAscListWithKey\'.\n--\n-- > let f key new_value old_value = show key ++ ":" ++ new_value ++ "|" ++ old_value\n-- > fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"c")] == fromList [(3, "3:a|b"), (5, "5:c|5:b|a")]\n-- > fromListWithKey f [] == empty\n\nfromListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a\nfromListWithKey f xs\n  = Foldable.foldl\' ins empty xs\n  where\n    ins t (k,x) = insertWithKey f k x t\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order.\n--\n-- > fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]\n-- > fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]\n\nfromAscList :: [(Key,a)] -> IntMap a\nfromAscList = fromMonoListWithKey Nondistinct (\\_ x _ -> x)\n{-# NOINLINE fromAscList #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order, with a combining function on equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]\n\nfromAscListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a\nfromAscListWith f = fromMonoListWithKey Nondistinct (\\_ x y -> f x y)\n{-# NOINLINE fromAscListWith #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order, with a combining function on equal keys.\n-- /The precondition (input list is ascending) is not checked./\n--\n-- > let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value\n-- > fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "5:b|a")]\n\nfromAscListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a\nfromAscListWithKey f = fromMonoListWithKey Nondistinct f\n{-# NOINLINE fromAscListWithKey #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs where\n-- the keys are in ascending order and all distinct.\n-- /The precondition (input list is strictly ascending) is not checked./\n--\n-- > fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]\n\nfromDistinctAscList :: [(Key,a)] -> IntMap a\nfromDistinctAscList = fromMonoListWithKey Distinct (\\_ x _ -> x)\n{-# NOINLINE fromDistinctAscList #-}\n\n-- | \\(O(n)\\). Build a map from a list of key\\/value pairs with monotonic keys\n-- and a combining function.\n--\n-- The precise conditions under which this function works are subtle:\n-- For any branch mask, keys with the same prefix w.r.t. the branch\n-- mask must occur consecutively in the list.\n\nfromMonoListWithKey :: Distinct -> (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a\nfromMonoListWithKey distinct f = go\n  where\n    go []              = Nil\n    go ((kx,vx) : zs1) = addAll\' kx vx zs1\n\n    -- `addAll\'` collects all keys equal to `kx` into a single value,\n    -- and then proceeds with `addAll`.\n    addAll\' !kx vx []\n        = Tip kx vx\n    addAll\' !kx vx ((ky,vy) : zs)\n        | Nondistinct <- distinct, kx == ky\n        = let v = f kx vy vx in addAll\' ky v zs\n        -- inlined: | otherwise = addAll kx (Tip kx vx) (ky : zs)\n        | m <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' m ky vy zs\n        = addAll kx (linkWithMask m ky ty {-kx-} (Tip kx vx)) zs\'\n\n    -- for `addAll` and `addMany`, kx is /a/ key inside the tree `tx`\n    -- `addAll` consumes the rest of the list, adding to the tree `tx`\n    addAll !_kx !tx []\n        = tx\n    addAll !kx !tx ((ky,vy) : zs)\n        | m <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' m ky vy zs\n        = addAll kx (linkWithMask m ky ty {-kx-} tx) zs\'\n\n    -- `addMany\'` is similar to `addAll\'`, but proceeds with `addMany\'`.\n    addMany\' !_m !kx vx []\n        = Inserted (Tip kx vx) []\n    addMany\' !m !kx vx zs0@((ky,vy) : zs)\n        | Nondistinct <- distinct, kx == ky\n        = let v = f kx vy vx in addMany\' m ky v zs\n        -- inlined: | otherwise = addMany m kx (Tip kx vx) (ky : zs)\n        | mask kx m /= mask ky m\n        = Inserted (Tip kx vx) zs0\n        | mxy <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' mxy ky vy zs\n        = addMany m kx (linkWithMask mxy ky ty {-kx-} (Tip kx vx)) zs\'\n\n    -- `addAll` adds to `tx` all keys whose prefix w.r.t. `m` agrees with `kx`.\n    addMany !_m !_kx tx []\n        = Inserted tx []\n    addMany !m !kx tx zs0@((ky,vy) : zs)\n        | mask kx m /= mask ky m\n        = Inserted tx zs0\n        | mxy <- branchMask kx ky\n        , Inserted ty zs\' <- addMany\' mxy ky vy zs\n        = addMany m kx (linkWithMask mxy ky ty {-kx-} tx) zs\'\n{-# INLINE fromMonoListWithKey #-}\n\ndata Inserted a = Inserted !(IntMap a) ![(Key,a)]\n\ndata Distinct = Distinct | Nondistinct\n\n{--------------------------------------------------------------------\n  Eq\n--------------------------------------------------------------------}\ninstance Eq a => Eq (IntMap a) where\n  t1 == t2  = equal t1 t2\n  t1 /= t2  = nequal t1 t2\n\nequal :: Eq a => IntMap a -> IntMap a -> Bool\nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2)\nequal (Tip kx x) (Tip ky y)\n  = (kx == ky) && (x==y)\nequal Nil Nil = True\nequal _   _   = False\n\nnequal :: Eq a => IntMap a -> IntMap a -> Bool\nnequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2)\nnequal (Tip kx x) (Tip ky y)\n  = (kx /= ky) || (x/=y)\nnequal Nil Nil = False\nnequal _   _   = True\n\n-- | @since 0.5.9\ninstance Eq1 IntMap where\n  liftEq eq (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n    = (m1 == m2) && (p1 == p2) && (liftEq eq l1 l2) && (liftEq eq r1 r2)\n  liftEq eq (Tip kx x) (Tip ky y)\n    = (kx == ky) && (eq x y)\n  liftEq _eq Nil Nil = True\n  liftEq _eq _   _   = False\n\n{--------------------------------------------------------------------\n  Ord\n--------------------------------------------------------------------}\n\ninstance Ord a => Ord (IntMap a) where\n    compare m1 m2 = compare (toList m1) (toList m2)\n\n-- | @since 0.5.9\ninstance Ord1 IntMap where\n  liftCompare cmp m n =\n    liftCompare (liftCompare cmp) (toList m) (toList n)\n\n{--------------------------------------------------------------------\n  Functor\n--------------------------------------------------------------------}\n\ninstance Functor IntMap where\n    fmap = map\n\n#ifdef __GLASGOW_HASKELL__\n    a <$ Bin p m l r = Bin p m (a <$ l) (a <$ r)\n    a <$ Tip k _     = Tip k a\n    _ <$ Nil         = Nil\n#endif\n\n{--------------------------------------------------------------------\n  Show\n--------------------------------------------------------------------}\n\ninstance Show a => Show (IntMap a) where\n  showsPrec d m   = showParen (d > 10) $\n    showString "fromList " . shows (toList m)\n\n-- | @since 0.5.9\ninstance Show1 IntMap where\n    liftShowsPrec sp sl d m =\n        showsUnaryWith (liftShowsPrec sp\' sl\') "fromList" d (toList m)\n      where\n        sp\' = liftShowsPrec sp sl\n        sl\' = liftShowList sp sl\n\n{--------------------------------------------------------------------\n  Read\n--------------------------------------------------------------------}\ninstance (Read e) => Read (IntMap e) where\n#ifdef __GLASGOW_HASKELL__\n  readPrec = parens $ prec 10 $ do\n    Ident "fromList" <- lexP\n    xs <- readPrec\n    return (fromList xs)\n\n  readListPrec = readListPrecDefault\n#else\n  readsPrec p = readParen (p > 10) $ \\ r -> do\n    ("fromList",s) <- lex r\n    (xs,t) <- reads s\n    return (fromList xs,t)\n#endif\n\n-- | @since 0.5.9\ninstance Read1 IntMap where\n    liftReadsPrec rp rl = readsData $\n        readsUnaryWith (liftReadsPrec rp\' rl\') "fromList" fromList\n      where\n        rp\' = liftReadsPrec rp rl\n        rl\' = liftReadList rp rl\n\n{--------------------------------------------------------------------\n  Helpers\n--------------------------------------------------------------------}\n{--------------------------------------------------------------------\n  Link\n--------------------------------------------------------------------}\nlink :: Prefix -> IntMap a -> Prefix -> IntMap a -> IntMap a\nlink p1 t1 p2 t2 = linkWithMask (branchMask p1 p2) p1 t1 {-p2-} t2\n{-# INLINE link #-}\n\n-- `linkWithMask` is useful when the `branchMask` has already been computed\nlinkWithMask :: Mask -> Prefix -> IntMap a -> IntMap a -> IntMap a\nlinkWithMask m p1 t1 {-p2-} t2\n  | zero p1 m = Bin p m t1 t2\n  | otherwise = Bin p m t2 t1\n  where\n    p = mask p1 m\n{-# INLINE linkWithMask #-}\n\n{--------------------------------------------------------------------\n  @bin@ assures that we never have empty trees within a tree.\n--------------------------------------------------------------------}\nbin :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a\nbin _ _ l Nil = l\nbin _ _ Nil r = r\nbin p m l r   = Bin p m l r\n{-# INLINE bin #-}\n\n-- binCheckLeft only checks that the left subtree is non-empty\nbinCheckLeft :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a\nbinCheckLeft _ _ Nil r = r\nbinCheckLeft p m l r   = Bin p m l r\n{-# INLINE binCheckLeft #-}\n\n-- binCheckRight only checks that the right subtree is non-empty\nbinCheckRight :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a\nbinCheckRight _ _ l Nil = l\nbinCheckRight p m l r   = Bin p m l r\n{-# INLINE binCheckRight #-}\n\n{--------------------------------------------------------------------\n  Endian independent bit twiddling\n--------------------------------------------------------------------}\n\n-- | Should this key follow the left subtree of a \'Bin\' with switching\n-- bit @m@? N.B., the answer is only valid when @match i p m@ is true.\nzero :: Key -> Mask -> Bool\nzero i m\n  = (natFromInt i) .&. (natFromInt m) == 0\n{-# INLINE zero #-}\n\nnomatch,match :: Key -> Prefix -> Mask -> Bool\n\n-- | Does the key @i@ differ from the prefix @p@ before getting to\n-- the switching bit @m@?\nnomatch i p m\n  = (mask i m) /= p\n{-# INLINE nomatch #-}\n\n-- | Does the key @i@ match the prefix @p@ (up to but not including\n-- bit @m@)?\nmatch i p m\n  = (mask i m) == p\n{-# INLINE match #-}\n\n\n-- | The prefix of key @i@ up to (but not including) the switching\n-- bit @m@.\nmask :: Key -> Mask -> Prefix\nmask i m\n  = maskW (natFromInt i) (natFromInt m)\n{-# INLINE mask #-}\n\n\n{--------------------------------------------------------------------\n  Big endian operations\n--------------------------------------------------------------------}\n\n-- | The prefix of key @i@ up to (but not including) the switching\n-- bit @m@.\nmaskW :: Nat -> Nat -> Prefix\nmaskW i m\n  = intFromNat (i .&. ((-m) `xor` m))\n{-# INLINE maskW #-}\n\n-- | Does the left switching bit specify a shorter prefix?\nshorter :: Mask -> Mask -> Bool\nshorter m1 m2\n  = (natFromInt m1) > (natFromInt m2)\n{-# INLINE shorter #-}\n\n-- | The first switching bit where the two prefixes disagree.\nbranchMask :: Prefix -> Prefix -> Mask\nbranchMask p1 p2\n  = intFromNat (highestBitMask (natFromInt p1 `xor` natFromInt p2))\n{-# INLINE branchMask #-}\n\n{--------------------------------------------------------------------\n  Utilities\n--------------------------------------------------------------------}\n\n-- | \\(O(1)\\).  Decompose a map into pieces based on the structure\n-- of the underlying tree. This function is useful for consuming a\n-- map in parallel.\n--\n-- No guarantee is made as to the sizes of the pieces; an internal, but\n-- deterministic process determines this.  However, it is guaranteed that the\n-- pieces returned will be in ascending order (all elements in the first submap\n-- less than all elements in the second, and so on).\n--\n-- Examples:\n--\n-- > splitRoot (fromList (zip [1..6::Int] [\'a\'..])) ==\n-- >   [fromList [(1,\'a\'),(2,\'b\'),(3,\'c\')],fromList [(4,\'d\'),(5,\'e\'),(6,\'f\')]]\n--\n-- > splitRoot empty == []\n--\n--  Note that the current implementation does not return more than two submaps,\n--  but you should not depend on this behaviour because it can change in the\n--  future without notice.\nsplitRoot :: IntMap a -> [IntMap a]\nsplitRoot orig =\n  case orig of\n    Nil -> []\n    x@(Tip _ _) -> [x]\n    Bin _ m l r | m < 0 -> [r, l]\n                | otherwise -> [l, r]\n{-# INLINE splitRoot #-}\n\n\n{--------------------------------------------------------------------\n  Debugging\n--------------------------------------------------------------------}\n\n-- | \\(O(n \\min(n,W))\\). Show the tree that implements the map. The tree is shown\n-- in a compressed, hanging format.\nshowTree :: Show a => IntMap a -> String\nshowTree s\n  = showTreeWith True False s\n\n\n{- | \\(O(n \\min(n,W))\\). The expression (@\'showTreeWith\' hang wide map@) shows\n the tree that implements the map. If @hang@ is\n \'True\', a /hanging/ tree is shown otherwise a rotated tree is shown. If\n @wide@ is \'True\', an extra wide version is shown.\n-}\nshowTreeWith :: Show a => Bool -> Bool -> IntMap a -> String\nshowTreeWith hang wide t\n  | hang      = (showsTreeHang wide [] t) ""\n  | otherwise = (showsTree wide [] [] t) ""\n\nshowsTree :: Show a => Bool -> [String] -> [String] -> IntMap a -> ShowS\nshowsTree wide lbars rbars t = case t of\n  Bin p m l r ->\n    showsTree wide (withBar rbars) (withEmpty rbars) r .\n    showWide wide rbars .\n    showsBars lbars . showString (showBin p m) . showString "\\n" .\n    showWide wide lbars .\n    showsTree wide (withEmpty lbars) (withBar lbars) l\n  Tip k x ->\n    showsBars lbars .\n    showString " " . shows k . showString ":=" . shows x . showString "\\n"\n  Nil -> showsBars lbars . showString "|\\n"\n\nshowsTreeHang :: Show a => Bool -> [String] -> IntMap a -> ShowS\nshowsTreeHang wide bars t = case t of\n  Bin p m l r ->\n    showsBars bars . showString (showBin p m) . showString "\\n" .\n    showWide wide bars .\n    showsTreeHang wide (withBar bars) l .\n    showWide wide bars .\n    showsTreeHang wide (withEmpty bars) r\n  Tip k x ->\n    showsBars bars .\n    showString " " . shows k . showString ":=" . shows x . showString "\\n"\n  Nil -> showsBars bars . showString "|\\n"\n\nshowBin :: Prefix -> Mask -> String\nshowBin _ _\n  = "*" -- ++ show (p,m)\n\nshowWide :: Bool -> [String] -> String -> String\nshowWide wide bars\n  | wide      = showString (concat (reverse bars)) . showString "|\\n"\n  | otherwise = id\n\nshowsBars :: [String] -> ShowS\nshowsBars bars\n  = case bars of\n      [] -> id\n      _ : tl -> showString (concat (reverse tl)) . showString node\n\nnode :: String\nnode = "+--"\n\nwithBar, withEmpty :: [String] -> [String]\nwithBar bars   = "|  ":bars\nwithEmpty bars = "   ":bars\n'