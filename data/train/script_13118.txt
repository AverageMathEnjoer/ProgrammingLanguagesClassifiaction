b'context("Object_size")\n\n# Compatibility with base ---------------------------------------------------\n\ntest_that("size scales correctly with length (accounting for vector pool)", {\n  expect_same(numeric())\n  expect_same(1)\n  expect_same(2)\n  expect_same(1:10 + 0)\n  expect_same(1:1000 + 0)\n})\n\ntest_that("size correct for length one vectors", {\n  expect_same(1)\n  expect_same(1L)\n  expect_same("abc")\n  expect_same(paste(rep("banaana", 100), collapse = ""))\n  expect_same(charToRaw("a"))\n  expect_same(5 + 1i)\n})\n\ntest_that("size of list computed recursively", {\n  expect_same(list())\n  expect_same(as.list(1))\n  expect_same(as.list(1:2))\n  expect_same(as.list(1:3))\n\n  expect_same(list(list(list(list(list())))))\n})\n\ntest_that("size of symbols same as base", {\n  expect_same(quote(x))\n  expect_same(quote(asfsadfasdfasdfds))\n})\n\ntest_that("size of pairlists same as base", {\n  expect_same(pairlist())\n  expect_same(pairlist(1))\n  expect_same(pairlist(1, 2, 3))\n})\n\ntest_that("size of attributes included in object size", {\n  expect_same(c(x = 1))\n  expect_same(list(x = 1))\n  expect_same(c(x = "y"))\n})\n\ntest_that("duplicated CHARSXPS only counted once", {\n  expect_same("x")\n  expect_same(c("x", "y", "x"))\n  expect_same(c("banana", "banana", "banana"))\n})\n\n# Improved behaviour for shared components ------------------------------------\ntest_that("shared components only counted once", {\n  x <- 1:1e3\n  z <- list(x, x, x)\n\n  expect_equal(object_size(z), object_size(x) + object_size(vector("list", 3)))\n})\n\ntest_that("size of closures same as base", {\n  f <- function() NULL\n  attributes(f) <- NULL # zap srcrefs\n  environment(f) <- emptyenv()\n  expect_same(f)\n})\n\n# Environment sizes -----------------------------------------------------------\ntest_that("terminal environments have size zero", {\n  expect_equal(as.numeric(object_size(globalenv())), 0)\n  expect_equal(as.numeric(object_size(baseenv())), 0)\n  expect_equal(as.numeric(object_size(emptyenv())), 0)\n\n  expect_equal(as.numeric(object_size(asNamespace("stats"))), 0)\n})\n\ntest_that("environment size computed recursively", {\n  e <- new.env(parent = emptyenv())\n  e_size <- object_size(e)\n\n  f <- new.env(parent = e)\n  object_size(f)\n  expect_equal(object_size(f), 2 * object_size(e))\n})\n\ntest_that("size of function includes environment", {\n  f <- function() {\n    y <- 1:1e3\n    a ~ b\n  }\n  g <- function() {\n    y <- 1:1e3\n    function() 10\n  }\n\n  expect_true(object_size(f()) > object_size(1:1e3))\n  expect_true(object_size(g()) > object_size(1:1e3))\n})\n\ntest_that("size doesn\'t include parents of current environment", {\n  x <- 1:1e4 + 0\n  embedded <- (function() {\n    g <- function() {\n      x <- 1:1e3\n      a ~ b\n    }\n    object_size(g())\n  })()\n\n  expect_true(embedded < object_size(x))\n\n})\n\ntest_that("support dots in closure environments", {\n  fn <- (function(...) function() NULL)(foo)\n  expect_error(object_size(fn), NA)\n})\n\n'