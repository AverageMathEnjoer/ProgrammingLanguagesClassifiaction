b'/*\n    SPDX-FileCopyrightText: 2015-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "treemodel.h"\n\n#include <QDebug>\n#include <QTextStream>\n\n#include <KLocalizedString>\n\n#include <cmath>\n\n#include "resultdata.h"\n#include "util.h"\n\nnamespace {\n\nint indexOf(const RowData* row, const QVector<RowData>& siblings)\n{\n    Q_ASSERT(siblings.data() <= row);\n    Q_ASSERT(siblings.data() + siblings.size() > row);\n    return row - siblings.data();\n}\n\nconst RowData* rowAt(const QVector<RowData>& rows, int row)\n{\n    Q_ASSERT(rows.size() > row);\n    return rows.data() + row;\n}\n\n/// @return the parent row containing @p index\nconst RowData* toParentRow(const QModelIndex& index)\n{\n    return static_cast<const RowData*>(index.internalPointer());\n}\n}\n\nTreeModel::TreeModel(QObject* parent)\n    : QAbstractItemModel(parent)\n{\n    qRegisterMetaType<TreeData>();\n}\n\nTreeModel::~TreeModel()\n{\n}\n\nQVariant TreeModel::headerData(int section, Qt::Orientation orientation, int role) const\n{\n    if (orientation != Qt::Horizontal || section < 0 || section >= NUM_COLUMNS) {\n        return {};\n    }\n    if (role == Qt::InitialSortOrderRole) {\n        if (section == AllocationsColumn || section == PeakColumn || section == LeakedColumn\n            || section == TemporaryColumn) {\n            return Qt::DescendingOrder;\n        }\n    }\n    if (role == Qt::DisplayRole) {\n        switch (static_cast<Columns>(section)) {\n        case AllocationsColumn:\n            return i18n("Allocations");\n        case TemporaryColumn:\n            return i18n("Temporary");\n        case PeakColumn:\n            return i18n("Peak");\n        case LeakedColumn:\n            return i18n("Leaked");\n        case LocationColumn:\n            return i18n("Location");\n        case NUM_COLUMNS:\n            break;\n        }\n    } else if (role == Qt::ToolTipRole) {\n        switch (static_cast<Columns>(section)) {\n        case AllocationsColumn:\n            return i18n("<qt>The number of times an allocation function was called "\n                        "from this location.</qt>");\n        case TemporaryColumn:\n            return i18n("<qt>The number of temporary allocations. These allocations "\n                        "are directly followed by a free "\n                        "without any other allocations in-between.</qt>");\n        case PeakColumn:\n            return i18n("<qt>The contributions from a given location to the maximum heap "\n                        "memory consumption in bytes. This takes deallocations "\n                        "into account.</qt>");\n        case LeakedColumn:\n            return i18n("<qt>The bytes allocated at this location that have not been "\n                        "deallocated.</qt>");\n        case LocationColumn:\n            return i18n("<qt>The location from which an allocation function was "\n                        "called. Function symbol and file "\n                        "information "\n                        "may be unknown when debug information was missing when "\n                        "heaptrack was run.</qt>");\n        case NUM_COLUMNS:\n            break;\n        }\n    }\n    return {};\n}\n\nQVariant TreeModel::data(const QModelIndex& index, int role) const\n{\n    if (index.row() < 0 || index.column() < 0 || index.column() > NUM_COLUMNS) {\n        return {};\n    }\n\n    const auto row = (role == MaxCostRole) ? &m_maxCost : toRow(index);\n\n    if (role == Qt::DisplayRole || role == SortRole || role == MaxCostRole) {\n        switch (static_cast<Columns>(index.column())) {\n        case AllocationsColumn:\n            if (role == SortRole || role == MaxCostRole) {\n                return static_cast<qint64>(abs(row->cost.allocations));\n            }\n            return static_cast<qint64>(row->cost.allocations);\n        case TemporaryColumn:\n            if (role == SortRole || role == MaxCostRole) {\n                return static_cast<qint64>(abs(row->cost.temporary));\n            }\n            return static_cast<qint64>(row->cost.temporary);\n        case PeakColumn:\n            if (role == SortRole || role == MaxCostRole) {\n                return static_cast<qint64>(abs(row->cost.peak));\n            } else {\n                return Util::formatBytes(row->cost.peak);\n            }\n        case LeakedColumn:\n            if (role == SortRole || role == MaxCostRole) {\n                return static_cast<qint64>(abs(row->cost.leaked));\n            } else {\n                return Util::formatBytes(row->cost.leaked);\n            }\n        case LocationColumn:\n            return Util::toString(row->symbol, *m_data.resultData, Util::Short);\n        case NUM_COLUMNS:\n            break;\n        }\n    } else if (role == Qt::ToolTipRole) {\n        auto toStr = [this](StringIndex stringId) { return m_data.resultData->string(stringId); };\n        QString tooltip;\n        QTextStream stream(&tooltip);\n        stream << "<qt><pre style=\'font-family:monospace;\'>";\n        const auto module = toStr(row->symbol.moduleId);\n        stream << i18nc("1: function, 2: module, 3: module path", "%1\\n  in %2 (%3)",\n                        toStr(row->symbol.functionId).toHtmlEscaped(), Util::basename(module).toHtmlEscaped(),\n                        module.toHtmlEscaped());\n        stream << \'\\n\';\n        stream << \'\\n\';\n        const auto peakFraction = Util::formatCostRelative(row->cost.peak, m_maxCost.cost.peak);\n        const auto leakedFraction = Util::formatCostRelative(row->cost.leaked, m_maxCost.cost.leaked);\n        const auto allocationsFraction = Util::formatCostRelative(row->cost.allocations, m_maxCost.cost.allocations);\n        const auto temporaryFraction = Util::formatCostRelative(row->cost.temporary, row->cost.allocations);\n        const auto temporaryFractionTotal = Util::formatCostRelative(row->cost.temporary, m_maxCost.cost.temporary);\n        stream << i18n("peak contribution: %1 (%2% of total)\\n", Util::formatBytes(row->cost.peak), peakFraction);\n        stream << i18n("leaked: %1 (%2% of total)\\n", Util::formatBytes(row->cost.leaked), leakedFraction);\n        stream << i18n("allocations: %1 (%2% of total)\\n", row->cost.allocations, allocationsFraction);\n        stream << i18n("temporary: %1 (%2% of allocations, %3% of total)\\n", row->cost.temporary, temporaryFraction,\n                       temporaryFractionTotal);\n        if (!row->children.isEmpty()) {\n            auto child = row;\n            int max = 5;\n            if (child->children.count() == 1) {\n                stream << \'\\n\' << i18n("backtrace:") << \'\\n\';\n            }\n            while (child->children.count() == 1 && max-- > 0) {\n                stream << "\\n";\n                const auto module = toStr(child->symbol.moduleId);\n                stream << i18nc("1: function, 2: module, 3: module path", "%1\\n  in %2 (%3)",\n                                toStr(child->symbol.functionId).toHtmlEscaped(), Util::basename(module).toHtmlEscaped(),\n                                module.toHtmlEscaped());\n                child = child->children.data();\n            }\n            if (child->children.count() > 1) {\n                stream << "\\n";\n                stream << i18np("called from one location", "called from %1 locations", child->children.count());\n            }\n        }\n        stream << "</pre></qt>";\n        return tooltip;\n    } else if (role == SymbolRole) {\n        return QVariant::fromValue(row->symbol);\n    } else if (role == ResultDataRole) {\n        return QVariant::fromValue(m_data.resultData.get());\n    }\n    return {};\n}\n\nQModelIndex TreeModel::index(int row, int column, const QModelIndex& parent) const\n{\n    if (row < 0 || column < 0 || column >= NUM_COLUMNS || row >= rowCount(parent)) {\n        return QModelIndex();\n    }\n    return createIndex(row, column, const_cast<void*>(reinterpret_cast<const void*>(toRow(parent))));\n}\n\nQModelIndex TreeModel::parent(const QModelIndex& child) const\n{\n    if (!child.isValid()) {\n        return {};\n    }\n    const auto parent = toParentRow(child);\n    if (!parent) {\n        return {};\n    }\n    return createIndex(rowOf(parent), 0, const_cast<void*>(reinterpret_cast<const void*>(parent->parent)));\n}\n\nint TreeModel::rowCount(const QModelIndex& parent) const\n{\n    if (!parent.isValid()) {\n        return m_data.rows.size();\n    } else if (parent.column() != 0) {\n        return 0;\n    }\n    auto row = toRow(parent);\n    Q_ASSERT(row);\n    return row->children.size();\n}\n\nint TreeModel::columnCount(const QModelIndex& /*parent*/) const\n{\n    return NUM_COLUMNS;\n}\n\nvoid TreeModel::resetData(const TreeData& data)\n{\n    Q_ASSERT(data.resultData);\n    beginResetModel();\n    m_data = data;\n    endResetModel();\n}\n\nvoid TreeModel::setSummary(const SummaryData& data)\n{\n    beginResetModel();\n    m_maxCost.cost = data.cost;\n    endResetModel();\n}\n\nvoid TreeModel::clearData()\n{\n    beginResetModel();\n    m_data = {};\n    m_maxCost = {};\n    endResetModel();\n}\n\nconst RowData* TreeModel::toRow(const QModelIndex& index) const\n{\n    if (!index.isValid()) {\n        return nullptr;\n    }\n    if (const auto parent = toParentRow(index)) {\n        return rowAt(parent->children, index.row());\n    } else {\n        return rowAt(m_data.rows, index.row());\n    }\n}\n\nint TreeModel::rowOf(const RowData* row) const\n{\n    if (auto parent = row->parent) {\n        return indexOf(row, parent->children);\n    } else {\n        return indexOf(row, m_data.rows);\n    }\n}\n'