b'#\' calcMoversPriors\n#\'\n#\' calcMoversPriors calculates prior estimates of in-state and\n#\' cross-state movers rates from the IRS SOI Migration data,\n#\' which can be used to improve the accuracy of the EM algorithm.\n#\'\n#\' @usage calcMoversPriors(geo.a, geo.b, year.start, year.end,\n#\' county, state.a, state.b, matchrate.lambda, remove.instate)\n#\'\n#\' @param geo.a The state code (if state = TRUE) or county name\n#\' (if state = FALSE) for the earlier of the two voter files.\n#\' @param geo.b The state code (if state = TRUE) or county name\n#\' (if state = FALSE) for the later of the two voter files.\n#\' @param year.start The year of the voter file for geography A.\n#\' @param year.end The year of the voter file for geography B.\n#\' @param county Whether prior is being calculated on the county or state level.\n#\' Default is FALSE (for a state-level calculation).\n#\' @param state.a If \\code{county = TRUE} (indicating a county-level match),\n#\' the state code of \\code{geo.a}. Default is NULL.\n#\' @param state.b If \\code{county = TRUE} (indicating a county-level match),\n#\' the state code of \\code{geo.b}. Default is NULL.\n#\' @param matchrate.lambda If TRUE, then returns the match rate for lambda\n#\' (the expected share of observations in dataset A that can be found in\n#\' dataset B). If FALSE, then returns the expected share of matches across\n#\' all pairwise comparisons of datasets A and B. Default is FALSE\n#\' @param remove.instate If TRUE, then for calculating cross-state movers rates\n#\' assumes that successful matches have been subsetted out. The interpretation\n#\' of the prior is then the match rate conditional on being an out-of-state or\n#\' county mover. Default is TRUE.\n#\'\n#\' @return \\code{calcMoversPriors} returns a list with estimates of the expected\n#\' match rate, and of the expected in-state movers rate when matching within-state.\n#\'\n#\' @author Ben Fifield <benfifield@gmail.com>\n#\'\n#\' @examples calcMoversPriors(geo.a = "CA", geo.b = "CA", year.start = 2014, year.end = 2015)\n#\' \n#\' @export\ncalcMoversPriors <- function(geo.a, geo.b, year.start, year.end,\n                             county = FALSE, state.a = NULL, state.b = NULL,\n                             matchrate.lambda = FALSE, remove.instate = TRUE){\n\n    ## For visible bindings\n    start_year <- NULL; end_year <- NULL; y1_statefips <- NULL; y2_statefips <- NULL\n    y1_fips <- NULL; y2_fips <- NULL\n    \n    ## Load the correct level of IRS data\n    if(!county){\n        statefips <- get("statefips")\n        stateoutflow <- get("stateoutflow")\n        stateinflow <- get("stateinflow")\n        outfips <- statefips$statefips[statefips$state == geo.a]\n        infips <- statefips$statefips[statefips$state == geo.b]\n        outf <- subset(\n            stateoutflow, start_year >= year.start & end_year <= year.end\n            & y1_statefips == outfips\n        )\n        inf <- subset(\n            stateinflow, start_year >= year.start & end_year <= year.end\n            & y2_statefips == infips\n        )\n    }else{\n        countyfips <- get("countyfips")\n        countyoutflow <- get("countyoutflow")\n        countyinflow <- get("countyinflow")\n        geo.a <- tolower(geo.a); geo.b <- tolower(geo.b)\n        outfips <- countyfips$fips[countyfips$statecode == state.a &\n                                   countyfips$countyname == geo.a]\n        infips <- countyfips$fips[countyfips$statecode == state.b &\n                                  countyfips$countyname == geo.b]\n        outf <- subset(\n            countyoutflow, start_year >= year.start & end_year <= year.end\n            & y1_fips == outfips\n        )\n        inf <- subset(\n            countyinflow, start_year >= year.start & end_year <= year.end\n            & y2_fips == infips\n        )\n    }\n\n    ## Get the N sizes\n    inf$n <- inf$n1; outf$n <- outf$n1\n\n    ## Cross-state matching\n    if(geo.a != geo.b){\n        if(!county){\n            b_a <- outf$n[outf$y1_statefips == outfips &\n                          outf$y2_statefips == infips]\n            if(remove.instate){\n                denom_a <- (outf$n[outf$y1_statefips == outfips &\n                                   outf$y2_statefips == 96] +\n                            outf$n[outf$y1_statefips == outfips &\n                                   grepl("Same State", outf$y2_state_name)])\n                denom_b <- (inf$n[inf$y2_statefips == infips &\n                                  inf$y1_statefips == 96] +\n                            inf$n[inf$y2_statefips == infips &\n                                  grepl("Same State", inf$y1_state_name)])\n            }else{\n                denom_a <- (outf$n[outf$y1_statefips == outfips &\n                                   outf$y2_statefips == outfips] +\n                            outf$n[outf$y1_statefips == outfips &\n                                   outf$y2_statefips == 96] +\n                            outf$n[outf$y1_statefips == outfips &\n                                   grepl("Same State", outf$y2_state_name)])\n                denom_b <- (inf$n[inf$y1_statefips == infips &\n                                  inf$y2_statefips == infips] +\n                            inf$n[inf$y2_statefips == infips &\n                                  inf$y1_statefips == 96] +\n                            inf$n[inf$y2_statefips == infips &\n                                  grepl("Same State", inf$y1_state_name)])\n            }\n        }else{\n            b_a <- outf$n[outf$y1_fips == outfips & outf$y2_fips == infips]\n            denom_a <- (outf$n[outf$y1_fips == outfips &\n                               grepl("US and Foreign", outf$y2_countyname)] +\n                        outf$n[outf$y1_fips == outfips &\n                               grepl("Non-migrants", outf$y2_countyname)])\n            denom_b <- (inf$n[inf$y2_fips == infips &\n                              grepl("US and Foreign", inf$y1_countyname)] +\n                        inf$n[inf$y2_fips == infips &\n                              grepl("Non-migrants", inf$y1_countyname)])\n        }\n        ## Calculate mean\n        if(matchrate.lambda){\n            meancalc <- b_a / as.double(denom_a)\n        }else{\n            meancalc <- b_a / (as.double(denom_a) * as.double(denom_b))\n        }\n\n    }\n\n    ## Within-state matching\n    if(geo.a == geo.b){\n        if(!county){\n            nm_a <- outf$n[outf$y1_statefips == outfips &\n                           outf$y2_statefips == infips]\n            m_a <- outf$n[outf$y1_statefips == outfips &\n                          grepl("Same State", outf$y2_state_name)]\n            b_a <- nm_a + m_a\n            denom_a <- (outf$n[outf$y1_statefips == outfips &\n                               outf$y2_statefips == outfips] +\n                        outf$n[outf$y1_statefips == outfips &\n                               outf$y2_statefips == 96] +\n                        outf$n[outf$y1_statefips == outfips &\n                               grepl("Same State", outf$y2_state_name)])\n            denom_b <- (inf$n[inf$y1_statefips == infips &\n                              inf$y2_statefips == infips] +\n                        inf$n[inf$y2_statefips == infips &\n                              inf$y1_statefips == 96] +\n                        inf$n[inf$y2_statefips == infips &\n                              grepl("Same State", inf$y1_state_name)])            \n        }else{\n            b_a <- outf$n[outf$y1_fips == outfips & outf$y2_fips == infips]\n            denom_a <- (outf$n[outf$y1_fips == outfips &\n                               grepl("US and Foreign", outf$y2_countyname)] + \n                        outf$n[outf$y1_fips == outfips &\n                               grepl("Non-migrants", outf$y2_countyname)])\n            denom_b <- (inf$n[inf$y2_fips == infips &\n                              grepl("US and Foreign", inf$y1_countyname)] +\n                        inf$n[inf$y2_fips == infips &\n                              grepl("Non-migrants", inf$y1_countyname)])\n        }\n        if(matchrate.lambda){\n            meancalc <- b_a / as.double(denom_a)\n        }else{\n            meancalc <- b_a / (as.double(denom_a) * as.double(denom_b))\n        }\n        if(!county){\n            dir_mean <- m_a / (nm_a + m_a)\n        }else{\n            statemove <- get("statemove")\n            dir_mean <- statemove$est[statemove$state == state.a]\n        }\n    }\n\n    ## Return object\n    out <- list()\n    if(geo.a == geo.b){\n        if(meancalc < 0){\n            meancalc <- 1e-08\n        }\n        if(dir_mean < 0){\n            dir_mean <- 1e-08\n        }\n        out[["lambda.prior"]] <- meancalc\n        out[["pi.prior"]] <- dir_mean\n    }else{\n        if(meancalc < 0){\n            meancalc <- 1e-08\n        }\n        out[["lambda.prior"]] <- meancalc\n    }\n    \n    return(out)\n\n}\n\n'