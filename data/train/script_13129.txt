b'\xef\xbb\xbf// UVa1331 Minimax Triangulation\n// Rujia Liu\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst double eps = 1e-10;\nint dcmp(double x) {\n  if(fabs(x) < eps) return 0; else return x < 0 ? -1 : 1;\n}\n\nstruct Point {\n  double x, y;\n  Point(double x=0, double y=0):x(x),y(y) { }\n};\n\ntypedef Point Vector;\n\nVector operator + (const Vector& A, const Vector& B) { return Vector(A.x+B.x, A.y+B.y); }\nVector operator - (const Point& A, const Point& B) { return Vector(A.x-B.x, A.y-B.y); }\nVector operator * (const Vector& A, double p) { return Vector(A.x*p, A.y*p); }\n\nbool operator < (const Point& a, const Point& b) {\n  return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nbool operator == (const Point& a, const Point &b) {\n  return dcmp(a.x-b.x) == 0 && dcmp(a.y-b.y) == 0;\n}\n\ndouble Dot(const Vector& A, const Vector& B) { return A.x*B.x + A.y*B.y; }\ndouble Cross(const Vector& A, const Vector& B) { return A.x*B.y - A.y*B.x; }\ndouble Length(Vector A) { return sqrt(Dot(A, A)); }\n\nbool SegmentProperIntersection(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n  double c1 = Cross(a2-a1,b1-a1), c2 = Cross(a2-a1,b2-a1),\n  c3 = Cross(b2-b1,a1-b1), c4=Cross(b2-b1,a2-b1);\n  return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;\n}\n\nbool OnSegment(const Point& p, const Point& a1, const Point& a2) {\n  return dcmp(Cross(a1-p, a2-p)) == 0 && dcmp(Dot(a1-p, a2-p)) < 0;\n}\n\ntypedef vector<Point> Polygon;\n\nint isPointInPolygon(const Point& p, const Polygon& poly){\n  int n = poly.size();\n  int wn = 0;\n  for(int i = 0; i < n; i++){\n    const Point& p1 = poly[i];\n    const Point& p2 = poly[(i+1)%n];\n    if(p1 == p || p2 == p || OnSegment(p, p1, p2)) return -1; // \xe5\x9c\xa8\xe8\xbe\xb9\xe7\x95\x8c\xe4\xb8\x8a\n    int k = dcmp(Cross(p2-p1, p-p1));\n    int d1 = dcmp(p1.y - p.y);\n    int d2 = dcmp(p2.y - p.y);\n    if(k > 0 && d1 <= 0 && d2 > 0) wn++;\n    if(k < 0 && d2 <= 0 && d1 > 0) wn--;\n  }\n  if (wn != 0) return 1; // \xe5\x86\x85\xe9\x83\xa8\n  return 0; // \xe5\xa4\x96\xe9\x83\xa8\n}\n\nconst int maxn = 100 + 5;\n\nbool isDiagonal(const Polygon& poly, int a, int b) {\n  int n = poly.size();\n  for(int i = 0; i < n; i++)\n    if(i != a && i != b && OnSegment(poly[i], poly[a], poly[b])) return false; // \xe4\xb8\xad\xe9\x97\xb4\xe4\xb8\x8d\xe8\x83\xbd\xe6\x9c\x89\xe5\x85\xb6\xe4\xbb\x96\xe7\x82\xb9\n  for(int i = 0; i < n; i++)\n    if(SegmentProperIntersection(poly[i], poly[(i+1)%n], poly[a], poly[b])) return false; // \xe4\xb8\x8d\xe8\x83\xbd\xe5\x92\x8c\xe5\xa4\x9a\xe8\xbe\xb9\xe5\xbd\xa2\xe7\x9a\x84\xe8\xbe\xb9\xe8\xa7\x84\xe8\x8c\x83\xe7\x9b\xb8\xe4\xba\xa4\n  Point midp = (poly[a] + poly[b]) * 0.5;\n  return (isPointInPolygon(midp, poly) == 1); // \xe6\x95\xb4\xe6\x9d\xa1\xe7\xba\xbf\xe6\xae\xb5\xe5\x9c\xa8\xe5\xa4\x9a\xe8\xbe\xb9\xe5\xbd\xa2\xe5\x86\x85\n}\n\nconst double INF = 1e9;\ndouble d[maxn][maxn];\n\ndouble solve(const Polygon& poly) {\n  int n = poly.size();\n\n  for(int i = 0; i < n; i++)\n    for(int j = 0; j < n; j++) d[i][j] = -1;\n  for(int i = n-2; i >= 0; i--)\n    for(int j = i+1; j < n; j++) {\n      if(i + 1 == j) d[i][j] = 0;\n      else if(!(i == 0 && j == n-1) && !isDiagonal(poly, i, j)) d[i][j] = INF;\n      else {\n        d[i][j] = INF;\n        for(int k = i+1; k < j; k++) {\n          double m = max(d[i][k], d[k][j]);\n          double area = fabs(Cross(poly[j]-poly[i], poly[k]-poly[i])) / 2.0; // triangle i-j-k\n          m = max(m, area);\n          d[i][j] = min(d[i][j], m);\n        }\n      }\n    }\n  return d[0][n-1];\n}\n\nint main() {\n  int T, n;\n  scanf("%d", &T);\n  while(T--) {\n    scanf("%d", &n);\n    double x, y;\n    Polygon poly;\n    for(int i = 0; i < n; i++) { scanf("%lf%lf", &x, &y); poly.push_back(Point(x,y)); }\n    printf("%.1lf\\n", solve(poly));\n  }\n  return 0;\n}\n'