b'\n-- | A simple module that provides a more memory-efficient representation of `[Bool]`.\n\nmodule Data.BitList \n  ( BitList\n  , cons, head, tail, empty \n  , pack, unpack, length, drop\n  )\nwhere\n\nimport Data.Int\nimport Data.Bits\nimport Prelude as P hiding (head,tail,drop,length)\nimport qualified Data.List as L\nimport Test.HUnit\nimport Test.QuickCheck\nimport Test.QuickCheck.Gen\n\ndata BitList = One  {-# UNPACK #-} !Int {-# UNPACK #-} !Int64\n             | More {-# UNPACK #-} !Int {-# UNPACK #-} !Int64 BitList\n \ninstance Show BitList where \n show bl = "BitList " ++ show (map (\\b -> case b of True -> \'1\'; False -> \'0\') (unpack bl))\n-- show bl = "pack " ++ show (unpack bl)\n\nempty :: BitList\nempty = One 0 0\n\ncons :: Bool -> BitList -> BitList\ncons True  x@(One  64 _ )   = More 1 1 x\ncons False x@(One  64 _ )   = More 1 0 x\ncons True  x@(More 64 bv _) = More 1 1 x\ncons False x@(More 64 bv _) = More 1 0 x\ncons True    (One   i bv)   = One  (i+1) (bv `setBit` i)\ncons False   (One   i bv)   = One  (i+1) (bv           )\ncons True    (More  i bv r) = More (i+1) (bv `setBit` i) r\ncons False   (More  i bv r) = More (i+1) (bv           ) r\n\n-- TODO: May consider (More 0 _ _) representation to reduce extra\n-- allocation when size of the BitList is fluctuating back and forth.\n\nhead :: BitList -> Bool\nhead (One  0 _   ) = error "tried to take head of an empty BitList"\nhead (More 0 _  r) = error "BitList: data structure invariant failure!"\nhead (One  i bv  ) = bv `testBit` (i-1)\nhead (More i bv r) = bv `testBit` (i-1)\n\ntail :: BitList -> BitList\ntail (One  0 _   ) = error "tried to take the tail of an empty BitList"\ntail (One  i bv  ) = One  (i-1) bv\ntail (More 1 bv r) = r\ntail (More i bv r) = More (i-1) bv r\n\npack :: [Bool] -> BitList\npack  []   = One 0 0\npack (h:t) = cons h (pack t)\n\nunpack :: BitList -> [Bool] \nunpack (One 0 _)     = []\nunpack (One i bv)    = (bv `testBit` (i-1)) : unpack (One (i-1) bv)\nunpack (More 0 _ r)  =  unpack r\nunpack (More i bv r) = (bv `testBit` (i-1)) : unpack (More (i-1) bv r)\n\n-- drop :: Int -> BitList -> BitList\n-- drop 0 bl           = bl\n-- drop n bl | n >= 64 = case bl of \n-- \t\t        One _ _    -> error "drop: not enough elements in BitList"\n-- \t\t\tMore i _ r -> drop (n-i) r\n-- drop n bl = case bl of \n-- \t      One i  bv   -> One  (i-n) bv\n-- \t      More i bv r -> More (i-n) bv r\n\ndrop :: Int -> BitList -> BitList\ndrop n (One i bv)\n   | n >= i    = empty\n   | otherwise = One (i - n) bv\ndrop n (More i bv r)\n   | n >= i    = drop (n - i) r\n   | otherwise = More (i - n) bv r\n\nlength :: BitList -> Int\nlength (One  i _)   = i\nlength (More i _ r) = i + length r\n\n\n-- TODO: index, take, etc\n\n-- TODO: functor instance, etc.\n\ninstance Eq BitList where\n One i1 bv1 == One i2 bv2 \n    | i1 == i2 && mask bv1 == mask bv2  = True\n\nmask x = x\n\n--------------------------------------------------------------------------------\n-- Testing:\n\nt1 = pack (L.concat$ L.replicate 10 [True,False,True])\n\nt2 = L.length $ unpack $ pack $ replicate 1000 True\n\nt3 = pack $ replicate 1000 True\nt4 = drop 500 t3\np3 = L.and (unpack t3)\np4 = L.and (unpack t4)\n\nt5 = iterate tail t4 !! 250\nt5a = length t5\nt5b = L.length (unpack t5)\n\nt6 = drop 5 (More 1 0 (One 64 0)) \n-- More (-4) 0 (One 64 0)\n\ntests :: Test\ntests = \n  TestList \n    [ \n      show t1 ~=? "BitList \\"101101101101101101101101101101\\""\n    , t2  ~=? 1000\n    , t5a ~=? 250\n    , t5b ~=? 250\n    , p3  ~=? True\n    , p4  ~=? True\n    , length t6 ~=? 60\n    ]\n\n-- TODO: QuickCheck\n\n-- \\s -> length (take 5 s) == 5\n\n-- This won\'t work at tail []:\nprop_droptail xs =   drop 1 xs == tail xs\n\nq1 = quickCheck (prop_droptail :: BitList -> Bool)\n\ninstance Arbitrary BitList where\n  arbitrary = MkGen $ \\ rng n -> \n\t        let ls = (unGen arbitrary) rng n\n\t\tin pack ls'