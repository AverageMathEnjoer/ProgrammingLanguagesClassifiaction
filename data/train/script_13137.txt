b'// Copyright (c) 2023 Manuel Schneider\n\n#include <QDebug>\n#include <QDir>\n#include <QFileInfo>\n#include <QIcon>\n#include <QStandardPaths>\n#include <QString>\n#include "themefileparser.h"\n#include "iconlookup.h"\nusing namespace std;\n\nnamespace  {\n    QStringList icon_extensions = {"png", "svg", "xpm"};\n}\n\nQString XDG::IconLookup::iconPath(QStringList iconNames, QString themeName)\n{\n    QString result;\n    for ( const QString &iconName : iconNames )\n        if ( !(result = instance()->themeIconPath(iconName, themeName)).isNull() )\n            return result;\n    return {};\n}\n\nQString XDG::IconLookup::iconPath(QString iconName, QString themeName)\n{\n    return instance()->themeIconPath(iconName, themeName);\n}\n\nXDG::IconLookup::IconLookup()\n{\n    /*\n     * Icons and themes are looked for in a set of directories. By default,\n     * apps should look in $HOME/.icons (for backwards compatibility), in\n     * $XDG_DATA_DIRS/icons and in /usr/share/pixmaps (in that order).\n     */\n\n    QString path = QDir::home().filePath(".icons");\n    if (QFile::exists(path))\n        iconDirs_.append(path);\n\n    for (const QString &basedir : QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation))\n        if (QFile::exists(path = QDir(basedir).filePath("icons")))\n            iconDirs_.append(path);\n\n    path = "/usr/share/pixmaps";\n    if (QFile::exists(path))\n        iconDirs_.append(path);\n}\n\nXDG::IconLookup *XDG::IconLookup::instance()\n{\n    static IconLookup *instance_ = nullptr;\n    if (!instance_)\n        instance_ = new IconLookup();\n    return instance_;\n}\n\nQString XDG::IconLookup::themeIconPath(QString iconName, QString themeName)\n{\n    if (iconName.isEmpty())\n        return {};\n\n    if (themeName.isEmpty())\n        themeName = QIcon::themeName();\n\n    // if we have an absolute path, just return it\n    if (iconName[0] == \'/\') {\n        if (QFile::exists(iconName))\n            return iconName;\n        else\n            return {};\n    }\n\n    // check if it has an extension and strip it\n    for (const QString &ext: icon_extensions)\n        if (iconName.endsWith(QString(".").append(ext)))\n            iconName.chop(4);\n\n    // Check cache\n    try {\n        return iconCache_.at(iconName);\n    } catch (const out_of_range &) {}\n\n    QStringList checkedThemes;\n    QString iconPath;\n\n    // Lookup themefile\n    if (!(iconPath = doRecursiveIconLookup(iconName, themeName, &checkedThemes)).isNull())\n        return iconCache_.emplace(iconName, iconPath).first->second;\n\n    // Lookup in hicolor\n    if (!checkedThemes.contains("hicolor"))\n        if (!(iconPath = doRecursiveIconLookup(iconName, "hicolor", &checkedThemes)).isNull())\n            return iconCache_.emplace(iconName, iconPath).first->second;\n\n    // Now search unsorted\n    for (const QString &iconDir: iconDirs_)\n        for (const QString &ext: icon_extensions)\n            if (QFile(iconPath = QString("%1/%2.%3").arg(iconDir, iconName, ext)).exists())\n                return iconCache_.emplace(iconName, iconPath).first->second;\n\n    // Nothing found, save though to avoid repeated expensive lookups\n    return iconCache_.emplace(iconName, QString()).first->second;\n}\n\nQString XDG::IconLookup::doRecursiveIconLookup(const QString &iconName, const QString &themeName, QStringList *checked)\n{\n    // Exlude multiple scans\n    if (checked->contains(themeName))\n        return {};\n    checked->append(themeName);\n\n    // Check if theme exists\n    QString themeFile = lookupThemeFile(themeName);\n    if (themeFile.isNull())\n        return {};\n\n    // Check if icon exists\n    QString iconPath;\n    iconPath = doIconLookup(iconName, themeFile);\n    if (!iconPath.isNull())\n        return iconPath;\n\n    // Check its parents too\n    for (const QString &parent: ThemeFileParser(themeFile).inherits()) {\n        iconPath = doRecursiveIconLookup(iconName, parent, checked);\n        if (!iconPath.isNull())\n            return iconPath;\n    }\n\n    return {};\n}\n\nQString XDG::IconLookup::doIconLookup(const QString &iconName, const QString &themeFile)\n{\n    ThemeFileParser themeFileParser(themeFile);\n    QDir themeDir = QFileInfo(themeFile).dir();\n    QString themeName = themeDir.dirName();\n\n    // Get the sizes of the dirs\n    vector<pair<QString, int>> dirsAndSizes;\n    for (const QString &subdir: themeFileParser.directories())\n        dirsAndSizes.push_back(make_pair(subdir, themeFileParser.size(subdir)));\n\n    // Sort them by size\n    sort(dirsAndSizes.begin(), dirsAndSizes.end(),\n         [](pair<QString, int> a, pair<QString, int> b) {\n             return a.second > b.second;\n         });\n\n    // Well now search for a file beginning with the greatest\n    QString filename;\n    QFile file;\n    for (const auto &dirAndSize: dirsAndSizes) {\n        for (const QString &iconDir: iconDirs_) {\n            for (const QString &ext: icon_extensions) {\n                filename = QString("%1/%2/%3/%4.%5").arg(iconDir, themeName, dirAndSize.first, iconName, ext);\n                if (file.exists(filename)) {\n                    return filename;\n                }\n            }\n        }\n    }\n\n    return {};\n}\n\nQString XDG::IconLookup::lookupThemeFile(const QString &themeName)\n{\n    // Lookup themefile\n    for (const QString &iconDir: iconDirs_) {\n        QString indexFile = QString("%1/%2/index.theme").arg(iconDir, themeName);\n        if (QFile(indexFile).exists())\n            return indexFile;\n    }\n    return {};\n}\n'