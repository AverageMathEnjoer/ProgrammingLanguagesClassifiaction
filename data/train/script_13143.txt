b'// LM73 I2C class\n// Based on Texas Instruments datasheet http://www.ti.com/lit/ds/symlink/lm73.pdf\n// Note that this is a bare-bones driver and does not support all of the features\n// of the LM73. I only added what I needed.\n// 12/03/2012 Abe Erdos (abe@erdosmiller.com)\n\n#include "LM73.h"\n\nLM73::LM73() {\n    devAddr = LM73_DEFAULT_ADDRESS;\n    devConfig.all = 0x40; // reset state\n    devCtrlStat.all = 0x08; // reset state\n}\n\nLM73::LM73(uint8_t address) {\n    devAddr = address;\n    devConfig.all = 0x40; // reset state\n    devCtrlStat.all = 0x08; // reset state\n}\n\nvoid LM73::initialize() {\n    // there\'s nothing to do, really\n}\n\nbool LM73::testConnection() {\n    uint16_t buf;\n    I2Cdev::readWord(devAddr, LM73_RA_ID, &buf);\n    return buf == 0x0190;\n}\n\nLM73ConfigReg LM73::getConfig() {\n    I2Cdev::readByte(devAddr, LM73_RA_CONFIG, buffer);\n    devConfig.all = buffer[0];\n    return devConfig;\n}\n\nLM73CtrlStatReg LM73::getCtrlStat() {\n    I2Cdev::readByte(devAddr, LM73_RA_CTRL_STAT, buffer);\n    devCtrlStat.all = buffer[0];\n    return devCtrlStat;\n}\n\nvoid LM73::setCtrlStat(LM73CtrlStatReg value) {\n    I2Cdev::writeByte(devAddr, LM73_RA_CTRL_STAT, value.all);\n}\n\nuint8_t LM73::getResolution() {\n    LM73::getCtrlStat();\n    return devCtrlStat.bit.RES + 11;\n}\n\nfloat LM73::getTemp() {\n    uint16_t buf;\n    int16_t temp;\n    I2Cdev::readWord(devAddr, LM73_RA_TEMP, &buf);\n    temp = buf;\n    temp = (temp>>2);\n    return 0.03125f * (float)temp;\n}\n\nvoid LM73::setResolution(uint8_t resolution) {\n    if(10 < resolution && resolution < 15) {\n        LM73::getCtrlStat();\n        devCtrlStat.bit.RES = resolution - 11;\n        LM73::setCtrlStat(devCtrlStat);\n    }\n}\n\n'