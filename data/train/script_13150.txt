b'{-# OPTIONS_GHC\n  -fno-warn-deprecations\n  -fno-warn-orphans\n  #-}\n{-# LANGUAGE\n    CPP\n  , DeriveFunctor\n  , FlexibleContexts\n  , FlexibleInstances\n  , GeneralizedNewtypeDeriving\n  , MultiParamTypeClasses\n  , TypeFamilies\n  , UndecidableInstances\n  #-}\n#if MIN_VERSION_base(4,9,0)\n{-# OPTIONS_GHC -Wno-redundant-constraints #-}\n#endif\n\nmodule Rest.Client.Base\n  ( ApiInfo(..)\n  , ApiState(..)\n  , ApiT(..)\n  , Api\n  , ApiStateC(..)\n  , runT\n  , run\n  , runWithPort\n  , ApiResponse(..)\n  , responseToMaybe\n  ) where\n\n#if !MIN_VERSION_base(4,6,0)\nimport Prelude hiding (catch)\n#endif\n\nimport Control.Monad.Base\nimport Control.Monad.Catch (MonadCatch (catch))\nimport Control.Monad.Cont hiding (mapM)\nimport Control.Monad.Error hiding (mapM)\nimport Control.Monad.List hiding (mapM)\nimport Control.Monad.RWS hiding (mapM)\nimport Control.Monad.Reader hiding (mapM)\nimport Control.Monad.State hiding (mapM)\nimport Control.Monad.Trans.Control\nimport Control.Monad.Trans.Except (ExceptT)\nimport Control.Monad.Trans.Resource\nimport Control.Monad.Writer hiding (mapM)\nimport Data.ByteString\nimport Data.CaseInsensitive\nimport Network.HTTP.Conduit hiding (method, responseBody)\nimport Network.HTTP.Client (defaultManagerSettings)\n\nimport Rest.Types.Error\n\ndata ApiInfo =\n  ApiInfo\n   { manager :: Manager\n   , apiHost :: String\n   , apiPort :: Int\n   , headers :: [(String, String)]\n   }\n\nnewtype ApiState = ApiState { cookies :: CookieJar }\n\nnewtype ApiT m a = ApiT { unApiT :: StateT ApiState (ReaderT ApiInfo (ResourceT m)) a }\n  deriving ( Applicative\n           , Functor\n           , Monad\n           , MonadIO\n           )\n\ntype Api = ApiT IO\n\nclass (MonadResource m, MonadBaseControl IO m, Monad m, Functor m, MonadBase IO m) => ApiStateC m where\n  getApiState     :: m ApiState\n  putApiState     :: ApiState -> m ()\n  askApiInfo      :: m ApiInfo\n\ninstance (MonadBaseControl IO m, Monad m, Functor m, MonadBase IO m, MonadIO m, MonadThrow m) => ApiStateC (ApiT m) where\n  getApiState    = ApiT get\n  putApiState    = ApiT . put\n  askApiInfo     = ApiT (lift ask)\n\ninstance MonadTrans ApiT where\n  lift = ApiT . lift . lift . lift\n\ninstance MonadBase b m => MonadBase b (ApiT m) where\n  liftBase = liftBaseDefault\n\n#if MIN_VERSION_monad_control(1,0,0)\ninstance MonadTransControl ApiT where\n  type StT ApiT a = StT ResourceT (StT (ReaderT ApiInfo) (StT (StateT ApiState) a))\n  liftWith f = ApiT (liftWith (\\runs -> liftWith (\\runrr -> liftWith (\\runrs -> f (runrs . runrr . runs . unApiT)))))\n  restoreT = ApiT . restoreT . restoreT . restoreT\n\ninstance MonadBaseControl v m => MonadBaseControl v (ApiT m) where\n  type StM (ApiT m) a = ComposeSt ApiT m a\n  liftBaseWith = defaultLiftBaseWith\n  restoreM     = defaultRestoreM\n#else\ninstance MonadTransControl ApiT where\n  newtype StT ApiT a = StTApiT { unStTApiT :: StT ResourceT (StT (ReaderT ApiInfo) (StT (StateT ApiState) a)) }\n  liftWith f = ApiT (liftWith (\\runs -> liftWith (\\runrr -> liftWith (\\runrs -> f (fmap StTApiT . runrs . runrr . runs . unApiT)))))\n  restoreT = ApiT . restoreT . restoreT . restoreT . fmap unStTApiT\n\ninstance MonadBaseControl v m => MonadBaseControl v (ApiT m) where\n  newtype StM (ApiT m) a = StMApiT { unStMApiT :: ComposeSt ApiT m a }\n  liftBaseWith = defaultLiftBaseWith StMApiT\n  restoreM     = defaultRestoreM unStMApiT\n#endif\n\ninstance MonadThrow m => MonadThrow (ApiT m) where throwM = ApiT . lift . lift . lift . throwM\n\ninstance MonadCatch m => MonadCatch (ApiT m) where catch c f = ApiT (unApiT c `catch` (unApiT . f))\n\ninstance (MonadIO m, MonadThrow m, MonadBase IO m, Functor m, Applicative m) => MonadResource (ApiT m) where\n  liftResourceT = ApiT . lift . lift . transResourceT liftIO\n\ninstance ApiStateC m => ApiStateC (ExceptT e m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\ninstance (Error e, ApiStateC m) => ApiStateC (ErrorT e m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\ninstance (Monoid w, ApiStateC m) => ApiStateC (RWST r w s m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\ninstance (Monoid w, ApiStateC m) => ApiStateC (WriterT w m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\ninstance ApiStateC m => ApiStateC (ListT m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\ninstance ApiStateC m => ApiStateC (ReaderT r m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\ninstance ApiStateC m => ApiStateC (StateT s m) where\n  getApiState = lift getApiState\n  askApiInfo  = lift askApiInfo\n  putApiState = lift . putApiState\n\nrunT :: MonadBaseControl IO m => ApiInfo -> ApiState -> ApiT m a -> ResourceT m a\nrunT inf st api = runReaderT (evalStateT (unApiT api) st) inf\n\nrun :: String -> ApiT IO a -> IO a\nrun = flip runWithPort 80\n\nrunWithPort :: String -> Int -> ApiT IO a -> IO a\nrunWithPort hst prt api = do\n  m <- newManager defaultManagerSettings\n  runResourceT $ do\n    runT (ApiInfo m hst prt []) (ApiState (createCookieJar [])) api\n\ndata ApiResponse e a  =\n  ApiResponse\n    { statusCode      :: Int\n    , statusMessage   :: ByteString\n    , httpVersion     :: (Int, Int)\n    , responseHeaders :: [(CI ByteString , ByteString)]\n    , responseBody    :: Either (Reason e) a\n    } deriving (Functor, Show)\n\nresponseToMaybe :: ApiResponse e a -> Maybe a\nresponseToMaybe = either (const Nothing) Just . responseBody\n'