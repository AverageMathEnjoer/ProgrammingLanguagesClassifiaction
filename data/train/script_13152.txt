b'{-# OPTIONS_GHC -fno-warn-orphans #-}\n\n{-# LANGUAGE DataKinds, TypeOperators #-}\n{-# LANGUAGE TypeOperators, ScopedTypeVariables, FlexibleContexts #-}\n{-# LANGUAGE MonoLocalBinds #-}\n\n-- | Easy FFI via MessagePack.\n--\n-- You can use this module to expose any Haskell function to other Programming languages.\n--\n-- It allows to convert functions that take multiple arguments\n-- into functions that take one argument:\n-- A \'ByteString\' which contains all arguments encoded as a MessagePack array.\n--\n-- Common use cases:\n--\n-- * Write functions in fast native Haskell code, compile them into a dynamic.\n--   library (@.so@ \\/ @.dll@) and call them via C\\/Python\\/Ruby\\/whatever via @dlopen()@ or equivalents.\n--\n-- * Expose Haskell functions via a socket / the web\nmodule FFI.Anything.TypeUncurry.Msgpack (\n  MessagePackRec (..)\n, getTypeListFromMsgpackArray\n, uncurryMsgpack\n, tryUncurryMsgpack\n, tryUncurryMsgpackIO\n, byteStringToCStringFun\n, byteStringToCStringFunIO\n, export\n, exportIO\n) where\n\nimport           Data.ByteString (ByteString)\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BSL\nimport           Data.ByteString.Unsafe (unsafeUseAsCStringLen)\nimport           Data.Int (Int64)\nimport           Data.Maybe (fromMaybe)\nimport qualified Data.MessagePack as MSG\nimport           Data.Proxy\nimport           Data.Storable.Endian (peekBE, pokeBE)\nimport           Foreign.C\nimport           Foreign.Marshal.Alloc (mallocBytes)\nimport           Foreign.Marshal.Utils (copyBytes)\nimport           Foreign.Ptr (castPtr, plusPtr)\n\nimport FFI.Anything.TypeUncurry\n\n\n-- | Helper to allow writing a \'MSG.MessagePack\' instance for \'TypeList\'s.\n--\n-- We need this because we have to call \'parseArray\' at the top-level\n-- \'MSG.MessagePack\' instance, but not at each function argument step.\nclass MessagePackRec l where\n  fromObjectRec :: (MonadFail m) => [MSG.Object] -> m (TypeList l)\n\n-- | When no more types need to be unpacked, we are done.\ninstance MessagePackRec \'[] where\n  fromObjectRec v | null v = pure Nil\n  fromObjectRec _          = fail "fromObjectRec: passed object is not expected []"\n\n-- | Unpack one type by just parsing the next element.\ninstance (MSG.MessagePack a, MessagePackRec l) => MessagePackRec (a \': l) where\n  fromObjectRec (x:xs) = (:::) <$> MSG.fromObject x <*> fromObjectRec xs\n  fromObjectRec _      = fail "fromObjectRec: passed object is not expected (x:xs)"\n\n-- | Parses a tuple of arbitrary size (\'TypeList\'s) from a MessagePack array.\ngetTypeListFromMsgpackArray :: forall m l . (MessagePackRec l, ParamLength l, MonadFail m) => MSG.Object -> m (TypeList l)\ngetTypeListFromMsgpackArray obj = case obj of\n    MSG.ObjectArray v | length v == len -> fromObjectRec v\n    _                                   -> fail "getTypeListFromMsgpackArray: wrong object length"\n  where\n    len = paramLength (Proxy :: Proxy l)\n\ninstance (MessagePackRec l, ParamLength l) => MSG.MessagePack (TypeList l) where\n  fromObject = getTypeListFromMsgpackArray\n  toObject = error "call-haskell-from-anything: Serialising a TypeList is not supported (and not needed)!"\n\n\n-- | Standard error message when unpacking failed.\nerrorMsg :: String -> String\nerrorMsg locationStr = "call-haskell-from-anything: " ++ locationStr ++ ": got wrong number of function arguments or non-array"\n\n\n-- | Translates a function of type @a -> b -> ... -> r@ to\n-- a function that:\n--\n-- * takes as a single argument a \'ByteString\' containing all arguments serialized in a MessagePack array\n--\n-- * returns its result serialized in a \'ByteString\' via MessagePack \'MSG.pack\'\n--\n-- This function throws an \'error\' if the de-serialization of the arguments fails!\n-- It is recommended to use \'tryUncurryMsgpack\' instead.\nuncurryMsgpack :: (MSG.MessagePack (TypeList l), ToTypeList f l r, MSG.MessagePack r) => f -> (ByteString -> ByteString)\nuncurryMsgpack f = \\bs -> BSL.toStrict . MSG.pack $ (translate f $ fromMaybe (error (errorMsg "uncurryMsgpack")) $ MSG.unpack $ BSL.fromStrict bs)\n\n\n-- | Like \'uncurryMsgpack\', but for \'IO\' functions.\n--\n-- This function throws an \'error\' if the de-serialization of the arguments fails!\n-- It is recommended to use \'tryUncurryMsgpackIO\' instead.\nuncurryMsgpackIO :: (MSG.MessagePack (TypeList l), ToTypeList f l (IO r), MSG.MessagePack r) => f -> (ByteString -> IO ByteString)\nuncurryMsgpackIO f = \\bs -> BSL.toStrict . MSG.pack <$> (translate f $ fromMaybe (error (errorMsg "uncurryMsgpackIO")) $ MSG.unpack $ BSL.fromStrict bs)\n\n\n-- | Like \'uncurryMsgpack\', but makes it clear when the \'ByteString\' containing\n-- the function arguments does not contain the right number/types of arguments.\ntryUncurryMsgpack :: (MSG.MessagePack (TypeList l), ToTypeList f l r, MSG.MessagePack r) => f -> (ByteString -> Maybe ByteString)\ntryUncurryMsgpack f = \\bs -> case MSG.unpack $ BSL.fromStrict bs of\n  Nothing   -> Nothing\n  Just args -> Just . BSL.toStrict . MSG.pack $ (translate f $ args)\n\n\n-- | Like \'uncurryMsgpack\', but makes it clear when the \'ByteString\' containing\n-- the function arguments does not contain the right number/types of arguments.\ntryUncurryMsgpackIO :: (MSG.MessagePack (TypeList l), ToTypeList f l (IO r), MSG.MessagePack r) => f -> (ByteString -> Maybe (IO ByteString))\ntryUncurryMsgpackIO f = \\bs -> case MSG.unpack $ BSL.fromStrict bs of\n  Nothing   -> Nothing\n  Just args -> Just $ BSL.toStrict . MSG.pack <$> (translate f $ args)\n\n\n-- | O(n). Makes a copy of the ByteString\'s contents into a malloc()ed area.\n-- You need to free() the returned string when you\'re done with it.\nbyteStringToMallocedCStringWith64bitLength :: ByteString -> IO CString\nbyteStringToMallocedCStringWith64bitLength bs =\n  unsafeUseAsCStringLen bs $ \\(ptr, len) -> do\n    targetPtr <- mallocBytes (8 + len)\n    pokeBE (castPtr targetPtr) (fromIntegral len :: Int64)\n    copyBytes (targetPtr `plusPtr` 8) ptr len\n    return targetPtr\n\n\n-- * Exporting\n\n-- TODO implement via byteStringToCStringFunIO?\n-- | Transforms a \'ByteString\'-mapping function to \'CString\'-mapping function\n-- for use in the FFI.\nbyteStringToCStringFun :: (ByteString -> ByteString) -> CString -> IO CString\nbyteStringToCStringFun f cs = do\n  msgLength :: Int64 <- peekBE (castPtr cs)\n  cs_bs <- BS.packCStringLen (cs `plusPtr` 8, fromIntegral msgLength)\n  let res_bs = f cs_bs\n  res_cs <- byteStringToMallocedCStringWith64bitLength res_bs\n  return res_cs\n\n\n-- | Transforms a \'ByteString\'-mapping \'IO\' function to \'CString\'-mapping function\n-- for use in the FFI.\nbyteStringToCStringFunIO :: (ByteString -> IO ByteString) -> CString -> IO CString\nbyteStringToCStringFunIO f cs = do\n  msgLength :: Int64 <- peekBE (castPtr cs)\n  cs_bs <- BS.packCStringLen (cs `plusPtr` 8, fromIntegral msgLength)\n  res_bs <- f cs_bs\n  res_cs <- byteStringToMallocedCStringWith64bitLength res_bs\n  return res_cs\n\n\n-- | Exports a "pure" function\n-- to an FFI function that takes its arguments as a serialized MessagePack message.\n--\n-- Calling this function throws an \'error\' if the de-serialization of the arguments fails!\n-- Use \'tryExport\' if you want to handle this case.\nexport :: (MSG.MessagePack (TypeList l), ToTypeList f l r, MSG.MessagePack r) => f -> CString -> IO CString\nexport = byteStringToCStringFun . uncurryMsgpack\n\n\n-- | Exports an \'IO\' function to an FFI function that takes its arguments as a serialized MessagePack message.\n--\n-- Calling this function throws an \'error\' if the de-serialization of the arguments fails!\n-- Use \'tryExportIO\' if you want to handle this case.\nexportIO :: (MSG.MessagePack (TypeList l), ToTypeList f l (IO r), MSG.MessagePack r) => f -> CString -> IO CString\nexportIO = byteStringToCStringFunIO . uncurryMsgpackIO\n\n\n-- TODO make equivalent using tryUncurryMsgpack (tryExport)\n-- TODO make equivalent using tryUncurryMsgpackIO (tryExport)\n'