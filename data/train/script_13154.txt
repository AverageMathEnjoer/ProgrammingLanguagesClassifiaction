b'{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-name-shadowing #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE CPP #-}\n{-# LANGUAGE UndecidableInstances #-}\n\n-- | Data types for Postgres syntax. Access is given mainly for extension\n-- modules. The types and definitions here are likely to change.\nmodule Database.Beam.Postgres.Syntax\n    ( PgSyntaxF(..), PgSyntaxM\n    , PgSyntax(..)\n\n    , emit, emitBuilder, escapeString\n    , escapeBytea, escapeIdentifier\n    , pgParens\n\n    , nextSyntaxStep\n\n    , PgCommandSyntax(..), PgCommandType(..)\n    , PgSelectSyntax(..), PgSelectSetQuantifierSyntax(..)\n    , PgInsertSyntax(..)\n    , PgDeleteSyntax(..)\n    , PgUpdateSyntax(..)\n\n    , PgExpressionSyntax(..), PgFromSyntax(..), PgTableNameSyntax(..)\n    , PgComparisonQuantifierSyntax(..)\n    , PgExtractFieldSyntax(..)\n    , PgProjectionSyntax(..), PgGroupingSyntax(..)\n    , PgOrderingSyntax(..), PgValueSyntax(..)\n    , PgTableSourceSyntax(..), PgFieldNameSyntax(..)\n    , PgAggregationSetQuantifierSyntax(..)\n    , PgInsertValuesSyntax(..), PgInsertOnConflictSyntax(..)\n    , PgInsertOnConflictTargetSyntax(..), PgConflictActionSyntax(..)\n    , PgCreateTableSyntax(..), PgTableOptionsSyntax(..), PgColumnSchemaSyntax(..)\n    , PgDataTypeSyntax(..), PgColumnConstraintDefinitionSyntax(..), PgColumnConstraintSyntax(..)\n    , PgTableConstraintSyntax(..), PgMatchTypeSyntax(..), PgReferentialActionSyntax(..)\n\n    , PgAlterTableSyntax(..), PgAlterTableActionSyntax(..), PgAlterColumnActionSyntax(..)\n\n    , PgWindowFrameSyntax(..), PgWindowFrameBoundsSyntax(..), PgWindowFrameBoundSyntax(..)\n\n    , PgSelectLockingClauseSyntax(..)\n    , PgSelectLockingStrength(..)\n    , PgSelectLockingOptions(..)\n    , fromPgSelectLockingClause\n    , pgSelectStmt\n    , defaultPgValueSyntax\n\n    , PgDataTypeDescr(..)\n    , PgHasEnum(..)\n\n    , pgCreateExtensionSyntax, pgDropExtensionSyntax\n    , pgCreateEnumSyntax, pgDropTypeSyntax\n\n    , pgSimpleMatchSyntax\n\n    , pgSelectSetQuantifierDistinctOn\n\n    , pgDataTypeJSON\n\n    , pgTsQueryType, pgTsVectorType\n    , pgJsonType, pgJsonbType, pgUuidType\n    , pgMoneyType\n    , pgTsQueryTypeInfo, pgTsVectorTypeInfo\n\n    , pgByteaType, pgTextType, pgUnboundedArrayType\n    , pgSerialType, pgSmallSerialType, pgBigSerialType\n\n    , pgPointType, pgLineType, pgLineSegmentType, pgBoxType\n\n    , pgQuotedIdentifier, pgSepBy, pgDebugRenderSyntax\n    , pgRenderSyntaxScript, pgBuildAction\n\n    , pgBinOp, pgCompOp, pgUnOp, pgPostFix\n\n    , pgTestSyntax\n\n    , PostgresInaccessible ) where\n\nimport           Database.Beam hiding (insert)\nimport           Database.Beam.Backend.Internal.Compat\nimport           Database.Beam.Backend.SQL\nimport           Database.Beam.Migrate\nimport           Database.Beam.Migrate.SQL.Builder hiding (fromSqlConstraintAttributes)\nimport           Database.Beam.Migrate.Serialization\n\nimport           Control.Monad (guard)\nimport           Control.Monad.Free\nimport           Control.Monad.Free.Church\n\nimport           Data.Aeson (Value, object, (.=))\nimport           Data.Bits\nimport           Data.ByteString (ByteString)\nimport           Data.ByteString.Builder (Builder, byteString, char8, toLazyByteString)\nimport qualified Data.ByteString.Char8 as B\nimport           Data.ByteString.Lazy.Char8 (toStrict)\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport           Data.CaseInsensitive (CI)\nimport qualified Data.CaseInsensitive as CI\nimport           Data.Coerce\nimport           Data.Functor.Classes\nimport           Data.Hashable\nimport           Data.Int\nimport           Data.Maybe\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Semigroup\n#endif\nimport           Data.Scientific (Scientific)\nimport           Data.String (IsString(..), fromString)\nimport qualified Data.Text as T\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.Text.Lazy as TL\nimport           Data.Time (LocalTime, UTCTime, TimeOfDay, NominalDiffTime, Day)\nimport           Data.UUID.Types (UUID, toASCIIBytes)\nimport           Data.Word\nimport qualified Data.Vector as V\nimport           GHC.TypeLits\n\nimport qualified Database.PostgreSQL.Simple.ToField as Pg\nimport qualified Database.PostgreSQL.Simple.TypeInfo.Static as Pg\nimport qualified Database.PostgreSQL.Simple.Types as Pg (Oid(..), Binary(..), Null(..))\nimport qualified Database.PostgreSQL.Simple.Time as Pg (Date, LocalTimestamp, UTCTimestamp)\nimport qualified Database.PostgreSQL.Simple.HStore as Pg (HStoreList, HStoreMap, HStoreBuilder)\n\ndata PostgresInaccessible\n\n-- TODO This probably shouldn\'t be a free monad... oh well.\ndata PgSyntaxF f where\n  EmitByteString :: ByteString -> f -> PgSyntaxF f\n  EmitBuilder    :: Builder -> f -> PgSyntaxF f\n\n  EscapeString :: ByteString -> f -> PgSyntaxF f\n  EscapeBytea  :: ByteString -> f -> PgSyntaxF f\n  EscapeIdentifier :: ByteString -> f -> PgSyntaxF f\nderiving instance Functor PgSyntaxF\n\ninstance Eq1 PgSyntaxF where\n  liftEq eq (EmitByteString b1 next1) (EmitByteString b2 next2) =\n      b1 == b2 && next1 `eq` next2\n  liftEq eq (EmitBuilder b1 next1) (EmitBuilder b2 next2) =\n      toLazyByteString b1 == toLazyByteString b2 && next1 `eq` next2\n  liftEq eq (EscapeString b1 next1) (EscapeString b2 next2) =\n      b1 == b2 && next1 `eq` next2\n  liftEq eq (EscapeBytea b1 next1) (EscapeBytea b2 next2) =\n      b1 == b2 && next1 `eq` next2\n  liftEq eq (EscapeIdentifier b1 next1) (EscapeIdentifier b2 next2) =\n      b1 == b2 && next1 `eq` next2\n  liftEq _ _ _ = False\n\ninstance Eq f => Eq (PgSyntaxF f) where\n  (==) = eq1\n\ninstance Hashable PgSyntax where\n  hashWithSalt salt (PgSyntax s) = runF s finish step salt\n    where\n      finish _ salt = hashWithSalt salt ()\n      step (EmitByteString b hashRest) salt = hashRest (hashWithSalt salt (0 :: Int, b))\n      step (EmitBuilder b hashRest)    salt = hashRest (hashWithSalt salt (1 :: Int, toLazyByteString b))\n      step (EscapeString  b hashRest)  salt = hashRest (hashWithSalt salt (2 :: Int, b))\n      step (EscapeBytea  b hashRest)   salt = hashRest (hashWithSalt salt (3 :: Int, b))\n      step (EscapeIdentifier b hashRest) salt = hashRest (hashWithSalt salt (4 :: Int, b))\n\ninstance Sql92DisplaySyntax PgSyntax where\n  displaySyntax = BL.unpack . pgRenderSyntaxScript\n\ntype PgSyntaxM = F PgSyntaxF\n\n-- | A piece of Postgres SQL syntax, which may contain embedded escaped byte and\n-- text sequences. \'PgSyntax\' composes monoidally, and may be created with\n-- \'emit\', \'emitBuilder\', \'escapeString\', \'escapBytea\', and \'escapeIdentifier\'.\nnewtype PgSyntax\n  = PgSyntax { buildPgSyntax :: PgSyntaxM () }\n\ninstance Semigroup PgSyntax where\n  a <> b = PgSyntax (buildPgSyntax a >> buildPgSyntax b)\n\ninstance Monoid PgSyntax where\n  mempty = PgSyntax (pure ())\n  mappend = (<>)\n\ninstance Eq PgSyntax where\n  PgSyntax x == PgSyntax y = (fromF x :: Free PgSyntaxF ()) == fromF y\n\ninstance Show PgSyntax where\n  showsPrec prec s =\n    showParen (prec > 10) $\n    showString "PgSyntax <" .\n    shows (pgTestSyntax s) .\n    showString ">"\n\nemit :: ByteString -> PgSyntax\nemit bs = PgSyntax (liftF (EmitByteString bs ()))\n\nemitBuilder :: Builder -> PgSyntax\nemitBuilder b = PgSyntax (liftF (EmitBuilder b ()))\n\nescapeString, escapeBytea, escapeIdentifier :: ByteString -> PgSyntax\nescapeString bs = PgSyntax (liftF (EscapeString bs ()))\nescapeBytea bin = PgSyntax (liftF (EscapeBytea bin ()))\nescapeIdentifier id = PgSyntax (liftF (EscapeIdentifier id ()))\n\nnextSyntaxStep :: PgSyntaxF f -> f\nnextSyntaxStep (EmitByteString _ next) = next\nnextSyntaxStep (EmitBuilder _ next) = next\nnextSyntaxStep (EscapeString _ next) = next\nnextSyntaxStep (EscapeBytea _ next) = next\nnextSyntaxStep (EscapeIdentifier _ next) = next\n\n-- * Syntax types\n\ndata PgCommandType\n    = PgCommandTypeQuery\n    | PgCommandTypeDdl\n    | PgCommandTypeDataUpdate\n    | PgCommandTypeDataUpdateReturning\n      deriving Show\n\n-- | Representation of an arbitrary Postgres command. This is the combination of\n-- the command syntax (repesented by \'PgSyntax\'), as well as the type of command\n-- (represented by \'PgCommandType\'). The command type is necessary for us to\n-- know how to retrieve results from the database.\ndata PgCommandSyntax\n    = PgCommandSyntax\n    { pgCommandType :: PgCommandType\n    , fromPgCommand :: PgSyntax }\n\n-- | \'IsSql92SelectSyntax\' for Postgres\nnewtype PgSelectSyntax = PgSelectSyntax { fromPgSelect :: PgSyntax }\n\nnewtype PgSelectTableSyntax = PgSelectTableSyntax { fromPgSelectTable :: PgSyntax }\n\n-- | \'IsSql92InsertSyntax\' for Postgres\nnewtype PgInsertSyntax = PgInsertSyntax { fromPgInsert :: PgSyntax }\n\n-- | \'IsSql92DeleteSyntax\' for Postgres\nnewtype PgDeleteSyntax = PgDeleteSyntax { fromPgDelete :: PgSyntax }\n\n-- | \'IsSql92UpdateSyntax\' for Postgres\nnewtype PgUpdateSyntax = PgUpdateSyntax { fromPgUpdate :: PgSyntax }\n\nnewtype PgExpressionSyntax = PgExpressionSyntax { fromPgExpression :: PgSyntax } deriving Eq\nnewtype PgAggregationSetQuantifierSyntax = PgAggregationSetQuantifierSyntax { fromPgAggregationSetQuantifier :: PgSyntax }\nnewtype PgSelectSetQuantifierSyntax = PgSelectSetQuantifierSyntax { fromPgSelectSetQuantifier :: PgSyntax }\nnewtype PgFromSyntax = PgFromSyntax { fromPgFrom :: PgSyntax }\nnewtype PgTableNameSyntax = PgTableNameSyntax { fromPgTableName :: PgSyntax }\nnewtype PgComparisonQuantifierSyntax = PgComparisonQuantifierSyntax { fromPgComparisonQuantifier :: PgSyntax }\nnewtype PgExtractFieldSyntax = PgExtractFieldSyntax { fromPgExtractField :: PgSyntax }\nnewtype PgProjectionSyntax = PgProjectionSyntax { fromPgProjection :: PgSyntax }\nnewtype PgGroupingSyntax = PgGroupingSyntax { fromPgGrouping :: PgSyntax }\nnewtype PgValueSyntax = PgValueSyntax { fromPgValue :: PgSyntax }\nnewtype PgTableSourceSyntax = PgTableSourceSyntax { fromPgTableSource :: PgSyntax }\nnewtype PgFieldNameSyntax = PgFieldNameSyntax { fromPgFieldName :: PgSyntax }\nnewtype PgInsertValuesSyntax = PgInsertValuesSyntax { fromPgInsertValues :: PgSyntax }\nnewtype PgInsertOnConflictSyntax = PgInsertOnConflictSyntax { fromPgInsertOnConflict :: PgSyntax }\nnewtype PgInsertOnConflictTargetSyntax = PgInsertOnConflictTargetSyntax { fromPgInsertOnConflictTarget :: PgSyntax }\nnewtype PgInsertOnConflictUpdateSyntax = PgInsertOnConflictUpdateSyntax { fromPgInsertOnConflictUpdate :: PgSyntax }\nnewtype PgConflictActionSyntax = PgConflictActionSyntax { fromPgConflictAction :: PgSyntax }\ndata PgOrderingSyntax = PgOrderingSyntax { pgOrderingSyntax :: PgSyntax, pgOrderingNullOrdering :: Maybe PgNullOrdering }\ndata PgSelectLockingClauseSyntax = PgSelectLockingClauseSyntax { pgSelectLockingClauseStrength :: PgSelectLockingStrength\n                                                               , pgSelectLockingTables :: [T.Text]\n                                                               , pgSelectLockingClauseOptions :: Maybe PgSelectLockingOptions }\nnewtype PgCommonTableExpressionSyntax\n    = PgCommonTableExpressionSyntax { fromPgCommonTableExpression :: PgSyntax }\n\nfromPgOrdering :: PgOrderingSyntax -> PgSyntax\nfromPgOrdering (PgOrderingSyntax s Nothing) = s\nfromPgOrdering (PgOrderingSyntax s (Just PgNullOrderingNullsFirst)) = s <> emit " NULLS FIRST"\nfromPgOrdering (PgOrderingSyntax s (Just PgNullOrderingNullsLast)) = s <> emit " NULLS LAST"\n\ndata PgNullOrdering\n  = PgNullOrderingNullsFirst\n  | PgNullOrderingNullsLast\n  deriving (Show, Eq, Generic)\n\nfromPgSelectLockingClause :: PgSelectLockingClauseSyntax -> PgSyntax\nfromPgSelectLockingClause s =\n  emit " FOR " <>\n  (case pgSelectLockingClauseStrength s of\n    PgSelectLockingStrengthUpdate -> emit "UPDATE"\n    PgSelectLockingStrengthNoKeyUpdate -> emit "NO KEY UPDATE"\n    PgSelectLockingStrengthShare -> emit "SHARE"\n    PgSelectLockingStrengthKeyShare -> emit "KEY SHARE") <>\n  emitTables <>\n  (maybe mempty emitOptions $ pgSelectLockingClauseOptions s)\n  where\n    emitTables = case pgSelectLockingTables s of\n      [] -> mempty\n      tableNames -> emit " OF " <> (pgSepBy (emit ", ") (map pgQuotedIdentifier tableNames))\n\n    emitOptions PgSelectLockingOptionsNoWait = emit " NOWAIT"\n    emitOptions PgSelectLockingOptionsSkipLocked = emit " SKIP LOCKED"\n\n-- | Specifies the level of lock that will be taken against a row. See\n-- <https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS the manual section>\n-- for more information.\ndata PgSelectLockingStrength\n  = PgSelectLockingStrengthUpdate\n  -- ^ @UPDATE@\n  | PgSelectLockingStrengthNoKeyUpdate\n  -- ^ @NO KEY UPDATE@\n  | PgSelectLockingStrengthShare\n  -- ^ @SHARE@\n  | PgSelectLockingStrengthKeyShare\n  -- ^ @KEY SHARE@\n  deriving (Show, Eq, Generic)\n\n-- | Specifies how we should handle lock conflicts.\n--\n-- See\n-- <https://www.postgresql.org/docs/9.5/static/sql-select.html#SQL-FOR-UPDATE-SHARE the manual section>\n-- for more information\ndata PgSelectLockingOptions\n  = PgSelectLockingOptionsNoWait\n  -- ^ @NOWAIT@. Report an error rather than waiting for the lock\n  | PgSelectLockingOptionsSkipLocked\n  -- ^ @SKIP LOCKED@. Rather than wait for a lock, skip the row instead\n  deriving (Show, Eq, Generic)\n\ndata PgDataTypeDescr\n  = PgDataTypeDescrOid Pg.Oid (Maybe Int32)\n  | PgDataTypeDescrDomain T.Text\n  deriving (Show, Eq, Generic)\ninstance Hashable PgDataTypeDescr where\n  hashWithSalt salt (PgDataTypeDescrOid (Pg.Oid oid) dim) =\n    hashWithSalt salt (0 :: Int, fromIntegral oid :: Word32, dim)\n  hashWithSalt salt (PgDataTypeDescrDomain t) =\n    hashWithSalt salt (1 :: Int, t)\n\nnewtype PgCreateTableSyntax = PgCreateTableSyntax { fromPgCreateTable :: PgSyntax }\ndata PgTableOptionsSyntax = PgTableOptionsSyntax PgSyntax PgSyntax\nnewtype PgColumnSchemaSyntax = PgColumnSchemaSyntax { fromPgColumnSchema :: PgSyntax } deriving (Show, Eq)\ninstance Sql92DisplaySyntax PgColumnSchemaSyntax where\n  displaySyntax = displaySyntax . fromPgColumnSchema\n\ndata PgDataTypeSyntax\n  = PgDataTypeSyntax\n  { pgDataTypeDescr :: PgDataTypeDescr\n  , fromPgDataType :: PgSyntax\n  , pgDataTypeSerialized :: BeamSerializedDataType\n  } deriving Show\ninstance Sql92DisplaySyntax PgDataTypeSyntax where\n  displaySyntax = displaySyntax . fromPgDataType\n\ndata PgColumnConstraintDefinitionSyntax\n  = PgColumnConstraintDefinitionSyntax\n  { fromPgColumnConstraintDefinition :: PgSyntax\n  , pgColumnConstraintDefinitionSerialized :: BeamSerializedConstraintDefinition\n  } deriving Show\ninstance Sql92DisplaySyntax PgColumnConstraintDefinitionSyntax where\n  displaySyntax = displaySyntax . fromPgColumnConstraintDefinition\n\ndata PgColumnConstraintSyntax\n  = PgColumnConstraintSyntax\n  { fromPgColumnConstraint :: PgSyntax\n  , pgColumnConstraintSerialized :: BeamSerializedConstraint\n  }\nnewtype PgTableConstraintSyntax = PgTableConstraintSyntax { fromPgTableConstraint :: PgSyntax }\ndata PgMatchTypeSyntax\n  = PgMatchTypeSyntax\n  { fromPgMatchType :: PgSyntax\n  , pgMatchTypeSerialized :: BeamSerializedMatchType\n  }\ndata PgReferentialActionSyntax\n  = PgReferentialActionSyntax\n  { fromPgReferentialAction :: PgSyntax\n  , pgReferentialActionSerialized :: BeamSerializedReferentialAction\n  }\nnewtype PgDropTableSyntax = PgDropTableSyntax { fromPgDropTable :: PgSyntax }\nnewtype PgAlterTableSyntax = PgAlterTableSyntax { fromPgAlterTable :: PgSyntax }\nnewtype PgAlterTableActionSyntax = PgAlterTableActionSyntax { fromPgAlterTableAction :: PgSyntax }\nnewtype PgAlterColumnActionSyntax = PgAlterColumnActionSyntax { fromPgAlterColumnAction :: PgSyntax }\nnewtype PgWindowFrameSyntax = PgWindowFrameSyntax { fromPgWindowFrame :: PgSyntax }\nnewtype PgWindowFrameBoundsSyntax = PgWindowFrameBoundsSyntax { fromPgWindowFrameBounds :: PgSyntax }\nnewtype PgWindowFrameBoundSyntax = PgWindowFrameBoundSyntax { fromPgWindowFrameBound :: ByteString -> PgSyntax }\n\ninstance Hashable PgDataTypeSyntax where\n  hashWithSalt salt (PgDataTypeSyntax a _ _) = hashWithSalt salt a\ninstance Eq PgDataTypeSyntax where\n  PgDataTypeSyntax a _ _ == PgDataTypeSyntax b _ _ = a == b\n\ninstance HasDataTypeCreatedCheck PgDataTypeSyntax where\n  dataTypeHasBeenCreated (PgDataTypeSyntax (PgDataTypeDescrOid {}) _ _) _ = True\n  dataTypeHasBeenCreated (PgDataTypeSyntax (PgDataTypeDescrDomain d) _ _) pre =\n    not . null $\n    do PgHasEnum nm _ <- pre\n       guard (nm == d)\n\ninstance Eq PgColumnConstraintDefinitionSyntax where\n  PgColumnConstraintDefinitionSyntax a _ ==\n    PgColumnConstraintDefinitionSyntax b _ =\n      a == b\n\ninstance IsSql92Syntax PgCommandSyntax where\n  type Sql92SelectSyntax PgCommandSyntax = PgSelectSyntax\n  type Sql92InsertSyntax PgCommandSyntax = PgInsertSyntax\n  type Sql92UpdateSyntax PgCommandSyntax = PgUpdateSyntax\n  type Sql92DeleteSyntax PgCommandSyntax = PgDeleteSyntax\n\n  selectCmd = PgCommandSyntax PgCommandTypeQuery      . coerce\n  insertCmd = PgCommandSyntax PgCommandTypeDataUpdate . coerce\n  deleteCmd = PgCommandSyntax PgCommandTypeDataUpdate . coerce\n  updateCmd = PgCommandSyntax PgCommandTypeDataUpdate . coerce\n\ninstance IsSql92DdlCommandSyntax PgCommandSyntax where\n  type Sql92DdlCommandCreateTableSyntax PgCommandSyntax = PgCreateTableSyntax\n  type Sql92DdlCommandDropTableSyntax PgCommandSyntax = PgDropTableSyntax\n  type Sql92DdlCommandAlterTableSyntax PgCommandSyntax = PgAlterTableSyntax\n\n  createTableCmd = PgCommandSyntax PgCommandTypeDdl . coerce\n  dropTableCmd   = PgCommandSyntax PgCommandTypeDdl . coerce\n  alterTableCmd  = PgCommandSyntax PgCommandTypeDdl . coerce\n\ninstance IsSql92TableNameSyntax PgTableNameSyntax where\n  tableName Nothing t = PgTableNameSyntax (pgQuotedIdentifier t)\n  tableName (Just s) t = PgTableNameSyntax (pgQuotedIdentifier s <> emit "." <> pgQuotedIdentifier t)\n\ninstance IsSql92UpdateSyntax PgUpdateSyntax where\n  type Sql92UpdateFieldNameSyntax PgUpdateSyntax = PgFieldNameSyntax\n  type Sql92UpdateExpressionSyntax PgUpdateSyntax = PgExpressionSyntax\n  type Sql92UpdateTableNameSyntax PgUpdateSyntax = PgTableNameSyntax\n\n  updateStmt tbl fields where_ =\n    PgUpdateSyntax $\n    emit "UPDATE " <> fromPgTableName tbl <>\n    (case fields of\n       [] -> mempty\n       fields ->\n         emit " SET " <>\n         pgSepBy (emit ", ") (map (\\(field, val) -> fromPgFieldName field <> emit "=" <> fromPgExpression val) fields)) <>\n    maybe mempty (\\where_ -> emit " WHERE " <> fromPgExpression where_) where_\n\ninstance IsSql92DeleteSyntax PgDeleteSyntax where\n  type Sql92DeleteExpressionSyntax PgDeleteSyntax = PgExpressionSyntax\n  type Sql92DeleteTableNameSyntax PgDeleteSyntax = PgTableNameSyntax\n\n  deleteStmt tbl alias where_ =\n    PgDeleteSyntax $\n    emit "DELETE FROM " <> fromPgTableName tbl <>\n    maybe mempty (\\alias_ -> emit " AS " <> pgQuotedIdentifier alias_) alias <>\n    maybe mempty (\\where_ -> emit " WHERE " <> fromPgExpression where_) where_\n\n  deleteSupportsAlias _ = True\n\ninstance IsSql92SelectSyntax PgSelectSyntax where\n  type Sql92SelectSelectTableSyntax PgSelectSyntax = PgSelectTableSyntax\n  type Sql92SelectOrderingSyntax PgSelectSyntax = PgOrderingSyntax\n\n  selectStmt tbl ordering limit offset =\n    pgSelectStmt tbl ordering limit offset Nothing\n\ninstance IsSql92SelectTableSyntax PgSelectTableSyntax where\n  type Sql92SelectTableSelectSyntax PgSelectTableSyntax = PgSelectSyntax\n  type Sql92SelectTableExpressionSyntax PgSelectTableSyntax = PgExpressionSyntax\n  type Sql92SelectTableProjectionSyntax PgSelectTableSyntax = PgProjectionSyntax\n  type Sql92SelectTableFromSyntax PgSelectTableSyntax = PgFromSyntax\n  type Sql92SelectTableGroupingSyntax PgSelectTableSyntax = PgGroupingSyntax\n  type Sql92SelectTableSetQuantifierSyntax PgSelectTableSyntax = PgSelectSetQuantifierSyntax\n\n  selectTableStmt setQuantifier proj from where_ grouping having =\n    PgSelectTableSyntax $\n    emit "SELECT " <>\n    maybe mempty (\\setQuantifier\' -> fromPgSelectSetQuantifier setQuantifier\' <> emit " ") setQuantifier <>\n    fromPgProjection proj <>\n    (maybe mempty (emit " FROM " <> ) (coerce from)) <>\n    (maybe mempty (emit " WHERE " <>) (coerce where_)) <>\n    (maybe mempty (emit " GROUP BY " <>) (coerce grouping)) <>\n    (maybe mempty (emit " HAVING " <>) (coerce having))\n\n  unionTables all = pgTableOp (if all then "UNION ALL" else "UNION")\n  intersectTables all = pgTableOp (if all then "INTERSECT ALL" else "INTERSECT")\n  exceptTable all = pgTableOp (if all then "EXCEPT ALL" else "EXCEPT")\n\ninstance IsSql92GroupingSyntax PgGroupingSyntax where\n  type Sql92GroupingExpressionSyntax PgGroupingSyntax = PgExpressionSyntax\n\n  groupByExpressions es =\n      PgGroupingSyntax $\n      pgSepBy (emit ", ") (map fromPgExpression es)\n\ninstance IsSql92FromSyntax PgFromSyntax where\n  type Sql92FromExpressionSyntax PgFromSyntax = PgExpressionSyntax\n  type Sql92FromTableSourceSyntax PgFromSyntax = PgTableSourceSyntax\n\n  fromTable tableSrc Nothing = coerce tableSrc\n  fromTable tableSrc (Just (nm, colNms)) =\n      PgFromSyntax $\n      coerce tableSrc <> emit " AS " <> pgQuotedIdentifier nm <>\n      maybe mempty (\\colNms\' -> pgParens (pgSepBy (emit ",") (map pgQuotedIdentifier colNms\'))) colNms\n\n  innerJoin a b Nothing = PgFromSyntax (fromPgFrom a <> emit " CROSS JOIN " <> fromPgFrom b)\n  innerJoin a b (Just e) = pgJoin "INNER JOIN" a b (Just e)\n\n  leftJoin = pgJoin "LEFT JOIN"\n  rightJoin = pgJoin "RIGHT JOIN"\n\ninstance IsSql92FromOuterJoinSyntax PgFromSyntax where\n  outerJoin = pgJoin "FULL OUTER JOIN"\n\ninstance IsSql92OrderingSyntax PgOrderingSyntax where\n  type Sql92OrderingExpressionSyntax PgOrderingSyntax = PgExpressionSyntax\n\n  ascOrdering e = PgOrderingSyntax (fromPgExpression e <> emit " ASC") Nothing\n  descOrdering e = PgOrderingSyntax (fromPgExpression e <> emit " DESC") Nothing\n\ninstance IsSql2003OrderingElementaryOLAPOperationsSyntax PgOrderingSyntax where\n  nullsFirstOrdering o = o { pgOrderingNullOrdering = Just PgNullOrderingNullsFirst }\n  nullsLastOrdering o = o { pgOrderingNullOrdering = Just PgNullOrderingNullsLast }\n\ninstance IsSql92DataTypeSyntax PgDataTypeSyntax where\n  domainType nm = PgDataTypeSyntax (PgDataTypeDescrDomain nm) (pgQuotedIdentifier nm)\n                                   (domainType nm)\n\n  charType prec charSet = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.bpchar) (Just (fromIntegral (fromMaybe 1 prec))))\n                                           (emit "CHAR" <> pgOptPrec prec <> pgOptCharSet charSet)\n                                           (charType prec charSet)\n  varCharType prec charSet = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.varchar) (fmap fromIntegral prec))\n                                              (emit "VARCHAR" <> pgOptPrec prec <> pgOptCharSet charSet)\n                                              (varCharType prec charSet)\n  nationalCharType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.bpchar) (fmap fromIntegral prec))\n                                           (emit "NATIONAL CHAR" <> pgOptPrec prec)\n                                           (nationalCharType prec)\n  nationalVarCharType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.varchar) (fmap fromIntegral prec))\n                                              (emit "NATIONAL CHARACTER VARYING" <> pgOptPrec prec)\n                                              (nationalVarCharType prec)\n\n  bitType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.bit) (fmap fromIntegral prec))\n                                  (emit "BIT" <> pgOptPrec prec)\n                                  (bitType prec)\n  varBitType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.varbit) (fmap fromIntegral prec))\n                                     (emit "BIT VARYING" <> pgOptPrec prec)\n                                     (varBitType prec)\n\n  numericType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.numeric) (mkNumericPrec prec))\n                                      (emit "NUMERIC" <> pgOptNumericPrec prec)\n                                      (numericType prec)\n  decimalType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.numeric) (mkNumericPrec prec))\n                                      (emit "DECIMAL" <> pgOptNumericPrec prec)\n                                      (decimalType prec)\n\n  intType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.int4) Nothing) (emit "INT") intType\n  smallIntType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.int2) Nothing) (emit "SMALLINT") smallIntType\n\n  floatType prec = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.float4) Nothing) (emit "FLOAT" <> pgOptPrec prec)\n                                    (floatType prec)\n  doubleType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.float8) Nothing) (emit "DOUBLE PRECISION") doubleType\n  realType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.float4) Nothing) (emit "REAL") realType\n  dateType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.date) Nothing) (emit "DATE") dateType\n  timeType prec withTz = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.time) Nothing)\n                                          (emit "TIME" <> pgOptPrec prec <> if withTz then emit " WITH TIME ZONE" else mempty)\n                                          (timeType prec withTz)\n  timestampType prec withTz = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid (if withTz then Pg.timestamptz else Pg.timestamp)) Nothing)\n                                               (emit "TIMESTAMP" <> pgOptPrec prec <> if withTz then emit " WITH TIME ZONE" else mempty)\n                                               (timestampType prec withTz)\n\ninstance IsSql99DataTypeSyntax PgDataTypeSyntax where\n  characterLargeObjectType = pgTextType { pgDataTypeSerialized = characterLargeObjectType }\n  binaryLargeObjectType = pgByteaType { pgDataTypeSerialized = binaryLargeObjectType }\n  booleanType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.bool) Nothing) (emit "BOOLEAN")\n                                 booleanType\n  arrayType (PgDataTypeSyntax _ syntax serialized) sz =\n    PgDataTypeSyntax (error "TODO: array migrations")\n                     (syntax <> emit "[" <> emit (fromString (show sz)) <> emit "]")\n                     (arrayType serialized sz)\n  rowType = error "rowType"\n\ninstance IsSql99CommonTableExpressionSelectSyntax PgSelectSyntax where\n    type Sql99SelectCTESyntax PgSelectSyntax = PgCommonTableExpressionSyntax\n\n    withSyntax ctes (PgSelectSyntax select) =\n        PgSelectSyntax $\n        emit "WITH " <>\n        pgSepBy (emit ", ") (map fromPgCommonTableExpression ctes) <>\n        select\n\ninstance IsSql99RecursiveCommonTableExpressionSelectSyntax PgSelectSyntax where\n    withRecursiveSyntax ctes (PgSelectSyntax select) =\n        PgSelectSyntax $\n        emit "WITH RECURSIVE " <>\n        pgSepBy (emit ", ") (map fromPgCommonTableExpression ctes) <>\n        select\n\ninstance IsSql99CommonTableExpressionSyntax PgCommonTableExpressionSyntax where\n    type Sql99CTESelectSyntax PgCommonTableExpressionSyntax = PgSelectSyntax\n\n    cteSubquerySyntax tbl fields (PgSelectSyntax select) =\n        PgCommonTableExpressionSyntax $\n        pgQuotedIdentifier tbl <> pgParens (pgSepBy (emit ",") (map pgQuotedIdentifier fields)) <>\n        emit " AS " <> pgParens select\n\ninstance IsSql2008BigIntDataTypeSyntax PgDataTypeSyntax where\n  bigIntType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.int8) Nothing) (emit "BIGINT") bigIntType\n\ninstance Sql92SerializableDataTypeSyntax PgDataTypeSyntax where\n  serializeDataType = fromBeamSerializedDataType . pgDataTypeSerialized\n\npgOptPrec :: Maybe Word -> PgSyntax\npgOptPrec Nothing = mempty\npgOptPrec (Just x) = emit "(" <> emit (fromString (show x)) <> emit ")"\n\npgOptCharSet :: Maybe T.Text -> PgSyntax\npgOptCharSet Nothing = mempty\npgOptCharSet (Just cs) = emit " CHARACTER SET " <> emit (TE.encodeUtf8 cs)\n\npgOptNumericPrec :: Maybe (Word, Maybe Word) -> PgSyntax\npgOptNumericPrec Nothing = mempty\npgOptNumericPrec (Just (prec, Nothing)) = pgOptPrec (Just prec)\npgOptNumericPrec (Just (prec, Just dec)) = emit "(" <> emit (fromString (show prec)) <> emit ", " <> emit (fromString (show dec)) <> emit ")"\n\npgDataTypeJSON :: Value -> BeamSerializedDataType\npgDataTypeJSON v = BeamSerializedDataType (beamSerializeJSON "postgres" v)\n\npgByteaType :: PgDataTypeSyntax\npgByteaType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.bytea) Nothing) (emit "BYTEA")\n                               (pgDataTypeJSON "bytea")\n\npgSmallSerialType, pgSerialType, pgBigSerialType :: PgDataTypeSyntax\npgSmallSerialType = PgDataTypeSyntax (pgDataTypeDescr smallIntType) (emit "SMALLSERIAL") (pgDataTypeJSON "smallserial")\npgSerialType = PgDataTypeSyntax (pgDataTypeDescr intType) (emit "SERIAL") (pgDataTypeJSON "serial")\npgBigSerialType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.int8) Nothing) (emit "BIGSERIAL") (pgDataTypeJSON "bigserial")\n\npgPointType, pgLineType, pgLineSegmentType, pgBoxType :: PgDataTypeSyntax\npgPointType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.point) Nothing) (emit "POINT") (pgDataTypeJSON "point")\npgLineType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.line) Nothing) (emit "LINE") (pgDataTypeJSON "line")\npgLineSegmentType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.lseg) Nothing) (emit "LSEG") (pgDataTypeJSON "lseg")\npgBoxType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.box) Nothing) (emit "BOX") (pgDataTypeJSON "box")\n\npgUnboundedArrayType :: PgDataTypeSyntax -> PgDataTypeSyntax\npgUnboundedArrayType (PgDataTypeSyntax _ syntax serialized) =\n    PgDataTypeSyntax (error "Can\'t do array migrations yet")\n                     (syntax <> emit "[]")\n                     (pgDataTypeJSON (object [ "unbounded-array" .= fromBeamSerializedDataType serialized ]))\n\npgTsQueryTypeInfo :: Pg.TypeInfo\npgTsQueryTypeInfo = Pg.Basic (Pg.Oid 3615) \'U\' \',\' "tsquery"\n\npgTsQueryType :: PgDataTypeSyntax\npgTsQueryType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid pgTsQueryTypeInfo) Nothing)\n                                 (emit "TSQUERY") (pgDataTypeJSON "tsquery")\n\n-- | Postgres TypeInfo for tsvector\n-- TODO Is the Oid stable from postgres instance to postgres instance?\npgTsVectorTypeInfo :: Pg.TypeInfo\npgTsVectorTypeInfo = Pg.Basic (Pg.Oid 3614) \'U\' \',\' "tsvector"\n\npgTsVectorType :: PgDataTypeSyntax\npgTsVectorType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid pgTsVectorTypeInfo) Nothing)\n                                  (emit "TSVECTOR")\n                                  (pgDataTypeJSON "tsvector")\n\npgTextType :: PgDataTypeSyntax\npgTextType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.text) Nothing) (emit "TEXT")\n                              (pgDataTypeJSON "text")\n\npgJsonType, pgJsonbType :: PgDataTypeSyntax\npgJsonType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.json) Nothing) (emit "JSON") (pgDataTypeJSON "json")\npgJsonbType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.jsonb) Nothing) (emit "JSONB") (pgDataTypeJSON "jsonb")\n\npgUuidType :: PgDataTypeSyntax\npgUuidType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.uuid) Nothing) (emit "UUID") (pgDataTypeJSON "uuid")\n\npgMoneyType :: PgDataTypeSyntax\npgMoneyType = PgDataTypeSyntax (PgDataTypeDescrOid (Pg.typoid Pg.money) Nothing) (emit "MONEY") (pgDataTypeJSON "money")\n\nmkNumericPrec :: Maybe (Word, Maybe Word) -> Maybe Int32\nmkNumericPrec Nothing = Nothing\nmkNumericPrec (Just (whole, dec)) = Just $ (fromIntegral whole `shiftL` 16) .|. (fromIntegral (fromMaybe 0 dec) .&. 0xFFFF)\n\ninstance IsCustomSqlSyntax PgExpressionSyntax where\n  newtype CustomSqlSyntax PgExpressionSyntax =\n    PgCustomExpressionSyntax { fromPgCustomExpression :: PgSyntax }\n    deriving Monoid\n  customExprSyntax = PgExpressionSyntax . fromPgCustomExpression\n  renderSyntax = PgCustomExpressionSyntax . pgParens . fromPgExpression\n\ninstance Semigroup (CustomSqlSyntax PgExpressionSyntax) where\n  (<>) = mappend\n\ninstance IsString (CustomSqlSyntax PgExpressionSyntax) where\n  fromString = PgCustomExpressionSyntax . emit . fromString\n\ninstance IsSql92QuantifierSyntax PgComparisonQuantifierSyntax where\n  quantifyOverAll = PgComparisonQuantifierSyntax (emit "ALL")\n  quantifyOverAny = PgComparisonQuantifierSyntax (emit "ANY")\n\ninstance IsSql92ExtractFieldSyntax PgExtractFieldSyntax where\n  secondsField = PgExtractFieldSyntax (emit "SECOND")\n  minutesField = PgExtractFieldSyntax (emit "MINUTE")\n  hourField    = PgExtractFieldSyntax (emit "HOUR")\n  dayField     = PgExtractFieldSyntax (emit "DAY")\n  monthField   = PgExtractFieldSyntax (emit "MONTH")\n  yearField    = PgExtractFieldSyntax (emit "YEAR")\n\ninstance IsSql92ExpressionSyntax PgExpressionSyntax where\n  type Sql92ExpressionValueSyntax PgExpressionSyntax = PgValueSyntax\n  type Sql92ExpressionSelectSyntax PgExpressionSyntax = PgSelectSyntax\n  type Sql92ExpressionFieldNameSyntax PgExpressionSyntax = PgFieldNameSyntax\n  type Sql92ExpressionQuantifierSyntax PgExpressionSyntax = PgComparisonQuantifierSyntax\n  type Sql92ExpressionCastTargetSyntax PgExpressionSyntax = PgDataTypeSyntax\n  type Sql92ExpressionExtractFieldSyntax PgExpressionSyntax = PgExtractFieldSyntax\n\n  addE = pgBinOp "+"\n  subE = pgBinOp "-"\n  mulE = pgBinOp "*"\n  divE = pgBinOp "/"\n  modE = pgBinOp "%"\n  orE = pgBinOp "OR"\n  andE = pgBinOp "AND"\n  likeE = pgBinOp "LIKE"\n  overlapsE = pgBinOp "OVERLAPS"\n  eqE = pgCompOp "="\n  neqE = pgCompOp "<>"\n  eqMaybeE a b _ = pgBinOp "IS NOT DISTINCT FROM" a b\n  neqMaybeE a b _ = pgBinOp "IS DISTINCT FROM" a b\n  ltE = pgCompOp "<"\n  gtE = pgCompOp ">"\n  leE = pgCompOp "<="\n  geE = pgCompOp ">="\n  negateE = pgUnOp "-"\n  notE = pgUnOp "NOT"\n  existsE select = PgExpressionSyntax (emit "EXISTS (" <> fromPgSelect select <> emit ")")\n  uniqueE select = PgExpressionSyntax (emit "UNIQUE (" <> fromPgSelect select <> emit ")")\n  isNotNullE = pgPostFix "IS NOT NULL"\n  isNullE = pgPostFix "IS NULL"\n  isTrueE = pgPostFix "IS TRUE"\n  isFalseE = pgPostFix "IS FALSE"\n  isNotTrueE = pgPostFix "IS NOT TRUE"\n  isNotFalseE = pgPostFix "IS NOT FALSE"\n  isUnknownE = pgPostFix "IS UNKNOWN"\n  isNotUnknownE = pgPostFix "IS NOT UNKNOWN"\n  betweenE a b c = PgExpressionSyntax (emit "(" <> fromPgExpression a <> emit ") BETWEEN (" <>\n                                       fromPgExpression b <> emit ") AND (" <> fromPgExpression c <> emit ")")\n  valueE = coerce\n  rowE vs = PgExpressionSyntax $\n            emit "(" <>\n            pgSepBy (emit ", ") (coerce vs) <>\n            emit ")"\n  quantifierListE vs =\n    PgExpressionSyntax $\n    emit "(VALUES " <> pgSepBy (emit ", ") (fmap (pgParens . fromPgExpression) vs) <> emit ")"\n  fieldE = coerce\n  subqueryE s = PgExpressionSyntax (emit "(" <> fromPgSelect s <> emit ")")\n  positionE needle haystack =\n      PgExpressionSyntax $\n      emit "POSITION((" <> fromPgExpression needle <> emit ") IN (" <> fromPgExpression haystack <> emit "))"\n  nullIfE a b = PgExpressionSyntax (emit "NULLIF(" <> fromPgExpression a <> emit ", " <> fromPgExpression b <> emit ")")\n  absE x = PgExpressionSyntax (emit "ABS(" <> fromPgExpression x <> emit ")")\n  bitLengthE x = PgExpressionSyntax (emit "BIT_LENGTH(" <> fromPgExpression x <> emit ")")\n  charLengthE x = PgExpressionSyntax (emit "CHAR_LENGTH(" <> fromPgExpression x <> emit ")")\n  octetLengthE x = PgExpressionSyntax (emit "OCTET_LENGTH(" <> fromPgExpression x <> emit ")")\n  lowerE x = PgExpressionSyntax (emit "LOWER(" <> fromPgExpression x <> emit ")")\n  upperE x = PgExpressionSyntax (emit "UPPER(" <> fromPgExpression x <> emit ")")\n  trimE x = PgExpressionSyntax (emit "TRIM(" <> fromPgExpression x <> emit ")")\n  coalesceE es = PgExpressionSyntax (emit "COALESCE(" <> pgSepBy (emit ", ") (map fromPgExpression es) <> emit ")")\n  extractE field from = PgExpressionSyntax (emit "EXTRACT(" <> fromPgExtractField field <> emit " FROM (" <> fromPgExpression from <> emit "))")\n  castE e to = PgExpressionSyntax (emit "CAST((" <> fromPgExpression e <> emit ") AS " <> fromPgDataType to <> emit ")")\n  caseE cases else_ =\n      PgExpressionSyntax $\n      emit "CASE " <>\n      foldMap (\\(cond, res) -> emit "WHEN " <> fromPgExpression cond <> emit " THEN " <> fromPgExpression res <> emit " ") cases <>\n      emit "ELSE " <> fromPgExpression else_ <> emit " END"\n\n  currentTimestampE = PgExpressionSyntax $ emit "CURRENT_TIMESTAMP"\n\n  defaultE = PgExpressionSyntax $ emit "DEFAULT"\n\n  inE e es = PgExpressionSyntax $ pgParens (fromPgExpression e) <> emit " IN " <>\n                                  pgParens (pgSepBy (emit ", ") (map fromPgExpression es))\n  inSelectE e sel = PgExpressionSyntax $ pgParens (fromPgExpression e) <> emit " IN " <>\n                                         pgParens (fromPgSelect sel)\n\ninstance IsSql99FunctionExpressionSyntax PgExpressionSyntax where\n  functionCallE name args =\n    PgExpressionSyntax $\n    fromPgExpression name <>\n    pgParens (pgSepBy (emit ", ") (map fromPgExpression args))\n  functionNameE nm = PgExpressionSyntax (emit (TE.encodeUtf8 nm))\n\ninstance IsSql99ExpressionSyntax PgExpressionSyntax where\n  distinctE select = PgExpressionSyntax (emit "DISTINCT (" <> fromPgSelect select <> emit ")")\n  similarToE = pgBinOp "SIMILAR TO"\n\n  instanceFieldE i nm =\n    PgExpressionSyntax $\n    pgParens (fromPgExpression i) <> emit "." <> escapeIdentifier (TE.encodeUtf8 nm)\n\n  refFieldE i nm =\n    PgExpressionSyntax $\n    pgParens (fromPgExpression i) <> emit "->" <> escapeIdentifier (TE.encodeUtf8 nm)\n\ninstance IsSql99ConcatExpressionSyntax PgExpressionSyntax where\n  concatE [] = valueE (sqlValueSyntax ("" :: T.Text))\n  concatE [x] = x\n  concatE es =\n    PgExpressionSyntax $\n    emit "CONCAT" <> pgParens (pgSepBy (emit ", ") (map fromPgExpression es))\n\ninstance IsSql2003ExpressionSyntax PgExpressionSyntax where\n  type Sql2003ExpressionWindowFrameSyntax PgExpressionSyntax =\n    PgWindowFrameSyntax\n\n  overE expr frame =\n    PgExpressionSyntax $\n    fromPgExpression expr <> emit " " <> fromPgWindowFrame frame\n  rowNumberE = PgExpressionSyntax $ emit "ROW_NUMBER()"\n\ninstance IsSql2003EnhancedNumericFunctionsExpressionSyntax PgExpressionSyntax where\n  lnE    x = PgExpressionSyntax (emit "LN("    <> fromPgExpression x <> emit ")")\n  expE   x = PgExpressionSyntax (emit "EXP("   <> fromPgExpression x <> emit ")")\n  sqrtE  x = PgExpressionSyntax (emit "SQRT("  <> fromPgExpression x <> emit ")")\n  ceilE  x = PgExpressionSyntax (emit "CEIL("  <> fromPgExpression x <> emit ")")\n  floorE x = PgExpressionSyntax (emit "FLOOR(" <> fromPgExpression x <> emit ")")\n  powerE x y = PgExpressionSyntax (emit "POWER(" <> fromPgExpression x <> emit ", " <> fromPgExpression y <> emit ")")\n\ninstance IsSql2003ExpressionAdvancedOLAPOperationsSyntax PgExpressionSyntax where\n  denseRankAggE = PgExpressionSyntax $ emit "DENSE_RANK()"\n  percentRankAggE = PgExpressionSyntax $ emit "PERCENT_RANK()"\n  cumeDistAggE = PgExpressionSyntax $ emit "CUME_DIST()"\n\ninstance IsSql2003ExpressionElementaryOLAPOperationsSyntax PgExpressionSyntax where\n  rankAggE = PgExpressionSyntax $ emit "RANK()"\n  filterAggE agg filter =\n    PgExpressionSyntax $\n    fromPgExpression agg <> emit " FILTER (WHERE " <> fromPgExpression filter <> emit ")"\n\ninstance IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax PgExpressionSyntax where\n  stddevPopE = pgUnAgg "STDDEV_POP"\n  stddevSampE = pgUnAgg "STDDEV_SAMP"\n  varPopE = pgUnAgg "VAR_POP"\n  varSampE = pgUnAgg "VAR_SAMP"\n\n  covarPopE = pgBinAgg "COVAR_POP"\n  covarSampE = pgBinAgg "COVAR_SAMP"\n  corrE = pgBinAgg "CORR"\n  regrSlopeE = pgBinAgg "REGR_SLOPE"\n  regrInterceptE = pgBinAgg "REGR_INTERCEPT"\n  regrCountE = pgBinAgg "REGR_COUNT"\n  regrRSquaredE = pgBinAgg "REGR_R2"\n  regrAvgXE = pgBinAgg "REGR_AVGX"\n  regrAvgYE = pgBinAgg "REGR_AVGY"\n  regrSXXE = pgBinAgg "REGR_SXX"\n  regrSYYE = pgBinAgg "REGR_SYY"\n  regrSXYE = pgBinAgg "REGR_SXY"\n\ninstance IsSql2003NtileExpressionSyntax PgExpressionSyntax where\n  ntileE x = PgExpressionSyntax (emit "NTILE(" <> fromPgExpression x <> emit ")")\n\ninstance IsSql2003LeadAndLagExpressionSyntax PgExpressionSyntax where\n  leadE x Nothing Nothing =\n    PgExpressionSyntax (emit "LEAD(" <> fromPgExpression x <> emit ")")\n  leadE x (Just n) Nothing =\n    PgExpressionSyntax (emit "LEAD(" <> fromPgExpression x <> emit ", " <> fromPgExpression n <> emit ")")\n  leadE x (Just n) (Just def) =\n    PgExpressionSyntax (emit "LEAD(" <> fromPgExpression x <> emit ", " <> fromPgExpression n <> emit ", " <> fromPgExpression def <> emit ")")\n  leadE x Nothing (Just def) =\n    PgExpressionSyntax (emit "LEAD(" <> fromPgExpression x <> emit ", 1, " <> fromPgExpression def <> emit ")")\n\n  lagE x Nothing Nothing =\n    PgExpressionSyntax (emit "LAG(" <> fromPgExpression x <> emit ")")\n  lagE x (Just n) Nothing =\n    PgExpressionSyntax (emit "LAG(" <> fromPgExpression x <> emit ", " <> fromPgExpression n <> emit ")")\n  lagE x (Just n) (Just def) =\n    PgExpressionSyntax (emit "LAG(" <> fromPgExpression x <> emit ", " <> fromPgExpression n <> emit ", " <> fromPgExpression def <> emit ")")\n  lagE x Nothing (Just def) =\n    PgExpressionSyntax (emit "LAG(" <> fromPgExpression x <> emit ", 1, " <> fromPgExpression def <> emit ")")\n\ninstance IsSql2003FirstValueAndLastValueExpressionSyntax PgExpressionSyntax where\n  firstValueE x = PgExpressionSyntax (emit "FIRST_VALUE(" <> fromPgExpression x <> emit ")")\n  lastValueE x = PgExpressionSyntax (emit "LAST_VALUE(" <> fromPgExpression x <> emit ")")\n\ninstance IsSql2003NthValueExpressionSyntax PgExpressionSyntax where\n  nthValueE x n = PgExpressionSyntax (emit "NTH_VALUE(" <> fromPgExpression x <> emit ", " <> fromPgExpression n <> emit ")")\n\ninstance IsSql2003WindowFrameSyntax PgWindowFrameSyntax where\n  type Sql2003WindowFrameExpressionSyntax PgWindowFrameSyntax = PgExpressionSyntax\n  type Sql2003WindowFrameOrderingSyntax PgWindowFrameSyntax = PgOrderingSyntax\n  type Sql2003WindowFrameBoundsSyntax PgWindowFrameSyntax = PgWindowFrameBoundsSyntax\n\n  frameSyntax partition_ ordering_ bounds_ =\n    PgWindowFrameSyntax $\n    emit "OVER " <>\n    pgParens\n    (\n      maybe mempty (\\p -> emit "PARTITION BY " <> pgSepBy (emit ", ") (map fromPgExpression p)) partition_ <>\n      maybe mempty (\\o -> emit " ORDER BY " <> pgSepBy (emit ", ") (map fromPgOrdering o)) ordering_ <>\n      maybe mempty (\\b -> emit " ROWS " <> fromPgWindowFrameBounds b) bounds_\n    )\n\ninstance IsSql2003WindowFrameBoundsSyntax PgWindowFrameBoundsSyntax where\n  type Sql2003WindowFrameBoundsBoundSyntax PgWindowFrameBoundsSyntax = PgWindowFrameBoundSyntax\n\n  fromToBoundSyntax from Nothing =\n    PgWindowFrameBoundsSyntax (fromPgWindowFrameBound from "PRECEDING")\n  fromToBoundSyntax from (Just to) =\n    PgWindowFrameBoundsSyntax $\n    emit "BETWEEN " <> fromPgWindowFrameBound from "PRECEDING" <> emit " AND " <> fromPgWindowFrameBound to "FOLLOWING"\n\ninstance IsSql2003WindowFrameBoundSyntax PgWindowFrameBoundSyntax where\n  unboundedSyntax = PgWindowFrameBoundSyntax $ \\where_ -> emit "UNBOUNDED " <> emit where_\n  nrowsBoundSyntax 0 = PgWindowFrameBoundSyntax $ \\_ -> emit "CURRENT ROW"\n  nrowsBoundSyntax n = PgWindowFrameBoundSyntax $ \\where_ -> emit (fromString (show n)) <> emit " " <> emit where_\n\ninstance IsSql92AggregationExpressionSyntax PgExpressionSyntax where\n  type Sql92AggregationSetQuantifierSyntax PgExpressionSyntax = PgAggregationSetQuantifierSyntax\n\n  countAllE = PgExpressionSyntax (emit "COUNT(*)")\n  countE = pgUnAgg "COUNT"\n  avgE = pgUnAgg "AVG"\n  sumE = pgUnAgg "SUM"\n  minE = pgUnAgg "MIN"\n  maxE = pgUnAgg "MAX"\n\ninstance IsSql99AggregationExpressionSyntax PgExpressionSyntax where\n  everyE = pgUnAgg "EVERY"\n\n  -- According to the note at <https://www.postgresql.org/docs/9.2/static/functions-aggregate.html>\n  -- the following functions are equivalent.\n  someE = pgUnAgg "BOOL_OR"\n  anyE = pgUnAgg "BOOL_OR"\n\ninstance IsSql92AggregationSetQuantifierSyntax PgAggregationSetQuantifierSyntax where\n  setQuantifierDistinct = PgAggregationSetQuantifierSyntax $ emit "DISTINCT"\n  setQuantifierAll = PgAggregationSetQuantifierSyntax $ emit "ALL"\n\ninstance IsSql92AggregationSetQuantifierSyntax PgSelectSetQuantifierSyntax where\n  setQuantifierDistinct = PgSelectSetQuantifierSyntax $ emit "DISTINCT"\n  setQuantifierAll = PgSelectSetQuantifierSyntax $ emit "ALL"\n\npgSelectSetQuantifierDistinctOn :: [PgExpressionSyntax] -> PgSelectSetQuantifierSyntax\npgSelectSetQuantifierDistinctOn exprs =\n  PgSelectSetQuantifierSyntax $\n  emit "DISTINCT ON " <> pgParens (pgSepBy (emit ", ") (fromPgExpression <$> exprs))\n\npgUnAgg :: ByteString -> Maybe PgAggregationSetQuantifierSyntax -> PgExpressionSyntax -> PgExpressionSyntax\npgUnAgg fn q e =\n  PgExpressionSyntax $\n  emit fn <> emit "(" <> maybe mempty (\\q -> fromPgAggregationSetQuantifier q <> emit " ") q <> fromPgExpression e <> emit ")"\n\npgBinAgg :: ByteString -> Maybe PgAggregationSetQuantifierSyntax -> PgExpressionSyntax -> PgExpressionSyntax\n         -> PgExpressionSyntax\npgBinAgg fn q x y =\n  PgExpressionSyntax $\n  emit fn <> emit "(" <> maybe mempty (\\q -> fromPgAggregationSetQuantifier q <> emit " ") q\n          <> fromPgExpression x <> emit ", " <> fromPgExpression y <> emit ")"\n\ninstance IsSql92FieldNameSyntax PgFieldNameSyntax where\n  qualifiedField a b =\n    PgFieldNameSyntax $\n    pgQuotedIdentifier a <> emit "." <> pgQuotedIdentifier b\n  unqualifiedField = PgFieldNameSyntax . pgQuotedIdentifier\n\ninstance IsSql92TableSourceSyntax PgTableSourceSyntax where\n  type Sql92TableSourceSelectSyntax PgTableSourceSyntax = PgSelectSyntax\n  type Sql92TableSourceExpressionSyntax PgTableSourceSyntax = PgExpressionSyntax\n  type Sql92TableSourceTableNameSyntax PgTableSourceSyntax = PgTableNameSyntax\n\n  tableNamed = PgTableSourceSyntax . fromPgTableName\n  tableFromSubSelect s = PgTableSourceSyntax $ emit "(" <> fromPgSelect s <> emit ")"\n  tableFromValues vss = PgTableSourceSyntax . pgParens $\n                        emit "VALUES " <>\n                        pgSepBy (emit ", ")\n                                (map (\\vs -> pgParens (pgSepBy (emit ", ")\n                                                               (map fromPgExpression vs))) vss)\n\ninstance IsSql92ProjectionSyntax PgProjectionSyntax where\n  type Sql92ProjectionExpressionSyntax PgProjectionSyntax = PgExpressionSyntax\n\n  projExprs exprs =\n    PgProjectionSyntax $\n    pgSepBy (emit ", ")\n            (map (\\(expr, nm) -> fromPgExpression expr <>\n                                 maybe mempty (\\nm -> emit " AS " <> pgQuotedIdentifier nm) nm) exprs)\n\ninstance IsSql92InsertSyntax PgInsertSyntax where\n  type Sql92InsertTableNameSyntax PgInsertSyntax = PgTableNameSyntax\n  type Sql92InsertValuesSyntax PgInsertSyntax = PgInsertValuesSyntax\n\n  insertStmt tblName fields values =\n      PgInsertSyntax $\n      emit "INSERT INTO " <> fromPgTableName tblName <> emit "(" <>\n      pgSepBy (emit ", ") (map pgQuotedIdentifier fields) <>\n      emit ") " <> fromPgInsertValues values\n\ninstance IsSql92InsertValuesSyntax PgInsertValuesSyntax where\n  type Sql92InsertValuesExpressionSyntax PgInsertValuesSyntax = PgExpressionSyntax\n  type Sql92InsertValuesSelectSyntax PgInsertValuesSyntax = PgSelectSyntax\n\n  insertSqlExpressions es =\n      PgInsertValuesSyntax $\n      emit "VALUES " <>\n      pgSepBy (emit ", ")\n              (map (\\es -> emit "(" <> pgSepBy (emit ", ") (coerce es) <> emit ")")\n                   es)\n  insertFromSql (PgSelectSyntax a) = PgInsertValuesSyntax a\n\ninstance IsSql92DropTableSyntax PgDropTableSyntax where\n  type Sql92DropTableTableNameSyntax PgDropTableSyntax = PgTableNameSyntax\n\n  dropTableSyntax tblNm =\n    PgDropTableSyntax $\n    emit "DROP TABLE " <> fromPgTableName tblNm\n\ninstance IsSql92AlterTableSyntax PgAlterTableSyntax where\n  type Sql92AlterTableAlterTableActionSyntax PgAlterTableSyntax = PgAlterTableActionSyntax\n  type Sql92AlterTableTableNameSyntax PgAlterTableSyntax = PgTableNameSyntax\n\n  alterTableSyntax tblNm action =\n    PgAlterTableSyntax $\n    emit "ALTER TABLE " <> fromPgTableName tblNm <> emit " " <> fromPgAlterTableAction action\n\ninstance IsSql92AlterTableActionSyntax PgAlterTableActionSyntax where\n  type Sql92AlterTableAlterColumnActionSyntax PgAlterTableActionSyntax = PgAlterColumnActionSyntax\n  type Sql92AlterTableColumnSchemaSyntax PgAlterTableActionSyntax = PgColumnSchemaSyntax\n\n  alterColumnSyntax colNm action =\n    PgAlterTableActionSyntax $\n    emit "ALTER COLUMN " <> pgQuotedIdentifier colNm <> emit " " <> fromPgAlterColumnAction action\n\n  addColumnSyntax colNm schema =\n    PgAlterTableActionSyntax $\n    emit "ADD COLUMN " <> pgQuotedIdentifier colNm <> emit " " <> fromPgColumnSchema schema\n\n  dropColumnSyntax colNm =\n    PgAlterTableActionSyntax $\n    emit "DROP COLUMN " <> pgQuotedIdentifier colNm\n\n  renameTableToSyntax newNm =\n    PgAlterTableActionSyntax $\n    emit "RENAME TO " <> pgQuotedIdentifier newNm\n\n  renameColumnToSyntax oldNm newNm =\n    PgAlterTableActionSyntax $\n    emit "RENAME COLUMN " <> pgQuotedIdentifier oldNm <> emit " TO " <> pgQuotedIdentifier newNm\n\ninstance IsSql92AlterColumnActionSyntax PgAlterColumnActionSyntax where\n  setNullSyntax = PgAlterColumnActionSyntax (emit "DROP NOT NULL")\n  setNotNullSyntax = PgAlterColumnActionSyntax (emit "SET NOT NULL")\n\ninstance IsSql92CreateTableSyntax PgCreateTableSyntax where\n  type Sql92CreateTableTableNameSyntax PgCreateTableSyntax = PgTableNameSyntax\n  type Sql92CreateTableColumnSchemaSyntax PgCreateTableSyntax = PgColumnSchemaSyntax\n  type Sql92CreateTableTableConstraintSyntax PgCreateTableSyntax = PgTableConstraintSyntax\n  type Sql92CreateTableOptionsSyntax PgCreateTableSyntax = PgTableOptionsSyntax\n\n  createTableSyntax options tblNm fieldTypes constraints =\n    let (beforeOptions, afterOptions) =\n          case options of\n            Nothing -> (emit " ", emit " ")\n            Just (PgTableOptionsSyntax before after) ->\n              ( emit " " <> before <> emit " "\n              , emit " " <> after <> emit " " )\n    in PgCreateTableSyntax $\n       emit "CREATE" <> beforeOptions <> emit "TABLE " <> fromPgTableName tblNm <>\n       emit " (" <>\n       pgSepBy (emit ", ")\n               (map (\\(nm, type_) -> pgQuotedIdentifier nm <> emit " " <> fromPgColumnSchema type_)  fieldTypes <>\n                map fromPgTableConstraint constraints)\n       <> emit ")" <> afterOptions\n\ninstance IsSql92TableConstraintSyntax PgTableConstraintSyntax where\n  primaryKeyConstraintSyntax fieldNames =\n    PgTableConstraintSyntax $\n    emit "PRIMARY KEY(" <> pgSepBy (emit ", ") (map pgQuotedIdentifier fieldNames) <> emit ")"\n\ninstance Hashable PgColumnSchemaSyntax where\n  hashWithSalt salt = hashWithSalt salt . fromPgColumnSchema\ninstance IsSql92ColumnSchemaSyntax PgColumnSchemaSyntax where\n  type Sql92ColumnSchemaColumnTypeSyntax PgColumnSchemaSyntax = PgDataTypeSyntax\n  type Sql92ColumnSchemaExpressionSyntax PgColumnSchemaSyntax = PgExpressionSyntax\n  type Sql92ColumnSchemaColumnConstraintDefinitionSyntax PgColumnSchemaSyntax = PgColumnConstraintDefinitionSyntax\n\n  columnSchemaSyntax colType defaultClause constraints collation =\n    PgColumnSchemaSyntax syntax\n    where\n      syntax =\n        fromPgDataType colType <>\n        maybe mempty (\\d -> emit " DEFAULT " <> fromPgExpression d) defaultClause <>\n        (case constraints of\n           [] -> mempty\n           _ -> foldMap (\\c -> emit " " <> fromPgColumnConstraintDefinition c) constraints) <>\n        maybe mempty (\\nm -> emit " COLLATE " <> pgQuotedIdentifier nm) collation\n\ninstance IsSql92MatchTypeSyntax PgMatchTypeSyntax where\n  fullMatchSyntax = PgMatchTypeSyntax (emit "FULL") fullMatchSyntax\n  partialMatchSyntax = PgMatchTypeSyntax (emit "PARTIAL") partialMatchSyntax\n\npgMatchTypeJSON :: Value -> BeamSerializedMatchType\npgMatchTypeJSON v = BeamSerializedMatchType (beamSerializeJSON "postgres" v)\n\npgSimpleMatchSyntax :: PgMatchTypeSyntax\npgSimpleMatchSyntax = PgMatchTypeSyntax (emit "SIMPLE") (pgMatchTypeJSON "simple")\n\ninstance IsSql92ReferentialActionSyntax PgReferentialActionSyntax where\n  referentialActionCascadeSyntax = PgReferentialActionSyntax (emit "CASCADE") referentialActionCascadeSyntax\n  referentialActionNoActionSyntax = PgReferentialActionSyntax (emit "NO ACTION") referentialActionNoActionSyntax\n  referentialActionSetDefaultSyntax = PgReferentialActionSyntax (emit "SET DEFAULT") referentialActionSetDefaultSyntax\n  referentialActionSetNullSyntax = PgReferentialActionSyntax (emit "SET NULL") referentialActionSetNullSyntax\n\nfromSqlConstraintAttributes :: SqlConstraintAttributesBuilder -> PgSyntax\nfromSqlConstraintAttributes (SqlConstraintAttributesBuilder timing deferrable) =\n  maybe mempty timingBuilder timing <> maybe mempty deferrableBuilder deferrable\n  where timingBuilder InitiallyDeferred = emit "INITIALLY DEFERRED"\n        timingBuilder InitiallyImmediate = emit "INITIALLY IMMEDIATE"\n        deferrableBuilder False = emit "NOT DEFERRABLE"\n        deferrableBuilder True = emit "DEFERRABLE"\n\ninstance Hashable PgColumnConstraintDefinitionSyntax where\n  hashWithSalt salt = hashWithSalt salt . fromPgColumnConstraintDefinition\n\ninstance IsSql92ColumnConstraintDefinitionSyntax PgColumnConstraintDefinitionSyntax where\n  type Sql92ColumnConstraintDefinitionConstraintSyntax PgColumnConstraintDefinitionSyntax = PgColumnConstraintSyntax\n  type Sql92ColumnConstraintDefinitionAttributesSyntax PgColumnConstraintDefinitionSyntax = SqlConstraintAttributesBuilder\n\n  constraintDefinitionSyntax nm constraint attrs =\n    PgColumnConstraintDefinitionSyntax syntax\n      (constraintDefinitionSyntax nm (pgColumnConstraintSerialized constraint) (fmap sqlConstraintAttributesSerialized attrs))\n    where\n      syntax =\n        maybe mempty (\\nm -> emit "CONSTRAINT " <> pgQuotedIdentifier nm <> emit " " ) nm <>\n        fromPgColumnConstraint constraint <>\n        maybe mempty (\\a -> emit " " <> fromSqlConstraintAttributes a) attrs\n\ninstance Sql92SerializableConstraintDefinitionSyntax PgColumnConstraintDefinitionSyntax where\n  serializeConstraint = fromBeamSerializedConstraintDefinition . pgColumnConstraintDefinitionSerialized\n\ninstance IsSql92ColumnConstraintSyntax PgColumnConstraintSyntax where\n  type Sql92ColumnConstraintMatchTypeSyntax PgColumnConstraintSyntax = PgMatchTypeSyntax\n  type Sql92ColumnConstraintReferentialActionSyntax PgColumnConstraintSyntax = PgReferentialActionSyntax\n  type Sql92ColumnConstraintExpressionSyntax PgColumnConstraintSyntax = PgExpressionSyntax\n\n  notNullConstraintSyntax = PgColumnConstraintSyntax (emit "NOT NULL") notNullConstraintSyntax\n  uniqueColumnConstraintSyntax = PgColumnConstraintSyntax (emit "UNIQUE") uniqueColumnConstraintSyntax\n  primaryKeyColumnConstraintSyntax = PgColumnConstraintSyntax (emit "PRIMARY KEY") primaryKeyColumnConstraintSyntax\n  checkColumnConstraintSyntax expr =\n    PgColumnConstraintSyntax (emit "CHECK(" <> fromPgExpression expr <> emit ")")\n                             (checkColumnConstraintSyntax . BeamSerializedExpression . TE.decodeUtf8 .\n                              toStrict . pgRenderSyntaxScript . fromPgExpression $ expr)\n  referencesConstraintSyntax tbl fields matchType onUpdate onDelete =\n    PgColumnConstraintSyntax syntax\n      (referencesConstraintSyntax tbl fields (fmap pgMatchTypeSerialized matchType)\n                                  (fmap pgReferentialActionSerialized onUpdate)\n                                  (fmap pgReferentialActionSerialized onDelete))\n    where\n      syntax =\n        emit "REFERENCES " <> pgQuotedIdentifier tbl <> emit "("\n        <> pgSepBy (emit ", ") (map pgQuotedIdentifier fields) <> emit ")" <>\n        maybe mempty (\\m -> emit " " <> fromPgMatchType m) matchType <>\n        maybe mempty (\\a -> emit " ON UPDATE " <> fromPgReferentialAction a) onUpdate <>\n        maybe mempty (\\a -> emit " ON DELETE " <> fromPgReferentialAction a) onDelete\n\ndefaultPgValueSyntax :: Pg.ToField a => a -> PgValueSyntax\ndefaultPgValueSyntax =\n    PgValueSyntax . pgBuildAction . pure . Pg.toField\n\n-- Database Predicates\n\ndata PgHasEnum = PgHasEnum T.Text {- Enumeration name -} [T.Text] {- enum values -}\n    deriving (Show, Eq, Generic)\ninstance Hashable PgHasEnum\ninstance DatabasePredicate PgHasEnum where\n    englishDescription (PgHasEnum enumName values) =\n        "Has postgres enumeration " ++ show enumName ++ " with values " ++ show values\n\n    predicateSpecificity _ = PredicateSpecificityOnlyBackend "postgres"\n    serializePredicate (PgHasEnum name values) =\n        object [ "has-postgres-enum" .= object [ "name" .= name\n                                               , "values" .= values ] ]\n\n#define DEFAULT_SQL_SYNTAX(ty)                                  \\\n           instance HasSqlValueSyntax PgValueSyntax ty where    \\\n             sqlValueSyntax = defaultPgValueSyntax\n\nDEFAULT_SQL_SYNTAX(Bool)\nDEFAULT_SQL_SYNTAX(Double)\nDEFAULT_SQL_SYNTAX(Float)\nDEFAULT_SQL_SYNTAX(Int8)\nDEFAULT_SQL_SYNTAX(Int16)\nDEFAULT_SQL_SYNTAX(Int32)\nDEFAULT_SQL_SYNTAX(Int64)\nDEFAULT_SQL_SYNTAX(Integer)\nDEFAULT_SQL_SYNTAX(Word8)\nDEFAULT_SQL_SYNTAX(Word16)\nDEFAULT_SQL_SYNTAX(Word32)\nDEFAULT_SQL_SYNTAX(Word64)\nDEFAULT_SQL_SYNTAX(T.Text)\nDEFAULT_SQL_SYNTAX(TL.Text)\nDEFAULT_SQL_SYNTAX(Value)\nDEFAULT_SQL_SYNTAX(Pg.Oid)\nDEFAULT_SQL_SYNTAX(LocalTime)\nDEFAULT_SQL_SYNTAX(UTCTime)\nDEFAULT_SQL_SYNTAX(TimeOfDay)\nDEFAULT_SQL_SYNTAX(NominalDiffTime)\nDEFAULT_SQL_SYNTAX(Day)\nDEFAULT_SQL_SYNTAX([Char])\nDEFAULT_SQL_SYNTAX(Pg.HStoreMap)\nDEFAULT_SQL_SYNTAX(Pg.HStoreList)\nDEFAULT_SQL_SYNTAX(Pg.HStoreBuilder)\nDEFAULT_SQL_SYNTAX(Pg.Date)\nDEFAULT_SQL_SYNTAX(Pg.LocalTimestamp)\nDEFAULT_SQL_SYNTAX(Pg.UTCTimestamp)\nDEFAULT_SQL_SYNTAX(Scientific)\n\ninstance HasSqlValueSyntax PgValueSyntax (CI T.Text) where\n  sqlValueSyntax = sqlValueSyntax . CI.original\ninstance HasSqlValueSyntax PgValueSyntax (CI TL.Text) where\n  sqlValueSyntax = sqlValueSyntax . CI.original\n\ninstance HasSqlValueSyntax PgValueSyntax SqlNull where\n  sqlValueSyntax _ = defaultPgValueSyntax Pg.Null\n\ninstance HasSqlValueSyntax PgValueSyntax x => HasSqlValueSyntax PgValueSyntax (Maybe x) where\n  sqlValueSyntax Nothing = sqlValueSyntax SqlNull\n  sqlValueSyntax (Just x) = sqlValueSyntax x\n\ninstance HasSqlValueSyntax PgValueSyntax B.ByteString where\n  sqlValueSyntax = defaultPgValueSyntax . Pg.Binary\n\ninstance HasSqlValueSyntax PgValueSyntax BL.ByteString where\n  sqlValueSyntax = defaultPgValueSyntax . Pg.Binary\n\n-- This should be removed in favor of the default syntax if/when\n-- https://github.com/lpsmith/postgresql-simple/issues/277 is fixed upstream.\ninstance HasSqlValueSyntax PgValueSyntax UUID where\n  sqlValueSyntax v = PgValueSyntax $\n    emit "\'" <> emit (toASCIIBytes v) <> emit "\'::uuid"\n\ninstance Pg.ToField a => HasSqlValueSyntax PgValueSyntax (V.Vector a) where\n  sqlValueSyntax = defaultPgValueSyntax\n\ninstance TypeError (PreferExplicitSize Int Int32) => HasSqlValueSyntax PgValueSyntax Int where\n  sqlValueSyntax = defaultPgValueSyntax\n\ninstance TypeError (PreferExplicitSize Word Word32) => HasSqlValueSyntax PgValueSyntax Word where\n  sqlValueSyntax = defaultPgValueSyntax\n\npgQuotedIdentifier :: T.Text -> PgSyntax\npgQuotedIdentifier t =\n  escapeIdentifier (TE.encodeUtf8 t)\n\npgParens :: PgSyntax -> PgSyntax\npgParens a = emit "(" <> a <> emit ")"\n\npgTableOp :: ByteString -> PgSelectTableSyntax -> PgSelectTableSyntax\n          -> PgSelectTableSyntax\npgTableOp op tbl1 tbl2 =\n    PgSelectTableSyntax $\n    emit "(" <> fromPgSelectTable tbl1 <> emit ") " <> emit op <>\n    emit " (" <> fromPgSelectTable tbl2 <> emit ")"\n\npgCompOp :: ByteString -> Maybe PgComparisonQuantifierSyntax\n         -> PgExpressionSyntax -> PgExpressionSyntax -> PgExpressionSyntax\npgCompOp op quantifier a b =\n  PgExpressionSyntax $\n  emit "(" <> fromPgExpression a <>\n  emit (") " <> op) <>\n  maybe (emit " (" <> fromPgExpression b <> emit ")")\n        (\\q -> emit " " <> fromPgComparisonQuantifier q <> emit " " <> fromPgExpression b)\n        quantifier\n\npgBinOp :: ByteString -> PgExpressionSyntax -> PgExpressionSyntax -> PgExpressionSyntax\npgBinOp op a b =\n  PgExpressionSyntax $\n  emit "(" <> fromPgExpression a <> emit (") " <> op <> " (") <> fromPgExpression b <> emit ")"\n\npgPostFix, pgUnOp :: ByteString -> PgExpressionSyntax -> PgExpressionSyntax\npgPostFix op a =\n  PgExpressionSyntax $\n  emit "(" <> fromPgExpression a <> emit ") " <> emit op\npgUnOp op a =\n  PgExpressionSyntax $\n  emit (op <> "(") <> fromPgExpression a <> emit ")"\n\npgJoin :: ByteString -> PgFromSyntax -> PgFromSyntax -> Maybe PgExpressionSyntax -> PgFromSyntax\npgJoin joinType a b Nothing =\n  PgFromSyntax $\n  fromPgFrom a <> emit (" " <> joinType <> " ") <> fromPgFrom b <> emit " ON TRUE"\npgJoin joinType a b (Just on) =\n  PgFromSyntax $\n  fromPgFrom a <> emit (" " <> joinType <> " ") <> fromPgFrom b <>\n  emit " ON " <> fromPgExpression on\n\npgSepBy :: PgSyntax -> [PgSyntax] -> PgSyntax\npgSepBy _ [] = mempty\npgSepBy _ [x] = x\npgSepBy sep (x:xs) = x <> sep <> pgSepBy sep xs\n\npgDebugRenderSyntax :: PgSyntax -> IO ()\npgDebugRenderSyntax (PgSyntax p) = go p Nothing\n  where go :: PgSyntaxM () -> Maybe (PgSyntaxF ()) -> IO ()\n        go p = runF p finish step\n        step x lastBs =\n          case (x, lastBs) of\n            (EmitBuilder s next, lastBs) ->\n              step (EmitByteString (toStrict (toLazyByteString s)) next) lastBs\n            (x, Nothing) ->\n              nextSyntaxStep x (Just (fmap (const ()) x))\n            (EmitByteString x next, Just (EmitByteString before _)) ->\n              next (Just (EmitByteString (before <> x) ()))\n            (EscapeString x next, Just (EscapeString before _)) ->\n              next (Just (EscapeString (before <> x) ()))\n            (EscapeBytea x next, Just (EscapeBytea before _)) ->\n              next (Just (EscapeBytea (before <> x) ()))\n            (EscapeIdentifier x next, Just (EscapeIdentifier before _)) ->\n              next (Just (EscapeIdentifier (before <> x) ()))\n            (s, Just e) ->\n              renderStep e >>\n              nextSyntaxStep s (Just (fmap (const ()) s))\n\n        renderStep (EmitByteString x _) = putStrLn ("EmitByteString " <> show x)\n        renderStep (EmitBuilder x _) = putStrLn ("EmitBuilder " <> show (toLazyByteString x))\n        renderStep (EscapeString x _) = putStrLn ("EscapeString " <> show x)\n        renderStep (EscapeBytea x _) = putStrLn ("EscapeBytea " <> show x)\n        renderStep (EscapeIdentifier x _) = putStrLn ("EscapeIdentifier " <> show x)\n\n        finish x Nothing = pure x\n        finish x (Just s) = renderStep s >> pure x\n\npgBuildAction :: [ Pg.Action ] -> PgSyntax\npgBuildAction =\n  foldMap $ \\action ->\n  case action of\n    Pg.Plain x -> emitBuilder x\n    Pg.Escape str -> emit "\'" <> escapeString str <> emit "\'"\n    Pg.EscapeByteA bin -> emit "\'" <> escapeBytea bin <> emit "\'"\n    Pg.EscapeIdentifier id -> escapeIdentifier id\n    Pg.Many as -> pgBuildAction as\n\n-- * Postgres-specific extensions\n\n-- * Postgres specific commands\n\npgSelectStmt :: PgSelectTableSyntax\n             -> [PgOrderingSyntax]\n             -> Maybe Integer {-^ LIMIT -}\n             -> Maybe Integer {-^ OFFSET -}\n             -> Maybe PgSelectLockingClauseSyntax\n             -> PgSelectSyntax\npgSelectStmt tbl ordering limit offset locking =\n    PgSelectSyntax $\n    mconcat [ coerce tbl\n            , case ordering of\n                [] -> mempty\n                ordering -> emit " ORDER BY " <> pgSepBy (emit ", ") (map fromPgOrdering ordering)\n            , maybe mempty (emit . fromString . (" LIMIT " <>) . show) limit\n            , maybe mempty (emit . fromString . (" OFFSET " <>) . show) offset\n            , maybe mempty fromPgSelectLockingClause locking ]\n\npgCreateExtensionSyntax :: T.Text -> PgCommandSyntax\npgCreateExtensionSyntax extName =\n  PgCommandSyntax PgCommandTypeDdl $ emit "CREATE EXTENSION " <> pgQuotedIdentifier extName\n\npgDropExtensionSyntax :: T.Text -> PgCommandSyntax\npgDropExtensionSyntax extName =\n  PgCommandSyntax PgCommandTypeDdl $ emit "DROP EXTENSION " <> pgQuotedIdentifier extName\n\npgCreateEnumSyntax :: T.Text -> [PgValueSyntax] -> PgCommandSyntax\npgCreateEnumSyntax enumName vals =\n    PgCommandSyntax PgCommandTypeDdl $\n    emit "CREATE TYPE " <> pgQuotedIdentifier enumName <> emit " AS ENUM(" <>\n    pgSepBy (emit ", ") (fmap fromPgValue vals) <> emit ")"\n\npgDropTypeSyntax :: T.Text -> PgCommandSyntax\npgDropTypeSyntax typeName =\n    PgCommandSyntax PgCommandTypeDdl $\n    emit "DROP TYPE " <> pgQuotedIdentifier typeName\n\n-- -- * Pg-specific Q monad\n\n\ndata PgEscapeType = PgEscapeString | PgEscapeBytea | PgEscapeIdentifier\n  deriving (Show, Eq, Ord, Enum, Bounded)\ndata PgSyntaxPrim = PgSyntaxPrim (Maybe PgEscapeType) BL.ByteString deriving Show\n\ninstance IsString PgSyntaxPrim where\n  fromString = PgSyntaxPrim Nothing . fromString\n\npgTestSyntax :: PgSyntax -> [ PgSyntaxPrim ]\npgTestSyntax (PgSyntax syntax) = runF syntax finish step Nothing mempty id\n  where\n    finish _ escapeType curBuilder a =\n      let chunk = toLazyByteString curBuilder\n      in if BL.null chunk then a []\n         else a [ PgSyntaxPrim escapeType chunk ]\n\n    go next curType nextType curBuilder nextBuilder a\n      | curType == nextType = next curType (curBuilder <> nextBuilder) a\n      | otherwise = next nextType mempty (a . (PgSyntaxPrim curType (toLazyByteString curBuilder):))\n\n    step (EmitByteString bs next) curType curBuilder a =\n      go next curType Nothing curBuilder (byteString bs) a\n    step (EmitBuilder bs next) curType curBuilder a =\n      go next curType Nothing curBuilder bs a\n    step (EscapeString s next) curType curBuilder a =\n      go next curType (Just PgEscapeString) curBuilder (byteString s) a\n    step (EscapeBytea s next) curType curBuilder a =\n      go next curType (Just PgEscapeBytea) curBuilder (byteString s) a\n    step (EscapeIdentifier s next) curType curBuilder a =\n      go next curType (Just PgEscapeIdentifier) curBuilder (byteString s) a\n\npgRenderSyntaxScript :: PgSyntax -> BL.ByteString\npgRenderSyntaxScript (PgSyntax mkQuery) =\n  toLazyByteString (runF mkQuery finish step)\n  where\n    finish _ = mempty\n    step (EmitBuilder b next) = b <> next\n    step (EmitByteString b next) = byteString b <> next\n    step (EscapeString b next) = escapePgString b <> next\n    step (EscapeBytea b next) = escapePgBytea b <> next\n    step (EscapeIdentifier b next) = escapePgIdentifier b <> next\n\n    escapePgString b = byteString (B.concatMap (\\w -> if w == \'\\\'\' then "\'\'" else B.singleton w) b)\n    escapePgBytea _ = error "escapePgBytea: no connection"\n    escapePgIdentifier bs = char8 \'"\' <> foldMap quoteIdentifierChar (B.unpack bs) <> char8 \'"\'\n      where\n        quoteIdentifierChar \'"\' = char8 \'"\' <> char8 \'"\'\n        quoteIdentifierChar c = char8 c\n\n'