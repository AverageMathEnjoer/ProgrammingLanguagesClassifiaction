b"{-# LANGUAGE TypeFamilies #-}\n\nmodule Hoodle.ModelAction.Select.Transform where\n\nimport Control.Category ((.))\nimport Control.Lens (set, view)\nimport Control.Monad.Identity (runIdentity)\nimport Data.Bifunctor (second)\nimport Data.Hoodle.BBox\n  ( BBoxed (..),\n    makeBBoxed,\n  )\nimport Data.Hoodle.Generic\n  ( GLayer (..),\n    gbuffer,\n    gitems,\n    glayers,\n  )\nimport Data.Hoodle.Simple\n  ( Anchor (..),\n    Dimension (Dim),\n    Image (..),\n    Link (..),\n    SVG (..),\n    Stroke (..),\n  )\nimport Data.Strict.Tuple (Pair ((:!:)))\nimport Graphics.Hoodle.Render.Type\n  ( RItem (..),\n    selectedLayer,\n  )\nimport Graphics.Hoodle.Render.Type.HitTest\n  ( AlterList (..),\n    Hitted (..),\n    TAlterHitted,\n    TEitherAlterHitted (..),\n    getA,\n  )\nimport Hoodle.Type.Alias (Page, SelectMode)\nimport Prelude hiding (id, (.))\n\n-- |\nrItmsInActiveLyr :: Page SelectMode -> Either [RItem] (TAlterHitted RItem)\nrItmsInActiveLyr = unTEitherAlterHitted . view (glayers . selectedLayer . gitems)\n\n-- |\nchangeItemBy :: ((Double, Double) -> (Double, Double)) -> RItem -> RItem\nchangeItemBy func (RItemStroke strk) = RItemStroke (changeStrokeBy func strk)\nchangeItemBy func (RItemImage img sfc) = RItemImage (changeImageBy func img) sfc\nchangeItemBy func (RItemSVG svg rsvg) = RItemSVG (changeSVGBy func svg) rsvg\nchangeItemBy func (RItemLink lnk rsvg) = RItemLink (changeLinkBy func lnk) rsvg\nchangeItemBy func (RItemAnchor anc rsvg) = RItemAnchor (changeAnchorBy func anc) rsvg\n\n-- | modify stroke using a function\nchangeStrokeBy :: ((Double, Double) -> (Double, Double)) -> BBoxed Stroke -> BBoxed Stroke\nchangeStrokeBy func (BBoxed (Stroke t c w ds) _bbox) =\n  let change (x :!: y) =\n        let (nx, ny) = func (x, y)\n         in nx :!: ny\n      newds = map change ds\n      nstrk = Stroke t c w newds\n   in runIdentity (makeBBoxed nstrk)\nchangeStrokeBy func (BBoxed (VWStroke t c ds) _bbox) =\n  let change (x, y, z) =\n        let (nx, ny) = func (x, y)\n         in (nx, ny, z)\n      newds = map change ds\n      nstrk = VWStroke t c newds\n   in runIdentity (makeBBoxed nstrk)\n\n-- |\nchangeImageBy :: ((Double, Double) -> (Double, Double)) -> BBoxed Image -> BBoxed Image\nchangeImageBy func (BBoxed (Image bstr (x, y) (Dim w h)) _bbox) =\n  let (x1, y1) = func (x, y)\n      (x2, y2) = func (x + w, y + h)\n      nimg = Image bstr (x1, y1) (Dim (x2 - x1) (y2 - y1))\n   in runIdentity (makeBBoxed nimg)\n\n-- |\nchangeSVGBy :: ((Double, Double) -> (Double, Double)) -> BBoxed SVG -> BBoxed SVG\nchangeSVGBy func (BBoxed (SVG t c bstr (x, y) (Dim w h)) _bbox) =\n  let (x1, y1) = func (x, y)\n      (x2, y2) = func (x + w, y + h)\n      nsvg = SVG t c bstr (x1, y1) (Dim (x2 - x1) (y2 - y1))\n   in runIdentity (makeBBoxed nsvg)\n\n-- |\nchangeLinkBy :: ((Double, Double) -> (Double, Double)) -> BBoxed Link -> BBoxed Link\nchangeLinkBy func (BBoxed (Link i typ loc t c bstr (x, y) (Dim w h)) _bbox) =\n  let (x1, y1) = func (x, y)\n      (x2, y2) = func (x + w, y + h)\n      nlnk = Link i typ loc t c bstr (x1, y1) (Dim (x2 - x1) (y2 - y1))\n   in runIdentity (makeBBoxed nlnk)\nchangeLinkBy func (BBoxed (LinkDocID i lid loc t c bstr (x, y) (Dim w h)) _bbox) =\n  let (x1, y1) = func (x, y)\n      (x2, y2) = func (x + w, y + h)\n      nlnk = LinkDocID i lid loc t c bstr (x1, y1) (Dim (x2 - x1) (y2 - y1))\n   in runIdentity (makeBBoxed nlnk)\nchangeLinkBy func (BBoxed (LinkAnchor i lid loc aid bstr (x, y) (Dim w h)) _bbox) =\n  let (x1, y1) = func (x, y)\n      (x2, y2) = func (x + w, y + h)\n      nlnk = LinkAnchor i lid loc aid bstr (x1, y1) (Dim (x2 - x1) (y2 - y1))\n   in runIdentity (makeBBoxed nlnk)\n\n-- |\nchangeAnchorBy ::\n  ((Double, Double) -> (Double, Double)) ->\n  BBoxed Anchor ->\n  BBoxed Anchor\nchangeAnchorBy func (BBoxed (Anchor i bstr (x, y) (Dim w h)) _) =\n  let (x1, y1) = func (x, y)\n      (x2, y2) = func (x + w, y + h)\n      nanc = Anchor i bstr (x1, y1) (Dim (x2 - x1) (y2 - y1))\n   in runIdentity (makeBBoxed nanc)\n\n-- | modify the whole selection using a function\nchangeSelectionBy ::\n  ((Double, Double) -> (Double, Double)) ->\n  Page SelectMode ->\n  Page SelectMode\nchangeSelectionBy func tpage =\n  let activelayer = rItmsInActiveLyr tpage\n      buf = view (glayers . selectedLayer . gbuffer) tpage\n   in case activelayer of\n        Left _ -> tpage\n        Right alist ->\n          let alist' =\n                second (Hitted . map (changeItemBy func) . unHitted) alist\n              layer' = GLayer buf . TEitherAlterHitted . Right $ alist'\n           in set (glayers . selectedLayer) layer' tpage\n\n-- | special case of offset modification\nchangeSelectionByOffset :: (Double, Double) -> Page SelectMode -> Page SelectMode\nchangeSelectionByOffset (offx, offy) = changeSelectionBy (offsetFunc (offx, offy))\n\n-- |\noffsetFunc :: (Double, Double) -> (Double, Double) -> (Double, Double)\noffsetFunc (offx, offy) (x, y) = (x + offx, y + offy)\n\n-- | replace selection with one item\nreplaceSelection :: RItem -> Page SelectMode -> Page SelectMode\nreplaceSelection ritm tpage =\n  let activelayer = rItmsInActiveLyr tpage\n      buf = view (glayers . selectedLayer . gbuffer) tpage\n   in case activelayer of\n        Right (x :- Hitted _ys :- xs) ->\n          let xs' :: [RItem]\n              xs' = concat (getA xs)\n              alist' = x :- Hitted [ritm] :- xs' :- Empty\n              layer' = GLayer buf . TEitherAlterHitted . Right $ alist'\n           in set (glayers . selectedLayer) layer' tpage\n        _ -> tpage\n"