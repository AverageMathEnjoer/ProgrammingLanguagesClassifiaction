b'{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Graphics.Hoodle.Render.Item where\n\nimport Control.Monad (guard)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Identity (runIdentity)\nimport qualified Data.ByteString as B\nimport Data.ByteString.Base64 (decode)\nimport qualified Data.ByteString.Char8 as C8\nimport Data.Hoodle.BBox (makeBBoxed)\nimport Data.Hoodle.Simple\n  ( Anchor (..),\n    Item (..),\n    Link (..),\n    SVG (..),\n  )\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.GD.ByteString\n  ( loadJpegFile,\n    savePngByteString,\n  )\nimport Graphics.Hoodle.Render.Type.Item (RItem (..))\nimport Graphics.Hoodle.Render.Type.Renderer (Renderer)\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.Rendering.Cairo.SVG as RSVG\nimport Hoodle.Util.Process (checkPipe)\nimport System.Directory\n  ( getTemporaryDirectory,\n    removeFile,\n  )\nimport System.FilePath ((<.>), (</>))\n\n-- | construct renderable item\ncnstrctRItem :: Item -> Renderer RItem\ncnstrctRItem (ItemStroke strk) = return (RItemStroke (runIdentity (makeBBoxed strk)))\ncnstrctRItem (ItemImage img) =\n  let imgbbx = runIdentity (makeBBoxed img)\n   in return (RItemImage imgbbx Nothing)\ncnstrctRItem (ItemSVG svg@(SVG _ _ bstr _ _)) = do\n  let str = C8.unpack bstr\n      svgbbx = runIdentity (makeBBoxed svg)\n  rsvg <- liftIO (RSVG.svgNewFromString str)\n  return (RItemSVG svgbbx (Just rsvg))\ncnstrctRItem (ItemLink lnk@(Link _ _ _ _ _ bstr _ _)) = do\n  let str = C8.unpack bstr\n      lnkbbx = runIdentity (makeBBoxed lnk)\n  rsvg <- liftIO $ RSVG.svgNewFromString str\n  return (RItemLink lnkbbx (Just rsvg))\ncnstrctRItem (ItemLink lnk@(LinkDocID _ _ _ _ _ bstr _ _)) = do\n  let str = C8.unpack bstr\n      lnkbbx = runIdentity (makeBBoxed lnk)\n  rsvg <- liftIO $ RSVG.svgNewFromString str\n  return (RItemLink lnkbbx (Just rsvg))\ncnstrctRItem (ItemLink lnk@(LinkAnchor _ _ _ _ bstr _ _)) =\n  if C8.null bstr\n    then\n      let lnkbbx = runIdentity (makeBBoxed lnk)\n       in return (RItemLink lnkbbx Nothing)\n    else do\n      let str = C8.unpack bstr\n          lnkbbx = runIdentity (makeBBoxed lnk)\n      rsvg <- liftIO $ RSVG.svgNewFromString str\n      return (RItemLink lnkbbx (Just rsvg))\ncnstrctRItem (ItemAnchor anc@(Anchor _ bstr _ _)) =\n  if C8.null bstr\n    then\n      let ancbbx = runIdentity (makeBBoxed anc)\n       in return (RItemAnchor ancbbx Nothing)\n    else do\n      let str = C8.unpack bstr\n          ancbbx = runIdentity (makeBBoxed anc)\n      rsvg <- liftIO $ RSVG.svgNewFromString str\n      return (RItemAnchor ancbbx (Just rsvg))\n\n-- | get embedded png image. If not, just give me nothing.\ngetByteStringIfEmbeddedPNG :: C8.ByteString -> Maybe C8.ByteString\ngetByteStringIfEmbeddedPNG bstr = do\n  guard (C8.length bstr > 22)\n  let (header, dat) = C8.splitAt 22 bstr\n  guard (header == "data:image/png;base64,")\n  either (const Nothing) return (decode dat)\n\n-- | read JPG file using GD library and create cairo image surface\n--   currently, this uses temporary png file (which is potentially dangerous)\ngetJPGandCreateSurface :: FilePath -> IO Cairo.Surface\ngetJPGandCreateSurface fp = do\n  img <- loadJpegFile fp\n  bstr <- savePngByteString img\n  saveTempPNGToCreateSurface bstr\n\n-- |\nsaveTempPNGToCreateSurface :: C8.ByteString -> IO Cairo.Surface\nsaveTempPNGToCreateSurface bstr = do\n  tdir <- getTemporaryDirectory\n  tuuid <- nextRandom\n  let tfile = tdir </> show tuuid <.> "png"\n  B.writeFile tfile bstr\n  checkPipe tfile\n  sfc <- Cairo.imageSurfaceCreateFromPNG tfile\n  removeFile tfile\n  return sfc\n'