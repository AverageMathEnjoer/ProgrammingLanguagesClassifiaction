b'{-# LANGUAGE CPP #-}\n{-# OPTIONS_GHC -O2 #-}\n\n-- Microbenchmark for parfib with pedigree.\n\nimport Data.Int\nimport qualified Data.List as L\nimport System.Environment\nimport GHC.Conc\nimport System.Random\nimport Control.Monad.Par.Class as PC\n\n-- import qualified Control.Monad.Trans.State.Strict as TS\n-- import Data.BitList\n\nimport Control.Monad.Par.Pedigree \n\n#ifdef PARSCHED \nimport PARSCHED\n#else\n-- import Control.Monad.Par\n--import Control.Monad.Par.Scheds.ContFree\nimport Control.Monad.Par.Scheds.Direct\n#endif\n\n-- Define a RNG layer on top of whatever Par implementation was imported above:\n-- type MyPar a = TS.StateT Pedigree Par a\n\n-- type FibType = Int64\n\n-- Same recursion pattern as parfib but with extra cost at fork points\n-- to split the RNG.\npedTest :: Int -> ParPedigreeT Par Int64\npedTest n | n < 2 = do\n    p <- pedigree\n    -- Here we only return 1 for the "rightmost" path:\n    if all id (unpack p)\n     then return 1 \n     else return 0\npedTest n = do \n    xf <- PC.spawn_$ pedTest (n-1)\n    y  <-            pedTest (n-2)\n    x  <- PC.get xf\n    return (x+y)\n\n\nmain = do \n    args <- getArgs\n    let size = case args of \n            []      -> 20\n            [n]     -> read n\n\n--    let sum = runPar $ TS.evalStateT (pedTest size) empty \n    let sum = runPar $ runParPedigree (pedTest size)\n\n    putStrLn$ "Pedigree test: "++ show sum\n\n{-\n\n[2011.11.29]\n\nTiming RNG.hs:\n On a 3.1ghz 4 core intel westmere:\n\n     threads input time-pedigree time-parfib\n    1 34  6.7s   1.78s\n    2 34  3.5s   0.96s\n    4 34  1.9s   0.55s\n\nThat was using a "BitList" for pedigree.  Using a simple [Bool] does a\nlittle better and yields the following:\n\n    1 34  6.3s   1.78s\n    2 34  3.3s   0.96s\n    4 34  1.78s  0.55s\n\nI\'m seeing low productivities (a lot of time in GC).. typically 37%\nwith default settings and 52% with -A1M.\n\n -}\n'