b'module Network.OAuth2.Experiment.Pkce (\n  mkPkceParam,\n  CodeChallenge (..),\n  CodeVerifier (..),\n  CodeChallengeMethod (..),\n  PkceRequestParam (..),\n) where\n\nimport Control.Monad.IO.Class\nimport Crypto.Hash qualified as H\nimport Crypto.Random qualified as Crypto\nimport Data.ByteArray qualified as ByteArray\nimport Data.ByteString qualified as BS\nimport Data.ByteString.Base64.URL qualified as B64\nimport Data.Text (Text)\nimport Data.Text.Encoding qualified as T\nimport Data.Word\n\nnewtype CodeChallenge = CodeChallenge {unCodeChallenge :: Text}\n\nnewtype CodeVerifier = CodeVerifier {unCodeVerifier :: Text} deriving (Show)\n\ndata CodeChallengeMethod = S256\n  deriving (Show)\n\ndata PkceRequestParam = PkceRequestParam\n  { codeVerifier :: CodeVerifier\n  , codeChallenge :: CodeChallenge\n  , codeChallengeMethod :: CodeChallengeMethod\n  -- ^ spec says optional but really it shall be s256 or can be omitted?\n  -- https://datatracker.ietf.org/doc/html/rfc7636#section-4.3\n  }\n\nmkPkceParam :: MonadIO m => m PkceRequestParam\nmkPkceParam = do\n  codeV <- genCodeVerifier\n  pure\n    PkceRequestParam\n      { codeVerifier = CodeVerifier (T.decodeUtf8 codeV)\n      , codeChallenge = CodeChallenge (encodeCodeVerifier codeV)\n      , codeChallengeMethod = S256\n      }\n\nencodeCodeVerifier :: BS.ByteString -> Text\nencodeCodeVerifier = B64.encodeBase64Unpadded . BS.pack . ByteArray.unpack . hashSHA256\n\ngenCodeVerifier :: MonadIO m => m BS.ByteString\ngenCodeVerifier = liftIO $ getBytesInternal BS.empty\n\ncvMaxLen :: Int\ncvMaxLen = 128\n\n-- The default \'getRandomBytes\' generates bytes out of unreverved characters scope.\n-- code-verifier = 43*128unreserved\n--   unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"\n--   ALPHA = %x41-5A / %x61-7A\n--   DIGIT = %x30-39\ngetBytesInternal :: BS.ByteString -> IO BS.ByteString\ngetBytesInternal ba\n  | BS.length ba >= cvMaxLen = pure (BS.take cvMaxLen ba)\n  | otherwise = do\n      bs <- Crypto.getRandomBytes cvMaxLen\n      let bsUnreserved = ba `BS.append` BS.filter isUnreversed bs\n      getBytesInternal bsUnreserved\n\nhashSHA256 :: BS.ByteString -> H.Digest H.SHA256\nhashSHA256 = H.hash\n\nisUnreversed :: Word8 -> Bool\nisUnreversed w = w `BS.elem` unreverseBS\n\n{-\na-z: 97-122\nA-Z: 65-90\n-: 45\n.: 46\n_: 95\n~: 126\n-}\nunreverseBS :: BS.ByteString\nunreverseBS = BS.pack $ [97 .. 122] ++ [65 .. 90] ++ [45, 46, 95, 126]\n'