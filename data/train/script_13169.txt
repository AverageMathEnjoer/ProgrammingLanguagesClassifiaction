b'\xef\xbb\xbfopen System\nopen System.IO\n\n#load "packages/FsLab/FsLab.fsx"\nopen FSharp.Data\nopen RDotNet\nopen RProvider\nopen RProvider.ggplot2\nopen RProvider.datasets\nopen RProvider.igraph\n\n// =========================================\n// Compute graph statistics\n\nlet [<Literal>] linkFile =\n    __SOURCE_DIRECTORY__ + "/networks/starwars-episode-1-interactions.json"\ntype Network = JsonProvider<linkFile>\n\nlet file = __SOURCE_DIRECTORY__ + "/networks/starwars-episode-7-interactions-allCharacters.json"\n//let file = __SOURCE_DIRECTORY__ + "/networks/starwars-full-interactions-allCharacters.json"\nlet nodes = \n    Network.Load(file).Nodes \n    |> Seq.map (fun node -> node.Name) |> Array.ofSeq\nlet nodeLookup = nodes |> Array.mapi (fun i name -> i, name) |> dict\nlet links = Network.Load(file).Links\n\nlet mergeAnakin = true\nlet graph =\n    let edges = \n        links\n        |> Array.map (fun link ->\n            let n1 = nodeLookup.[link.Source]\n            let n2 = nodeLookup.[link.Target]\n            if mergeAnakin then \n                if n1 = "ANAKIN" then \n                    if "DARTH VADER" < n2 then [| "DARTH VADER"; n2 |] else [| n2; "DARTH VADER" |]\n                elif n2 = "ANAKIN" then \n                    if "DARTH VADER" < n1 then [| "DARTH VADER"; n1 |] else [| n1; "DARTH VADER" |]\n                else\n                    [| n1; n2 |]\n            else\n                  [| n1; n2 |] )\n        |> Array.distinct   // discard with duplicated edges\n        |> Array.concat\n    namedParams["edges", box edges; "dir", box "undirected"]\n    |> R.graph\n\n// Compute betweenness centrality    \n// Betweenness = ratio of number of shortest paths from all vertices to all\n//               others that pass through that node\nlet centrality = R.betweenness(graph)\nlet names = R.names(centrality).AsCharacter().ToArray()\nlet centralityValues = centrality.AsNumeric().ToArray()\n\n// Compute degree centrality\n// Degree centrality = number of other nodes connected to the node \nlet degreeCentrality = R.degree(graph)\nlet names\' = R.names(degreeCentrality).AsCharacter().ToArray()\nlet degreeValues = degreeCentrality.AsNumeric().ToArray() \n\nlet top_betweenness k = \n    Array.zip names centralityValues\n    |> Array.sortByDescending snd\n    |> Array.take k\n\nlet top_degree k = \n    Array.zip names\' degreeValues\n    |> Array.sortByDescending snd\n    |> Array.take k\n\nlet printMarkdownTable measureName top5 = \n    printfn "|\\t| Name | %s |" measureName\n    printfn "|---|-----|-----|"\n    top5 |> Array.iteri (fun i (name, (value : float)) ->  \n        if measureName = "Degree" then printfn "| %d. | %s | %d |" (i+1) name (int value)\n        else printfn "%d. | %s | %.1f |" (i+1) name value)\n\nprintMarkdownTable "Degree" (top_degree 5)\nprintMarkdownTable "Betweenness" (top_betweenness 5)\n\n// Look at shortest path between two nodes\nR.shortest__paths(namedParams["graph", box graph; "from", box "GREEDO"; "to", box "LEIA"])\n\n//=====================================================================\n// Compare graph density between the episodes\n\nlet densities, transitivity, nodeCounts = \n    [| for episodeIdx in 1..7 ->\n        let file = __SOURCE_DIRECTORY__ + "/networks/starwars-episode-" + string episodeIdx + "-interactions-allCharacters.json"\n        let nodes = \n            Network.Load(file).Nodes \n            |> Seq.map (fun node -> node.Name) |> Array.ofSeq\n        let nodeLookup = nodes |> Array.mapi (fun i name -> i, name) |> dict\n        let links = Network.Load(file).Links\n\n        let mergeAnakin = true\n        let graph =\n            let edges = \n                links\n                |> Array.collect (fun link ->\n                    let n1 = nodeLookup.[link.Source]\n                    let n2 = nodeLookup.[link.Target]\n                    if mergeAnakin then \n                        if n1 = "ANAKIN" then [| "DARTH VADER"; n2 |]\n                        elif n2 = "ANAKIN" then [| n1; "DARTH VADER" |]\n                        else\n                         [| n1 ; n2 |]\n                    else\n                         [| n1 ; n2 |] )\n            namedParams["edges", box edges; "dir", box "undirected"]\n            |> R.graph\n\n        let clust : float = R.transitivity(graph, "undirected").GetValue()\n        let density : float = R.graph_density(graph).GetValue()\n\n        density, clust, nodes.Length \n    |]\n    |> Array.unzip3\n\nopen XPlot.GoogleCharts\n\n// Plot the number of characters in each episode\nlet options =\n    Options(\n        title = "Number of characters",\n        hAxis = Axis(\n            title = "Number of characters", \n            viewWindowMode = "explicit", \n            viewWindow = ViewWindow(min = 0, max = 40)),\n        colors = [|"#3bc4c4"|]\n    )\n\nnodeCounts\n|> Array.mapi (fun i c -> "Episode " + string (i+1), c)\n|> Chart.Bar\n|> Chart.WithOptions(options)\n\n// Plot the clustering coefficient of each episode\nlet options2 =\n    Options(\n        title = "Clustering coefficient (transitivity)",\n        hAxis = Axis(\n            title = "Clustering coefficient")\n    )\n\ntransitivity\n|> Array.mapi (fun i c -> "Episode " + string (i+1), c)\n|> Chart.Bar\n|> Chart.WithOptions(options2)\n\n// Plot the density of each network\nlet options3 =\n    Options(\n        title = "Network density",\n        hAxis = Axis(title = "Density (%)", \n            viewWindowMode = "explicit", \n            viewWindow = ViewWindow(min = 5, max = 18)),\n        colors = [|"#3bc4c4"|]\n    )\n\ndensities\n|> Array.mapi (fun i c -> "Episode " + string (i+1), c * 100.0 )\n|> Chart.Bar\n|> Chart.WithOptions(options3)\n'