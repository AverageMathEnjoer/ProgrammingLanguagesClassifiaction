b'\n-- Massively parallel command-line util to check for available domains.\n-- Do not use unless you want to get blacklisted from whois servers\n-- very quickly.\n\nmodule Main where\n\nimport Control.Concurrent (forkIO, threadDelay)\nimport Control.Concurrent.Chan (Chan, newChan, readChan, writeChan)\nimport System.Process (readProcessWithExitCode)\nimport System.Exit (ExitCode(..))\nimport Options.Applicative hiding ((&))\n\nimport Control.Monad (replicateM, when, unless, forM_)\n\nimport Data.List (intercalate)\nimport Data.List.Split (splitOn)\nimport Text.Regex.TDFA ((=~))\n\na & f = f a\n\ntype RequestChannel = Chan (Either String String)\ntype ResultChannel = Chan (Either String (String, Bool))\n\n\n\ndata Configuration = Configuration\n    { namelength :: Int\n    , tlds :: String\n    , fromstdin :: Bool\n    , letters :: String\n    , workercount :: Int\n    , delay :: Int\n    , verbose :: Bool\n    }\n\n\ndefaultConfig = Configuration\n    { namelength = 3\n    , tlds = "com,net,org,biz,pro,tel,cat,int"\n    , fromstdin = False\n    , letters = "abcdefghijklmnopqrstuvwxyz1234567890"\n    , workercount = 4\n    , delay = 1\n    , verbose = False\n    }\n\n\noptparser :: ParserInfo Configuration\noptparser = info (helper <*> configparser) (fullDesc <> header "finddomain \xe2\x80\x93 Find out which domains are available")\n  where configparser = pure Configuration\n          <*> option    (long "length"  <> value (defaultConfig & namelength)  <> short \'s\' <> metavar "N"                 <> help "Sets the desired length for domain names")\n          <*> strOption (long "tlds"    <> value (defaultConfig & tlds)        <> short \'t\' <> metavar "tld1,tld2,..."     <> help "The TLDs being searched through")\n          <*> switch    (long "input"   <> value (defaultConfig & fromstdin)   <> short \'i\'                                <> help "Turns on checking of domain names from stdin")\n          <*> strOption (long "letters" <> value (defaultConfig & letters)                  <> metavar "LETTERS"           <> help "The allowed letters in the domain name")\n          <*> option    (long "workers" <> value (defaultConfig & workercount) <> short \'W\' <> metavar "N"                 <> help "The more workers, the faster it gets done")\n          <*> option    (long "delay"   <> value (defaultConfig & delay)       <> short \'d\' <> metavar "N"                 <> help "Make the program pause for N seconds between lookups")\n          <*> switch    (long "verbose" <> value (defaultConfig & verbose)                                                 <> help "Set verbose output")\n\n\n\nmain :: IO ()\nmain = do\n  -- set configuration from command-line options\n  config <- execParser optparser\n\n  requests <- newChan\n  results <- newChan\n\n  -- 1. spawn off the work producer\n  forkIO $ requestMaker config requests\n\n  -- 2. spawn off all the workers\n  forM_ [1.. config & workercount] . const . forkIO $\n      checkDomain config requests results\n\n  -- 3. and collect the results!\n  collect config results\n                                                                      \n\nrequestMaker :: Configuration -> RequestChannel -> IO ()\nrequestMaker config requests = do\n  -- the generator for random domain names\n  let subdomainGen = return $ replicateM (config & namelength) (config & letters)\n\n  -- if the user wants to input domain names themselves, let them\n  subdomains <- if config & fromstdin then lines <$> getContents else subdomainGen\n                            \n  -- create domains from combining domain names with TLDs                                          \n  let domains = map (intercalate ".") $ sequence [subdomains, splitOn "," $ config & tlds]\n\n  -- for each domain, request a whois on it and sleep a little\n  forM_ domains $ \\domain -> do\n    writeChan requests (Right domain)\n    threadDelay . (*1000000) $ config & delay\n\n  -- then tell all the workers they are done\n  forM_ [1.. config & workercount] $ \\_ ->\n    writeChan requests (Left "done")\n\n\ncollect :: Configuration -> ResultChannel -> IO ()\ncollect config results = do\n  result <- readChan results\n\n  case result of\n      -- we got a result to report!\n      Right (domain, unused) -> do\n          let available domain = putStrLn $ domain ++ " is available!"\n              -- only tell about unavailable domains in verbose mode\n              unavailable domain = when (config & verbose) $ putStrLn (domain ++ " is NOT available!")\n              action = if unused then available else unavailable\n          -- report about the domain\n          action domain\n          -- and collect the rest of the results\n          collect config results\n\n      -- if we\'re done, get outta here\n      Left "done" -> return ()\n      -- if a worker went wrong and verbose mode is on, crash and burn\n      Left s -> when (config & verbose) (fail s)\n\n\ncheckDomain :: Configuration -> RequestChannel -> ResultChannel -> IO ()\ncheckDomain config requests results = do\n  request <- readChan requests\n\n  case request of\n    -- if whois on a domain is requested\n    Right domain -> do\n      -- check the availability through whois\n      result <- domainAvailable domain\n\n      case result of\n        -- if we got a reply, forward it to the collector and continue checking for requests\n        Right unused -> writeChan results (Right (domain, unused)) >> recurse\n        -- if domainAvailable broke and we\'re verbose, crash, otherwise continue\n        Left s -> writeChan results (Left s) >> unless (config & verbose) recurse\n\n    -- if we\'re done, forward to collector and be done with it\n    Left "done" ->\n      writeChan results (Left "done")\n\n  where\n    recurse = checkDomain config requests results\n\n\ndomainAvailable :: String -> IO (Either String Bool)\ndomainAvailable domain = do\n  -- run whois for the domain and save the result\n  (exitcode, response, _) <- readProcessWithExitCode "whois" [domain] ""\n  let result = response =~ "[Nn]o [Mm]atch|NO MATCH|[Nn]ot [Ff]ound|NOT FOUND|[Nn]ot [Aa]vailable|NOT AVAILABLE"\n\n  return $ case exitcode of\n    ExitSuccess   -> Right result\n    ExitFailure 1 -> Right result\n\n    ExitFailure 127 ->\n        Left $ "Util \'whois\' could not be run!"\n    ExitFailure 2 ->\n        Left $ "whois limit exceeded for " ++ domain ++ "."\n    ExitFailure i ->\n        Left $ "\'whois " ++ domain ++ "\' terminated unexpectedly with error code " ++ show i ++ "."\n\n \n'