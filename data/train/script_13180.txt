b'/**\n * Copyright (C) 2020 Fernando Cejas Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.fernandocejas.sample.core.functional\n\nimport com.fernandocejas.sample.UnitTest\nimport com.fernandocejas.sample.core.exception.Failure.ServerError\nimport com.fernandocejas.sample.core.functional.Either.Left\nimport com.fernandocejas.sample.core.functional.Either.Right\nimport org.amshove.kluent.shouldBe\nimport org.amshove.kluent.shouldBeInstanceOf\nimport org.amshove.kluent.shouldEqual\nimport org.amshove.kluent.shouldEqualTo\nimport org.junit.Test\n\nclass EitherTest : UnitTest() {\n\n    @Test fun `Either Right should return correct type`() {\n        val result = Right("ironman")\n\n        result shouldBeInstanceOf Either::class.java\n        result.isRight shouldBe true\n        result.isLeft shouldBe false\n        result.fold({},\n                { right ->\n                    right shouldBeInstanceOf String::class.java\n                    right shouldEqualTo "ironman"\n                })\n    }\n\n    @Test fun `Either Left should return correct type`() {\n        val result = Left("ironman")\n\n        result shouldBeInstanceOf Either::class.java\n        result.isLeft shouldBe true\n        result.isRight shouldBe false\n        result.fold(\n                { left ->\n                    left shouldBeInstanceOf String::class.java\n                    left shouldEqualTo "ironman"\n                }, {})\n    }\n\n    @Test fun `Either fold should ignore passed argument if it is Right type`() {\n        val success = "Success"\n        val result = Right(success).getOrElse("Other")\n\n        result shouldEqualTo success\n    }\n\n    @Test fun `Either fold should return argument if it is Left type`() {\n        val other = "Other"\n        val result = Left("Failure").getOrElse(other)\n\n        result shouldEqual other\n    }\n\n    @Test\n    fun `given fold is called, when either is Right, applies fnR and returns its result`() {\n        val either = Right("Success")\n        val result = either.fold({ fail("Shouldn\'t be executed") }) { 5 }\n\n        result shouldBe 5\n        either.isRight shouldBe true\n    }\n\n    @Test\n    fun `given fold is called, when either is Left, applies fnL and returns its result`() {\n        val either = Left(12)\n\n        val foldResult = "Fold Result"\n        val result = either.fold({ foldResult }) { fail("Shouldn\'t be executed") }\n\n        result shouldBe foldResult\n        either.isLeft shouldBe true\n    }\n\n    @Test\n    fun `given flatMap is called, when either is Right, applies function and returns new Either`() {\n        val either = Right("Success")\n\n        val result = either.flatMap {\n            it shouldBe "Success"\n            Left(ServerError)\n        }\n\n        result shouldEqual Left(ServerError)\n        result.isLeft shouldBe true\n    }\n\n    @Test\n    fun `given flatMap is called, when either is Left, doesn\'t invoke function and returns original Either`() {\n        val either = Left(12)\n\n        val result = either.flatMap { Right(20) }\n\n        result.isLeft shouldBe true\n        result shouldEqual either\n    }\n\n    @Test\n    fun `given onFailure is called, when either is Right, doesn\'t invoke function and returns original Either`() {\n        val success = "Success"\n        val either = Right(success)\n\n        val result = either.onFailure { fail("Shouldn\'t be executed") }\n\n        result shouldBe either\n        either.getOrElse("Failure") shouldBe success\n    }\n\n    @Test\n    fun `given onFailure is called, when either is Left, invokes function with left value and returns original Either`() {\n        val either = Left(12)\n\n        var methodCalled = false\n        val result = either.onFailure {\n            it shouldBe 12\n            methodCalled = true\n        }\n\n        result shouldBe either\n        methodCalled shouldBe true\n    }\n\n    @Test\n    fun `given onSuccess is called, when either is Right, invokes function with right value and returns original Either`() {\n        val success = "Success"\n        val either = Right(success)\n\n        var methodCalled = false\n        val result = either.onSuccess {\n            it shouldEqual success\n            methodCalled = true\n        }\n\n        result shouldBe either\n        methodCalled shouldBe true\n    }\n\n    @Test\n    fun `given onSuccess is called, when either is Left, doesn\'t invoke function and returns original Either`() {\n        val either = Left(12)\n\n        val result = either.onSuccess {fail("Shouldn\'t be executed") }\n\n        result shouldBe either\n    }\n\n    @Test\n    fun `given map is called, when either is Right, invokes function with right value and returns a new Either`() {\n        val success = "Success"\n        val resultValue = "Result"\n        val either = Right(success)\n\n        val result = either.map {\n            it shouldBe success\n            resultValue\n        }\n\n        result shouldEqual Right(resultValue)\n    }\n\n    @Test\n    fun `given map is called, when either is Left, doesn\'t invoke function and returns original Either`() {\n        val either = Left(12)\n\n        val result = either.map { Right(20) }\n\n        result.isLeft shouldBe true\n        result shouldEqual either\n    }\n}\n'