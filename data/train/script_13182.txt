b'// (C) Copyright Reimar D\xc3\xb6ffinger 2018.\n// Based on zstd.cpp by:\n// (C) Copyright Milan Svoboda 2008.\n// (C) Copyright Jonathan Turkanis 2003.\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt.)\n\n// See http://www.boost.org/libs/iostreams for documentation.\n\n// Define BOOST_IOSTREAMS_SOURCE so that <boost/iostreams/detail/config.hpp>\n// knows that we are building the library (possibly exporting code), rather\n// than using it (possibly importing code).\n#define BOOST_IOSTREAMS_SOURCE\n\n#include <zstd.h>\n\n#include <boost/throw_exception.hpp>\n#include <boost/iostreams/detail/config/dyn_link.hpp>\n//#include <boost/iostreams/filter/zstd.hpp>\n#include "zstd.hpp"\n\nnamespace boost { namespace iostreams {\n\nnamespace zstd {\n                    // Compression levels\n\nconst uint32_t best_speed           = 1;\nconst uint32_t best_compression     = 19;\nconst uint32_t default_compression  = 3;\n\n                    // Status codes\n\nconst int okay                 = 0;\nconst int stream_end           = 1;\n\n                    // Flush codes\n\nconst int finish               = 0;\nconst int flush                = 1;\nconst int run                  = 2;\n} // End namespace zstd.\n\n//------------------Implementation of zstd_error------------------------------//\n\nzstd_error::zstd_error(size_t error)\n    : BOOST_IOSTREAMS_FAILURE(ZSTD_getErrorName(error)), error_(error)\n    { }\n\nvoid zstd_error::check BOOST_PREVENT_MACRO_SUBSTITUTION(size_t error)\n{\n    if (ZSTD_isError(error))\n        boost::throw_exception(zstd_error(error));\n}\n\n//------------------Implementation of zstd_base-------------------------------//\n\nnamespace detail {\n\nzstd_base::zstd_base()\n    : cstream_(ZSTD_createCStream()), dstream_(ZSTD_createDStream()), in_(new ZSTD_inBuffer), out_(new ZSTD_outBuffer), eof_(0)\n    { }\n\nzstd_base::~zstd_base()\n{\n    ZSTD_freeCStream(static_cast<ZSTD_CStream *>(cstream_));\n    ZSTD_freeDStream(static_cast<ZSTD_DStream *>(dstream_));\n    delete static_cast<ZSTD_inBuffer*>(in_);\n    delete static_cast<ZSTD_outBuffer*>(out_);\n}\n\nvoid zstd_base::before( const char*& src_begin, const char* src_end,\n                        char*& dest_begin, char* dest_end )\n{\n    ZSTD_inBuffer *in = static_cast<ZSTD_inBuffer *>(in_);\n    ZSTD_outBuffer *out = static_cast<ZSTD_outBuffer *>(out_);\n    in->src = src_begin;\n    in->size = static_cast<size_t>(src_end - src_begin);\n    in->pos = 0;\n    out->dst = dest_begin;\n    out->size = static_cast<size_t>(dest_end - dest_begin);\n    out->pos = 0;\n}\n\nvoid zstd_base::after(const char*& src_begin, char*& dest_begin, bool)\n{\n    ZSTD_inBuffer *in = static_cast<ZSTD_inBuffer *>(in_);\n    ZSTD_outBuffer *out = static_cast<ZSTD_outBuffer *>(out_);\n    src_begin = reinterpret_cast<const char*>(in->src) + in->pos;\n    dest_begin = reinterpret_cast<char*>(out->dst) + out->pos;\n}\n\nint zstd_base::deflate(int action)\n{\n    ZSTD_CStream *s = static_cast<ZSTD_CStream *>(cstream_);\n    ZSTD_inBuffer *in = static_cast<ZSTD_inBuffer *>(in_);\n    ZSTD_outBuffer *out = static_cast<ZSTD_outBuffer *>(out_);\n    // Ignore spurious extra calls.\n    // Note size > 0 will trigger an error in this case.\n    if (eof_ && in->size == 0) return zstd::stream_end;\n    size_t result = ZSTD_compressStream(s, out, in);\n    zstd_error::check BOOST_PREVENT_MACRO_SUBSTITUTION(result);\n    if (action != zstd::run)\n    {\n        result = action == zstd::finish ? ZSTD_endStream(s, out) : ZSTD_flushStream(s, out);\n        zstd_error::check BOOST_PREVENT_MACRO_SUBSTITUTION(result);\n        eof_ = action == zstd::finish && result == 0;\n        return result == 0 ? zstd::stream_end : zstd::okay;\n    }\n    return zstd::okay;\n}\n\nint zstd_base::inflate(int action)\n{\n    ZSTD_DStream *s = static_cast<ZSTD_DStream *>(dstream_);\n    ZSTD_inBuffer *in = static_cast<ZSTD_inBuffer *>(in_);\n    ZSTD_outBuffer *out = static_cast<ZSTD_outBuffer *>(out_);\n    // need loop since iostream code cannot handle short reads\n    do {\n        size_t result = ZSTD_decompressStream(s, out, in);\n        zstd_error::check BOOST_PREVENT_MACRO_SUBSTITUTION(result);\n    } while (in->pos < in->size && out->pos < out->size);\n    return action == zstd::finish && in->size == 0 && out->pos == 0 ? zstd::stream_end : zstd::okay;\n}\n\nvoid zstd_base::reset(bool compress, bool realloc)\n{\n    ZSTD_inBuffer *in = static_cast<ZSTD_inBuffer *>(in_);\n    ZSTD_outBuffer *out = static_cast<ZSTD_outBuffer *>(out_);\n    if (realloc)\n    {\n        memset(in, 0, sizeof(*in));\n        memset(out, 0, sizeof(*out));\n        eof_ = 0;\n\n        zstd_error::check BOOST_PREVENT_MACRO_SUBSTITUTION(\n            compress ?\n                ZSTD_initCStream(static_cast<ZSTD_CStream *>(cstream_), level) :\n                ZSTD_initDStream(static_cast<ZSTD_DStream *>(dstream_))\n        );\n    }\n}\n\nvoid zstd_base::do_init\n    ( const zstd_params& p, bool compress,\n      zstd::alloc_func, zstd::free_func,\n      void* )\n{\n    ZSTD_inBuffer *in = static_cast<ZSTD_inBuffer *>(in_);\n    ZSTD_outBuffer *out = static_cast<ZSTD_outBuffer *>(out_);\n\n    memset(in, 0, sizeof(*in));\n    memset(out, 0, sizeof(*out));\n    eof_ = 0;\n\n    level = p.level;\n    zstd_error::check BOOST_PREVENT_MACRO_SUBSTITUTION(\n        compress ?\n            ZSTD_initCStream(static_cast<ZSTD_CStream *>(cstream_), level) :\n            ZSTD_initDStream(static_cast<ZSTD_DStream *>(dstream_))\n    );\n}\n\n} // End namespace detail.\n\n//----------------------------------------------------------------------------//\n\n} } // End namespaces iostreams, boost.\n'