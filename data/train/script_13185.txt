b'// Copyright (c) 2023 Manuel Schneider\n\n#include "globalqueryhandlerprivate.h"\n#include <mutex>\nusing namespace std;\nusing namespace albert;\n\n\nstd::shared_mutex GlobalQueryHandlerPrivate::m;\nstd::map<std::pair<QString,QString>,RankItem::Score> GlobalQueryHandlerPrivate::usage_scores;\nbool GlobalQueryHandlerPrivate::prio_perfect_match;\n\nGlobalQueryHandlerPrivate::GlobalQueryHandlerPrivate(GlobalQueryHandler *q_) : q(q_) {}\n\nGlobalQueryHandlerPrivate::~GlobalQueryHandlerPrivate() = default;\n\nvoid GlobalQueryHandlerPrivate::setPrioritizePerfectMatch(bool val)\n{\n    unique_lock lock(m);\n    prio_perfect_match = val;\n}\n\nvoid GlobalQueryHandlerPrivate::setScores(std::map<std::pair<QString, QString>, RankItem::Score> scores)\n{\n    unique_lock lock(m);\n    usage_scores = std::move(scores);\n}\n\nvoid GlobalQueryHandlerPrivate::applyUsageScores(vector<RankItem> &rank_items) const\n{\n    shared_lock lock(m);\n    // https://github.com/albertlauncher/albert/issues/695\n    for (auto & rank_item : rank_items){\n\n        if (prio_perfect_match && rank_item.score == RankItem::MAX_SCORE){  // Prefer exact matches\n            rank_item.score = RankItem::MAX_SCORE/3*2;\n            try {\n                rank_item.score += usage_scores.at(make_pair(q->id(), rank_item.item->id()))/3;\n            } catch (const out_of_range &){}\n        } else {\n            try {\n                rank_item.score = usage_scores.at(make_pair(q->id(), rank_item.item->id()))/3 + RankItem::MAX_SCORE/3;\n            } catch (const out_of_range &){\n                rank_item.score = rank_item.score / 3;\n            }\n        }\n    }\n}\n\nvector<RankItem> GlobalQueryHandlerPrivate::handleGlobalQuery(const GlobalQueryHandler::GlobalQuery &query) const\n{\n    vector<RankItem> rank_items = q->handleGlobalQuery(query);\n    applyUsageScores(rank_items);\n    return rank_items;\n}\n'