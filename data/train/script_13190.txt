b'{-# LANGUAGE CPP #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE LambdaCase #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.Coroutine.Draw where\n\nimport Control.Concurrent.STM (atomically, modifyTVar\')\nimport Control.Lens (Lens\', set, view, (%~), (.~), (^.))\nimport Control.Monad (unless, void, when)\nimport Control.Monad.State (get, gets, liftIO, modify)\nimport Control.Monad.Trans.Crtn (request)\nimport Control.Monad.Trans.Crtn.Object (Arg (..), Res (..))\nimport Control.Monad.Trans.Crtn.Queue (enqueue)\nimport Control.Monad.Trans.Reader (runReaderT)\nimport qualified Data.HashMap.Strict as HM\nimport Data.Hoodle.BBox (BBox (..))\nimport qualified Data.IntMap as M\nimport Data.Time.Clock\n  ( getCurrentTime,\n  )\nimport Data.Time.LocalTime\n  ( getCurrentTimeZone,\n    localTimeOfDay,\n    todHour,\n    todMin,\n    todSec,\n    utcToLocalTime,\n  )\nimport Graphics.Hoodle.Render.Type\n  ( RenderCache,\n    Renderer,\n    RendererEvent (FinishCommandFor, SurfaceUpdate),\n    RendererState (..),\n  )\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Accessor\n  ( applyActionToAllCVS,\n    getCanvasGeometryCvsId,\n    getCurrentPageEitherFromHoodleModeState,\n    pureUpdateUhdl,\n    renderCache,\n  )\nimport Hoodle.Type.Alias (EditMode, SelectMode)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo (..),\n    canvasId,\n    canvasWidgets,\n    currentPageNum,\n    drawArea,\n    forBoth\',\n    mDrawSurface,\n    unboxBiAct,\n    unboxLens,\n    viewInfo,\n  )\nimport Hoodle.Type.Coroutine\n  ( MainCoroutine,\n    MainOp (DoEvent),\n    doIOaction,\n  )\nimport Hoodle.Type.Enum (DrawFlag (Clear, Efficient))\nimport Hoodle.Type.Event\n  ( AllEvent (SysEv, UsrEv),\n    RenderEvent (..),\n    SystemEvent (ClockUpdateEvent, RenderCacheUpdate),\n    UIEvent (UIGetFlag),\n    UserEvent\n      ( ActionOrdered,\n        RenderEv,\n        UIEv,\n        UpdateCanvas,\n        UpdateCanvasEfficient\n      ),\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    HoodleState,\n    UnitHoodle,\n    currentCanvasInfo,\n    currentUnit,\n    cvsInfoMap,\n    doesNotInvalidate,\n    genRenderQueue,\n    getCanvasInfo,\n    getCurrentCanvasId,\n    gtkUIManager,\n    hoodleModeState,\n    pdfRenderQueue,\n    renderCacheVar,\n    tempQueue,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( PageNum (..),\n    ViewMode (ContinuousPage, SinglePage),\n  )\nimport Hoodle.Type.Widget\n  ( clockWidgetConfig,\n    clockWidgetTime,\n    doesUseClockWidget,\n    widgetConfig,\n  )\nimport Hoodle.Util (msgShout)\nimport Hoodle.View.Draw\n  ( ContPageDraw (..),\n    DrawingFunction,\n    SinglePageDraw (..),\n    cairoXform4PageCoordinate,\n    drawContHoodle,\n    drawContHoodleSel,\n    drawSinglePage,\n    drawSinglePageSel,\n    mkXform4Page,\n  )\n\n-- | all event\nnextevent :: MainCoroutine UserEvent\nnextevent = do\n  Arg DoEvent ev <- request (Res DoEvent ())\n  case ev of\n    SysEv sev -> sysevent sev >> nextevent\n    UsrEv uev -> return uev\n\n-- | system event\nsysevent :: SystemEvent -> MainCoroutine ()\nsysevent ClockUpdateEvent = do\n  utctime <- liftIO getCurrentTime\n  zone <- liftIO getCurrentTimeZone\n  let ltime = utcToLocalTime zone utctime\n      ltimeofday = localTimeOfDay ltime\n      (h, m, s) :: (Int, Int, Int) =\n        (,,) <$> (\\x -> todHour x `mod` 12) <*> todMin <*> (floor . todSec) $\n          ltimeofday\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      cinfo = view currentCanvasInfo uhdl\n      cwgts = view (unboxLens canvasWidgets) cinfo\n      nwgts = set (clockWidgetConfig . clockWidgetTime) (h, m, s) cwgts\n      ncinfo = set (unboxLens canvasWidgets) nwgts cinfo\n  pureUpdateUhdl (const ((currentCanvasInfo .~ ncinfo) uhdl))\n  when (view (widgetConfig . doesUseClockWidget) cwgts) $ do\n    let cid = getCurrentCanvasId uhdl\n    modify (tempQueue %~ enqueue (Right (UsrEv (UpdateCanvasEfficient cid))))\nsysevent (RenderCacheUpdate (uuid, ssfc)) = do\n  cachevar <- gets (view renderCacheVar)\n  liftIO $ atomically $ modifyTVar\' cachevar (HM.insert uuid ssfc)\n  b <- gets (^. doesNotInvalidate)\n  unless b invalidateAll\nsysevent ev = msgShout (show ev)\n\n-- | update flag in HoodleState when corresponding toggle UI changed\nupdateFlagFromToggleUI ::\n  -- | UI toggle button id\n  String ->\n  -- | lens for flag\n  Lens\' HoodleState Bool ->\n  MainCoroutine Bool\nupdateFlagFromToggleUI toggleid lensforflag = do\n  xstate <- get\n  let ui = view gtkUIManager xstate\n  doIOaction $ \\_ -> do\n    agr <-\n      Gtk.uiManagerGetActionGroups ui >>= \\case\n        [] -> error "No action group? "\n        y : _ -> return y\n    togglea <-\n      Gtk.actionGroupGetAction agr toggleid\n        >>= maybe\n          (error "updateFlagFromToggleUI")\n          (return . Gtk.castToToggleAction)\n    b <- Gtk.toggleActionGetActive togglea\n    return (UsrEv (UIEv (UIGetFlag b)))\n  UIEv (UIGetFlag b) <-\n    waitSomeEvent (\\case UIEv (UIGetFlag _) -> True; _ -> False)\n  modify (set lensforflag b) >> return b\n\n-- |\ndata DrawingFunctionSet = DrawingFunctionSet\n  { singleEditDraw :: DrawingFunction \'SinglePage EditMode,\n    singleSelectDraw :: DrawingFunction \'SinglePage SelectMode,\n    contEditDraw :: DrawingFunction \'ContinuousPage EditMode,\n    contSelectDraw :: DrawingFunction \'ContinuousPage SelectMode\n  }\n\n-- |\ninvalidateGeneral ::\n  CanvasId ->\n  Maybe BBox ->\n  DrawFlag ->\n  DrawingFunction \'SinglePage EditMode ->\n  DrawingFunction \'SinglePage SelectMode ->\n  DrawingFunction \'ContinuousPage EditMode ->\n  DrawingFunction \'ContinuousPage SelectMode ->\n  MainCoroutine ()\ninvalidateGeneral cid mbbox flag drawf drawfsel drawcont drawcontsel = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  cache <- renderCache\n  unboxBiAct (fsingle cache uhdl) (fcont cache uhdl) . getCanvasInfo cid $ uhdl\n  where\n    fsingle :: RenderCache -> UnitHoodle -> CanvasInfo \'SinglePage -> MainCoroutine ()\n    fsingle cache uhdl cvsInfo = do\n      let cpn = PageNum . view currentPageNum $ cvsInfo\n          isCurrentCvs = cid == getCurrentCanvasId uhdl\n          epage = getCurrentPageEitherFromHoodleModeState cvsInfo (view hoodleModeState uhdl)\n          cvsid = view canvasId cvsInfo\n          cvs = view drawArea cvsInfo\n          msfc = view mDrawSurface cvsInfo\n      case epage of\n        Left page ->\n          void $\n            liftIO\n              ( unSinglePageDraw drawf cache cvsid isCurrentCvs (cvs, msfc) (cpn, page)\n                  <$> view viewInfo <*> pure mbbox <*> pure flag\n                  $ cvsInfo\n              )\n        Right tpage ->\n          void $\n            liftIO\n              ( unSinglePageDraw drawfsel cache cvsid isCurrentCvs (cvs, msfc) (cpn, tpage)\n                  <$> view viewInfo <*> pure mbbox <*> pure flag\n                  $ cvsInfo\n              )\n    fcont :: RenderCache -> UnitHoodle -> CanvasInfo \'ContinuousPage -> MainCoroutine ()\n    fcont cache uhdl cvsInfo = do\n      let hdlmodst = view hoodleModeState uhdl\n          isCurrentCvs = cid == getCurrentCanvasId uhdl\n      case hdlmodst of\n        ViewAppendState hdl -> do\n          hdl\' <- liftIO (unContPageDraw drawcont cache isCurrentCvs cvsInfo mbbox hdl flag)\n          pureUpdateUhdl (const ((hoodleModeState .~ ViewAppendState hdl\') uhdl))\n        SelectState thdl -> do\n          thdl\' <- liftIO (unContPageDraw drawcontsel cache isCurrentCvs cvsInfo mbbox thdl flag)\n          pureUpdateUhdl (const ((hoodleModeState .~ SelectState thdl\') uhdl))\n\n-- |\ninvalidateOther :: MainCoroutine ()\ninvalidateOther = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n      currCvsId = getCurrentCanvasId uhdl\n      cinfoMap = view cvsInfoMap uhdl\n      keys = M.keys cinfoMap\n  mapM_ invalidate (filter (/= currCvsId) keys)\n\n-- | invalidate clear\ninvalidate :: CanvasId -> MainCoroutine ()\ninvalidate = invalidateInBBox Nothing Clear\n\n-- |\ninvalidateInBBox ::\n  -- | desktop coord\n  Maybe BBox ->\n  DrawFlag ->\n  CanvasId ->\n  MainCoroutine ()\ninvalidateInBBox mbbox flag cid = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  geometry <- liftIO $ getCanvasGeometryCvsId cid uhdl\n  invalidateGeneral\n    cid\n    mbbox\n    flag\n    (drawSinglePage geometry)\n    (drawSinglePageSel geometry)\n    (drawContHoodle geometry)\n    (drawContHoodleSel geometry)\n\n-- |\ninvalidateAllInBBox ::\n  -- | desktop coordinate\n  Maybe BBox ->\n  DrawFlag ->\n  MainCoroutine ()\ninvalidateAllInBBox mbbox flag = applyActionToAllCVS (invalidateInBBox mbbox flag)\n\n-- |\ninvalidateAll :: MainCoroutine ()\ninvalidateAll = invalidateAllInBBox Nothing Clear\n\n-- | Invalidate Current canvas\ninvalidateCurrent :: MainCoroutine ()\ninvalidateCurrent = invalidate . getCurrentCanvasId . view (unitHoodles . currentUnit) =<< get\n\n-- | Drawing temporary gadgets\ninvalidateTemp :: CanvasId -> Cairo.Surface -> Cairo.Render () -> MainCoroutine ()\ninvalidateTemp cid tempsurface rndr = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  forBoth\' unboxBiAct (fsingle uhdl) . getCanvasInfo cid $ uhdl\n  where\n    fsingle :: UnitHoodle -> CanvasInfo a -> MainCoroutine ()\n    fsingle uhdl cvsInfo = do\n      let canvas = view drawArea cvsInfo\n          pnum = PageNum . view currentPageNum $ cvsInfo\n      geometry <- liftIO $ getCanvasGeometryCvsId cid uhdl\n      Just win <- liftIO $ Gtk.widgetGetWindow canvas\n      let xformfunc = cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n      liftIO $\n        Gtk.renderWithDrawWindow win $ do\n          Cairo.setSourceSurface tempsurface 0 0\n          Cairo.setOperator Cairo.OperatorSource\n          Cairo.paint\n          xformfunc\n          rndr\n\n-- | Drawing temporary gadgets with coordinate based on base page\ninvalidateTempBasePage ::\n  -- | current canvas id\n  CanvasId ->\n  -- | temporary cairo surface\n  Cairo.Surface ->\n  -- | current page number\n  PageNum ->\n  -- | temporary rendering function\n  Cairo.Render () ->\n  MainCoroutine ()\ninvalidateTempBasePage cid tempsurface pnum rndr = do\n  xst <- get\n  let uhdl = view (unitHoodles . currentUnit) xst\n  forBoth\' unboxBiAct (fsingle uhdl) . getCanvasInfo cid $ uhdl\n  where\n    fsingle :: UnitHoodle -> CanvasInfo a -> MainCoroutine ()\n    fsingle uhdl cvsInfo = do\n      let canvas = view drawArea cvsInfo\n      geometry <- liftIO $ getCanvasGeometryCvsId cid uhdl\n      Just win <- liftIO $ Gtk.widgetGetWindow canvas\n      let xformfunc = cairoXform4PageCoordinate (mkXform4Page geometry pnum)\n      liftIO $\n        Gtk.renderWithDrawWindow win $ do\n          Cairo.setSourceSurface tempsurface 0 0\n          Cairo.setOperator Cairo.OperatorSource\n          Cairo.paint\n          xformfunc\n          rndr\n\n-- |\nwaitSomeEvent :: (UserEvent -> Bool) -> MainCoroutine UserEvent\nwaitSomeEvent p = do\n  r <- nextevent\n  case r of\n    UpdateCanvas cid ->\n      -- this is temporary\n      invalidateInBBox Nothing Efficient cid >> waitSomeEvent p\n    _ -> if p r then return r else waitSomeEvent p\n\n-- |\ndoIOaction_ :: IO a -> MainCoroutine ()\ndoIOaction_ action = do\n  doIOaction $ \\_ -> action >> return (UsrEv ActionOrdered)\n  void $ waitSomeEvent (\\case ActionOrdered -> True; _ -> False)\n\ndefaultHandler :: (AllEvent -> IO ()) -> RendererEvent -> IO ()\ndefaultHandler evhandler (SurfaceUpdate s) =\n  Gtk.postGUIAsync . evhandler . SysEv . RenderCacheUpdate $ s\ndefaultHandler evhandler (FinishCommandFor sfcid) =\n  Gtk.postGUIAsync . evhandler . UsrEv . RenderEv . FinishCommand $ sfcid\n\n-- | order rendering routine\ncallRenderer :: Renderer RenderEvent -> MainCoroutine ()\ncallRenderer action = do\n  (tvarpdf, tvargen, tvarcache) <-\n    gets ((,,) <$> (^. pdfRenderQueue) <*> (^. genRenderQueue) <*> (^. renderCacheVar))\n  doIOaction $ \\evhandler ->\n    UsrEv . RenderEv <$> runReaderT action (RendererState (defaultHandler evhandler) tvarpdf tvargen tvarcache)\n\ncallRenderer_ :: Renderer a -> MainCoroutine ()\ncallRenderer_ action = do\n  callRenderer $ action >> return GotNone\n  void $ waitSomeEvent (\\case RenderEv GotNone -> True; _ -> False)\n'