b'module Database.Beam.Migrate.Tool.Branch where\n\nimport           Database.Beam.Migrate.Tool.CmdLine\nimport           Database.Beam.Migrate.Tool.Registry\n\nimport           Control.Monad\n\n#if !MIN_VERSION_base(4, 11, 0)\nimport           Data.Monoid\n#endif\nimport qualified Data.Text as T\n\nimport           System.Console.ANSI\n\nlistBranches :: MigrateCmdLine -> IO ()\nlistBranches cmdLine = do\n  reg <- lookupRegistry cmdLine\n\n  case migrationRegistryHead reg of\n    MigrationHeadDetached commitId -> do\n      setSGR [ SetColor Foreground Dull Green ]\n      putStrLn ("(Currently in detached HEAD mode at " ++ show commitId ++ ")")\n      setSGR [ Reset ]\n    _ -> pure ()\n\n  forM_ (migrationRegistryBranches reg) $ \\branch -> do\n    let isCurrent = migrationRegistryHead reg == MigrationHeadBranch (migrationBranchName branch)\n    putStrLn ((if isCurrent then "* " <> setSGRCode [ SetColor Foreground Dull Green ] else "  ") <>\n              T.unpack (migrationBranchName branch) <>\n              setSGRCode [ Reset ])\n\ndeleteBranch :: MigrateCmdLine -> T.Text -> IO ()\ndeleteBranch cmdLine branchNm =\n  updatingRegistry cmdLine $ \\reg ->\n  pure ((), reg { migrationRegistryBranches =\n                    filter (\\branch -> migrationBranchName branch /= branchNm)\n                           (migrationRegistryBranches reg) })\n\nnewBranch :: MigrateCmdLine -> Bool -> T.Text -> IO ()\nnewBranch cmdLine dontSwitch branchNm =\n  updatingRegistry cmdLine $ \\reg ->\n  case lookupBranch reg branchNm of\n    Nothing ->\n      pure ((), reg { migrationRegistryBranches = MigrationBranch branchNm (registryHeadCommit reg):migrationRegistryBranches reg\n                    , migrationRegistryHead = if dontSwitch then migrationRegistryHead reg else MigrationHeadBranch branchNm } )\n    Just _ -> fail "Branch already exists"\n'