b'{-# LANGUAGE\n    CPP\n  , DeriveDataTypeable\n  , FlexibleInstances\n  , ScopedTypeVariables\n  #-}\n\n#include "overlapping-compat.h"\n\nmodule Rest.StringMap.HashMap.Strict\n  ( StringHashMap\n  , fromHashMap\n  , toHashMap\n  , fromList\n  , toList\n  ) where\n\nimport Data.Aeson\nimport Data.HashMap.Strict (HashMap)\nimport Data.Hashable\nimport Data.JSON.Schema\nimport Data.String\nimport Data.String.ToString\nimport Data.Typeable\nimport Text.XML.HXT.Arrow.Pickle\nimport qualified Data.HashMap.Strict as H\n\nimport Rest.StringMap.Util\n\nnewtype StringHashMap a b = StringHashMap { unH :: HashMap a b }\n  deriving (Eq, Show, Typeable)\n\nfromHashMap :: HashMap a b -> StringHashMap a b\nfromHashMap = StringHashMap\n\ntoHashMap :: StringHashMap a b -> HashMap a b\ntoHashMap = unH\n\nfromList :: (Eq a, Hashable a) => [(a, b)] -> StringHashMap a b\nfromList = StringHashMap . H.fromList\n\ntoList :: StringHashMap a b -> [(a, b)]\ntoList = H.toList . unH\n\n-- | This is used with the assumption that a = b => f a = f b\nmapKeys :: (Hashable l, Eq l) => (k -> l) -> StringHashMap k v -> StringHashMap l v\nmapKeys f = StringHashMap . H.foldlWithKey\' (\\h k v -> H.insert (f k) v h) H.empty . unH\n\n-- | Base case since XmlPickler expects strings\ninstance XmlPickler b => XmlPickler (StringHashMap String b) where\n  xpickle = pickleStringMap fromList toList\n\n-- | General case\ninstance OVERLAPPABLE_ (Eq a, Hashable a, IsString a, ToString a, XmlPickler b) => XmlPickler (StringHashMap a b) where\n  xpickle = pickleMap mapKeys mapKeys\n\ninstance (ToString a, ToJSON b) => ToJSON (StringHashMap a b) where\n  toJSON = toJSON . toHashMap . mapKeys toString\n\ninstance (Eq a, Hashable a, IsString a, FromJSON b) => FromJSON (StringHashMap a b) where\n  parseJSON = fmap (mapKeys fromString . fromHashMap) . parseJSON\n\ninstance JSONSchema b => JSONSchema (StringHashMap a b) where\n  schema _ = mapSchema (Proxy :: Proxy b)\n'