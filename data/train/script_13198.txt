b'module Code.Build.Ruby where\n\nimport Code.Build\nimport Data.List\n\nhashmap :: [(String, Code)] -> Code\nhashmap [] = code "{}"\nhashmap items = ("{ " <-> many ", ") |><| mkStack (map ((\':\': ) . fst) items) |><| many " => " |>+<| map snd items <-> "}"\n\nstatements :: CodeList a => a -> Code\nstatements = mkStack . codeList\n\nblock :: CodeList a => a -> Code\nblock c = indent 2 (statements c)\n\nendBlock :: CodeList a => a -> Code\nendBlock c = indent 2 (statements c) <-> "end"\n\nrbIf :: (Codeable a, CodeList b) => a -> b -> Code\nrbIf cond blk = "if" <++> parenthesis cond <-> endBlock blk\n\nrbIf_ :: (Codeable a, CodeList b) => a -> b -> Code\nrbIf_ cond blk = "if" <++> parenthesis cond <-> block blk\n\nrbElsIf :: (Codeable a, CodeList b) => a -> b -> Code\nrbElsIf cond blk = "elsif" <++> parenthesis cond <-> endBlock blk\n\nrbElsIf_ :: (Codeable a, CodeList b) => a -> b -> Code\nrbElsIf_ cond blk = "elsif" <++> parenthesis cond <-> block blk\n\nrbElse :: CodeList b => b -> Code\nrbElse blk = "else" <-> endBlock blk\n\n--rbIfElse :: CodeList a => a -> Code\n--rbIfElse blk = "else" <-> block blk\n\nrbModule :: CodeList a => String -> a -> Code\nrbModule name c = "module" <++> name <-> endBlock c\n\nrbClass :: CodeList a => String -> a -> Code\nrbClass name c = "class" <++> name <-> endBlock c\n\nrequire :: String -> Code\nrequire name = "require" <++> string name\n\nfunction :: CodeList a => String -> [String] -> a -> Code\nfunction name pars body = "def" <++> name <++> parenthesis (intercalate ", " pars) <-> endBlock body\n\ncall :: CodeList a => String -> a -> Code\ncall func as | all singleLine (codeList as) = func <+> parenthesis (interleave ", " $ codeList as)\n             | otherwise                    = func <+| (("( " <-> many ", ") |>+<| as) <+> ")"\n\nret :: Codeable a => a -> Code\nret a = "return " <+| a\n\nstring :: Codeable a => a -> Code\nstring = surround "\'" "\'"\n\nnew :: CodeList a => String -> a ->  Code\nnew clas pars = clas ++ ".new" <+| parenthesis (interleave ", " $ codeList pars)\n\ninfix 2 .=.\n\n(.=.) :: Codeable b => String -> b -> Code\nv .=. c | singleLine (code c) = v <+> " = " <+| c\n        | otherwise           = v <+> " =" <-> indent 2 c\n'