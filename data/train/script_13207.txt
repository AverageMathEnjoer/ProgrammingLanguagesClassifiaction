b'{-# LANGUAGE GADTs #-}\n\nmodule Hoodle.Coroutine.Mode where\n\nimport Control.Lens (set, view, (.~))\nimport Control.Monad.State (liftIO)\nimport Data.Hoodle.BBox (bbox_upperleft)\nimport Data.Hoodle.Generic (gdimension)\nimport Data.Hoodle.Select\n  ( gHoodle2GSelect,\n    gSelect2GHoodle,\n    gselAll,\n    gselSelected,\n  )\nimport qualified Data.IntMap as M\nimport Graphics.Hoodle.Render (updatePageBuf)\nimport Graphics.Hoodle.Render.Type (hPage2RPage)\nimport qualified Graphics.UI.Gtk as Gtk (adjustmentGetValue)\nimport Hoodle.Accessor\n  ( getCurrentPageCurr,\n    getGeometry4CurrCvs,\n    updateUhdl,\n    updateXState,\n  )\nimport Hoodle.Coroutine.Draw\n  ( callRenderer_,\n    invalidateAll,\n    invalidateAllInBBox,\n  )\nimport Hoodle.Coroutine.Scroll (adjustScrollbarWithGeometryCurrent)\nimport Hoodle.GUI.Reflect\n  ( reflectPenColorUI,\n    reflectPenModeUI,\n    reflectPenWidthUI,\n  )\nimport Hoodle.Type.Alias (EditMode, Hoodle, SelectMode)\nimport Hoodle.Type.Canvas\n  ( CanvasInfo (..),\n    CanvasInfoBox (CanvasContPage, CanvasSinglePage),\n    ViewInfo (..),\n    adjustments,\n    canvasId,\n    canvasWidgets,\n    currentPageNum,\n    drawArea,\n    horizAdjConnId,\n    horizAdjustment,\n    mDrawSurface,\n    notifiedItem,\n    pageArrangement,\n    scrolledWindow,\n    unboxBiAct,\n    vertAdjConnId,\n    vertAdjustment,\n    viewInfo,\n    zoomMode,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event\n  ( UserEvent\n      ( ToContSinglePage,\n        ToSelectMode,\n        ToSinglePage,\n        ToViewAppendMode\n      ),\n  )\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (SelectState, ViewAppendState),\n    HoodleState,\n    UnitHoodle,\n    currentCanvasInfo,\n    currentUnit,\n    getCurrentCanvasId,\n    getHoodle,\n    hoodleModeState,\n    hoodleModeStateEither,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement\n  ( DesktopCoordinate (..),\n    PageCoordinate (..),\n    PageDimension (..),\n    PageNum (..),\n    ViewPortBBox (..),\n    makeContinuousArrangement,\n    makeSingleArrangement,\n    viewPortBBox,\n  )\nimport Hoodle.View.Coordinate\n  ( canvasDim,\n    desktop2Page,\n    makeCanvasGeometry,\n    page2Desktop,\n  )\n--\nimport Prelude hiding (mapM, mapM_)\n\nmodeChange :: UserEvent -> MainCoroutine ()\nmodeChange command = do\n  case command of\n    ToViewAppendMode -> updateXState select2edit >> invalidateAll\n    ToSelectMode -> updateXState edit2select >> invalidateAllInBBox Nothing Efficient\n    _ -> return ()\n  reflectPenModeUI\n  reflectPenColorUI\n  reflectPenWidthUI\n  where\n    select2edit xst =\n      either (noaction xst) (whenselect xst) . hoodleModeStateEither\n        . view (unitHoodles . currentUnit . hoodleModeState)\n        $ xst\n    edit2select xst =\n      either (whenedit xst) (noaction xst) . hoodleModeStateEither\n        . view (unitHoodles . currentUnit . hoodleModeState)\n        $ xst\n    noaction :: HoodleState -> a -> MainCoroutine HoodleState\n    noaction xst = const (return xst)\n    whenselect :: HoodleState -> Hoodle SelectMode -> MainCoroutine HoodleState\n    whenselect xst thdl = do\n      let pages = view gselAll thdl\n          mselect = view gselSelected thdl\n          cid = getCurrentCanvasId (view (unitHoodles . currentUnit) xst)\n      npages <-\n        maybe\n          (return pages)\n          ( \\(spgn, spage) -> do\n              let npage = hPage2RPage spage\n              callRenderer_ $ updatePageBuf cid npage\n              return $ M.adjust (const npage) spgn pages\n          )\n          mselect\n      let nthdl = set gselAll npages . set gselSelected Nothing $ thdl\n      return $ (unitHoodles . currentUnit . hoodleModeState .~ ViewAppendState (gSelect2GHoodle nthdl)) xst\n    whenedit :: HoodleState -> Hoodle EditMode -> MainCoroutine HoodleState\n    whenedit xst hdl =\n      return $ (unitHoodles . currentUnit . hoodleModeState .~ SelectState (gHoodle2GSelect hdl)) xst\n\n-- |\nviewModeChange :: UserEvent -> MainCoroutine ()\nviewModeChange command = do\n  case command of\n    ToSinglePage -> updateUhdl cont2single >> invalidateAll\n    ToContSinglePage -> updateUhdl single2cont >> invalidateAll\n    _ -> return ()\n  adjustScrollbarWithGeometryCurrent\n  where\n    cont2single :: UnitHoodle -> MainCoroutine UnitHoodle\n    cont2single uhdl = unboxBiAct (const (return uhdl)) (cont2SingPage uhdl) . view currentCanvasInfo $ uhdl\n    single2cont :: UnitHoodle -> MainCoroutine UnitHoodle\n    single2cont uhdl = unboxBiAct (sing2ContPage uhdl) (const (return uhdl)) . view currentCanvasInfo $ uhdl\n\ncont2SingPage :: UnitHoodle -> CanvasInfo a -> MainCoroutine UnitHoodle\ncont2SingPage uhdl cinfo = do\n  geometry <- liftIO $ getGeometry4CurrCvs uhdl\n  cdim <- liftIO $ return . canvasDim $ geometry\n  page <- getCurrentPageCurr\n  let zmode = view (viewInfo . zoomMode) cinfo\n      canvas = view drawArea cinfo\n      cpn = PageNum . view currentPageNum $ cinfo\n      pdim = PageDimension (view gdimension page)\n      ViewPortBBox bbox = view (viewInfo . pageArrangement . viewPortBBox) cinfo\n      (x0, y0) = bbox_upperleft bbox\n      (xpos, ypos) = maybe (0, 0) (unPageCoord . snd) $ desktop2Page geometry (DeskCoord (x0, y0))\n  let arr = makeSingleArrangement zmode pdim cdim (xpos, ypos)\n  let nvinfo = ViewInfo (view zoomMode (view viewInfo cinfo)) arr\n      ncinfo =\n        CanvasInfo\n          (view canvasId cinfo)\n          canvas\n          (view mDrawSurface cinfo)\n          (view scrolledWindow cinfo)\n          nvinfo\n          (unPageNum cpn)\n          (view horizAdjustment cinfo)\n          (view vertAdjustment cinfo)\n          (view horizAdjConnId cinfo)\n          (view vertAdjConnId cinfo)\n          (view canvasWidgets cinfo)\n          (view notifiedItem cinfo)\n  return $ (currentCanvasInfo .~ CanvasSinglePage ncinfo) uhdl\n\nsing2ContPage :: UnitHoodle -> CanvasInfo a -> MainCoroutine UnitHoodle\nsing2ContPage uhdl cinfo = do\n  cdim <-\n    liftIO $\n      canvasDim <$> getGeometry4CurrCvs uhdl\n  let zmode = view (viewInfo . zoomMode) cinfo\n      canvas = view drawArea cinfo\n      cpn = PageNum . view currentPageNum $ cinfo\n      (hadj, vadj) = view adjustments cinfo\n  (xpos, ypos) <- liftIO $ (,) <$> Gtk.adjustmentGetValue hadj <*> Gtk.adjustmentGetValue vadj\n  let arr =\n        makeContinuousArrangement\n          zmode\n          cdim\n          (getHoodle uhdl)\n          (cpn, PageCoord (xpos, ypos))\n  geometry <- liftIO $ makeCanvasGeometry cpn arr canvas\n  let DeskCoord (nxpos, nypos) = page2Desktop geometry (cpn, PageCoord (xpos, ypos))\n  let vinfo = view viewInfo cinfo\n      nvinfo = ViewInfo (view zoomMode vinfo) arr\n      ncinfotemp =\n        CanvasInfo\n          (view canvasId cinfo)\n          (view drawArea cinfo)\n          (view mDrawSurface cinfo)\n          (view scrolledWindow cinfo)\n          nvinfo\n          (view currentPageNum cinfo)\n          hadj\n          vadj\n          (view horizAdjConnId cinfo)\n          (view vertAdjConnId cinfo)\n          (view canvasWidgets cinfo)\n          (view notifiedItem cinfo)\n      ncpn = maybe cpn fst $ desktop2Page geometry (DeskCoord (nxpos, nypos))\n      ncinfo = (currentPageNum .~ unPageNum ncpn) ncinfotemp\n  return $ (currentCanvasInfo .~ CanvasContPage ncinfo) uhdl\n'