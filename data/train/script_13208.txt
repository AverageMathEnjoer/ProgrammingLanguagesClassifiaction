b'using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nusing sqlite3_int64 = System.Int64;\nusing System.Text;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2007 August 14\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    *************************************************************************\n    **\n    ** This file contains low-level memory allocation drivers for when\n    ** SQLite will use the standard C-library malloc/realloc/free interface\n    ** to obtain the memory it needs.\n    **\n    ** This file contains implementations of the low-level memory allocation\n    ** routines specified in the sqlite3_mem_methods object.\n    **\n    ** $Id: mem1.c,v 1.30 2009/03/23 04:33:33 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#include "sqliteInt.h"\n\n    /*\n    ** This version of the memory allocator is the default.  It is\n    ** used when no other memory allocator is specified using compile-time\n    ** macros.\n    */\n#if SQLITE_SYSTEM_MALLOC\n\n    /*\n** Like malloc(), but remember the size of the allocation\n** so that we can find it later using sqlite3MemSize().\n**\n** For this low-level routine, we are guaranteed that nByte>0 because\n** cases of nByte<=0 will be intercepted and dealt with by higher level\n** routines.\n*/\n    static byte[] sqlite3MemMalloc( int nByte )\n    {\n      //sqlite3_int64 p;\n      //Debug.Assert(nByte > 0 );\n      //nByte = ROUND8(nByte);\n      //p = malloc( nByte + 8 );\n      //if ( p )\n      //{\n      //  p[0] = nByte;\n      //  p++;\n      //}\n      //return (void*)p;\n      return new byte[nByte];\n    }\n    /*\n    ** Free memory.\n    */\n    // -- overloads ---------------------------------------\n    static void sqlite3MemFree<T>( ref T x ) where T : class\n    { x = null; }\n    static void sqlite3MemFree( ref  string x ) { x = null; }\n    //\n\n    /*\n    ** Like free() but works for allocations obtained from sqlite3MemMalloc()\n    ** or sqlite3MemRealloc().\n    **\n    ** For this low-level routine, we already know that pPrior!=0 since\n    ** cases where pPrior==0 will have been intecepted and dealt with\n    ** by higher-level routines.\n    */\n    //static void sqlite3MemFree(void pPrior){\n    //  sqlite3_int64 p = (sqlite3_int64*)pPrior;\n    //  Debug.Assert(pPrior!=0 );\n    //  p--;\n    //  free(p);\n    //}\n\n    /*\n    ** Like realloc().  Resize an allocation previously obtained from\n    ** sqlite3MemMalloc().\n    **\n    ** For this low-level interface, we know that pPrior!=0.  Cases where\n    ** pPrior==0 while have been intercepted by higher-level routine and\n    ** redirected to xMalloc.  Similarly, we know that nByte>0 becauses\n    ** cases where nByte<=0 will have been intercepted by higher-level\n    ** routines and redirected to xFree.\n    */\n    static byte[] sqlite3MemRealloc( ref byte[] pPrior, int nByte )\n    {\n      //  sqlite3_int64 p = (sqlite3_int64*)pPrior;\n      //  Debug.Assert(pPrior!=0 && nByte>0 );\n      //  nByte = ROUND8( nByte );\n      //  p = (sqlite3_int64*)pPrior;\n      //  p--;\n      //  p = realloc(p, nByte+8 );\n      //  if( p ){\n      //    p[0] = nByte;\n      //    p++;\n      //  }\n      //  return (void*)p;\n      Array.Resize( ref pPrior, nByte );\n      return pPrior;\n    }\n\n    /*\n    ** Report the allocated size of a prior return from xMalloc()\n    ** or xRealloc().\n    */\n    static int sqlite3MemSize( byte[] pPrior )\n    {\n      //  sqlite3_int64 p;\n      //  if( pPrior==0 ) return 0;\n      //  p = (sqlite3_int64*)pPrior;\n      //  p--;\n      //  return p[0];\n      return (int)pPrior.Length;\n    }\n\n    /*\n    ** Round up a request size to the next valid allocation size.\n    */\n    static int sqlite3MemRoundup( int n )\n    {\n      return ROUND8( n );\n    }\n\n    /*\n    ** Initialize this module.\n    */\n    static int sqlite3MemInit( object NotUsed )\n    {\n      UNUSED_PARAMETER( NotUsed );\n      return SQLITE_OK;\n    }\n\n    /*\n    ** Deinitialize this module.\n    */\n    static void sqlite3MemShutdown( object NotUsed )\n    {\n      UNUSED_PARAMETER( NotUsed );\n      return;\n    }\n\n    /*\n    ** This routine is the only routine in this file with external linkage.\n    **\n    ** Populate the low-level memory allocation function pointers in\n    ** sqlite3GlobalConfig.m with pointers to the routines in this file.\n    */\n    static void sqlite3MemSetDefault()\n    {\n      sqlite3_mem_methods defaultMethods = new sqlite3_mem_methods(\n      sqlite3MemMalloc,\n      sqlite3MemFree,\n      sqlite3MemRealloc,\n      sqlite3MemSize,\n      sqlite3MemRoundup,\n      (dxMemInit)sqlite3MemInit,\n      (dxMemShutdown)sqlite3MemShutdown,\n      0\n      );\n      sqlite3_config( SQLITE_CONFIG_MALLOC, defaultMethods );\n    }\n#endif //* SQLITE_SYSTEM_MALLOC */\n  }\n}\n'