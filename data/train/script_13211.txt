b'module Render\n  ( -- * GUI parameters\n    canvasWidth,\n    canvasHeight,\n    timelineMargin,\n\n    -- * conversion function\n    secToPixel,\n    pixelToSec,\n\n    -- * draw functions\n    drawEventMark,\n    drawTimeGrid,\n    drawTimeline,\n    drawHistBar,\n    drawLogcatState,\n\n    -- * flush double buffer\n    flushDoubleBuffer,\n  )\nwhere\n\nimport Control.Concurrent.STM (TVar, atomically, readTVar)\nimport Control.Lens ((^.))\nimport Control.Monad.IO.Class (liftIO)\nimport Data.Fixed (Fixed (MkFixed), Nano)\nimport Data.Foldable (for_)\nimport qualified Data.List as L\nimport qualified Data.Map as Map\nimport Data.Maybe (fromMaybe)\nimport Data.Sequence (Seq)\nimport GHC.RTS.Events (Event (..))\nimport qualified GI.Cairo.Render as R\nimport Types\n  ( HasLogcatState (..),\n    HasViewState (..),\n    LogcatState,\n    ViewState,\n  )\nimport Util.Event (eventInfoEnumMap, eventInfoToString)\n\ncanvasWidth :: Double\ncanvasWidth = 1440\n\ncanvasHeight :: Double\ncanvasHeight = 768\n\ntimelineMargin :: Double\ntimelineMargin = 300\n\ntimelineScale :: Double\ntimelineScale = 50\n\nsecToPixel :: Nano -> Nano -> Double\nsecToPixel origin sec =\n  realToFrac (sec - origin) * timelineScale + 10.0\n\npixelToSec :: Nano -> Double -> Nano\npixelToSec origin px =\n  realToFrac ((px - 10.0) / timelineScale) + origin\n\ndrawEventMark :: ViewState -> Event -> R.Render ()\ndrawEventMark vs ev = do\n  let origin = vs ^. viewTimeOrigin\n      sec = MkFixed (fromIntegral (evTime ev)) :: Nano\n      x = secToPixel origin sec\n      evname = eventInfoToString (evSpec ev)\n      tag = fromMaybe 0 (L.lookup evname eventInfoEnumMap)\n      y = fromIntegral tag * 3.0\n  R.moveTo x y\n  R.lineTo x (y + 2)\n  R.stroke\n\ndrawTimeGrid :: ViewState -> R.Render ()\ndrawTimeGrid vs = do\n  let origin = vs ^. viewTimeOrigin\n      tmax = pixelToSec origin canvasWidth\n      ts = [0, 1 .. tmax]\n      lblTs = [0, 10 .. tmax]\n  R.setSourceRGBA 0 0 1 0.5\n  R.setLineWidth 0.1\n  R.setLineCap R.LineCapRound\n  R.setLineJoin R.LineJoinRound\n  for_ ts $ \\t -> do\n    let x = secToPixel origin t\n    R.moveTo x 0\n    R.lineTo x 150\n    R.stroke\n  R.setSourceRGBA 0 0 1 0.8\n  R.setFontSize 8\n  for_ lblTs $ \\t -> do\n    R.moveTo (secToPixel origin t) 10\n    R.textPath (show (floor t :: Int) <> " s")\n    R.stroke\n\ndrawTimeline :: ViewState -> Seq Event -> R.Render ()\ndrawTimeline vs evs = do\n  drawTimeGrid vs\n  R.setSourceRGBA 0.16 0.18 0.19 1.0\n  R.setLineWidth 0.3\n  R.setLineCap R.LineCapRound\n  R.setLineJoin R.LineJoinRound\n  for_ evs $ \\ev ->\n    drawEventMark vs ev\n\ndrawHistBar :: (Double, Double) -> (String, Int) -> R.Render ()\ndrawHistBar (xoffset, yoffset) (ev, value) = do\n  let tag = fromMaybe 0 (L.lookup ev eventInfoEnumMap)\n  R.setSourceRGBA 0.16 0.18 0.19 1.0\n  R.setLineWidth 1.0\n  let y = yoffset + 10.0 * fromIntegral tag\n      w = fromIntegral value / 100.0\n  R.moveTo xoffset (y + 10.0)\n  R.setFontSize 8.0\n  R.textPath ev\n  R.fill\n  R.rectangle (xoffset + 100) (y + 2) w 8\n  R.fill\n  R.moveTo (xoffset + 104 + w) (y + 10.0)\n  R.textPath (show value)\n  R.fill\n\ndrawLogcatState :: TVar LogcatState -> R.Render ()\ndrawLogcatState sref = do\n  R.setSourceRGB 1 1 1\n  R.rectangle 0 0 canvasWidth canvasHeight\n  R.fill\n  s <- liftIO $ atomically $ readTVar sref\n  let evs = s ^. logcatEventStore\n      hist = s ^. logcatEventHisto\n      vs = s ^. logcatViewState\n  let xoffset = 10\n      yoffset = 100\n  drawTimeline vs evs\n  R.setSourceRGBA 0 0 1 0.8\n  R.setLineWidth 1\n  R.moveTo 0 150\n  R.lineTo canvasWidth 150\n  R.stroke\n  for_ (Map.toAscList hist) $ \\(ev, value) ->\n    drawHistBar (xoffset, yoffset) (ev, value)\n\nflushDoubleBuffer :: R.Surface -> R.Render ()\nflushDoubleBuffer sfc = do\n  R.setSourceSurface sfc 0 0\n  R.setOperator R.OperatorSource\n  R.paint\n'