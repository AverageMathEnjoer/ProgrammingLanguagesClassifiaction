b'// Copyright (c) 2022 Manuel Schneider\n\n#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include "albert/util/standarditem.h"\n#include "doctest/doctest.h"\n#include "itemindex.h"\n#include "levenshtein.h"\n#include "albert/extensions/indexqueryhandler.h"\n#include <QString>\n#include <chrono>\n#include <iostream>\nusing namespace albert;\nusing namespace std;\nusing namespace std::chrono;\n\n#include <ctime>\n#include <unistd.h>\n\nstd::string gen_random(const int len) {\n    static const char alphanum[] =\n            "0123456789"\n            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\n            "abcdefghijklmnopqrstuvwxyz";\n    std::string tmp_s;\n    tmp_s.reserve(len);\n\n    for (int i = 0; i < len; ++i) {\n        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];\n    }\n\n    return tmp_s;\n}\n\nvoid levenshtein_compare_benchmarks_and_check_results(const vector<QString> &strings, uint k){\n    Levenshtein l;\n    vector<bool> results_old;\n    vector<bool> results_new;\n\n    results_old.reserve(strings.size());\n    auto start = system_clock::now();\n    auto i = strings.cbegin();\n    auto j = strings.crbegin();\n    for (; i != strings.cend(); ++i, ++j)\n        results_old.push_back(l.checkPrefixEditDistance_Legacy(*i, *j, k));\n    long duration_old = duration_cast<microseconds>(system_clock::now()-start).count();\n\n    results_new.reserve(strings.size());\n    start = system_clock::now();\n    i = strings.cbegin();\n    j = strings.crbegin();\n    for (; i != strings.cend(); ++i, ++j)\n        results_new.push_back(l.computePrefixEditDistanceWithLimit(*i, *j, k) <= k);\n    long duration_new = duration_cast<microseconds>(system_clock::now()-start).count();\n\n    cout << "Levensthein old: " << setw(12)<<duration_old << " \xc2\xb5s. New: "<< setw(12) << duration_new\n         << " \xc2\xb5s. Ratio: " << duration_new/(float)duration_old <<endl;\n    CHECK(results_old == results_new);\n}\n\nTEST_CASE("Benchmark new levenshtein")\n{\n//    int test_count = 100000;\n//\n//    srand((unsigned)time(NULL) * getpid());\n//\n//    vector<QString> strings(test_count);\n//    auto lens = {4,8,16,24};\n//    auto divisor=4;\n//    cout << "Randoms"<<endl;\n//    for (int len : lens){\n//        int k = floor(len/divisor);\n//        cout << "len: "<< setw(2)<<len<<". k: "<<k<<" ";\n//        for (auto &string : strings)\n//            string = QString::fromStdString(gen_random(len));\n//        levenshtein_compare_benchmarks_and_check_results(strings, k);\n//    }\n//\n//    cout << "Equals"<<endl;\n//    for (int len : lens) {\n//        int k = floor(len/divisor);\n//        cout << "len: "<< setw(2)<<len<<". k: "<<k<<" ";\n//        for (auto &string : strings)\n//            string = QString(len, \'a\');\n//        levenshtein_compare_benchmarks_and_check_results(strings, k);\n//    }\n//\n//    cout << "Halfhalf equal random"<<endl;\n//    for (int len : lens) {\n//        int k = floor(len/divisor);\n//        cout << "len: "<< setw(2)<<len<<". k: "<<k<<" ";\n//        for (auto &string : strings)\n//            string = QString("%1%2").arg(QString(len/2, \'a\'), QString::fromStdString(gen_random(len/2)));\n//        levenshtein_compare_benchmarks_and_check_results(strings, k);\n//    }\n}\n\n\nTEST_CASE("Levenshtein")\n{\n    Levenshtein l;\n\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefg", "ab_efghij", 0) == 1);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefg", "ab_efghij", 2) == 2);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefg", "ab_efgh", 2) == 2);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcde__h", "abcdefghij", 1) == 2);\n\n    // plain\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "test", 0) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "test", 1) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "test", 2) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "test_", 0) == 0);\n\n    //fuzzy substitution\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "_est____", 1) == 1);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "__st____", 1) == 2);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "_est____", 2) == 1);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "__st____", 2) == 2);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "___t____", 2) == 3);\n\n    //fuzzy deletion\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "ttest____", 1) == 1);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "tttest____", 1) == 2);\n\n    //fuzzy insertion\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "est____", 1) == 1);\n    CHECK(l.computePrefixEditDistanceWithLimit("test", "st____", 1) > 1);\n\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 1) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 2) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 3) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 4) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 5) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 6) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 7) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abcdefghij", "abcdefghij", 8) == 0);\n\n    // Bug 2022-11-20 string is smaller than prefix\n    CHECK(l.computePrefixEditDistanceWithLimit("abc", "abc", 1) == 0);\n    CHECK(l.computePrefixEditDistanceWithLimit("abc", "ab", 1) == 1);\n    CHECK(l.computePrefixEditDistanceWithLimit("abc", "a", 1) == 2);\n    CHECK(l.computePrefixEditDistanceWithLimit("abc", "", 1) == 2);\n}\n\nTEST_CASE("Index")\n{\n    auto match = [&](const QStringList& item_strings, const QString& search_string, bool case_sesitivity, int q, int fuzzy){\n\n        auto index = ItemIndex("[ ]+", case_sesitivity, q, fuzzy);\n        vector<IndexItem> index_items;\n        for (auto &string : item_strings)\n            index_items.emplace_back(make_shared<StandardItem>(string), string);\n        index.setItems(::move(index_items));\n        return index.search(search_string, true);\n    };\n\n    // case sensitivity\n    CHECK(match({"a","A"}, "a", true, 0, 0).size() == 1);\n    CHECK(match({"a","A"}, "A", true, 0, 0).size() == 1);\n\n    // intersection\n    CHECK(match({"a b","b c","c d"}, "a", false, 0, 0).size() == 1);\n    CHECK(match({"a b","b c","c d"}, "b", false, 0, 0).size() == 2);\n    CHECK(match({"a b","b c","c d"}, "c", false, 0, 0).size() == 2);\n    CHECK(match({"a b","b c","c d"}, "d", false, 0, 0).size() == 1);\n    CHECK(match({"a b","b c","c d"}, "b c", false, 0, 0).size() == 1);\n\n    // sequence\n    CHECK(match({"a b","b a","a b"}, "a b", false, 0, 0).size() == 2);\n    CHECK(match({"a b","b a","a b"}, "b a", false, 0, 0).size() == 1);\n\n    // fuzzy\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abc", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "ab_", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "a__", false, 2, 3).size() == 0);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcdef", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abc_e_", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "a_c_e_", false, 2, 3).size() == 0);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcdefghi", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcdefg_i", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcde_g_i", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abc_e_g_i", false, 2, 3).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "a_c_e_g_i", false, 2, 3).size() == 0);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcd", false, 2, 4).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abc_", false, 2, 4).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "ab__", false, 2, 4).size() == 0);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcdefgh", false, 2, 4).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcdefg_", false, 2, 4).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abcde_g_", false, 2, 4).size() == 1);\n    CHECK(match({"abcdefghijklmnopqrstuvwxyz"}, "abc_e_g_", false, 2, 4).size() == 0);\n\n    // score\n    CHECK(match({"a","ab","abc"}, "a", false, 2, 3).size() == 3);\n    CHECK(match({"a","ab","abc"}, "a", false, 2, 3)[0].score == (Score)(1.0/3.0*MAX_SCORE));\n    CHECK(match({"a","ab","abc"}, "a", false, 2, 3)[1].score == (Score)(1.0/2.0*MAX_SCORE));\n    CHECK(match({"a","ab","abc"}, "a", false, 2, 3)[2].score == (Score)(1.0*MAX_SCORE));\n\n    CHECK(match({"abc","abd"}, "abe", false, 2, 3)[0].score == (Score)(2.0/3.0*MAX_SCORE));\n    CHECK(match({"abc","abd"}, "abe", false, 2, 3)[1].score == (Score)(2.0/3.0*MAX_SCORE));\n\n    std::vector<albert::RankItem> M = match({"abc","abd","abcdef"}, "abc", false, 2, 3);\n    sort(M.begin(), M.end(), [](auto &a, auto &b){ return a.item->id() < b.item->id(); });\n    CHECK(M[0].score == (Score)(3.0/3.0*MAX_SCORE));\n    CHECK(M[1].score == (Score)(3.0/6.0*MAX_SCORE));\n    CHECK(M[2].score == (Score)(2.0/3.0*MAX_SCORE));\n}'