b'\xef\xbb\xbf// \xe5\x85\xab\xe6\x95\xb0\xe7\xa0\x81\xef\xbc\x8c\xe4\xbd\xbf\xe7\x94\xa8STL\xe9\x9b\x86\xe5\x90\x88\xef\xbc\x88\xe6\x9c\x80\xe5\xa5\xbd\xe5\x86\x99\xef\xbc\x89\n// Rujia Liu\n#include<cstdio>\n#include<cstring>\n#include<set>\nusing namespace std;\n\ntypedef int State[9];\nconst int MAXSTATE = 1000000;\nState st[MAXSTATE], goal;\nint dist[MAXSTATE];\n\nset<int> vis;\nvoid init_lookup_table() { vis.clear(); }\nint try_to_insert(int s) {\n  int v = 0;\n  for(int i = 0; i < 9; i++) v = v * 10 + st[s][i];\n  if(vis.count(v)) return 0;\n  vis.insert(v);\n  return 1;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nint bfs() {\n  init_lookup_table();\n  int front = 1, rear = 2;\n  while(front < rear) {\n    State& s = st[front];\n    if(memcmp(goal, s, sizeof(s)) == 0) return front;\n    int z;\n    for(z = 0; z < 9; z++) if(!s[z]) break;\n    int x = z/3, y = z%3;\n    for(int d = 0; d < 4; d++) {\n      int newx = x + dx[d];\n      int newy = y + dy[d];\n      int newz = newx * 3 + newy;\n      if(newx >= 0 && newx < 3 && newy >= 0 && newy < 3) {\n        State& t = st[rear];\n        memcpy(&t, &s, sizeof(s));\n        t[newz] = s[z];\n        t[z] = s[newz];\n        dist[rear] = dist[front] + 1;\n        if(try_to_insert(rear)) rear++;\n      }\n    }\n    front++;\n  }\n  return 0;\n}\n\nint main() {\n  for(int i = 0; i < 9; i++)\n    scanf("%d", &st[1][i]);\n  for(int i = 0; i < 9; i++)\n    scanf("%d", &goal[i]);\n  int ans = bfs();\n  if(ans > 0) printf("%d\\n", dist[ans]);\n  else printf("-1\\n");\n  return 0;\n}\n'