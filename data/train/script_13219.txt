b"import Data.List\nimport Data.List.Ordered\nimport Data.Array\nimport System.Random\n\nxs = [7, 3, 1, 9, 5]\nys = [40, 20, 30, 60, 50]\n\nsortsums :: Ord a => Num a => [a] -> [a] -> [a]\nsortsums xs ys = map fst (sortsubs xs (map negate ys))\n\nsortsubs :: Ord a => Num a => [a] -> [a] -> [(a, (Int, Int))]\nsortsubs xs ys = sortBy (cmp (mkArray xs ys)) (subs xs ys)\n\ncmp a (_, (i, j)) (_, (k, l)) = compare (a ! (1, i, k)) (a ! (2, j, l))\n\nsubs :: Num a => [a] -> [a] -> [(a, (Int, Int))]\nsubs xs ys = [ (x - y, (i, j)) | (x, i) <- zip xs [1..], (y, j) <- zip ys [1..]]\n\ntable :: Ord a => Num a => [a] -> [a] -> [(Int, Int, Int)]\ntable xs ys = map snd (map (tag 1) xxs `merge` map (tag 2) yys) \n              where xxs = sortsubs' xs\n                    yys = sortsubs' ys\n\ntag :: Int -> (a, (Int, Int)) -> (a, (Int, Int, Int))\ntag i (x,(j,k)) = (x,(i,j,k))\n\nmkArray :: Ord a => Num a => [a] -> [a] -> Array (Int, Int, Int) Integer\nmkArray xs ys = array b (zip (table xs ys) [1..])\n                where b = ((1, 1, 1), (2, p, p))\n                      p = max (length xs) (length ys)\n\nsortsubs' :: Ord a => Num a => [a] -> [(a, (Int, Int))]\nsortsubs' []    = []\nsortsubs' [w]   = [(w - w, (1, 1))]\nsortsubs' ws = foldr1 (merge) [xxs, map (incr m) xys, map (incl m) yxs, map (incb m) yys]\n    where xxs               = sortsubs' xs\n          xys               = sortBy (cmp (mkArray xs ys )) (subs xs ys ) \n          yxs               = map switch (reverse xys )\n          yys               = sortsubs' ys\n          (xs, ys)          = splitAt m ws\n          m                 = (length ws) `div` 2\n          incl m (x,(i,j))  = (x, (m + i, j)) \n          incr m (x,(i,j))  = (x, (i, m + j))\n          incb m (x,(i,j))  = (x, (m + i, m + j))\n          switch (x,(i,j))  = (negate x, (j, i))\n\nmain = putStrLn $ show $ sortsums xs ys \n\n"