b'#include <stdio.h>\n#include "pico/stdlib.h"\n#include "hardware/i2c.h"\n#ifndef PICO_DEFAULT_LED_PIN // PICO w with WiFi\n#include "pico/cyw43_arch.h"\n#endif\n#include "MPU6050.h"\n\nMPU6050 accelgyro;\n\nconst int iAx = 0;\nconst int iAy = 1;\nconst int iAz = 2;\nconst int iGx = 3;\nconst int iGy = 4;\nconst int iGz = 5;\n\nconst int usDelay = 3150;   // empirical, to hold sampling to 200 Hz\nconst int NFast =  1000;    // the bigger, the better (but slower)\nconst int NSlow = 10000;    // ..\n      int LowValue[6];\n      int HighValue[6];\n      int Smoothed[6];\n      int LowOffset[6];\n      int HighOffset[6];\n      int Target[6];\n      int N;\n\nvoid GetSmoothed(){ int16_t RawValue[6];\n    int i;\n    long Sums[6];\n    for (i = iAx; i <= iGz; i++)\n      { Sums[i] = 0; }\n\n    for (i = 1; i <= N; i++)\n      { // get sums\n        accelgyro.getMotion6(&RawValue[iAx], &RawValue[iAy], &RawValue[iAz], \n                             &RawValue[iGx], &RawValue[iGy], &RawValue[iGz]);\n        if ((i % 500) == 0)\n          printf(".");\n        sleep_us(usDelay);\n        for (int j = iAx; j <= iGz; j++)\n          Sums[j] = Sums[j] + RawValue[j];\n      } // get sums\n    for (i = iAx; i <= iGz; i++)\n      { Smoothed[i] = (Sums[i] + N/2) / N ; }\n} // GetSmoothed\n\nvoid Initialize(){\n    printf("Initializing I2C devices...\\n");\n    accelgyro.initialize();\n\n    // verify connection\n    printf("Testing device connections...\\n");\n    if(accelgyro.testConnection()) printf("MPU6050 connection successful\\n");\n    else {printf("MPU6050 connection failed\\n");}\n    printf("\\nPID tuning Each Dot = 100 readings");\n  /*A tidbit on how PID (PI actually) tuning works. \n    When we change the offset in the MPU6050 we can get instant results. This allows us to use Proportional and \n    integral of the PID to discover the ideal offsets. Integral is the key to discovering these offsets, Integral \n    uses the error from set-point (set-point is zero), it takes a fraction of this error (error * ki) and adds it \n    to the integral value. Each reading narrows the error down to the desired offset. The greater the error from \n    set-point, the more we adjust the integral value. The proportional does its part by hiding the noise from the \n    integral math. The Derivative is not used because of the noise and because the sensor is stationary. With the \n    noise removed the integral value lands on a solid offset after just 600 readings. At the end of each set of 100 \n    readings, the integral value is used for the actual offsets and the last proportional reading is ignored due to \n    the fact it reacts to any noise.\n  */\n        accelgyro.CalibrateAccel(6);\n        accelgyro.CalibrateGyro(6);\n        printf("\\nat 600 Readings");\n        accelgyro.PrintActiveOffsets();\n        printf("\\n");\n        accelgyro.CalibrateAccel(1);\n        accelgyro.CalibrateGyro(1);\n        printf("700 Total Readings");\n        accelgyro.PrintActiveOffsets();\n        printf("\\n");\n        accelgyro.CalibrateAccel(1);\n        accelgyro.CalibrateGyro(1);\n        printf("800 Total Readings");\n        accelgyro.PrintActiveOffsets();\n        printf("\\n");\n        accelgyro.CalibrateAccel(1);\n        accelgyro.CalibrateGyro(1);\n        printf("900 Total Readings");\n        accelgyro.PrintActiveOffsets();\n        printf("\\n");    \n        accelgyro.CalibrateAccel(1);\n        accelgyro.CalibrateGyro(1);\n        printf("1000 Total Readings");\n        accelgyro.PrintActiveOffsets();\n     printf("\\n\\nAny of the above offsets will work nice\\nLets proof the PID tuning using another method:"); \n} // Initialize\n\nvoid SetOffsets(int TheOffsets[6]){\n    accelgyro.setXAccelOffset(TheOffsets[iAx]);\n    accelgyro.setYAccelOffset(TheOffsets[iAy]);\n    accelgyro.setZAccelOffset(TheOffsets[iAz]);\n    accelgyro.setXGyroOffset(TheOffsets[iGx]);\n    accelgyro.setYGyroOffset(TheOffsets[iGy]);\n    accelgyro.setZGyroOffset(TheOffsets[iGz]);\n} // SetOffsets\n\n// The following may show up as a mess in the terminal unless it is on fullscreen\nvoid ShowProgress(){\n    printf("\\nXAccel\\t\\t\\tYAccel\\t\\t\\tZAccel\\t\\t\\tXGyro\\t\\t\\tYGyro\\t\\t\\tZGyro\\n");\n    for (int i = iAx; i <= iGz; i++){\n        printf("[%d,%d] --> [%d,%d]\\t", LowOffset[i], HighOffset[i], LowValue[i], HighValue[i]);\n    }\n    printf("\\n");\n} // ShowProgress\n\nvoid SetAveraging(int NewN){\n    N = NewN;\n    printf("\\nAveraging %d readings each time\\n", N);\n} // SetAveraging\n\nvoid PullBracketsIn(){\n    bool AllBracketsNarrow;\n    bool StillWorking;\n    int NewOffset[6];\n  \n    printf("\\nClosing in:\\n");\n    AllBracketsNarrow = false;\n    StillWorking = true;\n    while (StillWorking) \n      { StillWorking = false;\n        if (AllBracketsNarrow && (N == NFast))\n          { SetAveraging(NSlow); }\n        else\n          { AllBracketsNarrow = true; }// tentative\n        for (int i = iAx; i <= iGz; i++)\n          { if (HighOffset[i] <= (LowOffset[i]+1))\n              { NewOffset[i] = LowOffset[i]; }\n            else\n              { // binary search\n                StillWorking = true;\n                NewOffset[i] = (LowOffset[i] + HighOffset[i]) / 2;\n                if (HighOffset[i] > (LowOffset[i] + 10))\n                  { AllBracketsNarrow = false; }\n              } // binary search\n          }\n        SetOffsets(NewOffset);\n        GetSmoothed();\n        for (int i = iAx; i <= iGz; i++)\n          { // closing in\n            if (Smoothed[i] > Target[i])\n              { // use lower half\n                HighOffset[i] = NewOffset[i];\n                HighValue[i] = Smoothed[i];\n              } // use lower half\n            else\n              { // use upper half\n                LowOffset[i] = NewOffset[i];\n                LowValue[i] = Smoothed[i];\n              } // use upper half\n          } // closing in\n        ShowProgress();\n      } // still working\n   \n} // PullBracketsIn\n\nvoid PullBracketsOut(){\n    bool Done = false;\n    int NextLowOffset[6];\n    int NextHighOffset[6];\n\n    printf("\\nExpanding:\\n");\n \n    while (!Done)\n      { Done = true;\n        SetOffsets(LowOffset);\n        GetSmoothed();\n        for (int i = iAx; i <= iGz; i++)\n          { // got low values\n            LowValue[i] = Smoothed[i];\n            if (LowValue[i] >= Target[i])\n              { Done = false;\n                NextLowOffset[i] = LowOffset[i] - 1000;\n              }\n            else\n              { NextLowOffset[i] = LowOffset[i]; }\n          } // got low values\n      \n        SetOffsets(HighOffset);\n        GetSmoothed();\n        for (int i = iAx; i <= iGz; i++)\n          { // got high values\n            HighValue[i] = Smoothed[i];\n            if (HighValue[i] <= Target[i])\n              { Done = false;\n                NextHighOffset[i] = HighOffset[i] + 1000;\n              }\n            else\n              { NextHighOffset[i] = HighOffset[i]; }\n          } // got high values\n        ShowProgress();\n        for (int i = iAx; i <= iGz; i++)\n          { LowOffset[i] = NextLowOffset[i];   // had to wait until ShowProgress done\n            HighOffset[i] = NextHighOffset[i]; // ..\n          }\n     } // keep going\n} // PullBracketsOut\n\nvoid initLED() {\n#ifndef PICO_DEFAULT_LED_PIN // PICO w with WiFi\n    printf ("we have board with wifi (pico w) \\n");\n    if (cyw43_arch_init()) {\n        printf("WiFi init failed");\n        exit(3);\n    }\n#else\n    printf ("we have board without wifi\\n");\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n#endif // PICO_DEFAULT_LED_PIN\n\n} // initLED()\n\nvoid  waitForUsbConnect() {\n#ifdef _PICO_STDIO_USB_H // We are using PICO_STDIO_USB. Have to wait for connection.\n    \n#ifndef PICO_DEFAULT_LED_PIN\n    while (!stdio_usb_connected()) { // blink the pico\'s led until usb connection is established\n        cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 0);\n        sleep_ms(250);\n        cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 1);\n        sleep_ms(250);\n    }\n#else\n    while (!stdio_usb_connected()) { // blink the pico\'s led until usb connection is established\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        sleep_ms(250);\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n        sleep_ms(250);\n    }\n#endif // PICO_DEFAULT_LED_PIN\n#endif // _PICO_STDIO_USB_H\n} //  waitForUsbConnect\n\nint main()\n{\n    stdio_init_all();\n\n    // I2C Initialisation. Using it at 400Khz.\n    i2c_init(i2c_default, 400*1000);\n    \n    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);\n    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);\n    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);\n    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);\n\n    // setup blink led\n    initLED();\n    waitForUsbConnect();\n\n    Initialize();\n    for (int i = iAx; i <= iGz; i++)\n      { // set targets and initial guesses\n        Target[i] = 0; // must fix for ZAccel \n        HighOffset[i] = 0;\n        LowOffset[i] = 0;\n      } // set targets and initial guesses\n    Target[iAz] = 16384;\n    SetAveraging(NFast);\n    \n    PullBracketsOut();\n    PullBracketsIn();\n    \n    printf("\\n\\n-------------- done --------------");\n\n    return 0;\n}\n'