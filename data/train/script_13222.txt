b'/*\n    SPDX-FileCopyrightText: 2014-2017 Milian Wolff <mail@milianw.de>\n\n    SPDX-License-Identifier: LGPL-2.1-or-later\n*/\n\n#include "libheaptrack.h"\n#include "util/config.h"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <dlfcn.h>\n#include <unistd.h>\n\n#include <atomic>\n#include <type_traits>\n\nusing namespace std;\n\n#if defined(_ISOC11_SOURCE)\n#define HAVE_ALIGNED_ALLOC 1\n#else\n#define HAVE_ALIGNED_ALLOC 0\n#endif\n\n// NOTE: adding noexcept to C functions is a hard error in clang++\n//       (but not even a warning in GCC, even with -Wall)\n#if defined(__GNUC__) && !defined(__clang__)\n#define LIBC_FUN_ATTRS noexcept\n#else\n#define LIBC_FUN_ATTRS\n#endif\n\nextern "C" {\n\n// Foward declare mimalloc (https://github.com/microsoft/mimalloc) functions so we don\'t need to include its .h.\nvoid* mi_malloc(size_t size) LIBC_FUN_ATTRS;\nvoid* mi_calloc(size_t count, size_t size) LIBC_FUN_ATTRS;\nvoid* mi_realloc(void* p, size_t newsize) LIBC_FUN_ATTRS;\nvoid  mi_free(void* p) LIBC_FUN_ATTRS;\n\n}\n\nnamespace {\n\nnamespace hooks {\n\nenum class HookType\n{\n    Required,\n    Optional\n};\n\ntemplate <typename Signature, typename Base, HookType Type>\nstruct hook\n{\n    Signature original = nullptr;\n\n    void init() noexcept\n    {\n        auto ret = dlsym(RTLD_NEXT, Base::identifier);\n        if (!ret && Type == HookType::Optional) {\n            return;\n        }\n        if (!ret) {\n            fprintf(stderr, "Could not find original function %s\\n", Base::identifier);\n            abort();\n        }\n        original = reinterpret_cast<Signature>(ret);\n    }\n\n    template <typename... Args>\n    auto operator()(Args... args) const noexcept -> decltype(original(args...))\n    {\n        return original(args...);\n    }\n\n    explicit operator bool() const noexcept\n    {\n        return original;\n    }\n};\n\n#define HOOK(name, type)                                                                                               \\\n    struct name##_t : public hook<decltype(&::name), name##_t, type>                                                   \\\n    {                                                                                                                  \\\n        static constexpr const char* identifier = #name;                                                               \\\n    } name\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored "-Wignored-attributes"\n\nHOOK(malloc, HookType::Required);\nHOOK(free, HookType::Required);\nHOOK(calloc, HookType::Required);\n#if HAVE_CFREE\nHOOK(cfree, HookType::Optional);\n#endif\nHOOK(realloc, HookType::Required);\nHOOK(posix_memalign, HookType::Optional);\n#if HAVE_VALLOC\nHOOK(valloc, HookType::Optional);\n#endif\n#if HAVE_ALIGNED_ALLOC\nHOOK(aligned_alloc, HookType::Optional);\n#endif\nHOOK(dlopen, HookType::Required);\nHOOK(dlclose, HookType::Required);\n\n// mimalloc functions\nHOOK(mi_malloc, HookType::Optional);\nHOOK(mi_calloc, HookType::Optional);\nHOOK(mi_realloc, HookType::Optional);\nHOOK(mi_free, HookType::Optional);\n\n#pragma GCC diagnostic pop\n#undef HOOK\n\n/**\n * Dummy implementation, since the call to dlsym from findReal triggers a call\n * to calloc.\n *\n * This is only called at startup and will eventually be replaced by the\n * "proper" calloc implementation.\n */\nstruct DummyPool\n{\n    static const constexpr size_t MAX_SIZE = 1024;\n    char buf[MAX_SIZE] = {0};\n    size_t offset = 0;\n\n    bool isDummyAllocation(void* ptr) noexcept\n    {\n        return ptr >= buf && ptr < buf + MAX_SIZE;\n    }\n\n    void* alloc(size_t num, size_t size) noexcept\n    {\n        size_t oldOffset = offset;\n        offset += num * size;\n        if (offset >= MAX_SIZE) {\n            fprintf(stderr,\n                    "failed to initialize, dummy calloc buf size exhausted: "\n                    "%zu requested, %zu available\\n",\n                    offset, MAX_SIZE);\n            abort();\n        }\n        return buf + oldOffset;\n    }\n};\n\nDummyPool& dummyPool()\n{\n    static DummyPool pool;\n    return pool;\n}\n\nvoid* dummy_calloc(size_t num, size_t size) noexcept\n{\n    return dummyPool().alloc(num, size);\n}\n\nvoid init()\n{\n    // heaptrack_init itself calls calloc via std::mutex/_libpthread_init on FreeBSD\n    hooks::calloc.original = &dummy_calloc;\n    hooks::calloc.init();\n    heaptrack_init(getenv("DUMP_HEAPTRACK_OUTPUT"),\n                   [] {\n                       hooks::dlopen.init();\n                       hooks::dlclose.init();\n                       hooks::malloc.init();\n                       hooks::free.init();\n                       hooks::calloc.init();\n#if HAVE_CFREE\n                       hooks::cfree.init();\n#endif\n                       hooks::realloc.init();\n                       hooks::posix_memalign.init();\n#if HAVE_VALLOC\n                       hooks::valloc.init();\n#endif\n#if HAVE_ALIGNED_ALLOC\n                       hooks::aligned_alloc.init();\n#endif\n\n                       // mimalloc functions\n                       hooks::mi_malloc.init();\n                       hooks::mi_calloc.init();\n                       hooks::mi_realloc.init();\n                       hooks::mi_free.init();\n\n                       // cleanup environment to prevent tracing of child apps\n                       unsetenv("LD_PRELOAD");\n                       unsetenv("DUMP_HEAPTRACK_OUTPUT");\n                   },\n                   nullptr, nullptr);\n}\n}\n}\n\nextern "C" {\n\n/// TODO: memalign, pvalloc, ...?\n\nvoid* malloc(size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::malloc) {\n        hooks::init();\n    }\n\n    void* ptr = hooks::malloc(size);\n    heaptrack_malloc(ptr, size);\n    return ptr;\n}\n\nvoid free(void* ptr) LIBC_FUN_ATTRS\n{\n    if (!hooks::free) {\n        hooks::init();\n    }\n\n    if (hooks::dummyPool().isDummyAllocation(ptr)) {\n        return;\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    heaptrack_free(ptr);\n\n    hooks::free(ptr);\n}\n\nvoid* realloc(void* ptr, size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::realloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::realloc(ptr, size);\n\n    if (ret) {\n        heaptrack_realloc(ptr, size, ret);\n    }\n\n    return ret;\n}\n\nvoid* calloc(size_t num, size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::calloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::calloc(num, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, num * size);\n    }\n\n    return ret;\n}\n\n#if HAVE_CFREE\nvoid cfree(void* ptr) LIBC_FUN_ATTRS\n{\n    if (!hooks::cfree) {\n        hooks::init();\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    if (ptr) {\n        heaptrack_free(ptr);\n    }\n\n    hooks::cfree(ptr);\n}\n#endif\n\nint posix_memalign(void** memptr, size_t alignment, size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::posix_memalign) {\n        hooks::init();\n    }\n\n    int ret = hooks::posix_memalign(memptr, alignment, size);\n\n    if (!ret) {\n        heaptrack_malloc(*memptr, size);\n    }\n\n    return ret;\n}\n\n#if HAVE_ALIGNED_ALLOC\nvoid* aligned_alloc(size_t alignment, size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::aligned_alloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::aligned_alloc(alignment, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, size);\n    }\n\n    return ret;\n}\n#endif\n\n#if HAVE_VALLOC\nvoid* valloc(size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::valloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::valloc(size);\n\n    if (ret) {\n        heaptrack_malloc(ret, size);\n    }\n\n    return ret;\n}\n#endif\n\nvoid* dlopen(const char* filename, int flag) LIBC_FUN_ATTRS\n{\n    if (!hooks::dlopen) {\n        hooks::init();\n    }\n\n#ifdef RTLD_DEEPBIND\n    if (filename && flag & RTLD_DEEPBIND) {\n        heaptrack_warning([](FILE* out) {\n            fprintf(out,\n                    "Detected dlopen call with RTLD_DEEPBIND which breaks function call interception. "\n                    "Heaptrack will drop this flag. If your application relies on it, try to run `heaptrack "\n                    "--use-inject` instead.");\n        });\n        flag &= ~RTLD_DEEPBIND;\n    }\n#endif\n\n    void* ret = hooks::dlopen(filename, flag);\n\n    if (ret) {\n        heaptrack_invalidate_module_cache();\n    }\n\n    return ret;\n}\n\nint dlclose(void* handle) LIBC_FUN_ATTRS\n{\n    if (!hooks::dlclose) {\n        hooks::init();\n    }\n\n    int ret = hooks::dlclose(handle);\n\n    if (!ret) {\n        heaptrack_invalidate_module_cache();\n    }\n\n    return ret;\n}\n\n// mimalloc functions, implementations just copied from above and names changed\nvoid* mi_malloc(size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::mi_malloc) {\n        hooks::init();\n    }\n\n    void* ptr = hooks::mi_malloc(size);\n    heaptrack_malloc(ptr, size);\n    return ptr;\n}\n\nvoid* mi_realloc(void* ptr, size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::mi_realloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::mi_realloc(ptr, size);\n\n    if (ret) {\n        heaptrack_realloc(ptr, size, ret);\n    }\n\n    return ret;\n}\n\nvoid* mi_calloc(size_t num, size_t size) LIBC_FUN_ATTRS\n{\n    if (!hooks::mi_calloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::mi_calloc(num, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, num * size);\n    }\n\n    return ret;\n}\n\nvoid mi_free(void* ptr) LIBC_FUN_ATTRS\n{\n    if (!hooks::mi_free) {\n        hooks::init();\n    }\n\n    if (hooks::dummyPool().isDummyAllocation(ptr)) {\n        return;\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    heaptrack_free(ptr);\n\n    hooks::mi_free(ptr);\n}\n}\n'