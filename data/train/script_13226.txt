b'package com.bennyhuo.kotlin.coroutines\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.channels.trySendBlocking\nimport kotlinx.coroutines.flow.callbackFlow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.conflate\nimport kotlin.concurrent.thread\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.resumeWithException\nimport kotlin.coroutines.suspendCoroutine\n\nsuspend fun main() {\n    println(runTaskSuspend())\n\n    try {\n        println(sendRequestSuspend())\n    } catch (e: Exception) {\n        println("send request: $e")\n    }\n\n    val scope = CoroutineScope(Dispatchers.Default)\n    scope.launch {\n        try {\n            println(sendRequestCancellableSuspend())\n        } catch (e: Exception) {\n            println("send request cancellable: $e")\n        }\n    }.join()\n\n    scope.launch {\n        startTaskAsFlow().collect {\n            when(it) {\n                OnComplete -> println("Done")\n                is OnError -> println("Error: ${it.t}")\n                is OnProgress -> println("Progress: ${it.value}")\n                is OnResult<*> -> println("Result: ${it.value}")\n            }\n        }\n    }.join()\n\n//    delay(100)\n//    scope.cancel()\n}\n\n//region single method\n/**\n * Delayed task, like handler.post\n */\nfun interface SingleMethodCallback {\n    fun onCallback(value: String)\n}\n\nfun runTask(callback: SingleMethodCallback) {\n   thread {\n       Thread.sleep(100)\n       callback.onCallback("runTask result")\n   }\n}\n\n//region suspend\nsuspend fun runTaskSuspend() = suspendCoroutine<String> { continuation ->\n    runTask {\n        continuation.resume(it)\n    }\n}\n//endregion\n//endregion\n\n//region success or failure\n/**\n * Http request callback\n * Dialog yes/no\n */\ninterface SuccessOrFailureCallback {\n    fun onSuccess(value: String)\n\n    fun onError(t: Throwable)\n}\n\nfun sendRequest(callback: SuccessOrFailureCallback) {\n    thread {\n        try {\n            Thread.sleep(100)\n            callback.onSuccess("Success")\n        } catch (e: Exception) {\n            callback.onError(e)\n        }\n    }\n}\n\n//region suspend\nsuspend fun sendRequestSuspend() = suspendCoroutine<String> {\n    continuation ->\n    sendRequest(object: SuccessOrFailureCallback {\n        override fun onSuccess(value: String) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n}\n//endregion\n\nfun interface Cancellable {\n    fun cancel()\n}\n\nfun sendRequestCancellable(callback: SuccessOrFailureCallback):Cancellable {\n    val t = thread {\n        try {\n            Thread.sleep(1000)\n            callback.onSuccess("Success")\n        } catch (e: Exception) {\n            callback.onError(e)\n        }\n    }\n    return Cancellable {\n        t.interrupt()\n    }\n}\n\n//region cancellable suspend\nsuspend fun sendRequestCancellableSuspend() = suspendCancellableCoroutine<String> {\n        continuation ->\n    val cancellable = sendRequestCancellable(object: SuccessOrFailureCallback {\n        override fun onSuccess(value: String) {\n            continuation.resume(value)\n        }\n\n        override fun onError(t: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })\n    continuation.invokeOnCancellation {\n        cancellable.cancel()\n    }\n}\n//endregion\n//endregion\n\n//region multi path\n/**\n * Download task callback\n */\ninterface MultiPathsCallback<T> {\n\n    fun onProgress(value: Int)\n\n    fun onResult(value: T)\n\n    fun onError(t: Throwable)\n\n    fun onComplete()\n\n}\n\nfun startTask(callback: MultiPathsCallback<String>): Cancellable {\n    val t = thread {\n        try {\n            (0..100).forEach {\n                Thread.sleep(10)\n                callback.onProgress(it)\n            }\n            callback.onResult("Done")\n            callback.onComplete()\n        } catch (e: Exception) {\n            callback.onError(e)\n        }\n    }\n    return Cancellable {\n        t.interrupt()\n    }\n}\n\n//region suspend\nsealed interface Event\nclass OnProgress(val value: Int): Event\nclass OnError(val t: Throwable): Event\nclass OnResult<T>(val value: T): Event\nobject OnComplete: Event\n\nfun startTaskAsFlow() = callbackFlow {\n    val cancellable = startTask(object: MultiPathsCallback<String> {\n        override fun onProgress(value: Int) {\n            trySendBlocking(OnProgress(value))\n        }\n\n        override fun onResult(value: String) {\n            trySendBlocking(OnResult(value))\n        }\n\n        override fun onError(t: Throwable) {\n            trySendBlocking(OnError(t))\n        }\n\n        override fun onComplete() {\n            trySendBlocking(OnComplete)\n            close()\n        }\n    })\n\n\n    awaitClose {\n        cancellable.cancel()\n    }\n}.conflate()\n//endregion\n//endregion'