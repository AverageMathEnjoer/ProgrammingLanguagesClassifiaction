b'{-# LANGUAGE ViewPatterns, OverloadedLists #-}\nmodule Resources where\n\nimport Data.IORef\nimport Test.Tasty\nimport Test.Tasty.Options\nimport Test.Tasty.Runners\nimport Test.Tasty.HUnit\nimport Control.Concurrent\nimport Control.Monad (void)\nimport qualified Data.IntMap as IntMap\nimport Data.Maybe\nimport Data.Foldable\nimport Control.Exception\nimport qualified Data.Sequence as Seq\nimport qualified Data.Set as Set\n\nimport Utils\n\ntestResources :: TestTree\ntestResources = testGroup "Resources"\n  [ testResources1\n  , testResources2\n  , testResources3\n  , testResources4\n  , testResources5\n  , testResources6\n  , testResources7\n  ]\n\ninitIORef :: IORef Bool -> IO (IORef Bool)\ninitIORef ref = do\n  v <- readIORef ref\n  if v\n    then assertFailure "resource was already initialized!"\n    else writeIORef ref True\n  return ref\nreleaseIORef :: IORef Bool -> IO ()\nreleaseIORef ref = do\n  v <- readIORef ref\n  if not v\n    then assertFailure "resource was not initialized!"\n    else writeIORef ref False\n\n------------------------------\n-- Normal operation\n\n-- this is a dummy tree we use for testing\ntestTree1 :: IORef Bool -> TestTree\ntestTree1 ref =\n  withResource (initIORef ref) releaseIORef $ \\ioRef ->\n  testGroup "dummy"\n    [ testCase "aaa" $ check ioRef\n    , testCase "bbb" $ check ioRef\n    , testCase "aab" $ threadDelay (10^5) >> check ioRef\n    ]\n\n  where\n    check ioRef = ioRef >>= readIORef >>= assertBool "ref is false!"\n\n-- this is the actual test\ntestResources1 :: TestTree\ntestResources1 = testCase "Normal; a test excluded by a pattern" $ do\n  ref <- newIORef False\n  launchTestTree\n    (setOption (fromJust $ parseTestPattern "aa") mempty)\n    (testTree1 ref) $\n    \\smap -> do\n      assertEqual "Number of tests to run" 2 (IntMap.size smap)\n      rs <- runSMap smap\n      assertBool "Resource is not available" $ all resultSuccessful rs\n      readIORef ref >>= assertBool "Resource was not released" . not\n      return $ const $ return ()\n\n------------------------------\n-- Exceptions\n\ntestTree2 :: TestTree\ntestTree2 =\n  withResource (error "exInit") (error "exFin") $ \\_ioRef -> testCase "body" $\n    error "exBody"\n\ntestResources2 :: TestTree\ntestResources2 = testCase "Exception during resource initialization" $\n  launchTestTree mempty testTree2 $ \\smap -> do\n  [r] <- runSMap smap\n  case resultOutcome r of\n    Failure (TestThrewException (fromException -> Just (ErrorCall "exInit"))) ->\n      return ()\n    c -> assertFailure $ "Unexpected outcome: " ++ show c\n  return $ const $ return ()\n\ntestTree3 :: IORef Bool -> TestTree\ntestTree3 ref =\n  withResource (initIORef ref) releaseIORef $ \\_ioRef -> testCase "body" $\n    error "exBody"\n\ntestResources3 :: TestTree\ntestResources3 = testCase "Exception in test body; resource is released" $ do\n  ref <- newIORef False\n  launchTestTree mempty (testTree3 ref) $ \\smap -> do\n    [r] <- runSMap smap\n    case resultOutcome r of\n      Failure (TestThrewException (fromException -> Just (ErrorCall "exBody"))) ->\n        return ()\n      c -> assertFailure $ "Unexpected outcome: " ++ show c\n    b <- readIORef ref\n    assertBool "Resource wasn\'t released" (not b)\n    return $ const $ return ()\n\ntestTree4 :: IORef Bool -> TestTree\ntestTree4 ref =\n  withResource (initIORef ref) (error "exFin") $ \\ioRef -> testCase "body" $\n  void ioRef\n\ntestResources4 :: TestTree\ntestResources4 = testCase "Exception in finalizer" $ do\n  ref <- newIORef False\n  launchTestTree mempty (testTree4 ref) $ \\smap -> do\n    [r] <- runSMap smap\n    case resultOutcome r of\n      Failure (TestThrewException (fromException -> Just (ErrorCall "exFin"))) ->\n        return ()\n      c -> assertFailure $ "Unexpected outcome: " ++ show c\n    return $ const $ return ()\n\ndata Step\n  = ResourceInitialized Int\n  | ResourceDestroyed Int\n  | ActionRan Int\n  deriving (Eq, Ord, Show)\n\naddStep :: IORef (Seq.Seq Step) -> Step -> IO ()\naddStep ref step = atomicModifyIORef\' ref (\\s -> (s Seq.|> step, ()))\n\ntestTree5 :: IORef (Seq.Seq Step) -> TestTree\ntestTree5 ref =\n  withResource (1 <$ addStep ref (ResourceInitialized 1)) (addStep ref . ResourceDestroyed) $ \\_ ->\n    withResource (2 <$ addStep ref (ResourceInitialized 2)) (addStep ref . ResourceDestroyed) $ \\_ ->\n      testGroup "group"\n        [ testCase "test" $ do\n            addStep ref (ActionRan i)\n            threadDelay (10^5)\n        | i <- [1,2]\n        ]\n\ntestResources5 :: TestTree\ntestResources5 = testCase "Order of finalizers when the test suite runs" $ do\n  ref <- newIORef mempty\n  launchTestTree mempty (testTree5 ref) $ \\smap -> do\n    _ <- runSMap smap\n    return $ const $ return ()\n  steps <- readIORef ref\n\n  -- We don\'t know the order of ActionRan 1 and 2, so can\'t use a single @?= as above\n  Seq.take 2 steps @?=\n    [ResourceInitialized 1, ResourceInitialized 2]\n  (Set.fromList . toList . Seq.take 2 . Seq.drop 2) steps @?=\n    [ActionRan 1, ActionRan 2]\n  (Seq.take 2 . Seq.drop 4) steps @?=\n    [ResourceDestroyed 2, ResourceDestroyed 1]\n\ntestResources6 :: TestTree\ntestResources6 = testCase "Order of finalizers when the test suite is aborted (1 thread)" $ do\n  ref <- newIORef mempty\n  launchTestTree (singleOption $ NumThreads 1) (testTree5 ref) $ \\_ -> do\n    -- do not wait until completion; abort before the first test finishes\n    threadDelay (4*10^4)\n    return $ const $ return ()\n  steps <- readIORef ref\n  toList steps @?=\n    [ ResourceInitialized 1, ResourceInitialized 2\n    , ActionRan 1 -- NB: no action 2\n    , ResourceDestroyed 2, ResourceDestroyed 1\n    ]\n\ntestResources7 :: TestTree\ntestResources7 = testCase "Order of finalizers when the test suite is aborted (2 threads)" $ do\n  ref <- newIORef mempty\n  launchTestTree (singleOption $ NumThreads 2) (testTree5 ref) $ \\_ -> do\n    -- do not wait until completion; abort before the first test finishes\n    threadDelay (4*10^4)\n    return $ const $ return ()\n  steps <- readIORef ref\n  Seq.take 2 steps @?=\n    [ResourceInitialized 1, ResourceInitialized 2]\n  (Set.fromList . toList . Seq.take 2 . Seq.drop 2) steps @?=\n    [ActionRan 1, ActionRan 2]\n  (Seq.take 2 . Seq.drop 4) steps @?=\n    [ResourceDestroyed 2, ResourceDestroyed 1]\n'