b'using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace Asn1 {\n\n/*\n * An AsnElt instance represents a decoded ASN.1 DER object. It is\n * immutable.\n */\n\npublic class AsnElt {\n\n\t/*\n\t * Universal tag values.\n\t */\n\tpublic const int BOOLEAN           = 1;\n\tpublic const int INTEGER           = 2;\n\tpublic const int BIT_STRING        = 3;\n\tpublic const int OCTET_STRING      = 4;\n\tpublic const int NULL              = 5;\n\tpublic const int OBJECT_IDENTIFIER = 6;\n\tpublic const int Object_Descriptor = 7;\n\tpublic const int EXTERNAL          = 8;\n\tpublic const int REAL              = 9;\n\tpublic const int ENUMERATED        = 10;\n\tpublic const int EMBEDDED_PDV      = 11;\n\tpublic const int UTF8String        = 12;\n\tpublic const int RELATIVE_OID      = 13;\n\tpublic const int SEQUENCE          = 16;\n\tpublic const int SET               = 17;\n\tpublic const int NumericString     = 18;\n\tpublic const int PrintableString   = 19;\n\tpublic const int T61String         = 20;\n\tpublic const int TeletexString     = 20;\n\tpublic const int VideotexString    = 21;\n\tpublic const int IA5String         = 22;\n\tpublic const int UTCTime           = 23;\n\tpublic const int GeneralizedTime   = 24;\n\tpublic const int GraphicString     = 25;\n\tpublic const int VisibleString     = 26;\n\tpublic const int GeneralString     = 27;\n\tpublic const int UniversalString   = 28;\n\tpublic const int CHARACTER_STRING  = 29;\n\tpublic const int BMPString         = 30;\n\n    /*\n\t * Tag classes.\n\t */\n    public const int UNIVERSAL   = 0;\n\tpublic const int APPLICATION = 1;\n\tpublic const int CONTEXT     = 2;\n\tpublic const int PRIVATE     = 3;\n\n\t/*\n\t * Internal rules\n\t * ==============\n\t *\n\t * Instances are immutable. They reference an internal buffer\n\t * that they never modify. The buffer is never shown to the\n\t * outside; when decoding and creating, copies are performed\n\t * where necessary.\n\t *\n\t * If the instance was created by decoding, then:\n\t *   objBuf   points to the array containing the complete object\n\t *   objOff   start offset for the object header\n\t *   objLen   complete object length\n\t *   valOff   offset for the first value byte\n\t *   valLen   value length (excluding the null-tag, if applicable)\n\t *   hasEncodedHeader  is true\n\t *\n\t * If the instance was created from an explicit value or from\n\t * sub-elements, then:\n\t *   objBuf   contains the value, or is null\n\t *   objOff   is 0\n\t *   objLen   is -1, or contains the computed object length\n\t *   valOff   is 0\n\t *   valLen   is -1, or contains the computed value length\n\t *   hasEncodedHeader  is false\n\t *\n\t * If objBuf is null, then the object is necessarily constructed\n\t * (Sub is not null). If objBuf is not null, then the encoded\n\t * value is known (the object may be constructed or primitive),\n\t * and valOff/valLen identify the actual value within objBuf.\n\t *\n\t * Tag class and value, and sub-elements, are referenced from\n\t * specific properties.\n\t */\n\n\tbyte[] objBuf;\n\tint objOff;\n\tint objLen;\n\tint valOff;\n\tint valLen;\n\tbool hasEncodedHeader;\n\n\tAsnElt()\n\t{\n\t}\n\n\t/*\n\t * The tag class for this element.\n\t */\n\tint tagClass_;\n\tpublic int TagClass {\n\t\tget {\n\t\t\treturn tagClass_;\n\t\t}\n\t\tprivate set {\n\t\t\ttagClass_ = value;\n\t\t}\n\t}\n\n\t/*\n\t * The tag value for this element.\n\t */\n\tint tagValue_;\n\tpublic int TagValue {\n\t\tget {\n\t\t\treturn tagValue_;\n\t\t}\n\t\tprivate set {\n\t\t\ttagValue_ = value;\n\t\t}\n\t}\n\n\t/*\n\t * The sub-elements. This is null if this element is primitive.\n\t * DO NOT MODIFY this array.\n\t */\n\tAsnElt[] sub_;\n\tpublic AsnElt[] Sub {\n\t\tget {\n\t\t\treturn sub_;\n\t\t}\n\t\tprivate set {\n\t\t\tsub_ = value;\n\t\t}\n\t}\n\n\t/*\n\t * The "constructed" flag: true for an elements with sub-elements,\n\t * false for a primitive element.\n\t */\n\tpublic bool Constructed {\n\t\tget {\n\t\t\treturn Sub != null;\n\t\t}\n\t}\n\n\t/*\n\t * The value length. When the object is BER-encoded with an\n\t * indefinite length, the value length includes all the sub-objects\n\t * but NOT the formal null-tag marker.\n\t */\n\tpublic int ValueLength {\n\t\tget {\n\t\t\tif (valLen < 0) {\n\t\t\t\tif (Constructed) {\n\t\t\t\t\tint vlen = 0;\n\t\t\t\t\tforeach (AsnElt a in Sub) {\n\t\t\t\t\t\tvlen += a.EncodedLength;\n\t\t\t\t\t}\n\t\t\t\t\tvalLen = vlen;\n\t\t\t\t} else {\n\t\t\t\t\tvalLen = objBuf.Length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn valLen;\n\t\t}\n\t}\n\n\t/*\n\t * The encoded object length (complete with header).\n\t */\n\tpublic int EncodedLength {\n\t\tget {\n\t\t\tif (objLen < 0) {\n\t\t\t\tint vlen = ValueLength;\n\t\t\t\tobjLen = TagLength(TagValue)\n\t\t\t\t\t+ LengthLength(vlen) + vlen;\n\t\t\t}\n\t\t\treturn objLen;\n\t\t}\n\t}\n\n\t/*\n\t * Check that this element is constructed. An exception is thrown\n\t * if this is not the case.\n\t */\n\tpublic void CheckConstructed()\n\t{\n\t\tif (!Constructed) {\n\t\t\tthrow new AsnException("not constructed");\n\t\t}\n\t}\n\n\t/*\n\t * Check that this element is primitive. An exception is thrown\n\t * if this is not the case.\n\t */\n\tpublic void CheckPrimitive()\n\t{\n\t\tif (Constructed) {\n\t\t\tthrow new AsnException("not primitive");\n\t\t}\n\t}\n\n\t/*\n\t * Get a sub-element. This method throws appropriate exceptions\n\t * if this element is not constructed, or the requested index\n\t * is out of range.\n\t */\n\tpublic AsnElt GetSub(int n)\n\t{\n\t\tCheckConstructed();\n\t\tif (n < 0 || n >= Sub.Length) {\n\t\t\tthrow new AsnException("no such sub-object: n=" + n);\n\t\t}\n\t\treturn Sub[n];\n\t}\n\n\t/*\n\t * Check that the tag is UNIVERSAL with the provided value.\n\t */\n\tpublic void CheckTag(int tv)\n\t{\n\t\tCheckTag(UNIVERSAL, tv);\n\t}\n\n\t/*\n\t * Check that the tag has the specified class and value.\n\t */\n\tpublic void CheckTag(int tc, int tv)\n\t{\n\t\tif (TagClass != tc || TagValue != tv) {\n\t\t\tthrow new AsnException("unexpected tag: " + TagString);\n\t\t}\n\t}\n\n\t/*\n\t * Check that this element is constructed and contains exactly\n\t * \'n\' sub-elements.\n\t */\n\tpublic void CheckNumSub(int n)\n\t{\n\t\tCheckConstructed();\n\t\tif (Sub.Length != n) {\n\t\t\tthrow new AsnException("wrong number of sub-elements: "\n\t\t\t\t+ Sub.Length + " (expected: " + n + ")");\n\t\t}\n\t}\n\n\t/*\n\t * Check that this element is constructed and contains at least\n\t * \'n\' sub-elements.\n\t */\n\tpublic void CheckNumSubMin(int n)\n\t{\n\t\tCheckConstructed();\n\t\tif (Sub.Length < n) {\n\t\t\tthrow new AsnException("not enough sub-elements: "\n\t\t\t\t+ Sub.Length + " (minimum: " + n + ")");\n\t\t}\n\t}\n\n\t/*\n\t * Check that this element is constructed and contains no more\n\t * than \'n\' sub-elements.\n\t */\n\tpublic void CheckNumSubMax(int n)\n\t{\n\t\tCheckConstructed();\n\t\tif (Sub.Length > n) {\n\t\t\tthrow new AsnException("too many sub-elements: "\n\t\t\t\t+ Sub.Length + " (maximum: " + n + ")");\n\t\t}\n\t}\n\n\t/*\n\t * Get a string representation of the tag class and value.\n\t */\n\tpublic string TagString {\n\t\tget {\n\t\t\treturn TagToString(TagClass, TagValue);\n\t\t}\n\t}\n\n\tstatic string TagToString(int tc, int tv)\n\t{\n\t\tswitch (tc) {\n\t\tcase UNIVERSAL:\n\t\t\tbreak;\n\t\tcase APPLICATION:\n\t\t\treturn "APPLICATION:" + tv;\n\t\tcase CONTEXT:\n\t\t\treturn "CONTEXT:" + tv;\n\t\tcase PRIVATE:\n\t\t\treturn "PRIVATE:" + tv;\n\t\tdefault:\n\t\t\treturn String.Format("INVALID:{0}/{1}", tc, tv);\n\t\t}\n\n\t\tswitch (tv) {\n\t\tcase BOOLEAN:           return "BOOLEAN";\n\t\tcase INTEGER:           return "INTEGER";\n\t\tcase BIT_STRING:        return "BIT_STRING";\n\t\tcase OCTET_STRING:      return "OCTET_STRING";\n\t\tcase NULL:              return "NULL";\n\t\tcase OBJECT_IDENTIFIER: return "OBJECT_IDENTIFIER";\n\t\tcase Object_Descriptor: return "Object_Descriptor";\n\t\tcase EXTERNAL:          return "EXTERNAL";\n\t\tcase REAL:              return "REAL";\n\t\tcase ENUMERATED:        return "ENUMERATED";\n\t\tcase EMBEDDED_PDV:      return "EMBEDDED_PDV";\n\t\tcase UTF8String:        return "UTF8String";\n\t\tcase RELATIVE_OID:      return "RELATIVE_OID";\n\t\tcase SEQUENCE:          return "SEQUENCE";\n\t\tcase SET:               return "SET";\n\t\tcase NumericString:     return "NumericString";\n\t\tcase PrintableString:   return "PrintableString";\n\t\tcase TeletexString:     return "TeletexString";\n\t\tcase VideotexString:    return "VideotexString";\n\t\tcase IA5String:         return "IA5String";\n\t\tcase UTCTime:           return "UTCTime";\n\t\tcase GeneralizedTime:   return "GeneralizedTime";\n\t\tcase GraphicString:     return "GraphicString";\n\t\tcase VisibleString:     return "VisibleString";\n\t\tcase GeneralString:     return "GeneralString";\n\t\tcase UniversalString:   return "UniversalString";\n\t\tcase CHARACTER_STRING:  return "CHARACTER_STRING";\n\t\tcase BMPString:         return "BMPString";\n\t\tdefault:\n\t\t\treturn String.Format("UNIVERSAL:" + tv);\n\t\t}\n\t}\n\n\t/*\n\t * Get the encoded length for a tag.\n\t */\n\tstatic int TagLength(int tv)\n\t{\n\t\tif (tv <= 0x1F) {\n\t\t\treturn 1;\n\t\t}\n\t\tint z = 1;\n\t\twhile (tv > 0) {\n\t\t\tz ++;\n\t\t\ttv >>= 7;\n\t\t}\n\t\treturn z;\n\t}\n\n\t/*\n\t * Get the encoded length for a length.\n\t */\n\tstatic int LengthLength(int len)\n\t{\n\t\tif (len < 0x80) {\n\t\t\treturn 1;\n\t\t}\n\t\tint z = 1;\n\t\twhile (len > 0) {\n\t\t\tz ++;\n\t\t\tlen >>= 8;\n\t\t}\n\t\treturn z;\n\t}\n\n\t/*\n\t * Decode an ASN.1 object. The provided buffer is internally\n\t * copied. Trailing garbage is not tolerated.\n\t */\n\tpublic static AsnElt Decode(byte[] buf)\n\t{\n\t\treturn Decode(buf, 0, buf.Length, true);\n\t}\n\n\t/*\n\t * Decode an ASN.1 object. The provided buffer is internally\n\t * copied. Trailing garbage is not tolerated.\n\t */\n\tpublic static AsnElt Decode(byte[] buf, int off, int len)\n\t{\n\t\treturn Decode(buf, off, len, true);\n\t}\n\n\t/*\n\t * Decode an ASN.1 object. The provided buffer is internally\n\t * copied. If \'exactLength\' is true, then trailing garbage is\n\t * not tolerated (it triggers an exception).\n\t */\n\tpublic static AsnElt Decode(byte[] buf, bool exactLength)\n\t{\n\t\treturn Decode(buf, 0, buf.Length, exactLength);\n\t}\n\n\t/*\n\t * Decode an ASN.1 object. The provided buffer is internally\n\t * copied. If \'exactLength\' is true, then trailing garbage is\n\t * not tolerated (it triggers an exception).\n\t */\n\tpublic static AsnElt Decode(byte[] buf, int off, int len,\n\t\tbool exactLength)\n\t{\n\t\tint tc, tv, valOff, valLen, objLen;\n\t\tbool cons;\n\t\tobjLen = Decode(buf, off, len,\n\t\t\tout tc, out tv, out cons,\n\t\t\tout valOff, out valLen);\n\t\tif (exactLength && objLen != len) {\n\t\t\tthrow new AsnException("trailing garbage");\n\t\t}\n\t\tbyte[] nbuf = new byte[objLen];\n\t\tArray.Copy(buf, off, nbuf, 0, objLen);\n\t\treturn DecodeNoCopy(nbuf, 0, objLen);\n\t}\n\n\t/*\n\t * Internal recursive decoder. The provided array is NOT copied.\n\t * Trailing garbage is ignored (caller should use the \'objLen\'\n\t * field to learn the total object length).\n\t */\n\tstatic AsnElt DecodeNoCopy(byte[] buf, int off, int len)\n\t{\n\t\tint tc, tv, valOff, valLen, objLen;\n\t\tbool cons;\n\t\tobjLen = Decode(buf, off, len,\n\t\t\tout tc, out tv, out cons,\n\t\t\tout valOff, out valLen);\n\t\tAsnElt a = new AsnElt();\n\t\ta.TagClass = tc;\n\t\ta.TagValue = tv;\n\t\ta.objBuf = buf;\n\t\ta.objOff = off;\n\t\ta.objLen = objLen;\n\t\ta.valOff = valOff;\n\t\ta.valLen = valLen;\n\t\ta.hasEncodedHeader = true;\n\t\tif (cons) {\n\t\t\tList<AsnElt> subs = new List<AsnElt>();\n\t\t\toff = valOff;\n\t\t\tint lim = valOff + valLen;\n\t\t\twhile (off < lim) {\n\t\t\t\tAsnElt b = DecodeNoCopy(buf, off, lim - off);\n\t\t\t\toff += b.objLen;\n\t\t\t\tsubs.Add(b);\n\t\t\t}\n\t\t\ta.Sub = subs.ToArray();\n\t\t} else {\n\t\t\ta.Sub = null;\n\t\t}\n\t\treturn a;\n\t}\n\n\t/*\n\t * Decode the tag and length, and get the value offset and length.\n\t * Returned value if the total object length.\n\t * Note: when an object has indefinite length, the terminated\n\t * "null tag" will NOT be considered part of the "value length".\n\t */\n\tstatic int Decode(byte[] buf, int off, int maxLen,\n\t\tout int tc, out int tv, out bool cons,\n\t\tout int valOff, out int valLen)\n\t{\n\t\tint lim = off + maxLen;\n\t\tint orig = off;\n\n\t\t/*\n\t\t * Decode tag.\n\t\t */\n\t\tCheckOff(off, lim);\n\t\ttv = buf[off ++];\n\t\tcons = (tv & 0x20) != 0;\n\t\ttc = tv >> 6;\n\t\ttv &= 0x1F;\n\t\tif (tv == 0x1F) {\n\t\t\ttv = 0;\n\t\t\tfor (;;) {\n\t\t\t\tCheckOff(off, lim);\n\t\t\t\tint c = buf[off ++];\n\t\t\t\tif (tv > 0xFFFFFF) {\n\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t"tag value overflow");\n\t\t\t\t}\n\t\t\t\ttv = (tv << 7) | (c & 0x7F);\n\t\t\t\tif ((c & 0x80) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Decode length.\n\t\t */\n\t\tCheckOff(off, lim);\n\t\tint vlen = buf[off ++];\n\t\tif (vlen == 0x80) {\n\t\t\t/*\n\t\t\t * Indefinite length. This is not strict DER, but\n\t\t\t * we allow it nonetheless; we must check that\n\t\t\t * the value was tagged as constructed, though.\n\t\t\t */\n\t\t\tvlen = -1;\n\t\t\tif (!cons) {\n\t\t\t\tthrow new AsnException("indefinite length"\n\t\t\t\t\t+ " but not constructed");\n\t\t\t}\n\t\t} else if (vlen > 0x80) {\n\t\t\tint lenlen = vlen - 0x80;\n\t\t\tCheckOff(off + lenlen - 1, lim);\n\t\t\tvlen = 0;\n\t\t\twhile (lenlen -- > 0) {\n\t\t\t\tif (vlen > 0x7FFFFF) {\n\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t"length overflow");\n\t\t\t\t}\n\t\t\t\tvlen = (vlen << 8) + buf[off ++];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Length was decoded, so the value starts here.\n\t\t */\n\t\tvalOff = off;\n\n\t\t/*\n\t\t * If length is indefinite then we must explore sub-objects\n\t\t * to get the value length.\n\t\t */\n\t\tif (vlen < 0) {\n\t\t\tfor (;;) {\n\t\t\t\tint tc2, tv2, valOff2, valLen2;\n\t\t\t\tbool cons2;\n\t\t\t\tint slen;\n\n\t\t\t\tslen = Decode(buf, off, lim - off,\n\t\t\t\t\tout tc2, out tv2, out cons2,\n\t\t\t\t\tout valOff2, out valLen2);\n\t\t\t\tif (tc2 == 0 && tv2 == 0) {\n\t\t\t\t\tif (cons2 || valLen2 != 0) {\n\t\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t\t"invalid null tag");\n\t\t\t\t\t}\n\t\t\t\t\tvalLen = off - valOff;\n\t\t\t\t\toff += slen;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\toff += slen;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (vlen > (lim - off)) {\n\t\t\t\tthrow new AsnException("value overflow");\n\t\t\t}\n\t\t\toff += vlen;\n\t\t\tvalLen = off - valOff;\n\t\t}\n\n\t\treturn off - orig;\n\t}\n\n\tstatic void CheckOff(int off, int lim)\n\t{\n\t\tif (off >= lim) {\n\t\t\tthrow new AsnException("offset overflow");\n\t\t}\n\t}\n\n\t/*\n\t * Get a specific byte from the value. This provided offset is\n\t * relative to the value start (first value byte has offset 0).\n\t */\n\tpublic int ValueByte(int off)\n\t{\n\t\tif (off < 0) {\n\t\t\tthrow new AsnException("invalid value offset: " + off);\n\t\t}\n\t\tif (objBuf == null) {\n\t\t\tint k = 0;\n\t\t\tforeach (AsnElt a in Sub) {\n\t\t\t\tint slen = a.EncodedLength;\n\t\t\t\tif ((k + slen) > off) {\n\t\t\t\t\treturn a.ValueByte(off - k);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (off < valLen) {\n\t\t\t\treturn objBuf[valOff + off];\n\t\t\t}\n\t\t}\n\t\tthrow new AsnException(String.Format(\n\t\t\t"invalid value offset {0} (length = {1})",\n\t\t\toff, ValueLength));\n\t}\n\n\t/*\n\t * Encode this object into a newly allocated array.\n\t */\n\tpublic byte[] Encode()\n\t{\n\t\tbyte[] r = new byte[EncodedLength];\n\t\tEncode(r, 0);\n\t\treturn r;\n\t}\n\n\t/*\n\t * Encode this object into the provided array. Encoded object\n\t * length is returned.\n\t */\n\tpublic int Encode(byte[] dst, int off)\n\t{\n\t\treturn Encode(0, Int32.MaxValue, dst, off);\n\t}\n\n\t/*\n\t * Encode this object into the provided array. Only bytes\n\t * at offset between \'start\' (inclusive) and \'end\' (exclusive)\n\t * are actually written. The number of written bytes is returned.\n\t * Offsets are relative to the object start (first tag byte).\n\t */\n\tint Encode(int start, int end, byte[] dst, int dstOff)\n\t{\n\t\t/*\n\t\t * If the encoded value is already known, then we just\n\t\t * dump it.\n\t\t */\n\t\tif (hasEncodedHeader) {\n\t\t\tint from = objOff + Math.Max(0, start);\n\t\t\tint to = objOff + Math.Min(objLen, end);\n\t\t\tint len = to - from;\n\t\t\tif (len > 0) {\n\t\t\t\tArray.Copy(objBuf, from, dst, dstOff, len);\n\t\t\t\treturn len;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tint off = 0;\n\n\t\t/*\n\t\t * Encode tag.\n\t\t */\n\t\tint fb = (TagClass << 6) + (Constructed ? 0x20 : 0x00);\n\t\tif (TagValue < 0x1F) {\n\t\t\tfb |= (TagValue & 0x1F);\n\t\t\tif (start <= off && off < end) {\n\t\t\t\tdst[dstOff ++] = (byte)fb;\n\t\t\t}\n\t\t\toff ++;\n\t\t} else {\n\t\t\tfb |= 0x1F;\n\t\t\tif (start <= off && off < end) {\n\t\t\t\tdst[dstOff ++] = (byte)fb;\n\t\t\t}\n\t\t\toff ++;\n\t\t\tint k = 0;\n\t\t\tfor (int v = TagValue; v > 0; v >>= 7, k += 7);\n\t\t\twhile (k > 0) {\n\t\t\t\tk -= 7;\n\t\t\t\tint v = (TagValue >> k) & 0x7F;\n\t\t\t\tif (k != 0) {\n\t\t\t\t\tv |= 0x80;\n\t\t\t\t}\n\t\t\t\tif (start <= off && off < end) {\n\t\t\t\t\tdst[dstOff ++] = (byte)v;\n\t\t\t\t}\n\t\t\t\toff ++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Encode length.\n\t\t */\n\t\tint vlen = ValueLength;\n\t\tif (vlen < 0x80) {\n\t\t\tif (start <= off && off < end) {\n\t\t\t\tdst[dstOff ++] = (byte)vlen;\n\t\t\t}\n\t\t\toff ++;\n\t\t} else {\n\t\t\tint k = 0;\n\t\t\tfor (int v = vlen; v > 0; v >>= 8, k += 8);\n\t\t\tif (start <= off && off < end) {\n\t\t\t\tdst[dstOff ++] = (byte)(0x80 + (k >> 3));\n\t\t\t}\n\t\t\toff ++;\n\t\t\twhile (k > 0) {\n\t\t\t\tk -= 8;\n\t\t\t\tif (start <= off && off < end) {\n\t\t\t\t\tdst[dstOff ++] = (byte)(vlen >> k);\n\t\t\t\t}\n\t\t\t\toff ++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Encode value. We must adjust the start/end window to\n\t\t * make it relative to the value.\n\t\t */\n\t\tEncodeValue(start - off, end - off, dst, dstOff);\n\t\toff += vlen;\n\n\t\t/*\n\t\t * Compute copied length.\n\t\t */\n\t\treturn Math.Max(0, Math.Min(off, end) - Math.Max(0, start));\n\t}\n\n\t/*\n\t * Encode the value into the provided buffer. Only value bytes\n\t * at offsets between \'start\' (inclusive) and \'end\' (exclusive)\n\t * are written. Actual number of written bytes is returned.\n\t * Offsets are relative to the start of the value.\n\t */\n\tint EncodeValue(int start, int end, byte[] dst, int dstOff)\n\t{\n\t\tint orig = dstOff;\n\t\tif (objBuf == null) {\n\t\t\tint k = 0;\n\t\t\tforeach (AsnElt a in Sub) {\n\t\t\t\tint slen = a.EncodedLength;\n\t\t\t\tdstOff += a.Encode(start - k, end - k,\n\t\t\t\t\tdst, dstOff);\n\t\t\t\tk += slen;\n\t\t\t}\n\t\t} else {\n\t\t\tint from = Math.Max(0, start);\n\t\t\tint to = Math.Min(valLen, end);\n\t\t\tint len = to - from;\n\t\t\tif (len > 0) {\n\t\t\t\tArray.Copy(objBuf, valOff + from,\n\t\t\t\t\tdst, dstOff, len);\n\t\t\t\tdstOff += len;\n\t\t\t}\n\t\t}\n\t\treturn dstOff - orig;\n\t}\n\n\t/*\n\t * Copy a value chunk. The provided offset (\'off\') and length (\'len\')\n\t * define the chunk to copy; the offset is relative to the value\n\t * start (first value byte has offset 0). If the requested window\n\t * exceeds the value boundaries, an exception is thrown.\n\t */\n\tpublic void CopyValueChunk(int off, int len, byte[] dst, int dstOff)\n\t{\n\t\tint vlen = ValueLength;\n\t\tif (off < 0 || len < 0 || len > (vlen - off)) {\n\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t"invalid value window {0}:{1}"\n\t\t\t\t+ " (value length = {2})", off, len, vlen));\n\t\t}\n\t\tEncodeValue(off, off + len, dst, dstOff);\n\t}\n\n\t/*\n\t * Copy the value into the specified array. The value length is\n\t * returned.\n\t */\n\tpublic int CopyValue(byte[] dst, int off)\n\t{\n\t\treturn EncodeValue(0, Int32.MaxValue, dst, off);\n\t}\n\n\t/*\n\t * Get a copy of the value as a freshly allocated array.\n\t */\n\tpublic byte[] CopyValue()\n\t{\n\t\tbyte[] r = new byte[ValueLength];\n\t\tEncodeValue(0, r.Length, r, 0);\n\t\treturn r;\n\t}\n\n\t/*\n\t * Get the value. This may return a shared buffer, that MUST NOT\n\t * be modified.\n\t */\n\tbyte[] GetValue(out int off, out int len)\n\t{\n\t\tif (objBuf == null) {\n\t\t\t/*\n\t\t\t * We can modify objBuf because CopyValue()\n\t\t\t * called ValueLength, thus valLen has been\n\t\t\t * filled.\n\t\t\t */\n\t\t\tobjBuf = CopyValue();\n\t\t\toff = 0;\n\t\t\tlen = objBuf.Length;\n\t\t} else {\n\t\t\toff = valOff;\n\t\t\tlen = valLen;\n\t\t}\n\t\treturn objBuf;\n\t}\n\n\t/*\n\t * Interpret the value as a BOOLEAN.\n\t */\n\tpublic bool GetBoolean()\n\t{\n\t\tif (Constructed) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid BOOLEAN (constructed)");\n\t\t}\n\t\tint vlen = ValueLength;\n\t\tif (vlen != 1) {\n\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t"invalid BOOLEAN (length = {0})", vlen));\n\t\t}\n\t\treturn ValueByte(0) != 0;\n\t}\n\n\t/*\n\t * Interpret the value as an INTEGER. An exception is thrown if\n\t * the value does not fit in a \'long\'.\n\t */\n\tpublic long GetInteger()\n\t{\n\t\tif (Constructed) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid INTEGER (constructed)");\n\t\t}\n\t\tint vlen = ValueLength;\n\t\tif (vlen == 0) {\n\t\t\tthrow new AsnException("invalid INTEGER (length = 0)");\n\t\t}\n\t\tint v = ValueByte(0);\n\t\tlong x;\n\t\tif ((v & 0x80) != 0) {\n\t\t\tx = -1;\n\t\t\tfor (int k = 0; k < vlen; k ++) {\n\t\t\t\tif (x < ((-1L) << 55)) {\n\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t"integer overflow (negative)");\n\t\t\t\t}\n\t\t\t\tx = (x << 8) + (long)ValueByte(k);\n\t\t\t}\n\t\t} else {\n\t\t\tx = 0;\n\t\t\tfor (int k = 0; k < vlen; k ++) {\n\t\t\t\tif (x >= (1L << 55)) {\n\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t"integer overflow (positive)");\n\t\t\t\t}\n\t\t\t\tx = (x << 8) + (long)ValueByte(k);\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\n\t/*\n\t * Interpret the value as an INTEGER. An exception is thrown if\n\t * the value is outside of the provided range.\n\t */\n\tpublic long GetInteger(long min, long max)\n\t{\n\t\tlong v = GetInteger();\n\t\tif (v < min || v > max) {\n\t\t\tthrow new AsnException("integer out of allowed range");\n\t\t}\n\t\treturn v;\n\t}\n\n\t/*\n\t * Interpret the value as an INTEGER. Return its hexadecimal\n\t * representation (uppercase), preceded by a \'0x\' or \'-0x\'\n\t * header, depending on the integer sign. The number of\n\t * hexadecimal digits is even. Leading zeroes are returned (but\n\t * one may remain, to ensure an even number of digits). If the\n\t * integer has value 0, then 0x00 is returned.\n\t */\n\tpublic string GetIntegerHex()\n\t{\n\t\tif (Constructed) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid INTEGER (constructed)");\n\t\t}\n\t\tint vlen = ValueLength;\n\t\tif (vlen == 0) {\n\t\t\tthrow new AsnException("invalid INTEGER (length = 0)");\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte[] tmp = CopyValue();\n\t\tif (tmp[0] >= 0x80) {\n\t\t\tsb.Append(\'-\');\n\t\t\tint cc = 1;\n\t\t\tfor (int i = tmp.Length - 1; i >= 0; i --) {\n\t\t\t\tint v = ((~tmp[i]) & 0xFF) + cc;\n\t\t\t\ttmp[i] = (byte)v;\n\t\t\t\tcc = v >> 8;\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\twhile (k < tmp.Length && tmp[k] == 0) {\n\t\t\tk ++;\n\t\t}\n\t\tif (k == tmp.Length) {\n\t\t\treturn "0x00";\n\t\t}\n\t\tsb.Append("0x");\n\t\twhile (k < tmp.Length) {\n\t\t\tsb.AppendFormat("{0:X2}", tmp[k ++]);\n\t\t}\n\t\treturn sb.ToString();\n\t}\n\n\t/*\n\t * Interpret the value as an OCTET STRING. The value bytes are\n\t * returned. This method supports constructed values and performs\n\t * the reassembly.\n\t */\n\tpublic byte[] GetOctetString()\n\t{\n\t\tint len = GetOctetString(null, 0);\n\t\tbyte[] r = new byte[len];\n\t\tGetOctetString(r, 0);\n\t\treturn r;\n\t}\n\n\t/*\n\t * Interpret the value as an OCTET STRING. The value bytes are\n\t * written in dst[], starting at offset \'off\', and the total value\n\t * length is returned. If \'dst\' is null, then no byte is written\n\t * anywhere, but the total length is still returned. This method\n\t * supports constructed values and performs the reassembly.\n\t */\n\tpublic int GetOctetString(byte[] dst, int off)\n\t{\n\t\tif (Constructed) {\n\t\t\tint orig = off;\n\t\t\tforeach (AsnElt ae in Sub) {\n\t\t\t\tae.CheckTag(AsnElt.OCTET_STRING);\n\t\t\t\toff += ae.GetOctetString(dst, off);\n\t\t\t}\n\t\t\treturn off - orig;\n\t\t}\n\t\tif (dst != null) {\n\t\t\treturn CopyValue(dst, off);\n\t\t} else {\n\t\t\treturn ValueLength;\n\t\t}\n\t}\n\n\t/*\n\t * Interpret the value as a BIT STRING. The bits are returned,\n\t * with the "ignored bits" cleared.\n\t */\n\tpublic byte[] GetBitString()\n\t{\n\t\tint bitLength;\n\t\treturn GetBitString(out bitLength);\n\t}\n\n\t/*\n\t * Interpret the value as a BIT STRING. The bits are returned,\n\t * with the "ignored bits" cleared. The actual bit length is\n\t * written in \'bitLength\'.\n\t */\n\tpublic byte[] GetBitString(out int bitLength)\n\t{\n\t\tif (Constructed) {\n\t\t\t/*\n\t\t\t * TODO: support constructed BIT STRING values.\n\t\t\t */\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid BIT STRING (constructed)");\n\t\t}\n\t\tint vlen = ValueLength;\n\t\tif (vlen == 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid BIT STRING (length = 0)");\n\t\t}\n\t\tint fb = ValueByte(0);\n\t\tif (fb > 7 || (vlen == 1 && fb != 0)) {\n\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t"invalid BIT STRING (start = 0x{0:X2})", fb));\n\t\t}\n\t\tbyte[] r = new byte[vlen - 1];\n\t\tCopyValueChunk(1, vlen - 1, r, 0);\n\t\tif (vlen > 1) {\n\t\t\tr[r.Length - 1] &= (byte)(0xFF << fb);\n\t\t}\n\t\tbitLength = (r.Length << 3) - fb;\n\t\treturn r;\n\t}\n\n\t/*\n\t * Interpret the value as a NULL.\n\t */\n\tpublic void CheckNull()\n\t{\n\t\tif (Constructed) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid NULL (constructed)");\n\t\t}\n\t\tif (ValueLength != 0) {\n\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t"invalid NULL (length = {0})", ValueLength));\n\t\t}\n\t}\n\n\t/*\n\t * Interpret the value as an OBJECT IDENTIFIER, and return it\n\t * (in decimal-dotted string format).\n\t */\n\tpublic string GetOID()\n\t{\n\t\tCheckPrimitive();\n\t\tif (valLen == 0) {\n\t\t\tthrow new AsnException("zero-length OID");\n\t\t}\n\t\tint v = objBuf[valOff];\n\t\tif (v >= 120) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid OID: first byte = " + v);\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.Append(v / 40);\n\t\tsb.Append(\'.\');\n\t\tsb.Append(v % 40);\n\t\tlong acc = 0;\n\t\tbool uv = false;\n\t\tfor (int i = 1; i < valLen; i ++) {\n\t\t\tv = objBuf[valOff + i];\n\t\t\tif ((acc >> 56) != 0) {\n\t\t\t\tthrow new AsnException(\n\t\t\t\t\t"invalid OID: integer overflow");\n\t\t\t}\n\t\t\tacc = (acc << 7) + (long)(v & 0x7F);\n\t\t\tif ((v & 0x80) == 0) {\n\t\t\t\tsb.Append(\'.\');\n\t\t\t\tsb.Append(acc);\n\t\t\t\tacc = 0;\n\t\t\t\tuv = false;\n\t\t\t} else {\n\t\t\t\tuv = true;\n\t\t\t}\n\t\t}\n\t\tif (uv) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid OID: truncated");\n\t\t}\n\t\treturn sb.ToString();\n\t}\n\n\t/*\n\t * Get the object value as a string. The string type is inferred\n\t * from the tag.\n\t */\n\tpublic string GetString()\n\t{\n\t\tif (TagClass != UNIVERSAL) {\n\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t"cannot infer string type: {0}:{1}",\n\t\t\t\tTagClass, TagValue));\n\t\t}\n\t\treturn GetString(TagValue);\n\t}\n\n\t/*\n\t * Get the object value as a string. The string type is provided\n\t * (universal tag value). Supported string types include\n\t * NumericString, PrintableString, IA5String, TeletexString\n\t * (interpreted as ISO-8859-1), UTF8String, BMPString and\n\t * UniversalString; the "time types" (UTCTime and GeneralizedTime)\n\t * are also supported, though, in their case, the internal\n\t * contents are not checked (they are decoded as PrintableString).\n\t */\n\tpublic string GetString(int type)\n\t{\n\t\tif (Constructed) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid string (constructed)");\n\t\t}\n\t\tswitch (type) {\n\t\tcase NumericString:\n\t\tcase PrintableString:\n\t\tcase IA5String:\n\t\tcase TeletexString:\n\t\tcase UTCTime:\n\t\tcase GeneralizedTime:\n\t\t\treturn DecodeMono(objBuf, valOff, valLen, type);\n\t\tcase UTF8String:\n\t\t\treturn DecodeUTF8(objBuf, valOff, valLen);\n\t\tcase BMPString:\n\t\t\treturn DecodeUTF16(objBuf, valOff, valLen);\n\t\tcase UniversalString:\n\t\t\treturn DecodeUTF32(objBuf, valOff, valLen);\n\t\tdefault:\n\t\t\tthrow new AsnException(\n\t\t\t\t"unsupported string type: " + type);\n\t\t}\n\t}\n\n\tstatic string DecodeMono(byte[] buf, int off, int len, int type)\n\t{\n\t\tchar[] tc = new char[len];\n\t\tfor (int i = 0; i < len; i ++) {\n\t\t\ttc[i] = (char)buf[off + i];\n\t\t}\n\t\tVerifyChars(tc, type);\n\t\treturn new string(tc);\n\t}\n\n\tstatic string DecodeUTF8(byte[] buf, int off, int len)\n\t{\n\t\t/*\n\t\t * Skip BOM.\n\t\t */\n\t\tif (len >= 3 && buf[off] == 0xEF\n\t\t\t&& buf[off + 1] == 0xBB && buf[off + 2] == 0xBF)\n\t\t{\n\t\t\toff += 3;\n\t\t\tlen -= 3;\n\t\t}\n\t\tchar[] tc = null;\n\t\tfor (int k = 0; k < 2; k ++) {\n\t\t\tint tcOff = 0;\n\t\t\tfor (int i = 0; i < len; i ++) {\n\t\t\t\tint c = buf[off + i];\n\t\t\t\tint e;\n\t\t\t\tif (c < 0x80) {\n\t\t\t\t\te = 0;\n\t\t\t\t} else if (c < 0xC0) {\n\t\t\t\t\tthrow BadByte(c, UTF8String);\n\t\t\t\t} else if (c < 0xE0) {\n\t\t\t\t\tc &= 0x1F;\n\t\t\t\t\te = 1;\n\t\t\t\t} else if (c < 0xF0) {\n\t\t\t\t\tc &= 0x0F;\n\t\t\t\t\te = 2;\n\t\t\t\t} else if (c < 0xF8) {\n\t\t\t\t\tc &= 0x07;\n\t\t\t\t\te = 3;\n\t\t\t\t} else {\n\t\t\t\t\tthrow BadByte(c, UTF8String);\n\t\t\t\t}\n\t\t\t\twhile (e -- > 0) {\n\t\t\t\t\tif (++ i >= len) {\n\t\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t\t"invalid UTF-8 string");\n\t\t\t\t\t}\n\t\t\t\t\tint d = buf[off + i];\n\t\t\t\t\tif (d < 0x80 || d > 0xBF) {\n\t\t\t\t\t\tthrow BadByte(d, UTF8String);\n\t\t\t\t\t}\n\t\t\t\t\tc = (c << 6) + (d & 0x3F);\n\t\t\t\t}\n\t\t\t\tif (c > 0x10FFFF) {\n\t\t\t\t\tthrow BadChar(c, UTF8String);\n\t\t\t\t}\n\t\t\t\tif (c > 0xFFFF) {\n\t\t\t\t\tc -= 0x10000;\n\t\t\t\t\tint hi = 0xD800 + (c >> 10);\n\t\t\t\t\tint lo = 0xDC00 + (c & 0x3FF);\n\t\t\t\t\tif (tc != null) {\n\t\t\t\t\t\ttc[tcOff] = (char)hi;\n\t\t\t\t\t\ttc[tcOff + 1] = (char)lo;\n\t\t\t\t\t}\n\t\t\t\t\ttcOff += 2;\n\t\t\t\t} else {\n\t\t\t\t\tif (tc != null) {\n\t\t\t\t\t\ttc[tcOff] = (char)c;\n\t\t\t\t\t}\n\t\t\t\t\ttcOff ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tc == null) {\n\t\t\t\ttc = new char[tcOff];\n\t\t\t}\n\t\t}\n\t\tVerifyChars(tc, UTF8String);\n\t\treturn new string(tc);\n\t}\n\n\tstatic string DecodeUTF16(byte[] buf, int off, int len)\n\t{\n\t\tif ((len & 1) != 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid UTF-16 string: length = " + len);\n\t\t}\n\t\tlen >>= 1;\n\t\tif (len == 0) {\n\t\t\treturn "";\n\t\t}\n\t\tbool be = true;\n\t\tint hi = buf[off];\n\t\tint lo = buf[off + 1];\n\t\tif (hi == 0xFE && lo == 0xFF) {\n\t\t\toff += 2;\n\t\t\tlen --;\n\t\t} else if (hi == 0xFF && lo == 0xFE) {\n\t\t\toff += 2;\n\t\t\tlen --;\n\t\t\tbe = false;\n\t\t}\n\t\tchar[] tc = new char[len];\n\t\tfor (int i = 0; i < len; i ++) {\n\t\t\tint b0 = buf[off ++];\n\t\t\tint b1 = buf[off ++];\n\t\t\tif (be) {\n\t\t\t\ttc[i] = (char)((b0 << 8) + b1);\n\t\t\t} else {\n\t\t\t\ttc[i] = (char)((b1 << 8) + b0);\n\t\t\t}\n\t\t}\n\t\tVerifyChars(tc, BMPString);\n\t\treturn new string(tc);\n\t}\n\n\tstatic string DecodeUTF32(byte[] buf, int off, int len)\n\t{\n\t\tif ((len & 3) != 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid UTF-32 string: length = " + len);\n\t\t}\n\t\tlen >>= 2;\n\t\tif (len == 0) {\n\t\t\treturn "";\n\t\t}\n\t\tbool be = true;\n\t\tif (buf[off] == 0x00\n\t\t\t&& buf[off + 1] == 0x00\n\t\t\t&& buf[off + 2] == 0xFE\n\t\t\t&& buf[off + 3] == 0xFF)\n\t\t{\n\t\t\toff += 4;\n\t\t\tlen --;\n\t\t} else if (buf[off] == 0xFF\n\t\t\t&& buf[off + 1] == 0xFE\n\t\t\t&& buf[off + 2] == 0x00\n\t\t\t&& buf[off + 3] == 0x00)\n\t\t{\n\t\t\toff += 4;\n\t\t\tlen --;\n\t\t\tbe = false;\n\t\t}\n\n\t\tchar[] tc = null;\n\t\tfor (int k = 0; k < 2; k ++) {\n\t\t\tint tcOff = 0;\n\t\t\tfor (int i = 0; i < len; i ++) {\n\t\t\t\tuint b0 = buf[off + 0];\n\t\t\t\tuint b1 = buf[off + 1];\n\t\t\t\tuint b2 = buf[off + 2];\n\t\t\t\tuint b3 = buf[off + 3];\n\t\t\t\tuint c;\n\t\t\t\tif (be) {\n\t\t\t\t\tc = (b0 << 24) | (b1 << 16)\n\t\t\t\t\t\t| (b2 << 8) | b3;\n\t\t\t\t} else {\n\t\t\t\t\tc = (b3 << 24) | (b2 << 16)\n\t\t\t\t\t\t| (b1 << 8) | b0;\n\t\t\t\t}\n\t\t\t\tif (c > 0x10FFFF) {\n\t\t\t\t\tthrow BadChar((int)c, UniversalString);\n\t\t\t\t}\n\t\t\t\tif (c > 0xFFFF) {\n\t\t\t\t\tc -= 0x10000;\n\t\t\t\t\tint hi = 0xD800 + (int)(c >> 10);\n\t\t\t\t\tint lo = 0xDC00 + (int)(c & 0x3FF);\n\t\t\t\t\tif (tc != null) {\n\t\t\t\t\t\ttc[tcOff] = (char)hi;\n\t\t\t\t\t\ttc[tcOff + 1] = (char)lo;\n\t\t\t\t\t}\n\t\t\t\t\ttcOff += 2;\n\t\t\t\t} else {\n\t\t\t\t\tif (tc != null) {\n\t\t\t\t\t\ttc[tcOff] = (char)c;\n\t\t\t\t\t}\n\t\t\t\t\ttcOff ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tc == null) {\n\t\t\t\ttc = new char[tcOff];\n\t\t\t}\n\t\t}\n\t\tVerifyChars(tc, UniversalString);\n\t\treturn new string(tc);\n\t}\n\n\tstatic void VerifyChars(char[] tc, int type)\n\t{\n\t\tswitch (type) {\n\t\tcase NumericString:\n\t\t\tforeach (char c in tc) {\n\t\t\t\tif (!IsNum(c)) {\n\t\t\t\t\tthrow BadChar(c, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\tcase PrintableString:\n\t\tcase UTCTime:\n\t\tcase GeneralizedTime:\n\t\t\tforeach (char c in tc) {\n\t\t\t\tif (!IsPrintable(c)) {\n\t\t\t\t\tthrow BadChar(c, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\tcase IA5String:\n\t\t\tforeach (char c in tc) {\n\t\t\t\tif (!IsIA5(c)) {\n\t\t\t\t\tthrow BadChar(c, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\tcase TeletexString:\n\t\t\tforeach (char c in tc) {\n\t\t\t\tif (!IsLatin1(c)) {\n\t\t\t\t\tthrow BadChar(c, type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For Unicode string types (UTF-8, BMP...).\n\t\t */\n\t\tfor (int i = 0; i < tc.Length; i ++) {\n\t\t\tint c = tc[i];\n\t\t\tif (c >= 0xFDD0 && c <= 0xFDEF) {\n\t\t\t\tthrow BadChar(c, type);\n\t\t\t}\n\t\t\tif (c == 0xFFFE || c == 0xFFFF) {\n\t\t\t\tthrow BadChar(c, type);\n\t\t\t}\n\t\t\tif (c < 0xD800 || c > 0xDFFF) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c > 0xDBFF) {\n\t\t\t\tthrow BadChar(c, type);\n\t\t\t}\n\t\t\tint hi = c & 0x3FF;\n\t\t\tif (++ i >= tc.Length) {\n\t\t\t\tthrow BadChar(c, type);\n\t\t\t}\n\t\t\tc = tc[i];\n\t\t\tif (c < 0xDC00 || c > 0xDFFF) {\n\t\t\t\tthrow BadChar(c, type);\n\t\t\t}\n\t\t\tint lo = c & 0x3FF;\n\t\t\tc = 0x10000 + lo + (hi << 10);\n\t\t\tif ((c & 0xFFFE) == 0xFFFE) {\n\t\t\t\tthrow BadChar(c, type);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic bool IsNum(int c)\n\t{\n\t\treturn c == \' \' || (c >= \'0\' && c <= \'9\');\n\t}\n\n\tinternal static bool IsPrintable(int c)\n\t{\n\t\tif (c >= \'A\' && c <= \'Z\') {\n\t\t\treturn true;\n\t\t}\n\t\tif (c >= \'a\' && c <= \'z\') {\n\t\t\treturn true;\n\t\t}\n\t\tif (c >= \'0\' && c <= \'9\') {\n\t\t\treturn true;\n\t\t}\n\t\tswitch (c) {\n\t\tcase \' \': case \'(\': case \')\': case \'+\':\n\t\tcase \',\': case \'-\': case \'.\': case \'/\':\n\t\tcase \':\': case \'=\': case \'?\': case \'\\\'\':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic bool IsIA5(int c)\n\t{\n\t\treturn c < 128;\n\t}\n\n\tstatic bool IsLatin1(int c)\n\t{\n\t\treturn c < 256;\n\t}\n\n\tstatic AsnException BadByte(int c, int type)\n\t{\n\t\treturn new AsnException(String.Format(\n\t\t\t"unexpected byte 0x{0:X2} in string of type {1}",\n\t\t\tc, type));\n\t}\n\n\tstatic AsnException BadChar(int c, int type)\n\t{\n\t\treturn new AsnException(String.Format(\n\t\t\t"unexpected character U+{0:X4} in string of type {1}",\n\t\t\tc, type));\n\t}\n\n\t/*\n\t * Decode the value as a date/time. Returned object is in UTC.\n\t * Type of date is inferred from the tag value.\n\t */\n\tpublic DateTime GetTime()\n\t{\n\t\tif (TagClass != UNIVERSAL) {\n\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t"cannot infer date type: {0}:{1}",\n\t\t\t\tTagClass, TagValue));\n\t\t}\n\t\treturn GetTime(TagValue);\n\t}\n\n\t/*\n\t * Decode the value as a date/time. Returned object is in UTC.\n\t * The time string type is provided as parameter (UTCTime or\n\t * GeneralizedTime).\n\t */\n\tpublic DateTime GetTime(int type)\n\t{\n\t\tbool isGen = false;\n\t\tswitch (type) {\n\t\tcase UTCTime:\n\t\t\tbreak;\n\t\tcase GeneralizedTime:\n\t\t\tisGen = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new AsnException(\n\t\t\t\t"unsupported date type: " + type);\n\t\t}\n\t\tstring s = GetString(type);\n\t\tstring orig = s;\n\n\t\t/*\n\t\t * UTCTime has format:\n\t\t *    YYMMDDhhmm[ss](Z|(+|-)hhmm)\n\t\t *\n\t\t * GeneralizedTime has format:\n\t\t *    YYYYMMDDhhmmss[.uu*][Z|(+|-)hhmm]\n\t\t *\n\t\t * Differences between the two types:\n\t\t * -- UTCTime encodes year over two digits; GeneralizedTime\n\t\t * uses four digits. UTCTime years map to 1950..2049 (00 is\n\t\t * 2000).\n\t\t * -- Seconds are optional with UTCTime, mandatory with\n\t\t * GeneralizedTime.\n\t\t * -- GeneralizedTime can have fractional seconds (optional).\n\t\t * -- Time zone is optional for GeneralizedTime. However,\n\t\t * a missing time zone means "local time" which depends on\n\t\t * the locality, so this is discouraged.\n\t\t *\n\t\t * Some other notes:\n\t\t * -- If there is a fractional second, then it must include\n\t\t * at least one digit. This implementation processes the\n\t\t * first three digits, and ignores the rest (if present).\n\t\t * -- Time zone offset ranges from -23:59 to +23:59.\n\t\t * -- The calendar computations are delegated to .NET\'s\n\t\t * DateTime (and DateTimeOffset) so this implements a\n\t\t * Gregorian calendar, even for dates before 1589. Year 0\n\t\t * is not supported.\n\t\t */\n\n\t\t/*\n\t\t * Check characters.\n\t\t */\n\t\tforeach (char c in s) {\n\t\t\tif (c >= \'0\' && c <= \'9\') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == \'.\' || c == \'+\' || c == \'-\' || c == \'Z\') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow BadTime(type, orig);\n\t\t}\n\n\t\tbool good = true;\n\n\t\t/*\n\t\t * Parse the time zone.\n\t\t */\n\t\tint tzHours = 0;\n\t\tint tzMinutes = 0;\n\t\tbool negZ = false;\n\t\tbool noTZ = false;\n\t\tif (s.EndsWith("Z")) {\n\t\t\ts = s.Substring(0, s.Length - 1);\n\t\t} else {\n\t\t\tint j = s.IndexOf(\'+\');\n\t\t\tif (j < 0) {\n\t\t\t\tj = s.IndexOf(\'-\');\n\t\t\t\tnegZ = true;\n\t\t\t}\n\t\t\tif (j < 0) {\n\t\t\t\tnoTZ = true;\n\t\t\t} else {\n\t\t\t\tstring t = s.Substring(j + 1);\n\t\t\t\ts = s.Substring(0, j);\n\t\t\t\tif (t.Length != 4) {\n\t\t\t\t\tthrow BadTime(type, orig);\n\t\t\t\t}\n\t\t\t\ttzHours = Dec2(t, 0, ref good);\n\t\t\t\ttzMinutes = Dec2(t, 2, ref good);\n\t\t\t\tif (tzHours < 0 || tzHours > 23\n\t\t\t\t\t|| tzMinutes < 0 || tzMinutes > 59)\n\t\t\t\t{\n\t\t\t\t\tthrow BadTime(type, orig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Lack of time zone is allowed only for GeneralizedTime.\n\t\t */\n\t\tif (noTZ && !isGen) {\n\t\t\tthrow BadTime(type, orig);\n\t\t}\n\n\t\t/*\n\t\t * Parse the date elements.\n\t\t */\n\t\tif (s.Length < 4) {\n\t\t\tthrow BadTime(type, orig);\n\t\t}\n\t\tint year = Dec2(s, 0, ref good);\n\t\tif (isGen) {\n\t\t\tyear = year * 100 + Dec2(s, 2, ref good);\n\t\t\ts = s.Substring(4);\n\t\t} else {\n\t\t\tif (year < 50) {\n\t\t\t\tyear += 100;\n\t\t\t}\n\t\t\tyear += 1900;\n\t\t\ts = s.Substring(2);\n\t\t}\n\t\tint month = Dec2(s, 0, ref good);\n\t\tint day = Dec2(s, 2, ref good);\n\t\tint hour = Dec2(s, 4, ref good);\n\t\tint minute = Dec2(s, 6, ref good);\n\t\tint second = 0;\n\t\tint millisecond = 0;\n\t\tif (isGen) {\n\t\t\tsecond = Dec2(s, 8, ref good);\n\t\t\tif (s.Length >= 12 && s[10] == \'.\') {\n\t\t\t\ts = s.Substring(11);\n\t\t\t\tforeach (char c in s) {\n\t\t\t\t\tif (c < \'0\' || c > \'9\') {\n\t\t\t\t\t\tgood = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts += "0000";\n\t\t\t\tmillisecond = 10 * Dec2(s, 0, ref good)\n\t\t\t\t\t+ Dec2(s, 2, ref good) / 10;\n\t\t\t} else if (s.Length != 10) {\n\t\t\t\tgood = false;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (s.Length) {\n\t\t\tcase 8:\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tsecond = Dec2(s, 8, ref good);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow BadTime(type, orig);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Parsing is finished; if any error occurred, then\n\t\t * the \'good\' flag has been cleared.\n\t\t */\n\t\tif (!good) {\n\t\t\tthrow BadTime(type, orig);\n\t\t}\n\n\t\t/*\n\t\t * Leap seconds are not supported by .NET, so we claim\n\t\t * they do not occur.\n\t\t */\n\t\tif (second == 60) {\n\t\t\tsecond = 59;\n\t\t}\n\n\t\t/*\n\t\t * .NET implementation performs all the checks (including\n\t\t * checks on month length depending on year, as per the\n\t\t * proleptic Gregorian calendar).\n\t\t */\n\t\ttry {\n\t\t\tif (noTZ) {\n\t\t\t\tDateTime dt = new DateTime(year, month, day,\n\t\t\t\t\thour, minute, second, millisecond,\n\t\t\t\t\tDateTimeKind.Local);\n\t\t\t\treturn dt.ToUniversalTime();\n\t\t\t}\n\t\t\tTimeSpan tzOff = new TimeSpan(tzHours, tzMinutes, 0);\n\t\t\tif (negZ) {\n\t\t\t\ttzOff = tzOff.Negate();\n\t\t\t}\n\t\t\tDateTimeOffset dto = new DateTimeOffset(\n\t\t\t\tyear, month, day, hour, minute, second,\n\t\t\t\tmillisecond, tzOff);\n\t\t\treturn dto.UtcDateTime;\n\t\t} catch (Exception e) {\n\t\t\tthrow BadTime(type, orig, e);\n\t\t}\n\t}\n\n\tstatic int Dec2(string s, int off, ref bool good)\n\t{\n\t\tif (off < 0 || off >= (s.Length - 1)) {\n\t\t\tgood = false;\n\t\t\treturn -1;\n\t\t}\n\t\tchar c1 = s[off];\n\t\tchar c2 = s[off + 1];\n\t\tif (c1 < \'0\' || c1 > \'9\' || c2 < \'0\' || c2 > \'9\') {\n\t\t\tgood = false;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 10 * (c1 - \'0\') + (c2 - \'0\');\n\t}\n\n\tstatic AsnException BadTime(int type, string s)\n\t{\n\t\treturn BadTime(type, s, null);\n\t}\n\n\tstatic AsnException BadTime(int type, string s, Exception e)\n\t{\n\t\tstring tt = (type == UTCTime) ? "UTCTime" : "GeneralizedTime";\n\t\tstring msg = String.Format("invalid {0} string: \'{1}\'", tt, s);\n\t\tif (e == null) {\n\t\t\treturn new AsnException(msg);\n\t\t} else {\n\t\t\treturn new AsnException(msg, e);\n\t\t}\n\t}\n\n\t/* =============================================================== */\n\n\t/*\n\t * Create a new element for a primitive value. The provided buffer\n\t * is internally copied.\n\t */\n\tpublic static AsnElt MakePrimitive(int tagValue, byte[] val)\n\t{\n\t\treturn MakePrimitive(UNIVERSAL, tagValue, val, 0, val.Length);\n\t}\n\n\t/*\n\t * Create a new element for a primitive value. The provided buffer\n\t * is internally copied.\n\t */\n\tpublic static AsnElt MakePrimitive(int tagValue,\n\t\tbyte[] val, int off, int len)\n\t{\n\t\treturn MakePrimitive(UNIVERSAL, tagValue, val, off, len);\n\t}\n\n\t/*\n\t * Create a new element for a primitive value. The provided buffer\n\t * is internally copied.\n\t */\n\tpublic static AsnElt MakePrimitive(\n\t\tint tagClass, int tagValue, byte[] val)\n\t{\n\t\treturn MakePrimitive(tagClass, tagValue, val, 0, val.Length);\n\t}\n\n\t/*\n\t * Create a new element for a primitive value. The provided buffer\n\t * is internally copied.\n\t */\n\tpublic static AsnElt MakePrimitive(int tagClass, int tagValue,\n\t\tbyte[] val, int off, int len)\n\t{\n\t\tbyte[] nval = new byte[len];\n\t\tArray.Copy(val, off, nval, 0, len);\n\t\treturn MakePrimitiveInner(tagClass, tagValue, nval, 0, len);\n\t}\n\n\t/*\n\t * Like MakePrimitive(), but the provided array is NOT copied.\n\t * This is for other factory methods that already allocate a\n\t * new array.\n\t */\n\tstatic AsnElt MakePrimitiveInner(int tagValue, byte[] val)\n\t{\n\t\treturn MakePrimitiveInner(UNIVERSAL, tagValue,\n\t\t\tval, 0, val.Length);\n\t}\n\n\tstatic AsnElt MakePrimitiveInner(int tagValue,\n\t\tbyte[] val, int off, int len)\n\t{\n\t\treturn MakePrimitiveInner(UNIVERSAL, tagValue, val, off, len);\n\t}\n\n\tstatic AsnElt MakePrimitiveInner(int tagClass, int tagValue, byte[] val)\n\t{\n\t\treturn MakePrimitiveInner(tagClass, tagValue,\n\t\t\tval, 0, val.Length);\n\t}\n\n\tstatic AsnElt MakePrimitiveInner(int tagClass, int tagValue,\n\t\tbyte[] val, int off, int len)\n\t{\n\t\tAsnElt a = new AsnElt();\n\t\ta.objBuf = new byte[len];\n\t\tArray.Copy(val, off, a.objBuf, 0, len);\n\t\ta.objOff = 0;\n\t\ta.objLen = -1;\n\t\ta.valOff = 0;\n\t\ta.valLen = len;\n\t\ta.hasEncodedHeader = false;\n\t\tif (tagClass < 0 || tagClass > 3) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid tag class: " + tagClass);\n\t\t}\n\t\tif (tagValue < 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid tag value: " + tagValue);\n\t\t}\n\t\ta.TagClass = tagClass;\n\t\ta.TagValue = tagValue;\n\t\ta.Sub = null;\n\t\treturn a;\n\t}\n\n\t/*\n\t * Create a new INTEGER value for the provided integer.\n\t */\n\tpublic static AsnElt MakeInteger(long x)\n\t{\n\t\tif (x >= 0) {\n\t\t\treturn MakeInteger((ulong)x);\n\t\t}\n\t\tint k = 1;\n\t\tfor (long w = x; w <= -(long)0x80; w >>= 8) {\n\t\t\tk ++;\n\t\t}\n\t\tbyte[] v = new byte[k];\n\t\tfor (long w = x; k > 0; w >>= 8) {\n\t\t\tv[-- k] = (byte)w;\n\t\t}\n\t\treturn MakePrimitiveInner(INTEGER, v);\n\t}\n\n\t/*\n\t * Create a new INTEGER value for the provided integer.\n\t */\n\tpublic static AsnElt MakeInteger(ulong x)\n\t{\n\t\tint k = 1;\n\t\tfor (ulong w = x; w >= 0x80; w >>= 8) {\n\t\t\tk ++;\n\t\t}\n\t\tbyte[] v = new byte[k];\n\t\tfor (ulong w = x; k > 0; w >>= 8) {\n\t\t\tv[-- k] = (byte)w;\n\t\t}\n\t\treturn MakePrimitiveInner(INTEGER, v);\n\t}\n\n\t/*\n\t * Create a new INTEGER value for the provided integer. The x[]\n\t * array uses _unsigned_ big-endian encoding.\n\t */\n\tpublic static AsnElt MakeInteger(byte[] x)\n\t{\n\t\tint xLen = x.Length;\n\t\tint j = 0;\n\t\twhile (j < xLen && x[j] == 0x00) {\n\t\t\tj ++;\n\t\t}\n\t\tif (j == xLen) {\n\t\t\treturn MakePrimitiveInner(INTEGER, new byte[] { 0x00 });\n\t\t}\n\t\tbyte[] v;\n\t\tif (x[j] < 0x80) {\n\t\t\tv = new byte[xLen - j];\n\t\t\tArray.Copy(x, j, v, 0, v.Length);\n\t\t} else {\n\t\t\tv = new byte[1 + xLen - j];\n\t\t\tArray.Copy(x, j, v, 1, v.Length - 1);\n\t\t}\n\t\treturn MakePrimitiveInner(INTEGER, v);\n\t}\n\n\t/*\n\t * Create a new INTEGER value for the provided integer. The x[]\n\t * array uses _signed_ big-endian encoding.\n\t */\n\tpublic static AsnElt MakeIntegerSigned(byte[] x)\n\t{\n\t\tint xLen = x.Length;\n\t\tif (xLen == 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"Invalid signed integer (empty)");\n\t\t}\n\t\tint j = 0;\n\t\tif (x[0] >= 0x80) {\n\t\t\twhile (j < (xLen - 1)\n\t\t\t\t&& x[j] == 0xFF\n\t\t\t\t&& x[j + 1] >= 0x80)\n\t\t\t{\n\t\t\t\tj ++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (j < (xLen - 1)\n\t\t\t\t&& x[j] == 0x00\n\t\t\t\t&& x[j + 1] < 0x80)\n\t\t\t{\n\t\t\t\tj ++;\n\t\t\t}\n\t\t}\n\t\tbyte[] v = new byte[xLen - j];\n\t\tArray.Copy(x, j, v, 0, v.Length);\n\t\treturn MakePrimitiveInner(INTEGER, v);\n\t}\n\n\t/*\n\t * Create a BIT STRING from the provided value. The number of\n\t * "unused bits" is set to 0.\n\t */\n\tpublic static AsnElt MakeBitString(byte[] buf)\n\t{\n\t\treturn MakeBitString(buf, 0, buf.Length);\n\t}\n\n\tpublic static AsnElt MakeBitString(byte[] buf, int off, int len)\n\t{\n\t\tbyte[] tmp = new byte[len + 1];\n\t\tArray.Copy(buf, off, tmp, 1, len);\n\t\treturn MakePrimitiveInner(BIT_STRING, tmp);\n\t}\n\n\t/*\n\t * Create a BIT STRING from the provided value. The number of\n\t * "unused bits" is specified.\n\t */\n\tpublic static AsnElt MakeBitString(int unusedBits, byte[] buf)\n\t{\n\t\treturn MakeBitString(unusedBits, buf, 0, buf.Length);\n\t}\n\n\tpublic static AsnElt MakeBitString(int unusedBits,\n\t\tbyte[] buf, int off, int len)\n\t{\n\t\tif (unusedBits < 0 || unusedBits > 7\n\t\t\t|| (unusedBits != 0 && len == 0))\n\t\t{\n\t\t\tthrow new AsnException(\n\t\t\t\t"Invalid number of unused bits in BIT STRING: "\n\t\t\t\t+ unusedBits);\n\t\t}\n\t\tbyte[] tmp = new byte[len + 1];\n\t\ttmp[0] = (byte)unusedBits;\n\t\tArray.Copy(buf, off, tmp, 1, len);\n\t\tif (len > 0) {\n\t\t\ttmp[len - 1] &= (byte)(0xFF << unusedBits);\n\t\t}\n\t\treturn MakePrimitiveInner(BIT_STRING, tmp);\n\t}\n\n\t/*\n\t * Create an OCTET STRING from the provided value.\n\t */\n\tpublic static AsnElt MakeBlob(byte[] buf)\n\t{\n\t\treturn MakeBlob(buf, 0, buf.Length);\n\t}\n\n\tpublic static AsnElt MakeBlob(byte[] buf, int off, int len)\n\t{\n\t\treturn MakePrimitive(OCTET_STRING, buf, off, len);\n\t}\n\n\t/*\n\t * Create a new constructed elements, by providing the relevant\n\t * sub-elements.\n\t */\n\tpublic static AsnElt Make(int tagValue, params AsnElt[] subs)\n\t{\n\t\treturn Make(UNIVERSAL, tagValue, subs);\n\t}\n\n\t/*\n\t * Create a new constructed elements, by providing the relevant\n\t * sub-elements.\n\t */\n\tpublic static AsnElt Make(int tagClass, int tagValue,\n\t\tparams AsnElt[] subs)\n\t{\n\t\tAsnElt a = new AsnElt();\n\t\ta.objBuf = null;\n\t\ta.objOff = 0;\n\t\ta.objLen = -1;\n\t\ta.valOff = 0;\n\t\ta.valLen = -1;\n\t\ta.hasEncodedHeader = false;\n\t\tif (tagClass < 0 || tagClass > 3) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid tag class: " + tagClass);\n\t\t}\n\t\tif (tagValue < 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid tag value: " + tagValue);\n\t\t}\n\t\ta.TagClass = tagClass;\n\t\ta.TagValue = tagValue;\n\t\tif (subs == null) {\n\t\t\ta.Sub = new AsnElt[0];\n\t\t} else {\n\t\t\ta.Sub = new AsnElt[subs.Length];\n\t\t\tArray.Copy(subs, 0, a.Sub, 0, subs.Length);\n\t\t}\n\t\treturn a;\n\t}\n\n\t/*\n\t * Create a SET OF: sub-elements are automatically sorted by\n\t * lexicographic order of their DER encodings. Identical elements\n\t * are merged.\n\t */\n\tpublic static AsnElt MakeSetOf(params AsnElt[] subs)\n\t{\n\t\tAsnElt a = new AsnElt();\n\t\ta.objBuf = null;\n\t\ta.objOff = 0;\n\t\ta.objLen = -1;\n\t\ta.valOff = 0;\n\t\ta.valLen = -1;\n\t\ta.hasEncodedHeader = false;\n\t\ta.TagClass = UNIVERSAL;\n\t\ta.TagValue = SET;\n\t\tif (subs == null) {\n\t\t\ta.Sub = new AsnElt[0];\n\t\t} else {\n\t\t\tSortedDictionary<byte[], AsnElt> d =\n\t\t\t\tnew SortedDictionary<byte[], AsnElt>(\n\t\t\t\t\tCOMPARER_LEXICOGRAPHIC);\n\t\t\tforeach (AsnElt ax in subs) {\n\t\t\t\td[ax.Encode()] = ax;\n\t\t\t}\n\t\t\tAsnElt[] tmp = new AsnElt[d.Count];\n\t\t\tint j = 0;\n\t\t\tforeach (AsnElt ax in d.Values) {\n\t\t\t\ttmp[j ++] = ax;\n\t\t\t}\n\t\t\ta.Sub = tmp;\n\t\t}\n\t\treturn a;\n\t}\n\n\tstatic IComparer<byte[]> COMPARER_LEXICOGRAPHIC =\n\t\tnew ComparerLexicographic();\n\n\tclass ComparerLexicographic : IComparer<byte[]> {\n\n\t\tpublic int Compare(byte[] x, byte[] y)\n\t\t{\n\t\t\tint xLen = x.Length;\n\t\t\tint yLen = y.Length;\n\t\t\tint cLen = Math.Min(xLen, yLen);\n\t\t\tfor (int i = 0; i < cLen; i ++) {\n\t\t\t\tif (x[i] != y[i]) {\n\t\t\t\t\treturn (int)x[i] - (int)y[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn xLen - yLen;\n\t\t}\n\t}\n\n\t/*\n\t * Wrap an element into an explicit tag.\n\t */\n\tpublic static AsnElt MakeExplicit(int tagClass, int tagValue, AsnElt x)\n\t{\n\t\treturn Make(tagClass, tagValue, x);\n\t}\n\n\t/*\n\t * Wrap an element into an explicit CONTEXT tag.\n\t */\n\tpublic static AsnElt MakeExplicit(int tagValue, AsnElt x)\n\t{\n\t\treturn Make(CONTEXT, tagValue, x);\n\t}\n\n\t/*\n\t * Apply an implicit tag to a value. The source AsnElt object\n\t * is unmodified; a new object is returned.\n\t */\n\tpublic static AsnElt MakeImplicit(int tagClass, int tagValue, AsnElt x)\n\t{\n\t\tif (x.Constructed) {\n\t\t\treturn Make(tagClass, tagValue, x.Sub);\n\t\t}\n\t\tAsnElt a = new AsnElt();\n\t\ta.objBuf = x.GetValue(out a.valOff, out a.valLen);\n\t\ta.objOff = 0;\n\t\ta.objLen = -1;\n\t\ta.hasEncodedHeader = false;\n\t\ta.TagClass = tagClass;\n\t\ta.TagValue = tagValue;\n\t\ta.Sub = null;\n\t\treturn a;\n\t}\n\n\tpublic static AsnElt NULL_V = AsnElt.MakePrimitive(\n\t\tNULL, new byte[0]);\n\n\tpublic static AsnElt BOOL_TRUE = AsnElt.MakePrimitive(\n\t\tBOOLEAN, new byte[] { 0xFF });\n\tpublic static AsnElt BOOL_FALSE = AsnElt.MakePrimitive(\n\t\tBOOLEAN, new byte[] { 0x00 });\n\n\t/*\n\t * Create an OBJECT IDENTIFIER from its string representation.\n\t * This function tolerates extra leading zeros.\n\t */\n\tpublic static AsnElt MakeOID(string str)\n\t{\n\t\tList<long> r = new List<long>();\n\t\tint n = str.Length;\n\t\tlong x = -1;\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tint c = str[i];\n\t\t\tif (c == \'.\') {\n\t\t\t\tif (x < 0) {\n\t\t\t\t\tthrow new AsnException(\n\t\t\t\t\t\t"invalid OID (empty element)");\n\t\t\t\t}\n\t\t\t\tr.Add(x);\n\t\t\t\tx = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c < \'0\' || c > \'9\') {\n\t\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t\t"invalid character U+{0:X4} in OID",\n\t\t\t\t\tc));\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t} else if (x > ((Int64.MaxValue - 9) / 10)) {\n\t\t\t\tthrow new AsnException("OID element overflow");\n\t\t\t}\n\t\t\tx = x * (long)10 + (long)(c - \'0\');\n\t\t}\n\t\tif (x < 0) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid OID (empty element)");\n\t\t}\n\t\tr.Add(x);\n\t\tif (r.Count < 2) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid OID (not enough elements)");\n\t\t}\n\t\tif (r[0] > 2 || r[1] > 40) {\n\t\t\tthrow new AsnException(\n\t\t\t\t"invalid OID (first elements out of range)");\n\t\t}\n\n\t\tMemoryStream ms = new MemoryStream();\n\t\tms.WriteByte((byte)(40 * (int)r[0] + (int)r[1]));\n\t\tfor (int i = 2; i < r.Count; i ++) {\n\t\t\tlong v = r[i];\n\t\t\tif (v < 0x80) {\n\t\t\t\tms.WriteByte((byte)v);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k = -7;\n\t\t\tfor (long w = v; w != 0; w >>= 7, k += 7);\n\t\t\tms.WriteByte((byte)(0x80 + (int)(v >> k)));\n\t\t\tfor (k -= 7; k >= 0; k -= 7) {\n\t\t\t\tint z = (int)(v >> k) & 0x7F;\n\t\t\t\tif (k > 0) {\n\t\t\t\t\tz |= 0x80;\n\t\t\t\t}\n\t\t\t\tms.WriteByte((byte)z);\n\t\t\t}\n\t\t}\n\t\tbyte[] buf = ms.ToArray();\n\t\treturn MakePrimitiveInner(OBJECT_IDENTIFIER,\n\t\t\tbuf, 0, buf.Length);\n\t}\n\n\t/*\n\t * Create a string of the provided type and contents. The string\n\t * type is a universal tag value for one of the string or time\n\t * types.\n\t */\n\tpublic static AsnElt MakeString(int type, string str)\n\t{\n\t\tVerifyChars(str.ToCharArray(), type);\n\t\tbyte[] buf;\n\t\tswitch (type) {\n\t\tcase NumericString:\n\t\tcase PrintableString:\n\t\tcase UTCTime:\n\t\tcase GeneralizedTime:\n\t\tcase IA5String:\n\t\tcase TeletexString:\n\t\tcase GeneralString:\n\t\t\tbuf = EncodeMono(str);\n\t\t\tbreak;\n\t\tcase UTF8String:\n\t\t\tbuf = EncodeUTF8(str);\n\t\t\tbreak;\n\t\tcase BMPString:\n\t\t\tbuf = EncodeUTF16(str);\n\t\t\tbreak;\n\t\tcase UniversalString:\n\t\t\tbuf = EncodeUTF32(str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new AsnException(\n\t\t\t\t"unsupported string type: " + type);\n\t\t}\n\t\treturn MakePrimitiveInner(type, buf);\n\t}\n\n\tstatic byte[] EncodeMono(string str)\n\t{\n\t\tbyte[] r = new byte[str.Length];\n\t\tint k = 0;\n\t\tforeach (char c in str) {\n\t\t\tr[k ++] = (byte)c;\n\t\t}\n\t\treturn r;\n\t}\n\n\t/*\n\t * Get the code point at offset \'off\' in the string. Either one\n\t * or two \'char\' slots are used; \'off\' is updated accordingly.\n\t */\n\tstatic int CodePoint(string str, ref int off)\n\t{\n\t\tint c = str[off ++];\n\t\tif (c >= 0xD800 && c < 0xDC00 && off < str.Length) {\n\t\t\tint d = str[off];\n\t\t\tif (d >= 0xDC00 && d < 0xE000) {\n\t\t\t\tc = ((c & 0x3FF) << 10)\n\t\t\t\t\t+ (d & 0x3FF) + 0x10000;\n\t\t\t\toff ++;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\tstatic byte[] EncodeUTF8(string str)\n\t{\n\t\tint k = 0;\n\t\tint n = str.Length;\n\t\tMemoryStream ms = new MemoryStream();\n\t\twhile (k < n) {\n\t\t\tint cp = CodePoint(str, ref k);\n\t\t\tif (cp < 0x80) {\n\t\t\t\tms.WriteByte((byte)cp);\n\t\t\t} else if (cp < 0x800) {\n\t\t\t\tms.WriteByte((byte)(0xC0 + (cp >> 6)));\n\t\t\t\tms.WriteByte((byte)(0x80 + (cp & 63)));\n\t\t\t} else if (cp < 0x10000) {\n\t\t\t\tms.WriteByte((byte)(0xE0 + (cp >> 12)));\n\t\t\t\tms.WriteByte((byte)(0x80 + ((cp >> 6) & 63)));\n\t\t\t\tms.WriteByte((byte)(0x80 + (cp & 63)));\n\t\t\t} else {\n\t\t\t\tms.WriteByte((byte)(0xF0 + (cp >> 18)));\n\t\t\t\tms.WriteByte((byte)(0x80 + ((cp >> 12) & 63)));\n\t\t\t\tms.WriteByte((byte)(0x80 + ((cp >> 6) & 63)));\n\t\t\t\tms.WriteByte((byte)(0x80 + (cp & 63)));\n\t\t\t}\n\t\t}\n\t\treturn ms.ToArray();\n\t}\n\n\tstatic byte[] EncodeUTF16(string str)\n\t{\n\t\tbyte[] buf = new byte[str.Length << 1];\n\t\tint k = 0;\n\t\tforeach (char c in str) {\n\t\t\tbuf[k ++] = (byte)(c >> 8);\n\t\t\tbuf[k ++] = (byte)c;\n\t\t}\n\t\treturn buf;\n\t}\n\n\tstatic byte[] EncodeUTF32(string str)\n\t{\n\t\tint k = 0;\n\t\tint n = str.Length;\n\t\tMemoryStream ms = new MemoryStream();\n\t\twhile (k < n) {\n\t\t\tint cp = CodePoint(str, ref k);\n\t\t\tms.WriteByte((byte)(cp >> 24));\n\t\t\tms.WriteByte((byte)(cp >> 16));\n\t\t\tms.WriteByte((byte)(cp >> 8));\n\t\t\tms.WriteByte((byte)cp);\n\t\t}\n\t\treturn ms.ToArray();\n\t}\n\n\t/*\n\t * Create a time value of the specified type (UTCTime or\n\t * GeneralizedTime).\n\t */\n\tpublic static AsnElt MakeTime(int type, DateTime dt)\n\t{\n\t\tdt = dt.ToUniversalTime();\n\t\tstring str;\n\t\tswitch (type) {\n\t\tcase UTCTime:\n\t\t\tint year = dt.Year;\n\t\t\tif (year < 1950 || year >= 2050) {\n\t\t\t\tthrow new AsnException(String.Format(\n\t\t\t\t\t"cannot encode year {0} as UTCTime",\n\t\t\t\t\tyear));\n\t\t\t}\n\t\t\tyear = year % 100;\n\t\t\tstr = String.Format(\n\t\t\t\t"{0:d2}{1:d2}{2:d2}{3:d2}{4:d2}{5:d2}Z",\n\t\t\t\tyear, dt.Month, dt.Day,\n\t\t\t\tdt.Hour, dt.Minute, dt.Second);\n\t\t\tbreak;\n\t\tcase GeneralizedTime:\n\t\t\tstr = String.Format(\n\t\t\t\t"{0:d4}{1:d2}{2:d2}{3:d2}{4:d2}{5:d2}",\n\t\t\t\tdt.Year, dt.Month, dt.Day,\n\t\t\t\tdt.Hour, dt.Minute, dt.Second);\n\t\t\tint millis = dt.Millisecond;\n\t\t\tif (millis != 0) {\n\t\t\t\tif (millis % 100 == 0) {\n\t\t\t\t\tstr = String.Format("{0}.{1:d1}",\n\t\t\t\t\t\tstr, millis / 100);\n\t\t\t\t} else if (millis % 10 == 0) {\n\t\t\t\t\tstr = String.Format("{0}.{1:d2}",\n\t\t\t\t\t\tstr, millis / 10);\n\t\t\t\t} else {\n\t\t\t\t\tstr = String.Format("{0}.{1:d3}",\n\t\t\t\t\t\tstr, millis);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr = str + "Z";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new AsnException(\n\t\t\t\t"unsupported time type: " + type);\n\t\t}\n\t\treturn MakeString(type, str);\n\t}\n\n\t/*\n\t * Create a time value of the specified type (UTCTime or\n\t * GeneralizedTime).\n\t */\n\tpublic static AsnElt MakeTime(int type, DateTimeOffset dto)\n\t{\n\t\treturn MakeTime(type, dto.UtcDateTime);\n\t}\n\n\t/*\n\t * Create a time value with an automatic type selection\n\t * (UTCTime if year is in the 1950..2049 range, GeneralizedTime\n\t * otherwise).\n\t */\n\tpublic static AsnElt MakeTimeAuto(DateTime dt)\n\t{\n\t\tdt = dt.ToUniversalTime();\n\t\treturn MakeTime((dt.Year >= 1950 && dt.Year <= 2049)\n\t\t\t? UTCTime : GeneralizedTime, dt);\n\t}\n\n\t/*\n\t * Create a time value with an automatic type selection\n\t * (UTCTime if year is in the 1950..2049 range, GeneralizedTime\n\t * otherwise).\n\t */\n\tpublic static AsnElt MakeTimeAuto(DateTimeOffset dto)\n\t{\n\t\treturn MakeTimeAuto(dto.UtcDateTime);\n\t}\n}\n\n}\n'