b'{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Hoodle.ModelAction.ContextMenu where\n\nimport qualified Data.ByteString.Char8 as B\nimport Data.Hoodle.BBox (BBox (..))\nimport Data.Hoodle.Simple (Dimension (..), SVG (..))\nimport Data.UUID.V4 (nextRandom)\nimport Graphics.Hoodle.Render (renderRItem)\nimport Graphics.Hoodle.Render.Type\n  ( CanvasId,\n    RItem,\n    RenderCache,\n    isLinkInRItem,\n  )\nimport qualified Graphics.Rendering.Cairo as Cairo\nimport qualified Graphics.UI.Gtk as Gtk\nimport Hoodle.Type.Event\n  ( AllEvent (UsrEv),\n    ContextMenuEvent (..),\n    UserEvent (GotContextMenuSignal, OpenLink),\n  )\nimport Hoodle.Util (UrlPath (FileUrl, HttpUrl))\nimport System.Directory\n  ( getTemporaryDirectory,\n    removeFile,\n  )\nimport System.FilePath ((<.>), (</>))\n\n-- |\nmenuOpenALink :: (AllEvent -> IO ()) -> UrlPath -> IO Gtk.MenuItem\nmenuOpenALink evhandler urlpath = do\n  let urlname = case urlpath of\n        FileUrl fp -> fp\n        HttpUrl url -> url\n  menuitemlnk <- Gtk.menuItemNewWithLabel ("Open " ++ urlname :: String)\n  _ <- menuitemlnk `Gtk.on` Gtk.menuItemActivate $ evhandler (UsrEv (OpenLink urlpath Nothing))\n  return menuitemlnk\n\n-- |\nmenuCreateALink :: (AllEvent -> IO ()) -> [RItem] -> IO (Maybe Gtk.MenuItem)\nmenuCreateALink evhandler sitems =\n  if not (any isLinkInRItem sitems)\n    then do\n      mi <- Gtk.menuItemNewWithLabel ("Create a link to..." :: String)\n      _ <-\n        mi `Gtk.on` Gtk.menuItemActivate $\n          evhandler (UsrEv (GotContextMenuSignal CMenuCreateALink))\n      return (Just mi)\n    else return Nothing\n\n-- |\nmakeSVGFromSelection :: RenderCache -> CanvasId -> [RItem] -> BBox -> IO SVG\nmakeSVGFromSelection cache cid hititms (BBox (ulx, uly) (lrx, lry)) = do\n  uuid <- nextRandom\n  tdir <- getTemporaryDirectory\n  let filename = tdir </> show uuid <.> "svg"\n      (x, y) = (ulx, uly)\n      (w, h) = (lrx - ulx, lry - uly)\n  Cairo.withSVGSurface filename w h $ \\s -> Cairo.renderWith s $ do\n    Cairo.translate (-ulx) (-uly)\n    mapM_ (renderRItem cache cid) hititms\n  bstr <- B.readFile filename\n  let svg = SVG Nothing Nothing bstr (x, y) (Dim w h)\n  svg `seq` removeFile filename\n  return svg\n'