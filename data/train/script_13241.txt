b"module Hoodle.Coroutine.Eraser where\n\nimport Control.Lens (over, set, view, (.~))\nimport Control.Monad ((>=>))\nimport Control.Monad.State (get, liftIO)\nimport qualified Control.Monad.State as St\nimport Data.Hoodle.Generic\n  ( gitems,\n    gpages,\n  )\nimport qualified Data.IntMap as IM\nimport Graphics.Hoodle.Render (updateLayerBuf)\nimport Graphics.Hoodle.Render.Type.Item (RItem)\nimport Graphics.Hoodle.Render.Util.HitTest\n  ( hltHittedByLineRough,\n    hltItmsHittedByLineFrmSelectedStateT,\n  )\nimport Hoodle.Accessor\n  ( getCurrentPageCvsId,\n    rItmsInCurrLyr,\n  )\nimport Hoodle.Coroutine.Commit (commit)\nimport Hoodle.Coroutine.Draw\n  ( callRenderer_,\n    invalidateAll,\n    invalidateInBBox,\n    nextevent,\n  )\nimport Hoodle.Coroutine.Pen\n  ( commonPenStart,\n    penMoveAndUpOnly,\n  )\nimport Hoodle.Device (PointerCoord)\nimport Hoodle.ModelAction.Eraser (eraseHitted)\nimport Hoodle.ModelAction.Layer\n  ( adjustCurrentLayer,\n    getCurrentLayer,\n  )\nimport Hoodle.ModelAction.Page (updatePageAll)\nimport Hoodle.Type.Canvas\n  ( CanvasId,\n    CanvasInfo (..),\n    currentPageNum,\n    forBoth',\n    unboxBiAct,\n  )\nimport Hoodle.Type.Coroutine (MainCoroutine)\nimport Hoodle.Type.Enum (DrawFlag (Efficient))\nimport Hoodle.Type.Event (UserEvent)\nimport Hoodle.Type.HoodleState\n  ( HoodleModeState (ViewAppendState, unView),\n    HoodleState,\n    currentUnit,\n    getCanvasInfo,\n    hoodleModeState,\n    unitHoodles,\n  )\nimport Hoodle.Type.PageArrangement (PageNum (..))\nimport Hoodle.View.Coordinate (CanvasGeometry)\n\n-- |\neraserStart ::\n  CanvasId ->\n  PointerCoord ->\n  MainCoroutine ()\neraserStart cid = commonPenStart eraserAction cid >=> const (return ())\n  where\n    eraserAction _cinfo pnum geometry (x, y) _ = do\n      itms <- rItmsInCurrLyr\n      eraserProcess cid pnum geometry itms (x, y)\n\n-- |\neraserProcess ::\n  CanvasId ->\n  PageNum ->\n  CanvasGeometry ->\n  [RItem] ->\n  (Double, Double) ->\n  MainCoroutine ()\neraserProcess cid pnum geometry itms (x0, y0) = do\n  r <- nextevent\n  xst <- get\n  forBoth' unboxBiAct (f r xst) . getCanvasInfo cid . view (unitHoodles . currentUnit) $ xst\n  where\n    f :: UserEvent -> HoodleState -> CanvasInfo a -> MainCoroutine ()\n    f r xstate cvsInfo =\n      penMoveAndUpOnly\n        r\n        pnum\n        geometry\n        defact\n        (moveact xstate cvsInfo)\n        upact\n    defact = eraserProcess cid pnum geometry itms (x0, y0)\n    upact _ = invalidateAll\n    moveact xstate cvsInfo (_pcoord, (x, y)) = do\n      let line = ((x0, y0), (x, y))\n          hittestbbox = hltHittedByLineRough line itms\n          (hittestitem, hitState) =\n            St.runState (hltItmsHittedByLineFrmSelectedStateT line hittestbbox) False\n      if hitState\n        then do\n          page <- getCurrentPageCvsId cid\n          let uhdl = view (unitHoodles . currentUnit) xstate\n              currhdl = unView . view hoodleModeState $ uhdl\n              pgnum = view currentPageNum cvsInfo\n              currlayer = getCurrentLayer page\n          let (newitms, _maybebbox) = St.runState (eraseHitted hittestitem) Nothing\n              newlayerbbox = set gitems newitms currlayer\n          callRenderer_ $ updateLayerBuf cid newlayerbbox\n          let newpagebbox = adjustCurrentLayer newlayerbbox page\n              newhdlbbox = over gpages (IM.adjust (const newpagebbox) pgnum) currhdl\n              newhdlmodst = ViewAppendState newhdlbbox\n          uhdl' <- liftIO (updatePageAll newhdlmodst uhdl)\n          commit $ (unitHoodles . currentUnit .~ (hoodleModeState .~ newhdlmodst) uhdl') xstate\n          invalidateInBBox Nothing Efficient cid\n          nitms <- rItmsInCurrLyr\n          eraserProcess cid pnum geometry nitms (x, y)\n        else eraserProcess cid pnum geometry itms (x, y)\n"