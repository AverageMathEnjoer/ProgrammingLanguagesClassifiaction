b'// UVa1606 Amphiphilic Carbon Molecules\n// Rujia Liu\n// To make life a bit easier, we change each color 1 point into color 0.\n// Then we only need to find an angle interval with most points. See code for details.\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 1000 + 5;\n\nstruct Point {\n  int x, y;\n  double rad; // with respect to current point\n  bool operator<(const Point &rhs) const {\n    return rad < rhs.rad;\n  }\n}op[maxn], p[maxn];\n\nint n, color[maxn];\n\n// from O-A to O-B, is it a left turn?\nbool Left(Point A, Point B) {\n  return A.x * B.y - A.y * B.x >= 0;\n}\n\nint solve() {\n  if(n <= 2) return 2;\n  int ans = 0;\n\n  // pivot point\n  for(int i = 0; i < n; i++) {\n    int k = 0;\n\n    // the list of other point, sorted in increasing order of rad\n    for(int j = 0; j < n; j++)\n      if(j != i) {\n        p[k].x = op[j].x - op[i].x;\n        p[k].y = op[j].y - op[i].y;\n        if(color[j]) { p[k].x = -p[k].x; p[k].y = -p[k].y; }\n        p[k].rad = atan2(p[k].y, p[k].x);\n        k++;\n      }\n    sort(p, p+k);\n\n    // sweeping. cnt is the number of points whose rad is between p[L] and p[R]\n    int L = 0, R = 0, cnt = 2;\n    while(L < k) {\n      if(R == L) { R = (R+1)%k; cnt++; } // empty interval\n      while(R != L && Left(p[L], p[R])) { R = (R+1)%k; cnt++; } // stop when [L,R] spans across > 180 degrees\n      cnt--;\n      L++;\n      ans = max(ans, cnt);\n    }\n  }\n  return ans;\n}\n\nint main() {\n  while(scanf("%d", &n) == 1 && n) {\n    for(int i = 0; i < n; i++)\n      scanf("%d%d%d", &op[i].x, &op[i].y, &color[i]);\n    printf("%d\\n", solve());\n  }\n  return 0;\n}\n'