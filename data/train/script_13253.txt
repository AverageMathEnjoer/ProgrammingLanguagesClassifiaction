b'{-# LANGUAGE CPP #-}\n#if !defined(TESTING) && defined(__GLASGOW_HASKELL__)\n{-# LANGUAGE Safe #-}\n#endif\n\n#include "containers.h"\n\n-----------------------------------------------------------------------------\n-- |\n-- Module      :  Data.Set\n-- Copyright   :  (c) Daan Leijen 2002\n-- License     :  BSD-style\n-- Maintainer  :  libraries@haskell.org\n-- Portability :  portable\n--\n--\n-- = Finite Sets\n--\n-- The @\'Set\' e@ type represents a set of elements of type @e@. Most operations\n-- require that @e@ be an instance of the \'Ord\' class. A \'Set\' is strict in its\n-- elements.\n--\n-- For a walkthrough of the most commonly used functions see the\n-- <https://haskell-containers.readthedocs.io/en/latest/set.html sets introduction>.\n--\n-- Note that the implementation is generally /left-biased/. Functions that take\n-- two sets as arguments and combine them, such as `union` and `intersection`,\n-- prefer the entries in the first argument to those in the second. Of course,\n-- this bias can only be observed when equality is an equivalence relation\n-- instead of structural equality.\n--\n-- These modules are intended to be imported qualified, to avoid name\n-- clashes with Prelude functions, e.g.\n--\n-- >  import Data.Set (Set)\n-- >  import qualified Data.Set as Set\n--\n--\n-- == Warning\n--\n-- The size of the set must not exceed @maxBound::Int@. Violation of\n-- this condition is not detected and if the size limit is exceeded, its\n-- behaviour is undefined.\n--\n--\n-- == Implementation\n--\n-- The implementation of \'Set\' is based on /size balanced/ binary trees (or\n-- trees of /bounded balance/) as described by:\n--\n--    * Stephen Adams, \\"/Efficient sets: a balancing act/\\",\n--      Journal of Functional Programming 3(4):553-562, October 1993,\n--      <http://www.swiss.ai.mit.edu/~adams/BB/>.\n--    * J. Nievergelt and E.M. Reingold,\n--      \\"/Binary search trees of bounded balance/\\",\n--      SIAM journal of computing 2(1), March 1973.\n--\n--  Bounds for \'union\', \'intersection\', and \'difference\' are as given\n--  by\n--\n--    * Guy Blelloch, Daniel Ferizovic, and Yihan Sun,\n--      \\"/Just Join for Parallel Ordered Sets/\\",\n--      <https://arxiv.org/abs/1602.02120v3>.\n--\n-----------------------------------------------------------------------------\n\nmodule Data.Set (\n            -- * Set type\n#if !defined(TESTING)\n              Set          -- instance Eq,Ord,Show,Read,Data\n#else\n              Set(..)\n#endif\n\n            -- * Construction\n            , empty\n            , singleton\n            , fromList\n            , fromAscList\n            , fromDescList\n            , fromDistinctAscList\n            , fromDistinctDescList\n            , powerSet\n\n            -- * Insertion\n            , insert\n\n            -- * Deletion\n            , delete\n\n            -- * Generalized insertion/deletion\n\n            , alterF\n\n            -- * Query\n            , member\n            , notMember\n            , lookupLT\n            , lookupGT\n            , lookupLE\n            , lookupGE\n            , S.null\n            , size\n            , isSubsetOf\n            , isProperSubsetOf\n            , disjoint\n\n            -- * Combine\n            , union\n            , unions\n            , difference\n            , (\\\\)\n            , intersection\n            , cartesianProduct\n            , disjointUnion\n\n            -- * Filter\n            , S.filter\n            , takeWhileAntitone\n            , dropWhileAntitone\n            , spanAntitone\n            , partition\n            , split\n            , splitMember\n            , splitRoot\n\n            -- * Indexed\n            , lookupIndex\n            , findIndex\n            , elemAt\n            , deleteAt\n            , S.take\n            , S.drop\n            , S.splitAt\n\n            -- * Map\n            , S.map\n            , mapMonotonic\n\n            -- * Folds\n            , S.foldr\n            , S.foldl\n            -- ** Strict folds\n            , foldr\'\n            , foldl\'\n            -- ** Legacy folds\n            , fold\n\n            -- * Min\\/Max\n            , lookupMin\n            , lookupMax\n            , findMin\n            , findMax\n            , deleteMin\n            , deleteMax\n            , deleteFindMin\n            , deleteFindMax\n            , maxView\n            , minView\n\n            -- * Conversion\n\n            -- ** List\n            , elems\n            , toList\n            , toAscList\n            , toDescList\n\n            -- * Debugging\n            , showTree\n            , showTreeWith\n            , valid\n\n#if defined(TESTING)\n            -- Internals (for testing)\n            , bin\n            , balanced\n            , link\n            , merge\n#endif\n            ) where\n\nimport Data.Set.Internal as S\n'