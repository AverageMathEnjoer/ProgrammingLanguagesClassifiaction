b'module Database.Beam.Migrate.Tool.Migrate where\n\nimport           Database.Beam.Migrate.Backend\nimport           Database.Beam.Migrate.Tool.Backend\nimport           Database.Beam.Migrate.Tool.CmdLine\nimport           Database.Beam.Migrate.Tool.Diff\nimport           Database.Beam.Migrate.Tool.Registry\nimport           Database.Beam.Migrate.Tool.Status\n\nimport           Control.Applicative\nimport           Control.Monad\nimport qualified Control.Monad.Fail as Fail\n\nimport qualified Data.ByteString.Char8 as BS\nimport           Data.Char as Char\nimport           Data.Graph.Inductive.Graph\nimport qualified Data.Graph.Inductive.Query as Gr\nimport           Data.List (find)\nimport           Data.List.Split (splitWhen)\nimport           Data.String\nimport           Data.Text (Text)\nimport qualified Data.Text as T\nimport           Data.UUID (UUID)\n\nimport           System.IO\nimport           System.Console.ANSI\n\ndata MigrateDDLCommand cmd\n  = MigrateDDLCommandBeam BS.ByteString cmd\n  | MigrateDDLCommandRaw BS.ByteString\n  deriving Show\n\ndata CLIMigration cmd = CLIMigration Text [MigrateDDLCommand cmd]\n\nshowCommands :: [CLIMigration cmd] -> IO ()\nshowCommands cmds = do\n  putStrLn "The following commands will be run, in order:"\n\n  forM_ (zip [1..] cmds) $ \\(i, CLIMigration stepDescr cmds) ->\n    do putStrLn (yellow ("Step " ++ show i ++ ": " ++ T.unpack stepDescr))\n       forM_ (zip [1..] cmds) $ \\(cmdIdx, cmd) ->\n         case cmd of\n           MigrateDDLCommandRaw rawCmd ->\n             putStrLn (green ("  " ++ show cmdIdx) ++ ": " ++ BS.unpack rawCmd)\n           MigrateDDLCommandBeam rawCmd _ ->\n             putStrLn (green ("  " ++ show cmdIdx) ++ ": " ++ BS.unpack rawCmd)\n       putStrLn ""\n\n  where\n    yellow x = setSGRCode [ SetColor Foreground Dull Yellow ] ++ x ++ setSGRCode [ Reset ]\n    green x = setSGRCode [ SetColor Foreground Dull Green ] ++ x ++ setSGRCode [ Reset ]\n\ngetSchemaCommandsForBackend :: Fail.MonadFail m\n                            => MigrationRegistry -> Maybe (BeamMigrationBackend be m)\n                            -> UUID -> IO [ MigrateDDLCommand cmd ]\ngetSchemaCommandsForBackend reg Nothing id = fail "Asked to get haskell schema"\ngetSchemaCommandsForBackend reg (Just be@(BeamMigrationBackend {})) commitId =\n  do let path = schemaFilePathForBackend (Just (SomeBeamMigrationBackend be)) reg commitId\n     cmdData <- BS.lines <$> BS.readFile path\n\n     let cmds = fmap (fst . BS.spanEnd isSpace . BS.dropWhile isSpace . BS.unlines) $\n                filter (any (not . BS.null)) $ -- Ensure every command contains something\n                splitWhen ("--" `BS.isPrefixOf`) cmdData\n\n     pure (fmap MigrateDDLCommandRaw cmds)\n\ndoMigrateDatabase :: MigrateCmdLine -> Bool -> IO ()\ndoMigrateDatabase MigrateCmdLine { migrateDatabase = Nothing } _ =\n  fail "No database specified"\ndoMigrateDatabase cmdLine@MigrateCmdLine { migrateDatabase = Just dbName } script = do\n  registry <- lookupRegistry cmdLine\n  db <- lookupDb registry cmdLine\n\n  let destCommit = registryHeadCommit registry\n\n  sts <- getStatus cmdLine registry dbName\n  (_, _, SomeBeamMigrationBackend be@(BeamMigrationBackend {} :: BeamMigrationBackend be m)) <-\n    loadBackend cmdLine registry dbName\n\n  cmds <-\n    case sts of\n      MigrateStatusNoCommits False -> fail "The beam-migrate schema does not exist in this database"\n      MigrateStatusNoCommits True -> do\n        putStrLn "This database has no history."\n        putStrLn ("Migrating database to " ++ show destCommit)\n\n        let backendFmt = MigrationFormatBackend (unModuleName (migrationDbBackend db))\n\n            schema = lookupSchema destCommit [ backendFmt ] registry <|>\n                     lookupSchema destCommit [ MigrationFormatHaskell ] registry\n\n        case schema of\n          Nothing -> fail ("No schema for " ++ show destCommit ++ " in backend " ++ unModuleName (migrationDbBackend db))\n          Just sch -> do\n            -- TODO user should be able to override this choice\n            backend <- if backendFmt `elem` registeredSchemaInfoFormats sch\n                       then do\n                         putStrLn "Using native backend"\n                         pure (Just be)\n                       else do\n                         putStrLn "Using Haskell beam-migrate backend"\n                         pure Nothing\n\n            Just . pure . CLIMigration (fromString ("Initial import of schema " ++ show destCommit)) <$>\n              getSchemaCommandsForBackend registry backend destCommit\n\n      MigrateStatusAtBranch srcCommit _ (PredicateDiff expected actual)\n        | expected /= actual -> fail "The database does not match its current schema (TODO add --fix option)"\n        | otherwise -> do\n            let migrations = registryMigrationGraph registry\n\n                findMigration commit = fst <$> find (\\(_, s) -> registeredSchemaInfoHash s == commit) (labNodes migrations)\n\n            case (,) <$> findMigration srcCommit\n                     <*> findMigration  destCommit of\n              Nothing -> fail "Can\'t find schemas"\n              Just (sourceNode, destNode)\n                  | sourceNode == destNode -> do\n                      putStrLn "The database is already up-to-date with HEAD"\n                      pure Nothing\n                  | otherwise ->\n                      case unLPath (Gr.lesp sourceNode destNode migrations) of\n                        [] -> do\n                          hPutStr stderr . unlines $\n                            [ "There is no migration between " ++ show srcCommit ++\n                              " and " ++ show destCommit\n                            , ""\n                            , "You can ask beam to generate one for you automatically, by running \'beam-migrate migration new --auto"\n                            , "Alternatively, you can run \'beam-migrate migrate --manual\', to write a custom migration script"\n                            ]\n                          fail "No possible migration"\n                        path -> fail ("Migrating " ++ show path)\n\n  -- Now run all the commands, which are given as bytestrings\n  case cmds of\n    Nothing -> putStrLn "No migration being performed"\n    Just cmds\' -> do\n      showCommands cmds\'\n\n  putStrLn ("Should I run these commands?")\n  ack <- getLine\n\n  if fmap Char.toLower ack /= "yes"\n    then fail "Exiting due to user request..."\n    else do\n      putStrLn "Would run commands"\n'