b'using System.Diagnostics;\n\nnamespace CS_SQLite3\n{\n  public partial class CSSQLite\n  {\n    /*\n    ** 2004 May 22\n    **\n    ** The author disclaims copyright to this source code.  In place of\n    ** a legal notice, here is a blessing:\n    **\n    **    May you do good and not evil.\n    **    May you find forgiveness for yourself and forgive others.\n    **    May you share freely, never taking more than you give.\n    **\n    ******************************************************************************\n    **\n    ** This file contains macros and a little bit of code that is common to\n    ** all of the platform-specific files (os_*.c) and is #included into those\n    ** files.\n    **\n    ** This file should be #included by the os_*.c files only.  It is not a\n    ** general purpose header file.\n    **\n    ** $Id: os_common.h,v 1.38 2009/02/24 18:40:50 danielk1977 Exp $\n    **\n    *************************************************************************\n    **  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart\n    **  C#-SQLite is an independent reimplementation of the SQLite software library\n    **\n    **  $Header$\n    *************************************************************************\n    */\n    //#if !_OS_COMMON_H_\n    //#define _OS_COMMON_H_\n    /*\n    ** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n    ** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n    ** switch.  The following code should catch this problem at compile-time.\n    */\n#if MEMORY_DEBUG\n//# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."\n#endif\n\n#if SQLITE_DEBUG || TRACE\n    static bool sqlite3OsTrace = false;\n    static void OSTRACE1( string X ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X ); }\n    static void OSTRACE2( string X, object Y ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y ); }\n    static void OSTRACE3( string X, object Y, object Z ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z ); }\n    static void OSTRACE4( string X, object Y, object Z, object A ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A ); }\n    static void OSTRACE5( string X, object Y, object Z, object A, object B ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A, B ); }\n    static void OSTRACE6( string X, object Y, object Z, object A, object B, object C ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A, B, C ); }\n    static void OSTRACE7( string X, object Y, object Z, object A, object B, object C, object D ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A, B, C, D ); }\n#else\n//#define OSTRACE1(X)\n//#define OSTRACE2(X,Y)\n//#define OSTRACE3(X,Y,Z)\n//#define OSTRACE4(X,Y,Z,A)\n//#define OSTRACE5(X,Y,Z,A,B)\n//#define OSTRACE6(X,Y,Z,A,B,C)\n//#define OSTRACE7(X,Y,Z,A,B,C,D)\n#endif\n\n    /*\n** Macros for performance tracing.  Normally turned off.  Only works\n** on i486 hardware.\n*/\n#if SQLITE_PERFORMANCE_TRACE\n\n/*\n** hwtime.h contains inline assembler code for implementing\n** high-performance timing routines.\n*/\n//#include "hwtime.h"\n\nstatic sqlite_u3264 g_start;\nstatic sqlite_u3264 g_elapsed;\n//#define TIMER_START       g_start=sqlite3Hwtime()\n//#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n//#define TIMER_ELAPSED     g_elapsed\n#else\n    const int TIMER_START = 0;   //#define TIMER_START\n    const int TIMER_END = 0;     //#define TIMER_END\n    const int TIMER_ELAPSED = 0; //#define TIMER_ELAPSED     ((sqlite_u3264)0)\n#endif\n\n    /*\n** If we compile with the SQLITE_TEST macro set, then the following block\n** of code will give us the ability to simulate a disk I/O error.  This\n** is used for testing the I/O recovery logic.\n*/\n#if SQLITE_TEST\n\n    //static int sqlite3_io_error_hit = 0;            /* Total number of I/O Errors */\n    //static int sqlite3_io_error_hardhit = 0;        /* Number of non-benign errors */\n    //static int sqlite3_io_error_pending = 0;        /* Count down to first I/O error */\n    //static int sqlite3_io_error_persist = 0;        /* True if I/O errors persist */\n    static int sqlite3_io_error_benign = 0;         /* True if errors are benign */\n    //static int sqlite3_diskfull_pending = 0;\n    //static int sqlite3_diskfull = 0;\n    static void SimulateIOErrorBenign( int X ) { sqlite3_io_error_benign = ( X ); }\n    //#define SimulateIOError(CODE)  \\\n    //  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n    //       || sqlite3_io_error_pending-- == 1 )  \\\n    //              { local_ioerr(); CODE; }\n    static bool SimulateIOError()\n    {\n      if ( ( sqlite3_io_error_persist.iValue != 0 && sqlite3_io_error_hit.iValue != 0 )\n      || sqlite3_io_error_pending.iValue-- == 1 )\n      {\n        local_ioerr();\n        return true;\n      }\n      return false;\n    }\n\n    static void local_ioerr()\n    {\n#if TRACE\n      IOTRACE( "IOERR\\n" );\n#endif\n      sqlite3_io_error_hit.iValue++;\n      if ( sqlite3_io_error_benign == 0 ) sqlite3_io_error_hardhit.iValue++;\n    }\n    //#define SimulateDiskfullError(CODE) \\\n    //   if( sqlite3_diskfull_pending ){ \\\n    //     if( sqlite3_diskfull_pending == 1 ){ \\\n    //       local_ioerr(); \\\n    //       sqlite3_diskfull = 1; \\\n    //       sqlite3_io_error_hit = 1; \\\n    //       CODE; \\\n    //     }else{ \\\n    //       sqlite3_diskfull_pending--; \\\n    //     } \\\n    //   }\n    static bool SimulateDiskfullError()\n    {\n      if ( sqlite3_diskfull_pending.iValue != 0 )\n      {\n        if ( sqlite3_diskfull_pending.iValue == 1 )\n        {\n          local_ioerr();\n          sqlite3_diskfull.iValue = 1;\n          sqlite3_io_error_hit.iValue = 1;\n          return true;\n        }\n        else\n        {\n          sqlite3_diskfull_pending.iValue--;\n        }\n      }\n      return false;\n    }\n#else\n//#define SimulateIOErrorBenign(X)\n//#define SimulateIOError(A)\n//#define SimulateDiskfullError(A)\n#endif\n\n    /*\n** When testing, keep a count of the number of open files.\n*/\n#if SQLITE_TEST\n    //int sqlite3_open_file_count = 0;\n    static void OpenCounter( int X )\n    {\n      sqlite3_open_file_count.iValue += ( X );\n    }\n#else\n//#define OpenCounter(X)\n#endif\n    //#endif //* !_OS_COMMON_H_) */\n  }\n}\n'