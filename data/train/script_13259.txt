b'{-# LANGUAGE\n    DataKinds\n  , RankNTypes\n  , ScopedTypeVariables\n  , TypeFamilies\n  #-}\n-- | Combinators for specifying the input/output dictionaries of a\n-- \'Handler\'. The combinators can be combined using @(@\'.\'@)@.\nmodule Rest.Dictionary.Combinators\n  (\n  -- ** Input dictionaries\n\n    stringI\n  , xmlTextI\n  , fileI\n  , readI\n  , xmlI\n  , rawXmlI\n  , jsonI\n  , rawJsonI\n  , rawJsonAndXmlI\n\n  -- ** Output dictionaries\n\n  , stringO\n  , fileO\n  , xmlO\n  , rawXmlO\n  , jsonO\n  , rawJsonO\n  , rawJsonAndXmlO\n  , multipartO\n\n  -- ** Error dictionaries\n\n  , jsonE\n  , xmlE\n\n  -- ** Composed dictionaries\n\n  , xmlJsonI\n  , xmlJsonO\n  , xmlJsonE\n  , xmlJson\n\n  -- ** Header dictionaries\n\n  , mkHeader\n  , addHeader\n\n  -- ** Parameter dictionaries\n\n  , mkPar\n  , addPar\n\n  -- ** Deprecated\n\n  , someI\n  , someO\n  , someE\n  ) where\n\nimport Prelude hiding (id, (.))\n\nimport Control.Category\nimport Data.Aeson\nimport Data.ByteString.Lazy (ByteString)\nimport Data.JSON.Schema\nimport Data.Text.Lazy (Text)\nimport Data.Typeable\nimport Network.Multipart (BodyPart)\nimport Text.XML.HXT.Arrow.Pickle\nimport qualified Data.Label.Total as L\n\nimport Rest.Dictionary.Types\nimport Rest.Info\nimport Rest.Types.Error\n\n-- | Set custom sub-dictionary for recognizing headers.\n\nmkHeader :: Header h -> Dict x p i o e -> Dict h p i o e\nmkHeader = L.set headers\n\n-- | Add custom sub-dictionary for recognizing headers.\n\naddHeader :: Header h -> Dict h\' p i o e -> Dict (h, h\') p i o e\naddHeader = L.modify headers . TwoHeaders\n\n-- | Set custom sub-dictionary for recognizing parameters.\n\nmkPar :: Param p -> Dict h x i o e -> Dict h p i o e\nmkPar = L.set params\n\n-- | Add custom sub-dictionary for recognizing parameters.\n\naddPar :: Param p -> Dict h p\' i o e -> Dict h (p, p\') i o e\naddPar = L.modify params . TwoParams\n\n-- | Open up input type for extension with custom dictionaries.\n\n{-# DEPRECATED someI "This can be safely removed, it is now just the identity." #-}\nsomeI :: Dict h p i o e -> Dict h p i o e\nsomeI = id\n\n-- | Allow direct usage of as input as `String`.\n\nstringI :: Dict h p \'Nothing o e -> Dict h p (\'Just String) o e\nstringI = L.set inputs (Dicts [StringI])\n\n-- | Allow direct usage of as input as raw Xml `Text`.\n\nxmlTextI :: Dict h p \'Nothing o e -> Dict h p (\'Just Text) o e\nxmlTextI = L.set inputs (Dicts [XmlTextI])\n\n-- | Allow usage of input as file contents, represented as a `ByteString`.\n\nfileI :: Dict h p \'Nothing o e -> Dict h p (\'Just ByteString) o e\nfileI = L.set inputs (Dicts [FileI])\n\n-- | The input can be read into some instance of `Read`. For inspection reasons\n-- the type must also be an instance of both `Info` and `Show`.\n\nreadI :: (Info i, Read i, Show i, FromMaybe i i\' ~ i) => Dict h p i\' o e -> Dict h p (\'Just i) o e\nreadI = L.modify inputs (modDicts (ReadI:))\n\n-- | The input can be read into some instance of `XmlPickler`.\n\nxmlI :: (Typeable i, XmlPickler i, FromMaybe i i\' ~ i) => Dict h p i\' o e -> Dict h p (\'Just i) o e\nxmlI = L.modify inputs (modDicts (XmlI:))\n\n-- | The input can be used as an XML `ByteString`.\n\nrawXmlI :: Dict h p \'Nothing o e -> Dict h p (\'Just ByteString) o e\nrawXmlI = L.set inputs (Dicts [RawXmlI])\n\n-- | The input can be used as a JSON `ByteString`.\n\nrawJsonI :: Dict h p \'Nothing o e -> Dict h p (\'Just ByteString) o e\nrawJsonI = L.set inputs (Dicts [RawJsonI])\n\n-- | The input can be read into some instance of `Json`.\n\njsonI :: (Typeable i, FromJSON i, JSONSchema i, FromMaybe i i\' ~ i) => Dict h p i\' o e -> Dict h p (\'Just i) o e\njsonI = L.modify inputs (modDicts (JsonI:))\n\n-- | The input can be used as a JSON or XML `ByteString`.\n--\n-- An API client can send either format so the handler needs to handle both.\n\nrawJsonAndXmlI :: Dict h p \'Nothing o e -> Dict h p (\'Just (Either Json Xml)) o e\nrawJsonAndXmlI = L.set inputs (Dicts [RawJsonAndXmlI])\n\n-- | Open up output type for extension with custom dictionaries.\n\n{-# DEPRECATED someO "This can be safely removed, it is now just the identity." #-}\nsomeO :: Dict h p i o e -> Dict h p i o e\nsomeO = id\n\n-- | Allow output as plain String.\n\nstringO :: Dict h p i \'Nothing e -> Dict h p i (\'Just String) e\nstringO = L.set outputs (Dicts [StringO])\n\n-- | Allow file output using a combination of the raw data, the file\n-- name, and an attachment flag (causing the file to be downloaded by\n-- browsers instead of shown). The mime type will be determined from\n-- the file extension by your web server library, or\n-- "application/octet-stream" with an unknown extension.\n\nfileO :: Dict h p i \'Nothing e -> Dict h p i (\'Just (ByteString, String, Bool)) e\nfileO = L.set outputs (Dicts [FileO])\n\n-- | Allow output as XML using the `XmlPickler` type class.\n\nxmlO :: (Typeable o, XmlPickler o, FromMaybe o o\' ~ o) => Dict h p i o\' e -> Dict h p i (\'Just o) e\nxmlO = L.modify outputs (modDicts (XmlO:))\n\n-- | Allow output as raw XML represented as a `ByteString`.\n\nrawXmlO :: Dict h p i \'Nothing e -> Dict h p i (\'Just ByteString) e\nrawXmlO = L.set outputs (Dicts [RawXmlO])\n\n-- | Allow output as raw JSON represented as a `ByteString`.\n\nrawJsonO :: Dict h p i \'Nothing e -> Dict h p i (\'Just ByteString) e\nrawJsonO = L.set outputs (Dicts [RawJsonO])\n\n-- | Allow output as JSON using the `Json` type class.\n\njsonO :: (Typeable o, ToJSON o, JSONSchema o, FromMaybe o o\' ~ o) => Dict h p i o\' e -> Dict h p i (\'Just o) e\njsonO = L.modify outputs (modDicts (JsonO:))\n\n-- | Allow output as raw JSON and XML represented as `ByteString`s.\n-- Both values are needed since the accept header determines which one\n-- to send.\n\nrawJsonAndXmlO :: Dict h p i \'Nothing e -> Dict h p i (\'Just ByteString) e\nrawJsonAndXmlO = L.set outputs (Dicts [RawJsonAndXmlO])\n\n-- | Allow output as multipart. Writes out the ByteStrings separated\n-- by boundaries, with content type \'multipart/mixed\'.\n\nmultipartO :: Dict h p i \'Nothing e -> Dict h p i (\'Just [BodyPart]) e\nmultipartO = L.set outputs (Dicts [MultipartO])\n\n-- | Open up error type for extension with custom dictionaries.\n\n{-# DEPRECATED someE "This can be safely removed, it is now just the identity." #-}\nsomeE :: Dict h p i o e -> Dict h p i o e\nsomeE = id\n\n-- | Allow error output as JSON using the `Json` type class.\n\njsonE :: (ToResponseCode e, Typeable e, ToJSON e, JSONSchema e, FromMaybe e e\' ~ e) => Dict h p i o e\' -> Dict h p i o (\'Just e)\njsonE = L.modify errors (modDicts (JsonE:))\n\n-- | Allow error output as XML using the `XmlPickler` type class.\n\nxmlE :: (ToResponseCode e, Typeable e, XmlPickler e, FromMaybe e e\' ~ e) => Dict h p i o e\' -> Dict h p i o (\'Just e)\nxmlE = L.modify errors (modDicts (XmlE:))\n\n-- | The input can be read into some instance of both `Json` and `XmlPickler`.\n\nxmlJsonI :: (Typeable i, FromJSON i, JSONSchema i, XmlPickler i, FromMaybe i i\' ~ i) => Dict h p i\' o e -> Dict h p (\'Just i) o e\nxmlJsonI = xmlI . jsonI\n\n-- | Allow output as JSON using the `Json` type class and allow output as XML\n-- using the `XmlPickler` type class.\n\nxmlJsonO :: (Typeable o, ToJSON o, JSONSchema o, XmlPickler o, FromMaybe o o\' ~ o) => Dict h p i o\' e -> Dict h p i (\'Just o) e\nxmlJsonO = xmlO . jsonO\n\n-- | Allow error output as JSON using the `Json` type class and allow output as\n-- XML using the `XmlPickler` type class.\n\nxmlJsonE :: (ToResponseCode e, Typeable e, ToJSON e, JSONSchema e, XmlPickler e, FromMaybe e e\' ~ e) => Dict h p i o e\' -> Dict h p i o (\'Just e)\nxmlJsonE = xmlE . jsonE\n\n-- | The input can be read into some instance of both `Json` and `XmlPickler`\n-- and allow output as JSON using the `Json` type class and allow output as XML\n-- using the `XmlPickler` type class.\n\nxmlJson :: ( Typeable i, FromJSON i, JSONSchema i, XmlPickler i\n           , Typeable o, ToJSON o, JSONSchema o, XmlPickler o\n           , FromMaybe i i\' ~ i, FromMaybe o o\' ~ o\n           )\n        => Dict h p i\' o\' e -> Dict h p (\'Just i) (\'Just o) e\nxmlJson = xmlJsonI . xmlJsonO\n'