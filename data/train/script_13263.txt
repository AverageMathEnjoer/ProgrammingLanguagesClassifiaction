b'-- TODO: This file should be moved to hoodle-util.\n{- ORMOLU_DISABLE -}\n{-# Language CPP #-}\nmodule Hoodle.Util.Process where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Monad (when, (<=<))\nimport Control.Monad.Loops (untilM_)\nimport qualified Data.ByteString.Lazy as B\nimport Data.UUID.V4 (nextRandom)\nimport System.Directory (getTemporaryDirectory)\nimport System.FilePath ((<.>), (</>))\nimport System.IO (hFlush, stdout)\nimport System.Posix.Files\n  ( createNamedPipe,\n    fileExist,\n    ownerReadMode,\n    ownerWriteMode,\n    removeLink,\n    unionFileModes,\n  )\nimport System.Posix.IO\n  ( OpenMode (WriteOnly),\n    closeFd,\n    defaultFileFlags,\n    dupTo,\n    openFd,\n    stdOutput,\n  )\nimport System.Posix.Process (forkProcess)\n\n-- |\ncheckPipe :: FilePath -> IO ()\ncheckPipe fp = untilM_ (threadDelay 10000) (fileExist fp)\n\n-- |\nmkTmpFileName :: IO FilePath\nmkTmpFileName = do\n  tdir <- getTemporaryDirectory\n  tuuid <- nextRandom\n  return $ tdir </> show tuuid <.> "fifo"\n\n-- |\nexistThenRemove :: FilePath -> IO ()\nexistThenRemove fp = fileExist fp >>= \\b -> when b (removeLink fp)\n\n-- |\npipeAction :: IO () -> (B.ByteString -> IO a) -> IO a\npipeAction sender receiver = pipeActionWith sender (receiver <=< B.readFile)\n\n-- |\npipeActionWith :: IO () -> (FilePath -> IO a) -> IO a\npipeActionWith sender receiverf = do\n  filename <- mkTmpFileName\n  existThenRemove filename\n  createNamedPipe filename (unionFileModes ownerReadMode ownerWriteMode)\n  _ <- forkProcess $ do\n#if MIN_VERSION_unix(2, 8, 0)\n    fd <- openFd filename WriteOnly defaultFileFlags\n#else\n    fd <- openFd filename WriteOnly Nothing defaultFileFlags\n#endif\n    _ <- dupTo fd stdOutput\n    closeFd fd\n    sender\n    hFlush stdout\n  r <- checkPipe filename >> receiverf filename\n  removeLink filename\n  return r\n'