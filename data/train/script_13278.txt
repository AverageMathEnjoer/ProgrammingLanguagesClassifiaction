b"-- | Combinators and types specific to relationships.\n--\n--   These types and functions correspond with the relationships section in the\n--   <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ user guide>.\nmodule Database.Beam.Query.Relationships\n  ( -- * Relationships\n\n    -- ** Many-to-many relationships\n    ManyToMany, ManyToManyThrough\n  , manyToMany_, manyToManyPassthrough_\n\n    -- ** One-to-many relationships\n  , OneToMany, OneToManyOptional\n  , oneToMany_, oneToManyOptional_\n\n    -- ** One-to-one relationshships\n  , OneToOne, OneToMaybe\n  , oneToOne_, oneToMaybe_ ) where\n\nimport Database.Beam.Query.Combinators\nimport Database.Beam.Query.Operator\nimport Database.Beam.Query.Internal\nimport Database.Beam.Query.Ord\n\nimport Database.Beam.Schema\n\nimport Database.Beam.Backend.SQL\n\n\n-- | Synonym of 'OneToMany'. Useful for giving more meaningful types, when the\n--   relationship is meant to be one-to-one.\ntype OneToOne be db s one many = OneToMany be db s one many\n\n-- | Convenience type to declare one-to-many relationships. See the manual\n--   section on\n--   <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ relationships>\n--   for more information\ntype OneToMany be db s one many =\n  ( BeamSqlBackend be, BeamSqlBackendCanSerialize be Bool ) =>\n  one (QExpr be s) -> Q be db s (many (QExpr be s))\n\n-- | Synonym of 'OneToManyOptional'. Useful for giving more meaningful types,\n--   when the relationship is meant to be one-to-one.\ntype OneToMaybe be db s tbl rel = OneToManyOptional be db s tbl rel\n\n-- | Convenience type to declare one-to-many relationships with a nullable\n--   foreign key. See the manual section on\n--   <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ relationships>\n--   for more information\ntype OneToManyOptional be db s tbl rel =\n  ( BeamSqlBackend be, BeamSqlBackendCanSerialize be Bool\n  , BeamSqlBackendCanSerialize be SqlNull ) =>\n  tbl (QExpr be s) -> Q be db s (rel (Nullable (QExpr be s)))\n\n-- | Used to define one-to-many (or one-to-one) relationships. Takes the table\n--   to fetch, a way to extract the foreign key from that table, and the table to\n--   relate to.\noneToMany_, oneToOne_\n  :: ( Database be db, BeamSqlBackend be\n     , HasTableEquality be (PrimaryKey tbl)\n     , Table tbl, Table rel )\n  => DatabaseEntity be db (TableEntity rel) {-^ Table to fetch (many) -}\n  -> (rel (QExpr be s) -> PrimaryKey tbl (QExpr be s))\n     {-^ Foreign key -}\n  -> tbl (QExpr be s)\n  -> Q be db s (rel (QExpr be s))\noneToMany_ rel getKey tbl =\n  join_ rel (\\rel' -> getKey rel' ==. pk tbl)\noneToOne_ = oneToMany_\n\n-- | Used to define one-to-many (or one-to-one) relationships with a nullable\n--   foreign key. Takes the table to fetch, a way to extract the foreign key\n--   from that table, and the table to relate to.\noneToManyOptional_, oneToMaybe_\n  :: ( BeamSqlBackend be, Database be db\n     , Table tbl, Table rel\n     , HasTableEqualityNullable be (PrimaryKey tbl) )\n  => DatabaseEntity be db (TableEntity rel) {-^ Table to fetch -}\n  -> (rel (QExpr be s) -> PrimaryKey tbl (Nullable (QExpr be s)))\n     {-^ Foreign key -}\n  -> tbl (QExpr be s)\n  -> Q be db s (rel (Nullable (QExpr be s)))\noneToManyOptional_ rel getKey tbl =\n  leftJoin_ (all_ rel) (\\rel' -> getKey rel' ==. just_ (pk tbl))\noneToMaybe_ = oneToManyOptional_\n\n-- ** Many-to-many relationships\n\n-- | Convenience type to declare many-to-many relationships. See the manual\n--   section on\n--   <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ relationships>\n--   for more information\ntype ManyToMany be db left right =\n  forall s.\n  ( BeamSqlBackend be\n\n  , SqlEq (QExpr be s) (PrimaryKey left (QExpr be s))\n  , SqlEq (QExpr be s) (PrimaryKey right (QExpr be s)) ) =>\n  Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s)) ->\n  Q be db s (left (QExpr be s), right (QExpr be s))\n\n-- | Convenience type to declare many-to-many relationships with additional\n--   data. See the manual section on\n--   <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ relationships>\n--   for more information\ntype ManyToManyThrough be db through left right =\n  forall s.\n  ( BeamSqlBackend be\n\n  , SqlEq (QExpr be s) (PrimaryKey left (QExpr be s))\n  , SqlEq (QExpr be s) (PrimaryKey right (QExpr be s)) ) =>\n  Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s)) ->\n  Q be db s ( through (QExpr be s), left (QExpr be s), right (QExpr be s) )\n\n-- | Used to define many-to-many relationships without any additional data.\n--   Takes the join table and two key extraction functions from that table to the\n--   related tables. Also takes two `Q`s representing the table sources to relate.\n--\n--   See <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ the manual>\n--   for more information.\nmanyToMany_\n  :: ( Database be db\n     , Table joinThrough, Table left, Table right\n     , BeamSqlBackend be\n\n     , SqlEq (QExpr be s) (PrimaryKey left (QExpr be s))\n     , SqlEq (QExpr be s) (PrimaryKey right (QExpr be s)) )\n  => DatabaseEntity be db (TableEntity joinThrough)\n  -> (joinThrough (QExpr be s) -> PrimaryKey left (QExpr be s))\n  -> (joinThrough (QExpr be s) -> PrimaryKey right (QExpr be s))\n  -> Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s))\n  -> Q be db s (left (QExpr be s), right (QExpr be s))\nmanyToMany_ joinTbl leftKey rightKey left right = fmap (\\(_, l, r) -> (l, r)) $\n                                                  manyToManyPassthrough_ joinTbl leftKey rightKey left right\n\n-- | Used to define many-to-many relationships with additional data. Takes the\n--   join table and two key extraction functions from that table to the related\n--   tables. Also takes two `Q`s representing the table sources to relate.\n--\n--   See <https://haskell-beam.github.io/beam/user-guide/queries/relationships/ the manual>\n--   for more information.\nmanyToManyPassthrough_\n  :: ( Database be db\n     , Table joinThrough, Table left, Table right\n\n     , BeamSqlBackend be\n\n     , SqlEq (QExpr be s) (PrimaryKey left (QExpr be s))\n     , SqlEq (QExpr be s) (PrimaryKey right (QExpr be s)) )\n  => DatabaseEntity be db (TableEntity joinThrough)\n  -> (joinThrough (QExpr be s) -> PrimaryKey left (QExpr be s))\n  -> (joinThrough (QExpr be s) -> PrimaryKey right (QExpr be s))\n  -> Q be db s (left (QExpr be s))\n  -> Q be db s (right (QExpr be s))\n  -> Q be db s ( joinThrough (QExpr be s)\n               , left (QExpr be s)\n               , right (QExpr be s))\nmanyToManyPassthrough_ joinTbl leftKey rightKey left right =\n  do left_ <- left\n     right_ <- right\n     joinTbl_ <- join_ joinTbl (\\joinTbl_ -> leftKey joinTbl_ ==. primaryKey left_ &&.\n                                             rightKey joinTbl_ ==. primaryKey right_)\n     pure (joinTbl_, left_, right_)\n\n\n\n"