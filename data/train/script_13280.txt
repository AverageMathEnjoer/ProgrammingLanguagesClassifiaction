b'{-# OPTIONS_GHC -fno-warn-type-defaults #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nmodule Course.Gens where\n\nimport qualified Prelude             as P (fmap, foldr, (<$>), (<*>))\nimport           Test.QuickCheck     (Arbitrary (..), Gen, Property, Testable,\n                                      forAllShrink)\n\nimport           Course.Core\nimport           Course.List         (List (..), hlist, listh)\nimport           Course.ListZipper   (ListZipper (..), zipper)\n\ngenList :: Arbitrary a => Gen (List a)\ngenList = P.fmap ((P.foldr (:.) Nil) :: [a] -> List a) arbitrary\n\nshrinkList :: Arbitrary a => List a -> [List a]\nshrinkList =\n  P.fmap listh . shrink . hlist\n\ngenIntegerList :: Gen (List Integer)\ngenIntegerList = genList\n\ngenIntegerAndList :: Gen (Integer, List Integer)\ngenIntegerAndList = P.fmap (P.fmap listh) arbitrary\n\nshrinkIntegerAndList :: (Integer, List Integer) -> [(Integer, List Integer)]\nshrinkIntegerAndList = P.fmap (P.fmap listh) . shrink . P.fmap hlist\n\ngenTwoLists :: Gen (List Integer, List Integer)\ngenTwoLists = (,) P.<$> genIntegerList P.<*> genIntegerList\n\nshrinkTwoLists :: (List Integer, List Integer) -> [(List Integer, List Integer)]\nshrinkTwoLists (a,b) = P.fmap (\\(as,bs) -> (listh as, listh bs)) $ shrink (hlist a, hlist b)\n\ngenThreeLists :: Gen (List Integer, List Integer, List Integer)\ngenThreeLists = (,,) P.<$> genIntegerList P.<*> genIntegerList P.<*> genIntegerList\n\nshrinkThreeLists :: (List Integer, List Integer, List Integer) -> [(List Integer, List Integer, List Integer)]\nshrinkThreeLists (a,b,c) = P.fmap (\\(as,bs,cs) -> (listh as, listh bs, listh cs)) $ shrink (hlist a, hlist b, hlist c)\n\ngenListOfLists :: Gen (List (List Integer))\ngenListOfLists = P.fmap (P.fmap listh) (genList :: (Gen (List [Integer])))\n\nshrinkListOfLists :: Arbitrary a => List (List a) -> [List (List a)]\nshrinkListOfLists = P.fmap (P.fmap listh). shrinkList . P.fmap hlist\n\nforAllLists :: Testable prop => (List Integer -> prop) -> Property\nforAllLists = forAllShrink genIntegerList shrinkList\n\n-- (List Integer) and a Bool\ngenListAndBool :: Gen (List Integer, Bool)\ngenListAndBool = (,) P.<$> genIntegerList P.<*> arbitrary\n\nshrinkListAndBool :: (List Integer, Bool) -> [(List Integer, Bool)]\nshrinkListAndBool (xs,b) = (,) P.<$> (shrinkList xs) P.<*> (shrink b)\n\nforAllListsAndBool :: Testable prop\n                  => ((List Integer, Bool) -> prop)\n                  -> Property\nforAllListsAndBool =\n  forAllShrink genListAndBool shrinkListAndBool\n\n-- ListZipper Integer\ngenListZipper :: Gen (ListZipper Integer)\ngenListZipper =\n  zipper P.<$> arbitrary P.<*> arbitrary P.<*> arbitrary\n\nshrinkListZipper :: ListZipper Integer -> [ListZipper Integer]\nshrinkListZipper (ListZipper l x r) =\n  ListZipper P.<$> (shrinkList l) P.<*> (shrink x) P.<*> (shrinkList r)\n\nforAllListZipper :: Testable prop\n                 => (ListZipper Integer -> prop)\n                 -> Property\nforAllListZipper =\n  forAllShrink genListZipper shrinkListZipper\n\ngenListZipperWithInt :: Gen (ListZipper Integer, Int)\ngenListZipperWithInt =\n  (,) P.<$> genListZipper P.<*> arbitrary\n\nshrinkListZipperWithInt :: (ListZipper Integer, Int) -> [(ListZipper Integer, Int)]\nshrinkListZipperWithInt (z, i) =\n  (,) P.<$> (shrinkListZipper z) P.<*> (shrink i)\n\nforAllListZipperWithInt :: Testable prop\n                        => ((ListZipper Integer, Int) -> prop)\n                        -> Property\nforAllListZipperWithInt =\n  forAllShrink genListZipperWithInt shrinkListZipperWithInt\n'