b'#\' tableCounts\n#\'\n#\' Count pairs with the same pattern in the cross product between two datasets.\n#\'\n#\' @usage tableCounts(gammalist, nobs.a, nobs.b, n.cores)\n#\'\n#\' @param gammalist A list of objects produced by gammaKpar, gammaCK2par, or\n#\' gammaCKpar. \n#\' @param nobs.a number of observations in dataset 1\n#\' @param nobs.b number of observations in dataset 2\n#\' @param n.cores Number of cores to parallelize over. Default is NULL.\n#\'\n#\' @author Ted Enamorado <ted.enamorado@gmail.com>, Ben Fifield <benfifield@gmail.com>, and Kosuke Imai\n#\'\n#\' @return \\code{tableCounts} returns counts of all unique mathching patterns, which can be\n#\' fed directly into \\code{emlinkMAR} to get posterior matching probabilities for each unique pattern.\n#\'\n#\' @examples\n#\' \\dontrun{\n#\' ## Calculate gammas\n#\' g1 <- gammaCKpar(dfA$firstname, dfB$firstname)\n#\' g2 <- gammaCKpar(dfA$middlename, dfB$middlename)\n#\' g3 <- gammaCKpar(dfA$lastname, dfB$lastname)\n#\' g4 <- gammaKpar(dfA$birthyear, dfB$birthyear)\n#\'\n#\' ## Run tableCounts\n#\' tc <- tableCounts(list(g1, g2, g3, g4), nobs.a = nrow(dfA), nobs.b = nrow(dfB))\n#\' }\n#\' @export\n#\' @importFrom parallel detectCores makeCluster stopCluster mclapply\n#\' @importFrom doParallel registerDoParallel\n#\' @importFrom foreach "%dopar%" "%do%" foreach\n## ------------------------\n## To count unique patterns:\n## tableCounts is the\n## functions that does the trick\n## ------------------------\n\ntableCounts <- function(gammalist, nobs.a, nobs.b, n.cores = NULL) {\n    \n    ## Lists of indices:\n    ##     temp - exact\n    ##     ptemp - partial\n    ##     natemp - NAs\n    temp <- vector(mode = "list", length = length(gammalist))\n    ptemp <- vector(mode = "list", length = length(gammalist))\n    natemp <- vector(mode = "list", length = length(gammalist))\n\n    for(i in 1:length(gammalist)){\n        temp[[i]] <- gammalist[[i]]$matches2\n        if(!is.null(gammalist[[i]]$matches1)) {\n            ptemp[[i]] <- gammalist[[i]]$matches1\n        }\n        natemp[[i]] <- gammalist[[i]]$nas\n    }\n\n    ## Slicing the data:\n    n.slices1 <- max(round(as.numeric(nobs.a)/(10000), 0), 1) \n    n.slices2 <- max(round(as.numeric(nobs.b)/(10000), 0), 1) \n    \n    if(is.null(n.cores)) {\n        n.cores <- detectCores() - 1\n    }\n    \n    nc <- min(n.cores, n.slices1 * n.slices2)\n\n    ## Prep objects for m_func_par\n    limit.1 <- round(quantile((0:nobs.a), p = seq(0, 1, 1/n.slices1)), 0)\n    limit.2 <- round(quantile((0:nobs.b), p = seq(0, 1, 1/n.slices2)), 0)\n\n    last1 <- length(limit.1)\n    last2 <- length(limit.2)\n\n    n.lim.1 <- limit.1[-1] - limit.1[-last1]\n    n.lim.2 <- limit.2[-1] - limit.2[-last2]\n\n    ind.i <- 1:n.slices1\n    ind.j <- 1:n.slices2\n    ind <- as.matrix(expand.grid(ind.i, ind.j))\n\n    ## Run main function\n    if(Sys.info()[[\'sysname\']] == \'Darwin\') {\n        if (nc == 1) \'%oper%\' <- foreach::\'%do%\'\n        else { \n            \'%oper%\' <- foreach::\'%dopar%\'\n            cl <- makeCluster(nc)\n            registerDoParallel(cl)\n            on.exit(stopCluster(cl))\n        }\n\n        gammas <- foreach(i = 1:nrow(ind)) %oper% {\n            m_func_par(temp = temp, ptemp = ptemp, natemp = natemp,\n                       limit1 = limit.1, limit2 = limit.2,\n                       nlim1 = n.lim.1, nlim2 = n.lim.2,\n                       ind = as.matrix(t(ind[i, ])), listid = rep(1, 2),\n                       matchesLink = FALSE, threads = 1)\n      \t}\n        \n\tgammas_mat <- list()\n\tfor(i in 1:length(gammas)){\n            temp0 <- gammas[[i]]\t\n            temp1 <- as.matrix(lapply(temp0, function(x){\n                as.matrix(data.frame(x[[1]], x[[2]]))\n            }))\n            gammas_mat[[i]] <- temp1[[1]] \n        }\n\trm(temp0, temp1)\t\n\n        temp <- do.call(\'rbind\', gammas_mat)\n\n    } else {\n\n        gammas <- m_func_par(temp = temp, ptemp = ptemp, natemp = natemp,\n                             limit1 = limit.1, limit2 = limit.2,\n                             nlim1 = n.lim.1, nlim2 = n.lim.2,\n                             ind = ind, listid = rep(1, 2),\n                             matchesLink = FALSE, threads = nc)\n\n        gammas_mat <- lapply(gammas, function(x){\n            as.matrix(data.frame(x[[1]], x[[2]]))\n        })\n        \n        temp <- do.call(\'rbind\', gammas_mat)\n    }\n    \n    rm(gammas); rm(gammas_mat); gc()\n\n    counts.f <- as.matrix(tapply(as.numeric(temp[, 2]), temp[, 1], sum))\n    counts.d <- cbind( as.numeric(row.names(counts.f)), counts.f)\n    colnames(counts.d) <- c("pattern.id", "count")\n\n    ## Merge Counts\n    seq <- 1:(length(gammalist)*3)\n    b <- 2^(seq)\n    patterns.vec <- matrix(NA, 4, length(gammalist))\n    for(i in 1:length(gammalist)){\n        patterns.vec[,i] <- c(b[1:3 + (i-1)*3], 0)\n    }\n    patterns <- expand.grid(as.data.frame(patterns.vec))\n    pattern.id <- rowSums(patterns)\n    patterns <- cbind(patterns, pattern.id)\n    data.new.0 <- merge(patterns, counts.d, by = "pattern.id")\n    data.new.0 <- data.new.0[,-1]\n\n    b<-2\n    patterns.2vec <- c()\n    for(i in 1:length(gammalist)){\n        patterns.2vec <- c(patterns.2vec, 1/b^(1 + (i-1)*3))\n    }\n    patterns.2 <- t((patterns.2vec) * t(data.new.0[,1:length(gammalist)]))\n    data.new.1 <- cbind(patterns.2, data.new.0[,length(gammalist)+1])\n    names <- c(paste0("gamma.", 1:length(gammalist)), "counts")\n    colnames(data.new.1) <- names\n    sub.nc <- which(colSums(data.new.1) == 0)\n    sub.nc <- sub.nc[sub.nc > length(gammalist)]\n    if(length(sub.nc) > 0){\n        data.new.1 <- data.new.1[, -sub.nc]\n    }\n    nc <- ncol(data.new.1)\n    na.data.new <- data.new.1[, -c(nc), drop = FALSE]\n    na.data.new[na.data.new == 4] <- NA\n    data.new <- cbind(na.data.new, data.new.1[, nc])\n    colnames(data.new)[nc] <- "counts"\n    data.new <- data.new[data.new[, nc] > 0, ]\n    class(data.new) <- c("fastLink", "tableCounts")\n    return(data.new)\n    \n}\n\n## ------------------------\n## End of tableCounts\n## ------------------------\n\n'