b'{-\n\n$ cabal install -O2 monad-par-0.3\n$ ghc -O2 -threaded -rtsopts -with-rtsopts -N issue21.hs -o issue21.exe\n$ ./issue21.exe 10000000\n2089877\n$ ./issue21.exe 10000000\nissue21: <<loop>>issue21: issue21: issue21: thread blocked indefinitely in an MVar operation\n<<loop>>\n\n<<loop>>\nissue21: <<loop>>\n$ ghc -V\nThe Glorious Glasgow Haskell Compilation System, version 7.4.1\n\n-}\n{-# LANGUAGE CPP #-}\n\n#ifdef PARSCHED \nimport PARSCHED\n#else\n-- import Control.Monad.Par\n\n-- This bug was reported for the Trace scheduler:\n-- import Control.Monad.Par.Scheds.Trace\n-- import Control.Monad.Par.Scheds.Sparks\nimport Control.Monad.Par.Scheds.Direct\n\n-- This is ALSO failing for Adam\'s meta-par scheduler!\n-- import Control.Monad.Par.Meta.SMP (runPar, spawn, get)\n#endif\n\nimport System.Environment (getArgs)\nimport Control.DeepSeq\nimport GHC.Conc (myThreadId, numCapabilities)\nimport System.IO (hPutStrLn,stderr)\n\ndata M = M !Integer !Integer !Integer !Integer\n deriving Show\ninstance NFData M\n\ninstance Num M where\n  m * n = runPar $ do\n    m\' <- spawn (return m)\n    n\' <- spawn (return n)\n    m\'\' <- get m\'\n    n\'\' <- get n\'\n    return (m\'\' `mul` n\'\')\n\n(M a b c d) `mul` (M x y z w) = M\n  (a * x + b * z) (a * y + b * w)\n  (c * x + d * z) (c * y + d * w)\n\nfib :: Integer -> Integer\nfib n = let M f _ _ _ = M 0 1 1 1 ^ (n + 1) in f\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  tid <- myThreadId\n  hPutStrLn stderr$"Beginning benchmark on: "++show tid ++ ", numCapabilities "++show numCapabilities\n  \n  let n = case args of\n       -- Default to 10M to trigger the bug. \n       []  -> 10 * 1000 * 1000\n       [s] -> read s\n  print $ length $ show $ fib n\n'