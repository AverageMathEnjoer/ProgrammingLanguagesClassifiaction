b'-- | This module contains support for defining "ad-hoc" queries. That\n-- is queries on tables that do not necessarily have corresponding\n-- \'Beamable\' table types.\nmodule Database.Beam.Query.Adhoc\n  ( Adhoc(..)\n\n  , NamedField\n  , table_, field_\n  ) where\n\nimport           Database.Beam.Query.Internal\nimport           Database.Beam.Backend.SQL\n\nimport           Control.Monad.Free.Church\n\nimport           Data.Kind (Type)\nimport qualified Data.Text as T\n\nclass Adhoc structure where\n  type AdhocTable structure (f :: Type -> Type) :: Type\n\n  mkAdhocField :: (forall a. T.Text -> f a) -> structure -> AdhocTable structure f\n\nnewtype NamedField a = NamedField T.Text\n\ninstance Adhoc (NamedField a) where\n  type AdhocTable (NamedField a) f = f a\n\n  mkAdhocField mk (NamedField nm) = mk nm\n\ninstance (Adhoc a, Adhoc b) => Adhoc (a, b) where\n  type AdhocTable (a, b) y = (AdhocTable a y, AdhocTable b y)\n  mkAdhocField mk (a, b) = (mkAdhocField mk a, mkAdhocField mk b)\n\ninstance (Adhoc a, Adhoc b, Adhoc c) => Adhoc (a, b, c) where\n  type AdhocTable (a, b, c) y = (AdhocTable a y, AdhocTable b y, AdhocTable c y)\n  mkAdhocField mk (a, b, c) = (mkAdhocField mk a, mkAdhocField mk b, mkAdhocField mk c)\n\ninstance (Adhoc a, Adhoc b, Adhoc c, Adhoc d) => Adhoc (a, b, c, d) where\n  type AdhocTable (a, b, c, d) y = (AdhocTable a y, AdhocTable b y, AdhocTable c y, AdhocTable d y)\n  mkAdhocField mk (a, b, c, d) = (mkAdhocField mk a, mkAdhocField mk b, mkAdhocField mk c, mkAdhocField mk d)\n\ninstance (Adhoc a, Adhoc b, Adhoc c, Adhoc d, Adhoc e) => Adhoc (a, b, c, d, e) where\n  type AdhocTable (a, b, c, d, e) y = ( AdhocTable a y, AdhocTable b y, AdhocTable c y, AdhocTable d y\n                                      , AdhocTable e y )\n  mkAdhocField mk (a, b, c, d, e) = (mkAdhocField mk a, mkAdhocField mk b, mkAdhocField mk c, mkAdhocField mk d, mkAdhocField mk e)\n\ninstance (Adhoc a, Adhoc b, Adhoc c, Adhoc d, Adhoc e, Adhoc f) => Adhoc (a, b, c, d, e, f) where\n  type AdhocTable (a, b, c, d, e, f) y = ( AdhocTable a y, AdhocTable b y, AdhocTable c y, AdhocTable d y\n                                         , AdhocTable e y, AdhocTable f y )\n  mkAdhocField mk (a, b, c, d, e, f) = (mkAdhocField mk a, mkAdhocField mk b, mkAdhocField mk c, mkAdhocField mk d, mkAdhocField mk e, mkAdhocField mk f)\n\ninstance (Adhoc a, Adhoc b, Adhoc c, Adhoc d, Adhoc e, Adhoc f, Adhoc g) => Adhoc (a, b, c, d, e, f, g) where\n  type AdhocTable (a, b, c, d, e, f, g) y = ( AdhocTable a y, AdhocTable b y, AdhocTable c y, AdhocTable d y\n                                            , AdhocTable e y, AdhocTable f y, AdhocTable g y )\n  mkAdhocField mk (a, b, c, d, e, f, g) = (mkAdhocField mk a, mkAdhocField mk b, mkAdhocField mk c, mkAdhocField mk d, mkAdhocField mk e, mkAdhocField mk f, mkAdhocField mk g)\n\ninstance (Adhoc a, Adhoc b, Adhoc c, Adhoc d, Adhoc e, Adhoc f, Adhoc g, Adhoc h) =>\n  Adhoc (a, b, c, d, e, f, g, h) where\n  type AdhocTable (a, b, c, d, e, f, g, h) y = ( AdhocTable a y, AdhocTable b y, AdhocTable c y, AdhocTable d y\n                                               , AdhocTable e y, AdhocTable f y, AdhocTable g y, AdhocTable h y )\n  mkAdhocField mk (a, b, c, d, e, f, g, h) = (mkAdhocField mk a, mkAdhocField mk b, mkAdhocField mk c, mkAdhocField mk d, mkAdhocField mk e, mkAdhocField mk f, mkAdhocField mk g, mkAdhocField mk h)\n\n-- | Introduce a table into a query without using the \'Beamable\' and \'Database\' machinery.\n--\n-- The first argument is the optional name of the schema the table is in and the second is the name\n-- of the table to source from.\n--\n-- The third argument is a tuple (or any nesting of tuples) where each value is of type \'NamedField\'\n-- (use \'field_\' to construct).\n--\n-- The return value is a tuple (or any nesting of tuples) of the same shape as @structure@ but where\n-- each value is a \'QExpr\'.\n--\n-- For example, to source from the table @Table1@, with fields @Field1@ (A boolean), @Field2@ (a\n-- timestamp), and @Field3@ (a string)\n--\n-- > table_ Nothing "Table1" ( field_ @Bool "Field1", field_ @UTCTime "Field2", field_ @Text "Field3" )\n--\ntable_ :: forall be db structure s\n        . (Adhoc structure, BeamSqlBackend be, Projectible be (AdhocTable structure (QExpr be s)))\n       => Maybe T.Text -> T.Text -> structure -> Q be db s (AdhocTable structure (QExpr be s))\ntable_ schemaNm tblNm tbl =\n  Q $ liftF (QAll (\\_ -> fromTable (tableNamed (tableName schemaNm tblNm)) . Just . (, Nothing))\n                  (\\tblNm\' -> let mk :: forall a. T.Text -> QExpr be s a\n                                  mk nm = QExpr (\\_ -> fieldE (qualifiedField tblNm\' nm))\n                              in mkAdhocField mk tbl)\n                  (\\_ -> Nothing) snd)\n\n-- | Used to construct \'NamedField\'s, most often with an explicitly applied type.\n--\n-- The type can be omitted if the value is used unambiguously elsewhere.\nfield_ :: forall a. T.Text -> NamedField a\nfield_ = NamedField\n'